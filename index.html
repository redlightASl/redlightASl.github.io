<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="https://redlightasl.github.io">
  <title>红光今天吃什么</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="想搞FPGA的微电人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="红光今天吃什么">
<meta property="og:url" content="https://redlightasl.github.io/">
<meta property="og:site_name" content="红光今天吃什么">
<meta property="og:description" content="想搞FPGA的微电人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="RedlightASl">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="红光今天吃什么" type="application/atom+xml">
  
  
    <link rel="icon" href="/assets/favicon.png">
  
  <link rel="stylesheet" type="text/css" href="/./main.0cf68a.css">
  <style type="text/css">
  
    #container.show {
      background: linear-gradient(200deg,#f3c4ef,#a0cfe4);
    }
  </style>
  

  

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      
<div class="overlay" style="background: #9400d3"></div>
<!-- 左侧边栏（上半部分）不设置背景颜色 -->
<!-- <div class="overlay" > -->
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="/assets/Patchouli.jpg" class="js-avatar">
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/"></a></h1>
		</hgroup>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/tags/%E9%9A%8F%E7%AC%94/">随笔</a></li>
	        
			</ul>
		</nav>
		<!-- <nav> -->
			<!-- 总文章数 37 -->
		<!-- </nav>		 -->
		<nav class="header-smart-menu">
    		
    			
    			<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'friends')" href="javascript:void(0)">友链</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">关于我</a>
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/redlightASl" title="github"><i class="icon-github"></i></a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/redlightasl" title="zhihu"><i class="icon-zhihu"></i></a>
		        
					<a class="bilibili" target="_blank" href="https://space.bilibili.com/12073240" title="bilibili"><i class="icon-bilibili"></i></a>
		        
					<a class="mail" target="_blank" href="http://dddbbbdd@foxmail.com" title="mail"><i class="icon-mail"></i></a>
		        
					<a class="twitter" target="_blank" href="https://twitter.com/Redligh34025775" title="twitter"><i class="icon-twitter"></i></a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #9400d3"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="/assets/Patchouli.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author"></h1>
			</hgroup>
			
			
			
				
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/redlightASl" title="github"><i class="icon-github"></i></a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/redlightasl" title="zhihu"><i class="icon-zhihu"></i></a>
			        
						<a class="bilibili" target="_blank" href="https://space.bilibili.com/12073240" title="bilibili"><i class="icon-bilibili"></i></a>
			        
						<a class="mail" target="_blank" href="http://dddbbbdd@foxmail.com" title="mail"><i class="icon-mail"></i></a>
			        
						<a class="twitter" target="_blank" href="https://twitter.com/Redligh34025775" title="twitter"><i class="icon-twitter"></i></a>
			        
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 50%">
				
				
					<li style="width: 50%"><a href="/">主页</a></li>
		        
					<li style="width: 50%"><a href="/tags/%E9%9A%8F%E7%AC%94/">随笔</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1" class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            
  
    <article id="post-FPGA学习笔记3【基于Vivado封装自定义IP】" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/19/FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E3%80%90%E5%9F%BA%E4%BA%8EVivado%E5%B0%81%E8%A3%85%E8%87%AA%E5%AE%9A%E4%B9%89IP%E3%80%91/">FPGA学习笔记3【基于Vivado封装自定义IP】</a>
    </h1>
  

        
<!-- 显示阅读次数-->
<!--  -->
<!--显示阅读次数完毕 -->

        
        <a href="/2021/11/19/FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E3%80%90%E5%9F%BA%E4%BA%8EVivado%E5%B0%81%E8%A3%85%E8%87%AA%E5%AE%9A%E4%B9%89IP%E3%80%91/" class="archive-article-date">
  	<time datetime="2021-11-19T08:11:13.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2021-11-19</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="封装带AXI接口的自定义IP核"><a href="#封装带AXI接口的自定义IP核" class="headerlink" title="封装带AXI接口的自定义IP核"></a>封装带AXI接口的自定义IP核</h1><p>为了更方便地使用外部接口驱动或进行系统级的设计时，可以考虑将RTL设计打包制作成自定义的IP核，Vivado会自动生成相关的IP核接口；或者为了在ZYNQ中使用AXI总线将硬核与FPGA硬件部分互联，可以将FPGA部分的RTL设计打包成自定义IP核，Vivado会自动将生成的IP核的接口制作好，使用图形化界面就能快速实现SoC设计。特别地，可以使用这种方法在硬核外挂载软核</p>
<p>在Vivado的设计思想中，一个IP核就相当于一个函数，可以通过重用IP核做到模块化设计的效果</p>
<p>可以参考Xilinx Vivado封装自定义IP参考手册【代号ug1118】来获得更详细的操作指示</p>
<p>第一部分仅说明带AXI接口的自定义IP核封装方法</p>
<h2 id="创建与封装自定义IP的意义"><a href="#创建与封装自定义IP的意义" class="headerlink" title="创建与封装自定义IP的意义"></a>创建与封装自定义IP的意义</h2><p>在Vivado中含有一个IP Catalog流程，可以将下列源文档封装成自定义的IP</p>
<ul>
<li>RTL级HDL源文件</li>
<li>模拟模型文件</li>
<li>示例设计文件</li>
<li>Testbench</li>
<li>项目文件目录</li>
<li>Block Design</li>
</ul>
<p>同时Vivado也内置了Xilinx自制IP、第三方IP、用户定义IP的库</p>
<p>比起传统“Add Module”将RTL代码以中间级模块的方式例化添加到顶层模块，再封装出统一的顶层模块这样的操作流程，通过可视化的IP核管理可以更快速地实现项目模块化和后期完善修改流程</p>
<h2 id="创建自定义IP"><a href="#创建自定义IP" class="headerlink" title="创建自定义IP"></a>创建自定义IP</h2><p>示例程序使用自定义的IP实现LED呼吸灯效果</p>
<p>这个IP使用AXI接口与ZYNQ的硬核连接，可以使用软件控制IP核的“外设控制寄存器”来对自定义IP核的工作状况进行控制</p>
<h3 id="创建IP工程"><a href="#创建IP工程" class="headerlink" title="创建IP工程"></a>创建IP工程</h3><p>为了更好管理自定义IP核，通常将用户的RTL代码统一管理在独立目录下</p>
<p>在Vivado开始界面选择【Tasks】-【Manage IP】，选择新建一个IP核管理目录或打开已有目录，并新建项目</p>
<p>根据自己的硬件设备和习惯使用的HDL选择针对性的选项</p>
<p>完成创建后，选择【Tools】-【Create and Package New IP】</p>
<p><img src="/2021/11/19/FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E3%80%90%E5%9F%BA%E4%BA%8EVivado%E5%B0%81%E8%A3%85%E8%87%AA%E5%AE%9A%E4%B9%89IP%E3%80%91/image-20210511132753582.png" alt="image-20210511132753582"></p>
<p>如果准备创建一个单独的IP，可以直接Next，相关内容在下一部分介绍；在这里因为准备创建的项目需要使用到AXI4接口与硬核交互，所以选择最后这个选项</p>
<p>设置IP核名称后如下图进行AXI接口设置</p>
<p><img src="/2021/11/19/FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E3%80%90%E5%9F%BA%E4%BA%8EVivado%E5%B0%81%E8%A3%85%E8%87%AA%E5%AE%9A%E4%B9%89IP%E3%80%91/image-20210511162506573.png" alt="image-20210511162506573"></p>
<p>其中AXI接口有三种类型：</p>
<ul>
<li>Lite：适合数据量较小、速度较快的信号传输</li>
<li>Full：全规格的AXI总线，适合标准类型的数据传输</li>
<li>Stream：数据流传输，适合音视频信号等大规模数据的高速传输</li>
</ul>
<p>还有两种模式：</p>
<ul>
<li>Slave：从模式，IP接受外部数据控制</li>
<li>Master：主模式，IP控制外部设备</li>
</ul>
<p>完成设置后可以看到右侧User Repository中出现了自定义IP核</p>
<p><img src="/2021/11/19/FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E3%80%90%E5%9F%BA%E4%BA%8EVivado%E5%B0%81%E8%A3%85%E8%87%AA%E5%AE%9A%E4%B9%89IP%E3%80%91/image-20210511162609747.png" alt="image-20210511162609747"></p>
<p>这里右键IP核，选择【Edit in IP Packager】，之后Vivado会打开一个新界面用于管理IP核的RTL代码</p>
<p>自动生成的RTL代码分为两部分，一个是顶层模块，另一个是AXI总线接口逻辑；RTL代码中还默认生成了AXI总线相关逻辑的例化和提供给用户使用的区域（包括<strong>自定义参数</strong>、<strong>自定义端口</strong>、<strong>自定义顶层模块例化</strong>），但是需要注意：如果在AXI总线上开辟了独立的新端口，需要将相关代码单独添加到AXI总线逻辑的RTL代码中</p>
<h3 id="编写IP内部RTL代码"><a href="#编写IP内部RTL代码" class="headerlink" title="编写IP内部RTL代码"></a>编写IP内部RTL代码</h3><p>顶层例化代码如下所示：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 1 ns / 1 ps</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">module</span> breath_LED_IP_v1_0 #</span><br><span class="line">	(</span><br><span class="line">		<span class="comment">// Users to add parameters here</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// User parameters ends</span></span><br><span class="line">		<span class="comment">// Do not modify the parameters beyond this line</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// Parameters of Axi Slave Bus Interface S0_AXI</span></span><br><span class="line">		<span class="keyword">parameter</span> <span class="keyword">integer</span> C_S0_AXI_DATA_WIDTH	= <span class="number">32</span>,</span><br><span class="line">		<span class="keyword">parameter</span> <span class="keyword">integer</span> C_S0_AXI_ADDR_WIDTH	= <span class="number">4</span></span><br><span class="line">	)</span><br><span class="line">	(</span><br><span class="line">		<span class="comment">// Users to add ports here</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// User ports ends</span></span><br><span class="line">		<span class="comment">// Do not modify the ports beyond this line</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">// Ports of Axi Slave Bus Interface S0_AXI</span></span><br><span class="line">		<span class="keyword">input</span> <span class="keyword">wire</span>  s0_axi_aclk,</span><br><span class="line">		<span class="keyword">input</span> <span class="keyword">wire</span>  s0_axi_aresetn,</span><br><span class="line">		<span class="keyword">input</span> <span class="keyword">wire</span> [C_S0_AXI_ADDR_WIDTH-<span class="number">1</span> : <span class="number">0</span>] s0_axi_awaddr,</span><br><span class="line">		<span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">2</span> : <span class="number">0</span>] s0_axi_awprot,</span><br><span class="line">		<span class="keyword">input</span> <span class="keyword">wire</span>  s0_axi_awvalid,</span><br><span class="line">		<span class="keyword">output</span> <span class="keyword">wire</span>  s0_axi_awready,</span><br><span class="line">		<span class="keyword">input</span> <span class="keyword">wire</span> [C_S0_AXI_DATA_WIDTH-<span class="number">1</span> : <span class="number">0</span>] s0_axi_wdata,</span><br><span class="line">		<span class="keyword">input</span> <span class="keyword">wire</span> [(C_S0_AXI_DATA_WIDTH/<span class="number">8</span>)-<span class="number">1</span> : <span class="number">0</span>] s0_axi_wstrb,</span><br><span class="line">		<span class="keyword">input</span> <span class="keyword">wire</span>  s0_axi_wvalid,</span><br><span class="line">		<span class="keyword">output</span> <span class="keyword">wire</span>  s0_axi_wready,</span><br><span class="line">		<span class="keyword">output</span> <span class="keyword">wire</span> [<span class="number">1</span> : <span class="number">0</span>] s0_axi_bresp,</span><br><span class="line">		<span class="keyword">output</span> <span class="keyword">wire</span>  s0_axi_bvalid,</span><br><span class="line">		<span class="keyword">input</span> <span class="keyword">wire</span>  s0_axi_bready,</span><br><span class="line">		<span class="keyword">input</span> <span class="keyword">wire</span> [C_S0_AXI_ADDR_WIDTH-<span class="number">1</span> : <span class="number">0</span>] s0_axi_araddr,</span><br><span class="line">		<span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">2</span> : <span class="number">0</span>] s0_axi_arprot,</span><br><span class="line">		<span class="keyword">input</span> <span class="keyword">wire</span>  s0_axi_arvalid,</span><br><span class="line">		<span class="keyword">output</span> <span class="keyword">wire</span>  s0_axi_arready,</span><br><span class="line">		<span class="keyword">output</span> <span class="keyword">wire</span> [C_S0_AXI_DATA_WIDTH-<span class="number">1</span> : <span class="number">0</span>] s0_axi_rdata,</span><br><span class="line">		<span class="keyword">output</span> <span class="keyword">wire</span> [<span class="number">1</span> : <span class="number">0</span>] s0_axi_rresp,</span><br><span class="line">		<span class="keyword">output</span> <span class="keyword">wire</span>  s0_axi_rvalid,</span><br><span class="line">		<span class="keyword">input</span> <span class="keyword">wire</span>  s0_axi_rready</span><br><span class="line">	);</span><br><span class="line"><span class="comment">// Instantiation of Axi Bus Interface S0_AXI</span></span><br><span class="line">	breath_LED_IP_v1_0_S0_AXI # ( </span><br><span class="line">		<span class="variable">.C_S_AXI_DATA_WIDTH</span>(C_S0_AXI_DATA_WIDTH),</span><br><span class="line">		<span class="variable">.C_S_AXI_ADDR_WIDTH</span>(C_S0_AXI_ADDR_WIDTH)</span><br><span class="line">	) breath_LED_IP_v1_0_S0_AXI_inst (</span><br><span class="line">		<span class="variable">.led</span>(led),</span><br><span class="line">		<span class="variable">.S_AXI_ACLK</span>(s0_axi_aclk),</span><br><span class="line">		<span class="variable">.S_AXI_ARESETN</span>(s0_axi_aresetn),</span><br><span class="line">		<span class="variable">.S_AXI_AWADDR</span>(s0_axi_awaddr),</span><br><span class="line">		<span class="variable">.S_AXI_AWPROT</span>(s0_axi_awprot),</span><br><span class="line">		<span class="variable">.S_AXI_AWVALID</span>(s0_axi_awvalid),</span><br><span class="line">		<span class="variable">.S_AXI_AWREADY</span>(s0_axi_awready),</span><br><span class="line">		<span class="variable">.S_AXI_WDATA</span>(s0_axi_wdata),</span><br><span class="line">		<span class="variable">.S_AXI_WSTRB</span>(s0_axi_wstrb),</span><br><span class="line">		<span class="variable">.S_AXI_WVALID</span>(s0_axi_wvalid),</span><br><span class="line">		<span class="variable">.S_AXI_WREADY</span>(s0_axi_wready),</span><br><span class="line">		<span class="variable">.S_AXI_BRESP</span>(s0_axi_bresp),</span><br><span class="line">		<span class="variable">.S_AXI_BVALID</span>(s0_axi_bvalid),</span><br><span class="line">		<span class="variable">.S_AXI_BREADY</span>(s0_axi_bready),</span><br><span class="line">		<span class="variable">.S_AXI_ARADDR</span>(s0_axi_araddr),</span><br><span class="line">		<span class="variable">.S_AXI_ARPROT</span>(s0_axi_arprot),</span><br><span class="line">		<span class="variable">.S_AXI_ARVALID</span>(s0_axi_arvalid),</span><br><span class="line">		<span class="variable">.S_AXI_ARREADY</span>(s0_axi_arready),</span><br><span class="line">		<span class="variable">.S_AXI_RDATA</span>(s0_axi_rdata),</span><br><span class="line">		<span class="variable">.S_AXI_RRESP</span>(s0_axi_rresp),</span><br><span class="line">		<span class="variable">.S_AXI_RVALID</span>(s0_axi_rvalid),</span><br><span class="line">		<span class="variable">.S_AXI_RREADY</span>(s0_axi_rready)</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Add user logic here</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// User logic ends</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>默认生成的顶层代码大同小异，无非是AXI总线有无的区别</p>
<p>这里省略AXI总线逻辑代码（太长了）</p>
<p>注意改动代码时如果涉及到接口，需要同时修改顶层代码和AXI总线实现</p>
<p>其中比较常用的部分已经被Vivado自动空出来，如下所示：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在开头有这四行代码</span></span><br><span class="line">	<span class="comment">// Users to add parameters here</span></span><br><span class="line"><span class="comment">//中间可以存放自定义的参数</span></span><br><span class="line">	<span class="comment">// User parameters ends</span></span><br><span class="line">	......</span><br><span class="line">	<span class="comment">// Users to add ports here</span></span><br><span class="line"><span class="comment">//中间可以存放自定义的端口代码</span></span><br><span class="line">	<span class="comment">// User ports ends</span></span><br><span class="line">	......</span><br><span class="line"><span class="comment">//在末尾有这两行代码</span></span><br><span class="line">	<span class="comment">// Add user logic here</span></span><br><span class="line"><span class="comment">//中间就可以存放自定义的模块顶层例化代码</span></span><br><span class="line">	<span class="comment">// User logic ends</span></span><br></pre></td></tr></table></figure>

<p>右键点击【Design Sources】，选择添加新的HDL文件，编写呼吸灯控制代码，如下所示，并保存</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> breath_led(</span><br><span class="line">    <span class="keyword">input</span>          clk            , <span class="comment">//时钟信号</span></span><br><span class="line">    <span class="keyword">input</span>          <span class="number">_</span>rst           , <span class="comment">//复位信号</span></span><br><span class="line">    <span class="keyword">input</span>          sw_ctrl        , <span class="comment">//控制寄存器：呼吸灯开关控制信号 1：亮 0:灭</span></span><br><span class="line">    <span class="keyword">input</span>          led_en         , <span class="comment">//控制寄存器：设置呼吸灯频率设置使能信号</span></span><br><span class="line">    <span class="keyword">input</span>   [<span class="number">9</span>:<span class="number">0</span>]  set_freq_step  , <span class="comment">//控制寄存器：设置呼吸灯频率变化步长</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">output</span>         led              <span class="comment">//输出引脚，控制LED</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span>  START_FREQ_STEP = <span class="number">10&#x27;d100</span>; <span class="comment">//设置频率步长初始值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>  [<span class="number">15</span>:<span class="number">0</span>]  period_cnt  ;      <span class="comment">//周期计数器</span></span><br><span class="line"><span class="keyword">reg</span>  [<span class="number">9</span>:<span class="number">0</span>]   freq_step   ;      <span class="comment">//呼吸灯频率间隔步长</span></span><br><span class="line"><span class="keyword">reg</span>  [<span class="number">15</span>:<span class="number">0</span>]  duty_cycle  ;      <span class="comment">//设置高电平占空比的计数点</span></span><br><span class="line"><span class="keyword">reg</span>          inc_dec_flag;      <span class="comment">//用于表示高电平占空比的计数值,是递增还是递减</span></span><br><span class="line">                                <span class="comment">//为1时表示占空比递减,为0时表示占空比递增</span></span><br><span class="line"><span class="keyword">wire</span>         led_t       ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将周期信号计数值与占空比计数值进行比较，以输出驱动led的PWM信号</span></span><br><span class="line"><span class="keyword">assign</span> led_t = ( period_cnt &lt;= duty_cycle ) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span> ;</span><br><span class="line"><span class="keyword">assign</span> led = led_t &amp; sw_ctrl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//周期信号计数器在0-50_000之间计数</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="number">_</span>rst)</span><br><span class="line">        period_cnt &lt;= <span class="number">16&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!sw_ctrl)</span><br><span class="line">        period_cnt &lt;= <span class="number">16&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( period_cnt == <span class="number">16&#x27;d50_000</span> )</span><br><span class="line">        period_cnt &lt;= <span class="number">16&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        period_cnt &lt;= period_cnt + <span class="number">16&#x27;d1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置频率间隔</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="number">_</span>rst)</span><br><span class="line">        freq_step &lt;= START_FREQ_STEP;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(led_en)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(set_freq_step == <span class="number">0</span>)</span><br><span class="line">            freq_step &lt;= <span class="number">10&#x27;d1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(set_freq_step &gt;= <span class="number">10&#x27;d1_000</span>)</span><br><span class="line">            freq_step &lt;= <span class="number">10&#x27;d1_000</span>;</span><br><span class="line">        <span class="keyword">else</span>    </span><br><span class="line">            freq_step &lt;= set_freq_step;</span><br><span class="line">    <span class="keyword">end</span>        </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设定高电平占空比的计数值</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">_</span>rst == <span class="number">1&#x27;b0</span>)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        duty_cycle &lt;= <span class="number">16&#x27;d0</span>;</span><br><span class="line">        inc_dec_flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!sw_ctrl)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        duty_cycle &lt;= <span class="number">16&#x27;d0</span>; <span class="comment">//呼吸灯开关关闭时，信号清零</span></span><br><span class="line">        inc_dec_flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(period_cnt == <span class="number">16&#x27;d50_000</span>) <span class="comment">//每次计数完了一个周期，就调节占空比计数值</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(inc_dec_flag) <span class="comment">//占空比递减</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(duty_cycle == <span class="number">16&#x27;d0</span>)     </span><br><span class="line">                inc_dec_flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(duty_cycle &lt; freq_step)</span><br><span class="line">                duty_cycle &lt;= <span class="number">16&#x27;d0</span>;</span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                duty_cycle &lt;= duty_cycle - freq_step;</span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">        <span class="keyword">begin</span> <span class="comment">//占空比递增</span></span><br><span class="line">           	<span class="keyword">if</span>(duty_cycle &gt;= <span class="number">16&#x27;d50_000</span>)</span><br><span class="line">                inc_dec_flag &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                duty_cycle &lt;= duty_cycle + freq_step;</span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        duty_cycle &lt;= duty_cycle; <span class="comment">//未计数完一个周期时，占空比保持不变</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>在Vivado自动生成的AXI总线逻辑文件中如下编写例化：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Users to add parameters here</span></span><br><span class="line">		<span class="keyword">parameter</span>  START_FREQ_STEP = <span class="number">10&#x27;d100</span>, <span class="comment">//参数设置</span></span><br><span class="line"><span class="comment">// User parameters ends</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Users to add ports here</span></span><br><span class="line">		<span class="keyword">output</span> led, <span class="comment">//LED端口</span></span><br><span class="line"><span class="comment">// User ports ends</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Add user logic here</span></span><br><span class="line">	breath_led #(</span><br><span class="line">		<span class="variable">.START_FREQ_STEP</span> (START_FREQ_STEP) <span class="comment">//例化参数</span></span><br><span class="line">	)</span><br><span class="line">	u_breath_led(</span><br><span class="line">		<span class="variable">.clk</span>          	 (S_AXI_ACLK),		<span class="comment">//时钟信号</span></span><br><span class="line">		<span class="variable">._rst</span>         	 (S_AXI_ARESETN),	<span class="comment">//复位信号</span></span><br><span class="line">		<span class="variable">.sw_ctrl</span>      	 (slv_reg0[<span class="number">0</span>]),		<span class="comment">//AXI信号线0最低位为控制信号</span></span><br><span class="line">		<span class="variable">.led_en</span>       	 (slv_reg1[<span class="number">31</span>]),	<span class="comment">//AXI信号线1最高位为使能信号</span></span><br><span class="line">		<span class="variable">.set_freq_step</span>	 (slv_reg1[<span class="number">9</span>:<span class="number">0</span>]),	<span class="comment">//AXI信号线1第10位表示步长</span></span><br><span class="line">		<span class="variable">.led</span>			 (led)				<span class="comment">//输出信号</span></span><br><span class="line">	);</span><br><span class="line"><span class="comment">// User logic ends</span></span><br></pre></td></tr></table></figure>

<p>在Vivado自动生成的顶层文件中如下编写例化：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Users to add parameters here</span></span><br><span class="line">		<span class="keyword">parameter</span>  START_FREQ_STEP = <span class="number">10&#x27;d100</span>, <span class="comment">//初始参数值</span></span><br><span class="line"><span class="comment">// User parameters ends</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Users to add ports here</span></span><br><span class="line">		<span class="keyword">output</span> led, <span class="comment">//LED输出端口例化</span></span><br><span class="line"><span class="comment">// User ports end</span></span><br><span class="line"></span><br><span class="line">breath_LED_IP_v1_0_S0_AXI # ( </span><br><span class="line">		<span class="variable">.START_FREQ_STEP</span>(START_FREQ_STEP),  <span class="comment">//例化参数默认值</span></span><br><span class="line">		<span class="variable">.C_S_AXI_DATA_WIDTH</span>(C_S0_AXI_DATA_WIDTH),</span><br><span class="line">		<span class="variable">.C_S_AXI_ADDR_WIDTH</span>(C_S0_AXI_ADDR_WIDTH)</span><br><span class="line">	) breath_LED_IP_v1_0_S0_AXI_inst (</span><br><span class="line">		<span class="variable">.led</span>(led), <span class="comment">//例化LED输出端口</span></span><br><span class="line">		<span class="variable">.S_AXI_ACLK</span>(s0_axi_aclk),</span><br><span class="line">		<span class="variable">.S_AXI_ARESETN</span>(s0_axi_aresetn),</span><br><span class="line">		<span class="variable">.S_AXI_AWADDR</span>(s0_axi_awaddr),</span><br><span class="line">		<span class="variable">.S_AXI_AWPROT</span>(s0_axi_awprot),</span><br><span class="line">		<span class="variable">.S_AXI_AWVALID</span>(s0_axi_awvalid),</span><br><span class="line">		<span class="variable">.S_AXI_AWREADY</span>(s0_axi_awready),</span><br><span class="line">		<span class="variable">.S_AXI_WDATA</span>(s0_axi_wdata),</span><br><span class="line">		<span class="variable">.S_AXI_WSTRB</span>(s0_axi_wstrb),</span><br><span class="line">		<span class="variable">.S_AXI_WVALID</span>(s0_axi_wvalid),</span><br><span class="line">		<span class="variable">.S_AXI_WREADY</span>(s0_axi_wready),</span><br><span class="line">		<span class="variable">.S_AXI_BRESP</span>(s0_axi_bresp),</span><br><span class="line">		<span class="variable">.S_AXI_BVALID</span>(s0_axi_bvalid),</span><br><span class="line">		<span class="variable">.S_AXI_BREADY</span>(s0_axi_bready),</span><br><span class="line">		<span class="variable">.S_AXI_ARADDR</span>(s0_axi_araddr),</span><br><span class="line">		<span class="variable">.S_AXI_ARPROT</span>(s0_axi_arprot),</span><br><span class="line">		<span class="variable">.S_AXI_ARVALID</span>(s0_axi_arvalid),</span><br><span class="line">		<span class="variable">.S_AXI_ARREADY</span>(s0_axi_arready),</span><br><span class="line">		<span class="variable">.S_AXI_RDATA</span>(s0_axi_rdata),</span><br><span class="line">		<span class="variable">.S_AXI_RRESP</span>(s0_axi_rresp),</span><br><span class="line">		<span class="variable">.S_AXI_RVALID</span>(s0_axi_rvalid),</span><br><span class="line">		<span class="variable">.S_AXI_RREADY</span>(s0_axi_rready)</span><br><span class="line">	);</span><br></pre></td></tr></table></figure>

<p>编辑完成后即可退回原菜单</p>
<p>点击左侧流程中的【Run Synthesis】即可进行IP核的综合</p>
<h3 id="设置IP的可视化界面"><a href="#设置IP的可视化界面" class="headerlink" title="设置IP的可视化界面"></a>设置IP的可视化界面</h3><p>打开xml文件后即可在Vivado中进行编辑，</p>
<p>按顺序设置即可</p>
<p>其中在【Customization Parameters】菜单下会出现“更新参数”的选项提示，更新后会现多出一行自定义的参数，双击它如下图进行设置，即可将这个参数反映到IP可视化界面</p>
<p><img src="/2021/11/19/FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E3%80%90%E5%9F%BA%E4%BA%8EVivado%E5%B0%81%E8%A3%85%E8%87%AA%E5%AE%9A%E4%B9%89IP%E3%80%91/image-20210511201028511.png" alt="image-20210511201028511"></p>
<p>完成所有设置并确认无误后，即可在最后选项【Review and Package】中点击【Re-Package IP】即可封装IP</p>
<p>关闭项目后可以在原来的Vivado窗口中看到如下显示</p>
<p><img src="/2021/11/19/FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E3%80%90%E5%9F%BA%E4%BA%8EVivado%E5%B0%81%E8%A3%85%E8%87%AA%E5%AE%9A%E4%B9%89IP%E3%80%91/image-20210511201745806.png" alt="image-20210511201745806"></p>
<p>证明完成了IP封装</p>
<h2 id="使用自定义IP"><a href="#使用自定义IP" class="headerlink" title="使用自定义IP"></a>使用自定义IP</h2><h3 id="硬件部分"><a href="#硬件部分" class="headerlink" title="硬件部分"></a>硬件部分</h3><p>完成封装IP后，在任意工程中点击左侧【IP INTERGRATOR】-【Create Block Design】创建基于IP核的FPGA设计</p>
<p>但此时IP选项列表中没有自定义IP核，需要自己将IP核添加到工程</p>
<p>选择【Tools】-【Settings】-【IP】-【Repository】-【Add（加号+）】选择存放自定义IP的文件目录，即可将自定义的IP核添加到项目</p>
<p>如下图对IP核进行设置</p>
<p><img src="/2021/11/19/FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E3%80%90%E5%9F%BA%E4%BA%8EVivado%E5%B0%81%E8%A3%85%E8%87%AA%E5%AE%9A%E4%B9%89IP%E3%80%91/image-20210511204531656.png" alt="image-20210511204531656"></p>
<p>设置ZYNQ系统的DDR控制器和外设后，先进行自动生成原理图，再进行自动布线即可</p>
<p>注意要在led引脚处右键选择【Make External】生成一个引出的外部引脚，并将其改名为led</p>
<p><strong>生成外部引脚的过程就是使能逻辑块与IO块连接的过程</strong></p>
<p>接下来按照正常步骤生成硬件平台配置</p>
<p>由于led端口连接到PL部分，所以需要进行管脚约束才能使用</p>
<p>点击左侧综合按钮，综合后打开引脚设置（I/O Ports），将led_0的引脚映射到PL部分MIO上</p>
<p>根据手头的开发板选择引出引脚即可</p>
<p><img src="/2021/11/19/FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E3%80%90%E5%9F%BA%E4%BA%8EVivado%E5%B0%81%E8%A3%85%E8%87%AA%E5%AE%9A%E4%B9%89IP%E3%80%91/image-20210511210615915.png" alt="image-20210511210615915"></p>
<p>这里选用的是PL Bank的P15引脚</p>
<p>最后生成比特流并导出到硬件即可</p>
<h3 id="软件部分"><a href="#软件部分" class="headerlink" title="软件部分"></a>软件部分</h3><p>还是原来的步骤从.xsa文件导入配置到Vitis，并创建一个新应用程序</p>
<p>使用的软件代码如下所示</p>
<p>总体思路就是读写外设寄存器映射来的地址对外设寄存器进行操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;xparameters.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;xil_printf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;breath_led_ip.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;xil_io.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sleep.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LED_IP_BASEADDR   XPAR_BREATH_LED_IP_0_S0_AXI_BASEADDR</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LED_IP_REG0       BREATH_LED_IP_S0_AXI_SLV_REG0_OFFSET</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LED_IP_REG1       BREATH_LED_IP_S0_AXI_SLV_REG1_OFFSET</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> freq_flag;</span><br><span class="line">    <span class="keyword">int</span> led_state;</span><br><span class="line"></span><br><span class="line">	xil_printf(<span class="string">&quot;LED User IP Test!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">if</span>(freq_flag == <span class="number">0</span>)</span><br><span class="line">     	&#123;</span><br><span class="line">    		BREATH_LED_IP_mWriteReg(LED_IP_BASEADDR,LED_IP_REG1,<span class="number">0x800000ef</span>);</span><br><span class="line">        	freq_flag = <span class="number">1</span>;</span><br><span class="line">     	&#125;</span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">     	&#123;</span><br><span class="line">    	 	BREATH_LED_IP_mWriteReg(LED_IP_BASEADDR,LED_IP_REG1,<span class="number">0x8000002f</span>);</span><br><span class="line">         	freq_flag = <span class="number">0</span>;</span><br><span class="line">     	&#125;</span><br><span class="line">     	led_state = BREATH_LED_IP_mReadReg(LED_IP_BASEADDR,LED_IP_REG0);</span><br><span class="line"></span><br><span class="line">     	<span class="keyword">if</span>(led_state == <span class="number">0</span>)</span><br><span class="line">     	&#123;</span><br><span class="line">    	 	BREATH_LED_IP_mWriteReg (LED_IP_BASEADDR, LED_IP_REG0, <span class="number">1</span>);</span><br><span class="line">         	xil_printf(<span class="string">&quot;Breath LED ON\n&quot;</span>);</span><br><span class="line">     	&#125;</span><br><span class="line">     	sleep(<span class="number">5</span>);</span><br><span class="line">     	led_state = BREATH_LED_IP_mReadReg(LED_IP_BASEADDR,LED_IP_REG0);</span><br><span class="line">     	</span><br><span class="line">        <span class="keyword">if</span>(led_state == <span class="number">1</span>)</span><br><span class="line">     	&#123;</span><br><span class="line">    	 	BREATH_LED_IP_mWriteReg (LED_IP_BASEADDR, LED_IP_REG0, <span class="number">0</span>);</span><br><span class="line">         	xil_printf(<span class="string">&quot;Breath LED OFF\n&quot;</span>);</span><br><span class="line">     	&#125;</span><br><span class="line">     	sleep(<span class="number">1</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>烧录后LED呈呼吸灯效果，且可以看到呼吸灯闪烁频率变化</p>
<h1 id="封装不带AXI接口的IP核"><a href="#封装不带AXI接口的IP核" class="headerlink" title="封装不带AXI接口的IP核"></a>封装不带AXI接口的IP核</h1><p>Vivado支持将独立的RTL代码封装为IP核，方便以类似函数的方式重用IP核，同时可使用用户自定义的IP核接口协议</p>
<p>参考【ug1118】手册来获取详细信息</p>
<h2 id="创建自定义IP-1"><a href="#创建自定义IP-1" class="headerlink" title="创建自定义IP"></a>创建自定义IP</h2><h3 id="IP核逻辑封装"><a href="#IP核逻辑封装" class="headerlink" title="IP核逻辑封装"></a>IP核逻辑封装</h3><ol>
<li>创建一个RTL工程</li>
<li>编辑IP核的RTL代码</li>
<li>验证IP核逻辑并进行仿真</li>
<li>创建一个基于已有RTL代码的IP核封装</li>
<li>修改顶层文件</li>
<li>设置IP核端口和控制引脚端口输入输出模式（端口映射）</li>
<li>修改IP核的可视化界面配置进行封装</li>
<li>创建接口定义</li>
</ol>
<h3 id="接口封装"><a href="#接口封装" class="headerlink" title="接口封装"></a>接口封装</h3><ol>
<li>编辑接口协议的RTL实现</li>
<li>在IP核封装完成后在配置接口定义部分对接口进行相关设置</li>
<li>依次调整接口协议封装</li>
<li>添加接口协议的RTL文件</li>
<li>进行接口RTL文件的顶层文件端口映射</li>
<li>点击【Package IP】完成IP核封装</li>
</ol>
<h3 id="使用自定义IP核"><a href="#使用自定义IP核" class="headerlink" title="使用自定义IP核"></a>使用自定义IP核</h3><p>封装好的IP核如果出现适用设备相关的错误，可以直接删除对应的封装信息</p>
<p>使用IP核前需要先对IP核进行验证，可以选择编写testbench（普普通通的ZYNQ-7020板子配那么小的LUT规模直接烧就完事了！），也可以直接烧录到开发板（如果开发板很贵就别这样干了）</p>
<p>IP核验证完毕后就可以随意使用了</p>
<h3 id="封装IP核时可能遇到的问题"><a href="#封装IP核时可能遇到的问题" class="headerlink" title="封装IP核时可能遇到的问题"></a>封装IP核时可能遇到的问题</h3><ol>
<li><p>封装的IP核中包含了其他IP核</p>
<p> 如果包含了.xci文件（IP核的配置文件），Vivado会直接用新生成的子IP创建输出文件</p>
<p> 如果包含IP核的输出文件，Vivado则会从IP设置中生成HDL和XDC代码</p>
<p> 封装时推荐直接使用包含.xci文件的方式打包IP核，这样会方便重用IP和生成输出文件</p>
<p> 只要在打包当前IP的时候选择相关选项即可</p>
</li>
<li><p>如果在封装前分配好了引脚约束应该怎么办</p>
<p> 一般来说使用IP核的时候再进行引脚约束的过程会把之前的引脚约束覆盖掉</p>
<p> 但是为了保证不出错，一般在打包前或打包后将IP核的.xdc文件删除</p>
</li>
</ol>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">FPGA</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2021/11/19/FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E3%80%90%E5%9F%BA%E4%BA%8EVivado%E5%B0%81%E8%A3%85%E8%87%AA%E5%AE%9A%E4%B9%89IP%E3%80%91/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-FPGA学习笔记2【基础概念】" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/19/FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%E3%80%90%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E3%80%91/">FPGA学习笔记2【基础概念】</a>
    </h1>
  

        
<!-- 显示阅读次数-->
<!--  -->
<!--显示阅读次数完毕 -->

        
        <a href="/2021/11/19/FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%E3%80%90%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E3%80%91/" class="archive-article-date">
  	<time datetime="2021-11-19T08:09:38.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2021-11-19</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>Xilinx系FPGA使用vivado全家桶进行开发</p>
<p>性价比/低功耗：Spartan系列，常见Spartan-6、Spartan-7</p>
<p>中端/性价比：Artix系列，常见Artix-6、Artix-7</p>
<p>中高端：Kintex系列，常见Kintex-7</p>
<p>旗舰：Virtex系列，常见Virtex-7</p>
<p>命名规则：以Spartan-7 xc7s15ftgb196-1为例</p>
<table>
<thead>
<tr>
<th>用途级别</th>
<th>哪一代产品</th>
<th>逻辑单元数</th>
<th>封装类型</th>
<th>RoHS</th>
<th>封装元件号</th>
<th>引脚数</th>
<th>速度等级</th>
</tr>
</thead>
<tbody><tr>
<td>xc</td>
<td>7</td>
<td>15</td>
<td>ft</td>
<td>g</td>
<td>b</td>
<td>196</td>
<td>-1</td>
</tr>
<tr>
<td>商业级</td>
<td>第7代</td>
<td>15k个逻辑单元（单位为k）</td>
<td>1mm</td>
<td>6/6</td>
<td></td>
<td>共196引脚</td>
<td>慢速</td>
</tr>
</tbody></table>
<p>速度等级如下</p>
<table>
<thead>
<tr>
<th>-1</th>
<th>-L1</th>
<th>-L2</th>
<th>-2</th>
<th>-3</th>
</tr>
</thead>
<tbody><tr>
<td>慢速</td>
<td>慢速低功耗</td>
<td>中等速度低功耗</td>
<td>中等速度</td>
<td>高速</td>
</tr>
</tbody></table>
<h2 id="FPGA内部资源简介"><a href="#FPGA内部资源简介" class="headerlink" title="FPGA内部资源简介"></a>FPGA内部资源简介</h2><p>常用可编程逻辑器件：</p>
<ul>
<li>CPLD：复杂可编程逻辑器件。基于<strong>乘积项</strong>的与或逻辑阵列，基于FLASH运行，逻辑写入后会一直保存，掉电不丢失</li>
<li>FPGA：现场可编程门阵列。基于<strong>查找表</strong>的CLB阵列，基于SRAM运行，采用CMOS工艺制造，逻辑写入后需要上电才能保存，掉电丢失</li>
</ul>
<p>这两种器件都只能编程数字电路，无法在其上建立模拟电路</p>
<p><strong>FPGA的编程数据实际上存储在其中的SRAM里</strong>，运行时将数据读出配置好片上硬件资源运行；很多FPGA会配有单独的PROM，在运行时先将PROM读入片内RAM，配置完成后，FPGA开始工作；掉电后FPGA内部逻辑关系清空</p>
<p><strong>FPGA可以反复使用</strong>，一块Artix传祖孙三代天天用都不成问题；如果使用外接PROM的方法，FPGA的编程不需要专用的FPGA编程器，只要用通用的PROM编程器编程即可</p>
<p>FPGA内部一般有以下硬件资源：</p>
<ul>
<li>可编程逻辑单元（Xilinx制造的FPGA中将其称为CLB可编程逻辑块，由多个基本的LUT查找表、REG寄存器、MUX多路选择器组成）</li>
<li>可编程IO单元（用于可编程逻辑与外部引脚的连接）</li>
<li>底层嵌入功能单元（包括但不限于PLL、ADC等数字/模拟电路器件）</li>
<li>嵌入式块RAM（用于存储内部数据和可编程的硬件逻辑）</li>
<li>布线资源（将各个功能模块之间连接起来）</li>
<li>硬核（只有一部分FPGA才会嵌入，一般功能比较专用）</li>
</ul>
<p>其中<strong>CLB是组成FPGA的基本逻辑单元</strong>，<strong>LUT则是FPGA中逻辑表达式的基础</strong></p>
<h2 id="常用电路结构"><a href="#常用电路结构" class="headerlink" title="常用电路结构"></a>常用电路结构</h2><p>FPGA不擅长顺序结构，更擅长并行结构，如果要使用FPGA处理顺序结构的算法，比较常用有限状态机模型（FSM）</p>
<h3 id="有限状态机FSM（Finite-State-Machine）"><a href="#有限状态机FSM（Finite-State-Machine）" class="headerlink" title="有限状态机FSM（Finite State Machine）"></a>有限状态机FSM（Finite State Machine）</h3><p>有限状态机：在有限个状态之间按一定规律转换的时序电路</p>
<p>在FPGA中经常使用<strong>mealy状态机，它由当前输入和当前状态共同决定其输出</strong></p>
<p>状态机内部使用状态寄存器来存储当前状态：<strong>状态寄存器</strong>由一组触发器组成，用于记忆状态机当前所处的状态，这个状态的改变一般只发生在时钟信号跳变沿</p>
<p>状态是否改变、如何改变都取决于当前输入和当前状态的组合逻辑F（<strong>F是当前状态和输入信号的函数</strong>）</p>
<p>状态机的输出则由当前输入和当前状态的输出组合逻辑G决定（<strong>G也是当前状态和输入信号的函数</strong>）</p>
<p>组合逻辑F是状态寄存器的激励，当时钟信号跳变时，组合逻辑被读入状态寄存器，同时当前状态被输出到组合逻辑G</p>
<p><strong>输出只取决于当前状态的状态机称为moore状态机</strong></p>
<h3 id="四段论法构建FSM"><a href="#四段论法构建FSM" class="headerlink" title="四段论法构建FSM"></a>四段论法构建FSM</h3><ol>
<li>定义状态空间</li>
</ol>
<p>主要任务是<strong>构建状态寄存器和输出寄存器</strong></p>
<p>所有状态的集合称为状态空间</p>
<p>使用verilog对状态进行编码，使用一组二进制数表示状态的过程即为定义状态空间</p>
<p>之后应当定义两个reg变量，分别用于存储当前状态和下一个状态；如果需要用到以前的状态，相关变量也应该在这时候进行定义</p>
<p>推荐使用<code>独热码</code>进行编码</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">parameter</span> a=<span class="number">4&#x27;b0001</span>;</span><br><span class="line"><span class="keyword">parameter</span> a=<span class="number">4&#x27;b0010</span>;</span><br><span class="line"><span class="keyword">parameter</span> a=<span class="number">4&#x27;b0100</span>;</span><br><span class="line"><span class="keyword">parameter</span> a=<span class="number">4&#x27;b1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] current_state;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] next_state;</span><br></pre></td></tr></table></figure>

<p>注意变量位宽与编码位宽一致</p>
<ol start="2">
<li>配置状态跳转规则（时序逻辑）</li>
</ol>
<p>主要任务是<strong>构建组合逻辑G的状态转移部分</strong></p>
<p>一般使用<code>always块</code>配合posedge、negedge进行控制，敏感列表以时钟信号和复位边沿信号的组合进行定义</p>
<p>在块中使用非阻塞赋值来保证电路实时性</p>
<ol start="3">
<li>判断下个状态（组合逻辑）</li>
</ol>
<p>主要任务是<strong>构建组合逻辑F的输出部分</strong></p>
<p>使用当前状态和输入信号组成always块的敏感列表</p>
<p>使用<code>case</code>语句通过当前状态的编码筛选出当前状态，<strong>在case语句内嵌套</strong><code>if..else...</code>语句，根据输入信号情况为下一状态进行赋值（注意：<strong>if和else一定要配对</strong>，否则可能产生latch）</p>
<p>在块中使用阻塞赋值来保证电路不会出现时序错误</p>
<ol start="4">
<li>设置各个状态下的动作（组合逻辑）</li>
</ol>
<p>主要任务是<strong>构建组合逻辑G的输出寄存器</strong></p>
<p>一般是使用<code>assign</code>语句或<code>always块</code>对动作进行赋值</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用assign语句</span></span><br><span class="line"><span class="keyword">wire</span> output_1;</span><br><span class="line"><span class="keyword">assign</span> output_1=(current_state == T) ? <span class="number">1&#x27;b0</span> :<span class="number">1&#x27;b1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用always块</span></span><br><span class="line"><span class="keyword">wire</span> output_1;</span><br><span class="line"><span class="keyword">always</span> @(current_state) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(current_state == T)</span><br><span class="line">        output_1=<span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        output_1=<span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>不管使用哪种形式都应该以当前状态为基准进行判断</p>
<p>第四个部分搭建的电路相当于在组合输出逻辑G后面再加了一层由clk为控制时钟的同步寄存器，可以将输出逻辑与外部电路隔离</p>
<p>不加第四个部分的电路相当于由三段法构建，加上第四个部分的电路才是完整的四段法状态机</p>
<p>第四个部分的作用如下：</p>
<ul>
<li>滤除组合逻辑输出的毛刺</li>
<li>更有效地进行时序计算与约束</li>
<li>更容易使总线数据对齐，减小总线数据间偏移（防止总线信号线到达时间的差距），减小接收端数据采样出错的频率</li>
</ul>
<h3 id="加法器与乘法器"><a href="#加法器与乘法器" class="headerlink" title="加法器与乘法器"></a>加法器与乘法器</h3><p>直接在verilog模块中使用普通加法、乘法运算，综合后就可以得到超前进位加法器、乘法器，可以通过设置综合优化项目获取更小面积或更高性能</p>
<h1 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h1><p>以点灯程序为例</p>
<h2 id="确定设计方向"><a href="#确定设计方向" class="headerlink" title="确定设计方向"></a>确定设计方向</h2><ol>
<li>设计控制LED的GPIO，引出到外部引脚</li>
<li>设计计数器，控制1s延时</li>
<li>系统由50MHz时钟控制</li>
<li>需要一个复位信号输入</li>
</ol>
<h2 id="使用vivado开发"><a href="#使用vivado开发" class="headerlink" title="使用vivado开发"></a>使用vivado开发</h2><p>vivado是xilinx推出的专用于自家FPGA、SoC的IDE，提供了包括可视化IDE、Tcl脚本、Tcl Shell、IDE内嵌Tcl控制台命令的使用方式。使用流程在vivado界面左端的目录中展示</p>
<p>提供Tcl、AXI4、IP-XACT、Synopsys设计约束（SDC）等业界标准支持，Verilog HDL、VHDL、SystemVerilog三种硬件描述语言的支持，SystemC、C、C++三种软件语言高层次综合（HLS）的支持</p>
<h3 id="vivado中的电路结构网表描述"><a href="#vivado中的电路结构网表描述" class="headerlink" title="vivado中的电路结构网表描述"></a>vivado中的电路结构网表描述</h3><p>网表由单元（Ceil）、引脚（Pin）、端口（Port）、网络（Net）组成</p>
<p><strong>单元</strong>即设计单元，包括设计模块/实体、元件库中的基本元素（如LUT、FF、RAM、DSP等）、硬件功能的类属技术表示和黑盒</p>
<p><strong>引脚</strong>是单元上的连接点</p>
<p><strong>端口</strong>是设计的顶层端口</p>
<p><strong>网络</strong>类似电路设计中的“节点”，连接引脚、端口</p>
<h3 id="工程数据的目录结构"><a href="#工程数据的目录结构" class="headerlink" title="工程数据的目录结构"></a>工程数据的目录结构</h3><p><strong>和其他软件IDE一样</strong>，vivado中所有用户工程数据保存在当前工程目录中</p>
<p>vivado将统一的数据模型贯穿于整个设计流程中，使用Design Checkpoint（包含逻辑网表、约束、物理数据）文件对开发进度进行管理，该文件会在开发过程中生成，后缀名为<code>.dcp</code></p>
<p>项目目录下会包含以下内容</p>
<ul>
<li><p>工程名.xpr</p>
<p>  工程设置文件</p>
</li>
<li><p>工程名.run目录</p>
<p>  包含所有运行数据</p>
</li>
<li><p>工程名.srcs目录</p>
<p>  包含所有导入的HDL源文件、网表和XDC文件</p>
<p>  这些是设计过程中主要编写的文件</p>
</li>
<li><p>工程名.data目录</p>
<p>  保存布局规划和网表数据</p>
</li>
</ul>
<p>除此之外，vivado还会生成以下两种文件</p>
<ul>
<li><p>Journal文件（Vivado.jou）</p>
<p>  只包含Vivado IDE中执行的Tcl命令</p>
<p>  该文件会被保存在用户主目录下（如${HOME}或C:\Users\Administrator\AppData\Roaming\Xilinx\Vivado）</p>
<p>  用这个文件实现类似shell中“记录历史命令”的功能</p>
</li>
<li><p>Log文件</p>
<p>  包含Vivado IDE中所产生的所有消息（也会包含Tcl命令和结果、警告/错误信息）</p>
<p>  一般会和Journal文件保存在一起</p>
</li>
</ul>
<h3 id="vivado项目文件夹"><a href="#vivado项目文件夹" class="headerlink" title="vivado项目文件夹"></a>vivado项目文件夹</h3><p>一个vivado项目的文件夹通常包含以下几项：</p>
<ul>
<li>.xpr文件：Vivado IDE项目文件</li>
<li>.runs目录：包含所有运行数据</li>
<li>.srcs目录：包含所有被引用的HDL源文件和约束文件（网表文件、XDC文件等）</li>
<li>.data目录：存储和网表数据</li>
<li>.xdc目录：单独存储所有约束文件</li>
<li>.sim目录：存储所有仿真文件和testbench</li>
</ul>
<h3 id="Vivado设计模式"><a href="#Vivado设计模式" class="headerlink" title="Vivado设计模式"></a>Vivado设计模式</h3><ol>
<li><p>工程模式</p>
<p> 就是上面所说的创建工程-按照左边的流程一点点完成</p>
</li>
<li><p>非工程模式</p>
<p> 这是<strong>基于Tcl脚本的编译风格方法</strong>，用户需要自己管理源文件和设计流程</p>
<p> 全部使用Tcl指令运行，可以精确到每一步，会很繁琐但可以精细控制设计过程</p>
</li>
</ol>
<h3 id="XDC文件"><a href="#XDC文件" class="headerlink" title="XDC文件"></a>XDC文件</h3><p><strong>Vivado的一个特殊点就是它使用Xilinx设计约束（XDC）格式，不再支持ISE曾使用的用户约束文件（UCF）格式</strong></p>
<p>XDC约束是业界标准Synopsys设计约束（SDC）和Xilinx专有物理约束的组合</p>
<p>XDC文件是遵循Tcl语法的命令，使用vivado内置的Tcl解释器可以直接分析这些命令</p>
<p>特别注意：XDC命令是<strong>顺序执行</strong>的</p>
<h3 id="开发流程-1"><a href="#开发流程-1" class="headerlink" title="开发流程"></a>开发流程</h3><p>使用外部晶振作为时钟</p>
<p>在高级应用中通常会再写一个分频器或倍频器用于稳定信号或用于控制电路频率</p>
<h4 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h4><p>外部时钟为50MHz</p>
<p>系统时钟部分</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> LED(</span><br><span class="line">    <span class="keyword">input</span> clk,<span class="comment">//外部晶振时钟输入</span></span><br><span class="line">    <span class="keyword">input</span> <span class="number">_</span>rst,<span class="comment">//复位引脚输入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">1</span>:<span class="number">0</span>] led<span class="comment">//输出引脚控制LED</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>计数器部分</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">25</span>:<span class="number">0</span>] counter;<span class="comment">//外部时钟50MHz，计时1s，需要26位计数器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> <span class="number">_</span>rst)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="number">_</span>rst)<span class="comment">//如果复位引脚接地（按下复位按键）</span></span><br><span class="line">        counter&lt;=<span class="number">26&#x27;d0</span>;<span class="comment">//计数寄存器清零（复位）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(counter&lt;<span class="number">26&#x27;d5000_0000</span>)</span><br><span class="line">        counter&lt;=counter+<span class="number">1&#x27;b1</span>;<span class="comment">//向上计数</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        counter&lt;=<span class="number">26&#x27;d0</span>;<span class="comment">//到达计数上限时清零</span></span><br></pre></td></tr></table></figure>

<p>LED状态控制部分</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> led=(counter&lt;<span class="number">26&#x27;d2500_0000</span>) ? <span class="number">2&#x27;b01</span> : <span class="number">2&#x27;b10</span>;</span><br><span class="line"><span class="comment">//计数器小于计数位置时输出01，否则输出10</span></span><br></pre></td></tr></table></figure>

<p>总文件如下所示</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//`timescale 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> LED(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> <span class="number">_</span>rst,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">1</span>:<span class="number">0</span>] led</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//时钟寄存器</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">25</span>:<span class="number">0</span>] counter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IO输出部分</span></span><br><span class="line"><span class="keyword">assign</span> led=(counter&lt;<span class="number">26&#x27;d2500_0000</span>) ? <span class="number">2&#x27;b01</span> : <span class="number">2&#x27;b10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计数器部分</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> <span class="number">_</span>rst)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="number">_</span>rst)</span><br><span class="line">        counter&lt;=<span class="number">26&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(counter&lt;<span class="number">26&#x27;d5000_0000</span>)</span><br><span class="line">        counter&lt;=counter+<span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        counter&lt;=<span class="number">26&#x27;d0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h4 id="调用-自行配置IP、DSP等内部电路"><a href="#调用-自行配置IP、DSP等内部电路" class="headerlink" title="调用/自行配置IP、DSP等内部电路"></a>调用/自行配置IP、DSP等内部电路</h4><p>在vivado创建工程界面中常使用以下工程种类：</p>
<ol>
<li><p>RTL工程</p>
<p> 用户可以添加RTL源文件、Xilinx IP目录内的已有IP、用于层次化模块的EDIF网表、Vivado IP集成器内创建的块设计、数字信号处理的源文件到Vivado的<strong>RTL工程</strong>。其中使用已有IP可以包含Xilinx生成的XCI文件、由核生成器工具生成的已经过时的XCO文件、预编译的EDIF或者GNC格式的IP网表这些类型</p>
</li>
<li><p>Post-synthesis工程</p>
<p> 使用综合后的网表创建工程</p>
<p> 用户通过vivado、XST或第三方综合工具生成网表后选择这一工程选项，快速将其他平台的设计导入xilinx平台</p>
</li>
<li><p>I/O Planning工程</p>
<p> 创建一个空的I/O规划工程，先分配I/O和约束，再创建CSV、XDC和RTL输出文件。这些文件可用于创建原理图符号或印制PCB</p>
</li>
</ol>
<h4 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h4><p><strong>综合</strong>：将RTL级设计描述转换成门级描述的过程</p>
<p>vivado的综合是基于时间驱动的，为存储器利用率和性能做了优化。目前综合工具支持SystemVerilog、VHDL、Verilog三种语言及它们的混合，且支持XDC格式</p>
<p>综合工具需要使用XDC约束驱动综合优化，所以<strong>必须存在XDC文件</strong></p>
<h4 id="确定约束"><a href="#确定约束" class="headerlink" title="确定约束"></a>确定约束</h4><p>有两种类型的设计约束：</p>
<ul>
<li>物理约束：定义了引脚的位置和内部单元的绝对或相对位置，内部单元包括RAM、LUT、触发器和器件配置设置</li>
<li>时序约束：定义设计要求的频率。如果没有时序约束，Vivado仅会对布线长度和布局阻塞进行优化</li>
</ul>
<p>选择【Option】-【Strategy】右侧的下拉框中用于运行综合的预定义综合策略，设计者可以定义优化的方向</p>
<h4 id="执行综合"><a href="#执行综合" class="headerlink" title="执行综合"></a>执行综合</h4><p>RTL文件综合后将自动生成时序总结、时钟及其网络、DRC报告、噪声报告、利用率报告、功耗报告、原理图等选项，可以使用原理图查看综合后生成的完整网表结构</p>
<p>综合后，设计会表示为模块（Verilog中的module）、实体（VHDL中的Entity）的实例与基本元素（LUT、触发器、进位链元素、多路复用器MUX、块RAM、DSP单元、时钟元素、IO元素等）的网表集合</p>
<p>每个LUT表述的逻辑都能单独查看（真值表）</p>
<p>在windows下vivado的综合速度较慢，开始综合后需要等待一段时间</p>
<h4 id="行为级仿真"><a href="#行为级仿真" class="headerlink" title="行为级仿真"></a>行为级仿真</h4><p>在Simulation Sources目录下添加testbench文件，编写测试代码后就可以进行仿真</p>
<p>在左侧从窗口内找到SIMULATION选项并展开，点击【Run Simulation】-【Run Behavioral Simulation】就可以开始仿真</p>
<p>在Tcl Console中输入run命令可以控制仿真的运行时间；输入restart命令可以重新执行仿真</p>
<h4 id="实现约束"><a href="#实现约束" class="headerlink" title="实现约束"></a>实现约束</h4><h5 id="I-O规划"><a href="#I-O规划" class="headerlink" title="I/O规划"></a>I/O规划</h5><p>使用I/O Planning进行FPGA的输出引脚规划</p>
<p>可以使用Vivado的图形化界面添加引脚约束（点击I/O Planning选项），也可以在Constraints目录下添加约束文件并自行编写引脚约束</p>
<p>==注意约束文件使用XDC格式==</p>
<h5 id="设计实现"><a href="#设计实现" class="headerlink" title="设计实现"></a>设计实现</h5><p>在左侧选择【IMPLEMENTATION】，选择实现策略，可以自行调节设计实现优化的方向，包括以下内容：</p>
<ul>
<li>提高设计性能</li>
<li>减少LUT个数</li>
<li>添加整体功耗优化</li>
<li>修改流程步骤</li>
<li>减少阻塞和相关问题</li>
</ul>
<p>点击【Run Implementation】来执行设计实现</p>
<p>待完成后可以打开设计实现来查看FPGA内部布线及实际使用的逻辑资源</p>
<p>也可以查看相关报告</p>
<h4 id="静态时序分析STA"><a href="#静态时序分析STA" class="headerlink" title="静态时序分析STA"></a>静态时序分析STA</h4><p>一个器件的性能由构成设计单元的延迟决定，它可以通过静态时序分析（Static Timing Analysis，STA）验证</p>
<p>简单来说STA就是用来控制细化设备的延迟和时序的调试过程</p>
<h5 id="时序仿真"><a href="#时序仿真" class="headerlink" title="时序仿真"></a>时序仿真</h5><ol>
<li>选择需要使用的test-bench文件</li>
<li>选择vivado界面左侧【Run Simulation】-【Run Post-Implementation Timing Simulation】（运行实现后时序仿真）</li>
<li>执行时序仿真并观察仿真波形进行debug</li>
</ol>
<h4 id="生成比特流文件"><a href="#生成比特流文件" class="headerlink" title="生成比特流文件"></a>生成比特流文件</h4><p>比特流文件就是用于配置FPGA的编程文件，可以直接使用烧录器将比特流文件下载到目标FPGA中</p>
<ol>
<li><p>配置器件属性</p>
<p> 选择器件型号并进一步选择生成比特流文件的硬件约束</p>
</li>
<li><p>生成可编程文件</p>
<p> 在左侧窗口中选择【PROGRAM AND DEBUG】并右键选择【Bitstream Settings】即可打开比特流优化配置界面</p>
<p> 默认只生成一个二进制比特流<code>.bit</code>文件</p>
<p> 可以选择配置设定产生原始比特流<code>.rbt</code>文件、掩码文件、ASCII逻辑定位文件<code>.ll</code>、纯二进制文件<code>.bin</code>等选项</p>
</li>
</ol>
<h4 id="烧录使用"><a href="#烧录使用" class="headerlink" title="烧录使用"></a>烧录使用</h4><ol>
<li>开发板正常上电</li>
<li>开发板连接烧录器</li>
<li>将烧录器连接到PC并使用vivado连接烧录器（点击Auto Connect）</li>
<li>点击【Program Device】即可开始烧录</li>
</ol>
<h4 id="生成并烧录PROM文件"><a href="#生成并烧录PROM文件" class="headerlink" title="生成并烧录PROM文件"></a>生成并烧录PROM文件</h4><ol>
<li>除了生成比特流文件外还需要再选中“-bin_file”生成纯二进制文件</li>
<li>重新生成比特流文件和二进制文件</li>
<li>按照上面步骤连接开发板并在【Add Configuration Memory Part】-【Select Configuration Memory Part】中设置可用的SPI FLASH</li>
<li>正常烧录</li>
<li>配置开发板使PROM上电后自动将逻辑配置文件加载到FPGA</li>
</ol>
<h3 id="vivado支持的特殊开发方式"><a href="#vivado支持的特殊开发方式" class="headerlink" title="vivado支持的特殊开发方式"></a>vivado支持的特殊开发方式</h3><p>vivado是<strong>以IP为核心</strong>的设计工具</p>
<p>vivado具有一个<strong>共享的IP数据库</strong></p>
<h4 id="高层次综合"><a href="#高层次综合" class="headerlink" title="高层次综合"></a>高层次综合</h4><p>使用Vivado HLS软件可以将c、c++、system c语言编写的算法代码直接综合生成RTL代码</p>
<p>HLS从C语言中提取硬件结构的思路如下</p>
<ol>
<li>在顶层，从C代码中提取控制和数据通路</li>
<li>在顶层控制流的一些点将控制传递到子程序中</li>
<li>子程序可以与顶层或其他子程序并行执行</li>
<li>通过调度和绑定过程将C代码映射到硬件逻辑资源</li>
</ol>
<p>C代码的关键属性</p>
<ul>
<li><p>函数</p>
<p>  所有代码由函数组成，函数名被对应到RTL描述的模块</p>
</li>
<li><p>参数</p>
<p>  顶层函数的参数决定了硬件RTL本身的端口</p>
</li>
<li><p>类型</p>
<p>  变量类型越复杂，实现该变量所占用的面积越多</p>
</li>
<li><p>循环</p>
<p>  默认对于循环采用“回卷”的方式进行处理。对于每个C循环迭代，采用相同的状态或资源来实现。循环的处理分成三个部分：循环展开、循环平坦化和循环合并。默认情况下不展开循环，并将嵌套循环“平坦化”：将外层循环拆解为多个内层循环的组合；之后还会自动合并循环：将结果可以合并的多个循环在硬件层面上合并到统一的器件上</p>
</li>
<li><p>数组</p>
<p>  C代码中的数组常常被映射到FPGA中的BRAM资源，会因为存储器的读写操作具有互斥性而使得它会变成设备的性能瓶颈</p>
</li>
<li><p>操作符</p>
<p>  C代码中的操作符可能要求共享，通过共享可以在满足性能的前提下以控制面积或指定的硬件实现来满足并行化要求</p>
</li>
</ul>
<p>类似的，也可以使用C++算法描述并进行HLS</p>
<h4 id="IP集成库"><a href="#IP集成库" class="headerlink" title="IP集成库"></a>IP集成库</h4><p>Vivado提供了一个图形化界面用于调用自定义IP核，也可以使用代码方式调用IP核。IP核类似编程中的函数库，提供了数学运算加速器、硬件信号处理等电路，可以直接调用，非常方便</p>
<p>在左侧选择IP Catalog即可调用Vivado内置的一些IP核</p>
<p>点击即可调用，有些IP核需要自行下载</p>
<p>在弹出的窗口中调整IP核的相关约束，根据指示添加即可调用相关内容</p>
<p>用户也可以自行封装IP核以及自行连接已有IP核</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">FPGA</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2021/11/19/FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%E3%80%90%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E3%80%91/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-FPGA学习笔记1【FPGA原理与结构】" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/19/FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E3%80%90FPGA%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%93%E6%9E%84%E3%80%91/">FPGA学习笔记1【FPGA原理与结构】</a>
    </h1>
  

        
<!-- 显示阅读次数-->
<!--  -->
<!--显示阅读次数完毕 -->

        
        <a href="/2021/11/19/FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E3%80%90FPGA%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%93%E6%9E%84%E3%80%91/" class="archive-article-date">
  	<time datetime="2021-11-19T08:09:18.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2021-11-19</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>注意：本篇内容根据《FPGA原理和结构》（[日]天野英晴 著 赵谦 译）一书整理，作者也是初学者，有错漏请见谅</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>FPGA即<strong>现场可编程门阵列</strong>（Field Programmable Gate Arry），与之对应的是FPAA<strong>现场可编程模拟阵列</strong>（Field Programmable Analog Array）。这是一种可以通过重新编程来实现用户所需<strong>逻辑电路</strong>的半导体器件</p>
<h2 id="布尔代数"><a href="#布尔代数" class="headerlink" title="布尔代数"></a>布尔代数</h2><p>布尔运算是一种二值运算，在布尔运算中，运算数只有0或1，基本运算有<strong>与 ·</strong>、**或 +<strong>、</strong>非 ~**三种，可以通过这三种基本运算构造出异或、与非等等运算</p>
<p>布尔运算遵循的定理如下：</p>
<ul>
<li>零元：x·0=0，x+1=1</li>
<li>单位元：x·1=x，x+0=x</li>
<li>幂等律：x·x=x，x+x=x</li>
<li>补余律：x·(~x)=0，x+(~x)=1</li>
<li>互反律：~(~x)=x</li>
<li>常见的交换律、结合律、分配律</li>
<li>吸收律：x+(x·y)=x，x·(x+y)=x</li>
<li>德摩根定律：~(x+y)=(~x)·(~y)，~(x·y)=(~x)+(~y)</li>
</ul>
<p>布尔代数中的函数用<strong>逻辑表达式</strong>来描述，描述同一逻辑函数的逻辑表达式可能有多个。逻辑表达式中，逻辑变量以原变量或反变量的形式出现，原变量和反变量统称<strong>字面量</strong>，字面量的逻辑与称为<strong>与项</strong>，与项的逻辑或运算叫做<strong>积之和</strong>，包含所有字面量的与项称为最小项，由最小项构成的积之和称为标准积之和（<strong>标准积</strong>），类似的存在或项（字面量的逻辑或）、和之积、最大项、标准和的概念</p>
<p>逻辑函数还能通过<strong>真值表</strong>描述，针对逻辑函数所有可能的输入组合一一列出输出值就可以得到真值表。==一个逻辑函数的真值表唯一==，实现真值表定义的功能的电路称为<strong>查找表</strong>（LUT，Look-up Table），这就是FPGA的基本单元</p>
<p>写FPGA逻辑就是写其中的查找表逻辑</p>
<h2 id="数字电路"><a href="#数字电路" class="headerlink" title="数字电路"></a>数字电路</h2><p>数字电路也可以叫做逻辑电路</p>
<p>本质是用电路描述数字布尔逻辑。</p>
<p><strong>所有逻辑电路都能用积之和表达式来描述</strong></p>
<h3 id="组合逻辑电路"><a href="#组合逻辑电路" class="headerlink" title="组合逻辑电路"></a>组合逻辑电路</h3><p>不包含记忆元件，某时刻输出（逻辑函数值）仅取决于该时刻输入的数字电路就是组合逻辑电路</p>
<p>使用与-或-非三种门电路组合成的组合逻辑电路可以实现任何逻辑函数。这种方式被称为与-或逻辑电路或者是<strong>与-或阵列</strong></p>
<p>PLA（可编程逻辑阵列Programmable Logic Array）就是使用与-或阵列</p>
<h3 id="时序逻辑电路"><a href="#时序逻辑电路" class="headerlink" title="时序逻辑电路"></a>时序逻辑电路</h3><p>含有记忆元件，某时刻输出取决于该时刻输入及系统过去的电路状态的逻辑电路就是时序逻辑电路</p>
<p>时序逻辑电路分为同步和异步两种</p>
<p>同步时序电路的输入状态和内部状态的变化由时钟信号控制同步进行，但异步时序电路不需要时钟信号</p>
<p>异步时序电路设计需要考虑临界资源、亚稳态等诸多因素，FPGA很少涉及异步时序电路。一般地，FPGA使用有限状态机模型来实现同步时序电路，同步状态机将会在之后的硬件算法部分介绍</p>
<p>同步状态机分为Moore和Mealy两类，Mealy模型的状态数一般比Moore模型的少，电路规模一般也更小，但输入会立刻反映到输出，容易造成信号竞争导致非预期的错误输出，这种情况称为竞争<strong>冒险</strong>。Moore电路速度快且不易发生冒险，但是电路规模较大</p>
<h2 id="同步电路设计"><a href="#同步电路设计" class="headerlink" title="同步电路设计"></a>同步电路设计</h2><p>同步电路让系统状态的变化和时钟信号同步，从而降低电路设计难度</p>
<p><strong>同步电路设计是FPGA设计的基础</strong></p>
<p>触发器（Flip Flop，FF）是一种只能存储一个二进制位的存储单元，一般用作时序电路的记忆元件。FPGA内一般使用D触发器（D-FF）在时钟跳变沿将输入信号的变化传送至输出</p>
<p>它的真值表如下所示</p>
<table>
<thead>
<tr>
<th>输入 D</th>
<th>时钟 CLK</th>
<th>输出 Q</th>
<th>反相输出 Q</th>
</tr>
</thead>
<tbody><tr>
<td>x</td>
<td>0</td>
<td>保持之前状态</td>
<td>保持之前状态</td>
</tr>
<tr>
<td>0</td>
<td>上升沿</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>上升沿</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>x</td>
<td>1</td>
<td>保持之前状态</td>
<td>保持之前状态</td>
</tr>
<tr>
<td>x</td>
<td>下降沿</td>
<td>保持之前状态</td>
<td>保持之前状态</td>
</tr>
<tr>
<td>无论输入如何</td>
<td>当且仅当上升沿时</td>
<td>Q&lt;=D</td>
<td>Q&lt;=(~D)</td>
</tr>
<tr>
<td></td>
<td>任何其他情况</td>
<td>保持之前状态</td>
<td>保持之前状态</td>
</tr>
</tbody></table>
<h3 id="D触发器的局限性"><a href="#D触发器的局限性" class="headerlink" title="D触发器的局限性"></a>D触发器的局限性</h3><p>CMOS工艺下，D-FF由传输门1、主锁存器、传输门2、从锁存器串联组成</p>
<p>传输们起开关作用，会随CLK的状态变化切换开关，外部信号先被锁存在主锁存器，一个时钟周期后，信号会被再次锁存在从锁存器。这里传输门1和传输门2的时钟相位相反。</p>
<p>然而由于寄生电容、寄生电阻的存在，在时钟信号变化过快时，如果读取到还没有稳定下来而是在0和1之间摇摆的中间电位就会导致读取错误，这被称为<strong>亚稳态</strong>。所以一般会通过<strong>建立时间</strong>（Setup Time）来约束在时钟上升沿到来前输入D保持稳定的时间</p>
<p>对于下降沿的情况下，若输入在传输门变为高阻态之前就发生变化也会出现反相器环路震荡的隐患，所以使用<strong>保持时间</strong>（Hold Time）约束</p>
<p>由于这两个约束的存在，时钟频率需要受到限制，FPGA设计中使用静态时序分析STA来评估性能，静态时序分析主要评估FPGA上设计电路的延迟是否满足时序约束。此外还需要使用DRC约束和DC约束来保证电路的结构无误</p>
<p>STA验证具有验证速度高的特点，但对电路结构有要求：</p>
<ul>
<li>延迟分析的起点和终点必须是基于同一时钟的FF，从而能够通过累加延迟来计算、验证每条路径的总延迟</li>
</ul>
<p>所以FPGA一般来说都会使用单相同步时钟来设计</p>
<p>由于时钟信号驱动的负载（扇出数）、布线延迟等导致的时间差称为<strong>时钟偏移</strong>（skew）</p>
<p>由于时钟振荡器或PLL器件的输出变形或信号变形导致时钟边沿偏离平均位置的情况称为<strong>时钟抖动</strong>（jitter）</p>
<p>在实际ASIC设计中，需要控制时钟偏移和抖动在一定范围之内；FPGA上已经提前实现好了多层时钟树结构，并通过驱动能力强的专用布线（global buffer）将时钟低偏移地连接到全芯片的FF上，所以在时钟设计上比ASIC简便很多</p>
<h2 id="CPLD"><a href="#CPLD" class="headerlink" title="CPLD"></a>CPLD</h2><p>所有可编程逻辑器件统称PLD，而其中有CPLD（Complex PLD）一个特殊的分支，与FPGA相反，它基于ROM技术制造，基本结构是乘积项。由与阵列和或阵列组成的与-或构造就称为乘积项形式，这一结构的特点就是成本低廉、掉电后不会丢失逻辑</p>
<h1 id="FPGA简介"><a href="#FPGA简介" class="headerlink" title="FPGA简介"></a>FPGA简介</h1><p>FPGA是PLD的一种。实际上它并不是单纯由”门“形成的结构。</p>
<h2 id="FPGA结构简介"><a href="#FPGA结构简介" class="headerlink" title="FPGA结构简介"></a>FPGA结构简介</h2><p>FPGA大致由三部分构成：</p>
<ul>
<li>实现逻辑电路的逻辑要素：<strong>逻辑块</strong></li>
</ul>
<p>一般由查找表LUT、乘积项PT、数据选择器MUX等组成，不管什么方式，都应该是由实现FF等器件的数据存储电路和数据选择器MUX组成的</p>
<ul>
<li>和外部进行信号输入/输出的要素：<strong>I/O块</strong></li>
</ul>
<p>连接IO引脚和内部布线要素的模块，其中通常包括控制上拉下拉、输入输出、极性、速率、开漏等模式的控制电路和触发器等数据存储电路。一般会支持TTL、PCI、PCIE、SSTL等等单端标准IO和LVDS等差分标准IO</p>
<ul>
<li>连接前两种元素的布线要素：包括<strong>布线通道、开关块SB、连接块CB</strong></li>
</ul>
<p>可以通过布线资源形成任意的布线通路，其中主要通过开关的编程配置决定选择哪个布线通道</p>
<p>实际电路中还可能加入硬核处理器、DSP模块、块存储器等等其他具有固定功能的硬核电路</p>
<p><strong>硬核</strong>：具有固定结构、无法使用硬件描述语言编程的电路</p>
<p><strong>软核</strong>：具有一定结构，可以使用硬件描述语言编程的电路</p>
<p>这三个部分一般呈==岛型==排布，每个“岛“占据一个格子，格子之间是布线要素</p>
<h2 id="FPGA可编程技术"><a href="#FPGA可编程技术" class="headerlink" title="FPGA可编程技术"></a>FPGA可编程技术</h2><p>FPGA通过闪存、反熔丝和静态存储器作为可编程的基础，目前市面上的FPGA多使用SRAM技术（静态存储器）制造，这三种技术各有特点</p>
<h3 id="闪存"><a href="#闪存" class="headerlink" title="闪存"></a>闪存</h3><p>闪存（FLASH）是EEPROM的一种，属于非易失存储器，采用MOSFET（Metal-Oxide-Semiconductor Field Effect Transistor金属-氧化物-半导体场效应管）技术制造</p>
<blockquote>
<p>MOSFET是一种以<strong>金属栅极</strong>隔着<strong>氧化层</strong>利用电场效应来控制<strong>半导体</strong>的场效应晶体管。而与之相对的还有JFET，即结型场效应管，在N型半导体（这里以N沟道为例）两端加入P型半导体，并在其中P型半导体较少的一端引出源极和漏极，另一边的P型半导体引出栅极，用栅极电压产生的静电效应来控制漏极电流。MOSFET则是以P型半导体为基底，两个小块N型半导体嵌入，通过引脚引出作为源极和漏极，在基底上有一个二氧化硅薄片，上面固定了金属铝制造的栅极，当栅极加适当电压时，在两个N型半导体之间会出现导电沟道，即源-漏极电流出现（这里以增强型NMOSFET为例，PMOS的导通电流方向相反，耗尽型为不加栅极电压时才会导通）</p>
<p>无论P类型还是N类型的MOSFET都分为增强型和耗尽型两种，增强型的特点是“常开”，耗尽型的特点是“常闭”，这里的增强和耗尽指的是栅极电压控制漏极电流的“增强”或“耗尽”</p>
</blockquote>
<p>闪存根据写入方式不同可以分成两种：NAND型和NOR型，NAND型在写入时需要高电压，而NOR型在写入时需要大电流</p>
<p>NAND FLASH的MOSFET表现为耗尽型，源极、漏极之间存在一个栅极G，这里就和普通的DRAM构造相同（MOSFET结构），但是在栅极下方的二氧化硅中埋藏了一个多晶硅构成的浮栅。初始状态下浮栅不带电，根据耗尽型MOSFET的特点，栅极零偏压时电流可以通过；但当将栅极加高电压后，浮栅会由于电场效应（实际是产生了隧道电流）带电（负电），此时在低电压范围内，无论栅极加不加电压，导电沟道都关闭，电流无法通过，也就是说浮栅上存有电荷时表现为无电流通过；而只有再次在源极S上加高电压时，电流才能通过。由于浮栅中的电荷没有逃脱路径，因此可以半永久保存数据；当在源极加高电压时，可以将浮栅中的电子以隧道电流的形式引出。对于NOR FLASH的情况，通过在源极和漏极之间通大电流后，一部分电子作为热电子注入浮栅来完成写入</p>
<p>NAND FLASH的结构特点导致了它能够以位（比特）为单位写入（控制单个栅极电压），但只能以块为单位擦除（源极并联在一起，难以单个控制）</p>
<h3 id="基于闪存的可编程开关"><a href="#基于闪存的可编程开关" class="headerlink" title="基于闪存的可编程开关"></a>基于闪存的可编程开关</h3><p>FPGA内的可编程开关由两个晶体管组成，一个负责编程信号的写入/擦除，另一个用于控制用户电路的开关，两个晶体管共用控制栅极G和浮栅，从编程用开关管注入电子就可以直接决定用户所使用开关的状态</p>
<p>使用步骤如下：</p>
<ol>
<li>在编程晶体管S-D之间加5V</li>
<li>在G加-11V电压，电子自动流入G（G-D电压为-16V），开关开启</li>
<li>正常工作时，栅极保持2.5V，浮栅电位会大致维持在4.5V</li>
<li>擦除时，编程晶体管S、D接地，G极加16V电压后浮栅电位会降到0V以下，开关关闭</li>
</ol>
<p>可编程开关的以上特性决定了它存在一些缺点：</p>
<ul>
<li>无法使用CMOS工艺（最大硬伤，不过这也导致其成本较低）</li>
<li>重写次数有限制</li>
<li>接通电阻和负载电容较大</li>
</ul>
<p>它的优点如下：</p>
<ul>
<li>非易失、可重编程</li>
<li>对软性错误容错强、上电后立即工作（Live At Power-Up，LAPU）</li>
<li>尺寸较小（至少比SRAM工艺小，但是对于先进的FinFET优势就不大了）</li>
</ul>
<p>目前的CPLD很多都是基于该工艺制造</p>
<h3 id="反熔丝"><a href="#反熔丝" class="headerlink" title="反熔丝"></a>反熔丝</h3><p>熔丝是在电流过大时对电路进行保护或防止事故的元件，当有大电流流过时会自行发热并熔断。反熔丝的特性和熔丝正好相反：初始状态为开路，当通电后会发生熔合</p>
<p>一种反熔丝使用多晶硅和n^+^扩散层作为导体，在他们中甲插入ONO氧化物-氮化物-氧化物的电介质作为绝缘体的构造，ONO电介质厚度在10nm以下，通常在10V-5mA情况下可以形成上下连接的通路。其直径大约和接触孔（为了连接硅基底上的门电路和金属层或上下两层金属层而设置的通孔）相当，其导通电阻大概在300~500Ω</p>
<p>还有Metal-to-Metal设计的反熔丝，用于连接布线层，在上下两层金属布线层间插入绝缘的非晶硅和钨插塞等导体，在为编程时处于高阻抗状态，而在编程处理后可以变为几乎和金属层连线同等程度的低阻抗状态，导通电阻大约50~80Ω。在编程中需要约15mA电流</p>
<p>因为Metal-to-Metal反熔丝面积较小、导通电阻低，构造上不可能将配置信息直接读取出来，难以实行逆向工程，安全性很高，所以成为现代反熔丝技术的主流</p>
<p>反熔丝优点如下：</p>
<ul>
<li>尺寸小、密度高、非易失</li>
<li>接通电阻和负载电容小</li>
<li>安全性高、对软性错误容错性强</li>
</ul>
<p>缺点：</p>
<ul>
<li>无法重写</li>
<li>每根线都需要额外的晶体管用于编程</li>
<li>需要使用专用编程器且编程时间长</li>
<li>难以debug、出错率较高</li>
</ul>
<h3 id="静态存储器"><a href="#静态存储器" class="headerlink" title="静态存储器"></a>静态存储器</h3><p>静态存储器由两个CMOS反相器构成的触发器和两个传输晶体管（Pass-Transistor，PT）组成。他利用触发器的双稳态0和1记录数据，通过NMOS型的PT执行写入</p>
<p>静态存储器通常使用地址信号来驱动字线（读取地址信号所控字线上的多位数据），数据的读取也通过PT进行。由于FPGA需要一直读取数据，所以在FPGA中数据直接从触发器读取而不通过PT。</p>
<p>基于静态存储器的FPGA大多使用LUT，并使用MUX等来切换布线连接，真值表本身由多位静态存储器构成，这种FPGA一般称为SRAM型FPGA。说人话就是使用SRAM技术存储真值表来实现编程信息的存储</p>
<p>优点如下：</p>
<ul>
<li>能够使用先进的CMOS工艺</li>
<li>可重配置</li>
<li>重写次数没有限制（一片spartan传祖孙三辈人没问题）</li>
</ul>
<p>缺点：</p>
<ul>
<li>存储器尺寸大（可以通过FinFET工艺缓解）</li>
<li>易失性存储器</li>
<li>难以保证电路信息安全</li>
<li>对软性错误敏感</li>
<li>导通电阻、负载电容较大</li>
</ul>
<p>目前SRAM型FPGA占据市场主流，因为CMOS和FinFET就是无敌的存在，制程碾压一切</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>反熔丝待机耗电低、连接开关的接通电阻小、速度快，并且保密性高、无法进行重写，比较适用于军工等不要求最先进工艺但对可靠性要求高的场合</p>
<p>静态存储器工艺制程先进、性能强大，但存在易失性且安全性不高、待机功耗大（这一点正在逐渐改善）、耐放射线能力弱，但是很适合民用与实验，符合FPGA的定位，所以成为市场的主流</p>
<p>闪存工艺是静态存储器和反熔丝之间的平衡点，成本低廉且可以重写、可靠性较高，但是性能较劣势，说的难听点就是鸡肋，所以市场上基于闪存的FPGA已经越来越少</p>
<h2 id="FPGA的逻辑实现"><a href="#FPGA的逻辑实现" class="headerlink" title="FPGA的逻辑实现"></a>FPGA的逻辑实现</h2><p>基于LUT的FPGA逻辑块可以实现任何<strong>输入数在查找表电路输入数量之内</strong>的逻辑函数；基于乘积项方式实现的CPLD则需要先将表达式转换为标准积之和的形式</p>
<p>一个小型的电路至少需要通过IO PAD（输入信号）、FPGA内部布线、可编程逻辑块、FPGA内部布线、输出缓冲器、IO PAD（输出信号）这几个硬件资源才能实现</p>
<p>可编程逻辑块内的主要资源就是LUT，<strong>LUT是1个字只有1位的内存表</strong>，字数取决于地址的位数，FPGA中的查找表存储单元大多使用SRAM实现。一般k输入的LUT由2^k^个SRAM单元和一个2^k^输入的数据选择器组成，<strong>查找表的输入就是内存表的地址信号，输出就是该地址所选字的1位数据</strong>。k输入的查找表可以实现$2^{2^k}$种逻辑函数。</p>
<p>使用查找表时，先根据查找表的输入值对真值表进行转换，然后将函数值直接写入配置内存，当所要实现的逻辑函数的输入数比查找表的输入数多时，可以并联使用多个查找表来实现</p>
<h3 id="查找表的实现"><a href="#查找表的实现" class="headerlink" title="查找表的实现"></a>查找表的实现</h3><p>早期FPGA使用过5晶体管结构（两个晶体管构成一个非门，两个非门和一个额外的晶体管构成一个SRAM单元）存储单元，因为LUT中的SRAM总是在输出数据，所以查找表只需要以5晶体管存储单元为基础配合选择信号就可以实现了；在此之后Xilinx的Freeman改良了LUT的配置存储器，让其可以作为FPGA上的分散存储器使用，此时SRAM具有了独立的写入端口，该结构可以复用为存储器和查找表，使用两个输入信号作为控制——需要注意：存储器的读取端口和查找表的输出是通用的</p>
<p>随后，查找表又被改良可以作为移位寄存器使用；当前的查找表已经能够支持簇结构（cluster）和自适应（可以将一个8输入查找表分割为2个7输入查找表或1个7输入查找表和2个6输入查找表等小型查找表簇的方式使用，更加灵活）</p>
<h1 id="FPGA的结构"><a href="#FPGA的结构" class="headerlink" title="FPGA的结构"></a>FPGA的结构</h1><p>岛型FPGA由逻辑块、IO块、布线要素等组成，<strong>相邻的逻辑块、开关块、连接块组成了一个可重复逻辑模块</strong>，模块呈阵列型排列最终形成岛型FPGA</p>
<p>FPGA中具有专门用途的电路称为“硬核”，可编程的部分称为“软核”。Xilinx将逻辑块称为CLB（Configurable Logic Block可编辑逻辑块），Altera则将其称为LAB（Logic Array Block逻辑阵列块），但他们的基本原理一样</p>
<p>除了主要部件之外，现代FPGA通常还包括很多其他部件</p>
<h2 id="逻辑块结构"><a href="#逻辑块结构" class="headerlink" title="逻辑块结构"></a>逻辑块结构</h2><p>对于逻辑块架构，最重要的设计问题就是权衡逻辑块的功能和自身面积</p>
<blockquote>
<p>集成电路领域著名的AT^2^定律指的是对于某个给定的半导体工艺流程，如果其相关的某数字设计的面积是A，而执行时间是T，则存在一个下限边界B，使得AT^2^=B，也就是说面积和效率不可兼得</p>
</blockquote>
<p>这一点同样适用于FPGA</p>
<p>其中对逻辑块功能影响最大的是查找表的大小，因为k输入查找表可以实现任意k输入的函数，采用较大的查找表有助于减少逻辑块的使用数量，但k-LUT需要使用2^k^个配置存储单元，因此逻辑块自身的面积会增大，而且增加的输入/输出引脚数量会导致布线面积增大。</p>
<p>此外，FPGA运行速度还受到以下影响：如果增加每个逻辑块的功能，所实现电路的逻辑深度就更小；但同时也会增加逻辑块自身的内部延迟</p>
<p>逻辑深度指通过关键路径的逻辑块数量，它由FPGA设计环节中的技术映射过程决定（参考后面FPGA设计与ASIC设计的区别与原理部分），降低逻辑深度可以减少布线、提高电路速度，同时也会增加内部延迟，导致降低逻辑深度的效果大打折扣</p>
<p>综上所述，查找表的输入大小和FPGA的面积、延迟有密切关系</p>
<p><strong>现代的商用FPGA都倾向于采用6-LUT</strong></p>
<h3 id="专用进位逻辑"><a href="#专用进位逻辑" class="headerlink" title="专用进位逻辑"></a>专用进位逻辑</h3><p>为了提高算术运算电路的性能，现代FPGA逻辑块中还含有专用的进位电路，可以使用这些专用进位逻辑来获得更高集成度和运行速度</p>
<p>Xilinx没有设计专用的全加器电路，而是使用查找表和进位生成电路的组合来实现加法。全加器的加法运算用两个2输入EXOR实现，进位输出电路由1个EXOR和1个MUX组成</p>
<p>可以通过这种单元的不断组合实现多位加法器甚至加法器矩阵</p>
<h3 id="逻辑簇"><a href="#逻辑簇" class="headerlink" title="逻辑簇"></a>逻辑簇</h3><p>逻辑簇是由多个BLE群组化形成的逻辑块结构，逻辑簇内部局部布线采用硬连线连接，比外部的通用布线速度更快；逻辑簇内部局部布线的负载电容比外部通用布线小很多，因此对FPGA的耗电（特别是动态功耗）的削减有效果；逻辑簇内部BLE可以共享输入信号，有助于减少局部连接块的开关数量</p>
<p><strong>含有多BLE的逻辑块最大的优势就是在增加逻辑块功能性的同时又不会大幅影响FPGA的整体面积</strong></p>
<p>逻辑块面积随输入k的增大呈指数级增大；而增加逻辑簇中BLE的数量N会导致逻辑块的面积只按二次函数增长</p>
<p>计算逻辑块输入数量$I=\frac{k(N+1)}{2}$</p>
<p>根据上面的经验公式，逻辑块面积的增长得到了抑制</p>
<p>一般来说，面积延迟乘积性能最优的结构参数为：N=3~10,k=4~6</p>
<p>也就是说一个逻辑簇中设置3到10个输入、4到6个BLE比较好</p>
<h3 id="自适应查找表"><a href="#自适应查找表" class="headerlink" title="自适应查找表"></a>自适应查找表</h3><p>Xilinx在XC40000系列的逻辑块中推出了早期的不同输入数查找表结构</p>
<p>而现代的FPGA多支持将较多输入的查找表分解使用的机制，也就是<strong>自适应查找表</strong></p>
<h2 id="全局布线架构"><a href="#全局布线架构" class="headerlink" title="全局布线架构"></a>全局布线架构</h2><p>布线架构分为全局布线和详细布线，全局布线主要解决逻辑块的连接、布线通道的宽度等高层次问题；而详细布线则决定具体的连接方式</p>
<p>层次型FPGA使用UCB的HSRA布线构造，将FPGA内部布线分成多个层次，布线的交叉点上包含各层的开关，一般层次越高通道里连线的数量就越多。目前层次型FPGA已经不再适用</p>
<p>岛型FPGA就是一直在介绍的FPGA类型，下面的详细布线架构也将围绕岛型FPGA说明</p>
<h2 id="详细布线架构"><a href="#详细布线架构" class="headerlink" title="详细布线架构"></a>详细布线架构</h2><p>详细布线架构中需要确定逻辑块和布线通道之间的开关布置和布线的线段长度，以此来确定电路延迟</p>
<p>由连接块和开关块组成的布线要素对FPGA面积和电路延迟的影响很大，在决定详细布线架构时要注意：</p>
<ol>
<li>逻辑块和晶体管参数</li>
<li>布线线段长度的种类和比例</li>
<li>布线开关的晶体管参数</li>
</ol>
<p>还应该考虑传输晶体管和三态缓冲器使用上的平衡</p>
<p>现代FPGA为了更好的性能，通常使用较多单向连线和辅助的双向连线，并正在加大单向连线的比重；同时还提供了各种不同长度的连线，从短线到长距离布线，以此增强设备的时序表现</p>
<h2 id="开关块"><a href="#开关块" class="headerlink" title="开关块"></a>开关块</h2><p><strong>所有开关块均由可编程开关管构成，以下简称开关管，注意不要和晶体管意义上的开关管弄混</strong></p>
<h3 id="开关块的拓扑"><a href="#开关块的拓扑" class="headerlink" title="开关块的拓扑"></a>开关块的拓扑</h3><p>开关块位于横向和纵向布线通道的交叉处，通过可编程开关来控制布线路径，一般开关块的拓扑分为三种</p>
<p>对于一个开关块中的一个控制晶体管，负责三条交叉路经的通断，因此开关快都是从三个输入中选择一个输出，自由度F<del>s</del>=3</p>
<h4 id="不相交型"><a href="#不相交型" class="headerlink" title="不相交型"></a>不相交型</h4><p>Xilinx的特色拓扑，因此也被称为赛灵思型开关块</p>
<p>由6个开关管构成</p>
<p>将四个方向上序号相同的进行连接，相邻两个方向呈斜45度或15度连接</p>
<p>自由度较低</p>
<h4 id="通用型"><a href="#通用型" class="headerlink" title="通用型"></a>通用型</h4><p>同样由6个开关管构成，但两个成对的连线可以在开关块内互联</p>
<p>总体上可实现斜对角45度全连接</p>
<p>但是这种技术只能对应单倍线，无法应用在其他长度的布线上</p>
<h4 id="威尔顿型"><a href="#威尔顿型" class="headerlink" title="威尔顿型"></a>威尔顿型</h4><p>采用6*n个开关管连接序号不同的连线</p>
<p>自由度更高，可以实现顺时针、逆时针的闭环路径，可以提高FPGA的测试效率</p>
<h3 id="数据选择器结构"><a href="#数据选择器结构" class="headerlink" title="数据选择器结构"></a>数据选择器结构</h3><p>一般使用4输入的数据选择器延迟最优，8输入的数据选择器面积延迟乘积最优</p>
<h2 id="连接块与IO块"><a href="#连接块与IO块" class="headerlink" title="连接块与IO块"></a>连接块与IO块</h2><p>连接块也由可编程开关构成</p>
<p>连接块负责连接布线通道和逻辑块的输入/输出</p>
<p>由于需要考虑到连接块的面积，所以很少使用全交叉开关矩阵实现，而是使用节省掉一些开关的<strong>稀疏开关矩阵</strong></p>
<p>IO块则负责器件的IO引脚和逻辑块之间的接口部分</p>
<p>一般FPGA的IO除了固定用途的电源、时钟等专用引脚，还有用户可以配置的用户IO，用户IO具有输入/输出缓冲、输出驱动、信号方向控制、高阻抗控制等功能，和现代MCU的GPIO结构相似</p>
<p>一般具有以下特点：</p>
<ul>
<li>可配置的上拉、下拉电阻</li>
<li>输出使能信号可以控制输出缓冲器</li>
<li>输入/输出出啊其，可用于调整信号延迟</li>
<li>可编程的输出缓存器转换速率</li>
<li>可以调整使用TTL、CMOS、PCIE等多种输出电压标准或输入缓冲器阈值</li>
<li>专用延时电路，用于保证输入的保持时间</li>
<li>可适用于高速通信的差分信号LVDS</li>
<li>配置有钳位二极管</li>
</ul>
<p>总体而言连接块与IO块类似MCU中的总线桥和GPIO</p>
<h2 id="嵌入式硬核"><a href="#嵌入式硬核" class="headerlink" title="嵌入式硬核"></a>嵌入式硬核</h2><h3 id="DSP块"><a href="#DSP块" class="headerlink" title="DSP块"></a>DSP块</h3><p>现代FPGA被普遍用于数字信号处理DSP、人工智能加速AIA、硬件算法实现等场景，因此出现了搭载大量乘法器、浮点运算电路的FPGA</p>
<p>这些内嵌DSP块的结构大致如下：</p>
<p>输入</p>
<p>前置加法器</p>
<p>乘法器</p>
<p>累加运算单元</p>
<p>模式检测器与控制电路</p>
<p>输出</p>
<p>很多DSP块支持粒度调节和浮点运算支持</p>
<p>在FPGA厂商提供的IP生成工具中设置好相关IP就可以选择是否在DSP块上实现，同时使用FPGA厂商推荐的硬件描述语言使用方式，综合工具就可以自动识别并使用DSP块，也可以在代码中直接实例化并使用DSP块的模块，但这种方法缺乏可移植性</p>
<h3 id="硬宏"><a href="#硬宏" class="headerlink" title="硬宏"></a>硬宏</h3><p><strong>硬宏</strong>：商用FPGA中嵌入的专用硬件电路</p>
<p>硬件乘法器和DSP块都属于硬宏，但都比较常见，当前已经被视为商用FPGA的“标配”</p>
<p>除此之外，很多中高端产品都会搭载PCIE接口、USB接口、SPI接口、外部DRAM接口、专用DAC、ADC等硬宏</p>
<p>一般来说硬宏化的接口电路不多，需要考虑硬宏的位置再进行布局布线</p>
<h3 id="硬核处理器"><a href="#硬核处理器" class="headerlink" title="硬核处理器"></a>硬核处理器</h3><p>FPGA厂商已经越来越多地在高端品牌上搭载硬核处理器，也就是作为硬宏的嵌入式处理器</p>
<p>比较著名的就是Xilinx的Zynq系列，搭载ARM Cortex A系列处理器，可以运行Linux等通用OS或RT-Thread等大型RTOS，同时可以按照标准设计电路接口，让FPGA部分的用户电路与硬核处理器通过AMBA交换模块连接，以定制硬件的方式实现加速</p>
<h3 id="嵌入式存储器"><a href="#嵌入式存储器" class="headerlink" title="嵌入式存储器"></a>嵌入式存储器</h3><p>部分商用FPGA为了解决存储器总线带宽问题，直接将存储器嵌入到FPGA内部</p>
<p>这样的嵌入式存储器分为两种类型</p>
<ol>
<li><p>存储器块硬宏</p>
<p> 以硬宏的形式在架构中嵌入存储器块，在Xilinx的架构中，这种存储器被称为块存储器（Block RAM，BRAM），支持一分多、多合一</p>
<p> BRAM既可以作为单端口存储器也可以作为双端口存储器使用，可以方便的使用它作为FIFO存储器</p>
<p> 需要注意：BRAM不支持异步访问，想要同步两个时钟域还是应该使用传统的异步时钟FIFO</p>
</li>
<li><p>查找表存储器</p>
<p> 也可以使用逻辑块内部的查找表实现存储器</p>
<p> Xilinx的架构中，这种由查找表构成的存储器称为分布式RAM（distributed RAM），但只有被称为SLICEM的逻辑块中的查找表才能够作为分布式RAM使用。此外，为了不挤占查找表的存储资源，一般在需要小规模存储器时再使用这种方法</p>
</li>
</ol>
<p>嵌入式存储器一般和DSP块一样，只要按照FPGA厂商的说明编写HDL程序，综合后就能够调用</p>
<p>它的优点在于大，能有效节省外部总线资源和时序损耗</p>
<h3 id="配置链"><a href="#配置链" class="headerlink" title="配置链"></a>配置链</h3><p>把电路编程到FPGA上的过程叫做配置，向FPGA写入的电路信息叫做配置数据。配置数据包含在FPGA上实现电路的所有信息，包括但不仅限于查找表中的真值表数据和开关块中各个开关的状态等</p>
<p>一般地，FPGA可以分为三种类型</p>
<ul>
<li>SRAM型：掉电信息即丢失，所以一般在上电时使用内部或外部的自动配置器件将配置信息写入</li>
<li>闪存型：非易失，一般闪存写入次数的限制都比较大，虽然没有SRAM那样的永久寿命，但用十几年也没有问题，只是写入速度较慢</li>
<li>反熔丝型：写入一次后就不能再修改</li>
</ul>
<p>一般在调试过程中使用JTAG接口，可以实时观测FPGA内部信号的变化：先将观测信号的变化写入嵌入式存储器，再通过JTAG读取到上位机，这样就能直观地看到信号波形，称为<strong>虚拟逻辑分析仪</strong></p>
<p>这样对于配置流程就能有更好的把控</p>
<h3 id="PLL与MMCM"><a href="#PLL与MMCM" class="headerlink" title="PLL与MMCM"></a>PLL与MMCM</h3><p>过去的FPGA一般使用外部晶振，在内部的时钟信号频率受到限制</p>
<p>现代FPGA大多配置有PLL电路，可以将外部输入的基准时钟进行进一步处理</p>
<p>PLL即Phase Locked Loop锁相环，外部基准时钟输入<strong>鉴相器</strong>，鉴相器就是一个精密的时钟相位比较器，将PLL内部<strong>压控振荡器</strong>（Votage-Controlled Oscillator，VCO，可以根据所加的电压调整输出频率）生成的时钟与外部输入的基准时钟进行比较，如果两个时钟一致则维持VCO电压，否则调整控制电路对VCO电压进行调整（VCO主频过高则降低电压；反之升高电压），经过鉴相器得到的电压还存在一定的高频谐波，通过一个低通滤波器后输入VCO即可实现效果。整个电路呈现为</p>
<p>基准时钟输入-鉴相器-低通滤波器-VCO-反馈输入-标准输出</p>
<p>的状态。整个电路使用模拟电路实现，高频谐波由于反馈电路和后级电路耦合而产生</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">A[输入]--&gt;B(鉴相器)</span><br><span class="line">C[反馈]--&gt;B</span><br><span class="line">B--&gt;D[低通滤波器]</span><br><span class="line">D--&gt;E[VCO]</span><br><span class="line">E--&gt;C</span><br><span class="line">E--&gt;F[输出]</span><br></pre></td></tr></table></figure>

<p>除了基本结构之外，PLL通常还会在输入输出阶段添加额外的分频器用于削减输出频率；同时在反馈阶段加入分频器用于增加输出频率</p>
<p>流程框图如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">INPUT(输入)--&gt;A[基准时钟预分频器N]</span><br><span class="line">A--&gt;B(鉴相器)</span><br><span class="line">C[反馈时钟分频器M]--&gt;B</span><br><span class="line">D--&gt;E[VCO]</span><br><span class="line">E--&gt;C</span><br><span class="line">B--&gt;D[低通滤波器]</span><br><span class="line">E--&gt;F[输出时钟分频器1]</span><br><span class="line">F--&gt;OUTPUTA(输出时钟1)</span><br><span class="line">E--&gt;G[输出时钟分频器2]</span><br><span class="line">G--&gt;OUTPUTB(输出时钟2)</span><br><span class="line">E--&gt;H[输出时钟分频器i]</span><br><span class="line">H--&gt;OUTPUTC(输出时钟i)</span><br></pre></td></tr></table></figure>

<p>可以得到输出频率控制公式<br>$$<br>F_{vco}=\frac{M}{N \cdot K_i} F_{ref}<br>$$<br>式中M为反馈时钟分频器分频系数，N为基准时钟预分频器分频系数，K<del>i</del>为输出时钟分频器分频系数，最后对应输出时钟F<del>i</del></p>
<p>虽然可以通过有限个预分频器调节时钟，但事实上各个分频器的分频比是有限制的，设定值不能超出规定</p>
<p><strong>PLL实质上是一个以外部输入基准信号为目标，使用VCO为控制对象的线性反馈控制系统</strong>，在启动、复位或基准时钟大幅度变动时，无法做到立即响应，所以在PLL的输出时钟稳定前，由该时钟同步的用户电路可能会发生无法预测的动作。为了避免这种情况，常常使用PLL锁定机制，PLL通常会设置1位输出信号来表示PLL是否为锁定状态，外部电路可以利用该寄存器位来判断是否能使用时钟</p>
<p>使用数字方式也可以实现PLL类似的功能，称为DLL，具有响应速度快的优势。但是因为PLL的自由度更高、稳定性更好、成本更低，所以大多使用PLL或其升级版本MMCM</p>
<h1 id="FPGA设计流程与原理"><a href="#FPGA设计流程与原理" class="headerlink" title="FPGA设计流程与原理"></a>FPGA设计流程与原理</h1><h2 id="基于HDL"><a href="#基于HDL" class="headerlink" title="基于HDL"></a>基于HDL</h2><ol>
<li><p>使用FPGA厂商提供IDE创建工程</p>
</li>
<li><p>约束设定</p>
<p> 设置物理约束、引脚约束</p>
</li>
<li><p>创建源文件</p>
<p> 依次编写RTL级描述，可以按照自顶向下/自底向上设计方法，先编写顶层文件（系统级）或底层模块；通过模块例化进行层次连接</p>
</li>
<li><p>创建仿真源文件</p>
<p> 可以使用SystemVerilog等语言创建仿真用的源文件testbench</p>
</li>
<li><p>逻辑综合和技术映射</p>
<p> 对于Xilinx系FPGA来说需要先进行RTL文件的<strong>逻辑综合</strong>，如果使用了Verilog HDL则会先生成门级Verilog文件，随后生成网表文件，这些网表文件描述了逻辑门、触发器等逻辑元素的集合以及它们的连接关系。综合后在进行<strong>技术映射</strong>，将逻辑映射到FPGA实际的逻辑元素。</p>
<p> 一般在执行这两步时，厂商IDE会提供DRC、网表、逻辑分析报告，可以借此初步判断bug</p>
</li>
<li><p>RTL仿真</p>
<p> 使用testbench对电路进行仿真，这一步可以使用厂商提供的仿真软件或仿真器，也可以使用集成电路设计中常用的modelsim等仿真软件。通过对输入输出波形的仿真判断电路是否存在问题</p>
</li>
<li><p>布局布线</p>
<p> 利用片上逻辑和布线等资源实现网表。先进行逻辑元素再进行网络布线。布局过程中可以对信号拥挤度和传输延迟进行初步预测，不过并不一定准确，目前业界多使用STA静态时序分析进行仿真。需要特别注意的是，布局布线需要耗费很长时间，规模越大、逻辑资源使用率越高的电路耗时越长，且布线失败的可能性越大。当前的IDE中虽然有自动布局布线功能，但是也可能发生问题，这就需要换用硬件或重新设计架构、算法等</p>
</li>
<li><p>配置FPGA</p>
<p> 可以通过以下方法将编程数据烧录到FPGA：</p>
<ul>
<li><p>JTAG烧录比特流文件</p>
<p>  JTAG是面向器件编程和板卡调试的一种通用标准，FPGA厂商都提供了对应FPGA的JTAG烧录器/调试器</p>
<p>  但是JTAG烧录后如果FPGA断电或重置，配置信息就会丢失</p>
<p>  一般使用bit格式</p>
</li>
<li><p>自动从片外ROM中读取文件</p>
<p>  在上电或重置时可以让特殊配置过的FPGA从片外ROM中读取配置数据或使用其他控制器将片外文件数据加载到FPGA上</p>
<p>  一般使用mcs或pof格式</p>
</li>
<li><p>通过储存卡等写入</p>
</li>
<li><p>使用专用IC或总线协议配置FPGA</p>
</li>
</ul>
<p> 特别地，一些FPGA配备了处理器硬核，可以使用SD卡或专用总线，可以用这种方式自动加载FPGA</p>
</li>
<li><p>实机功能验证</p>
</li>
<li><p>优化</p>
<p>在实现功能后，可以考虑更改设计来让器件达到更高的工作频率或获得更高的效率</p>
</li>
</ol>
<h2 id="基于HLS"><a href="#基于HLS" class="headerlink" title="基于HLS"></a>基于HLS</h2><p>使用FPGA厂商专用的HLS工具可以将高级语言代码转换为HDL代码，进而实现方便的电路设计</p>
<p>详细内容可以查看其它关于HLS的介绍</p>
<h2 id="基于已有IP"><a href="#基于已有IP" class="headerlink" title="基于已有IP"></a>基于已有IP</h2><p>往往可以从厂商或开源社区获取到某些器件的RTL代码并加以修改融入当前设计</p>
<p>使用这种开发方式可以</p>
<ul>
<li>使用开源的处理器RTL代码实现软核处理器</li>
<li>构建SoC</li>
<li>整合软硬件开发</li>
</ul>
<h2 id="FPGA设计与ASIC设计的区别与原理"><a href="#FPGA设计与ASIC设计的区别与原理" class="headerlink" title="FPGA设计与ASIC设计的区别与原理"></a>FPGA设计与ASIC设计的区别与原理</h2><p>FPGA设计自由度较低，无法实现对硬件的定制，且无法在器件内集成模拟集成电路元件，但成本较低；而ASIC可以有更高的自由度，但成本高昂；FPGA也常常被用于ASIC设计中的原型验证</p>
<p>除此之外，FPGA与ASIC设计的不同点还体现在如下方面</p>
<h3 id="工艺映射"><a href="#工艺映射" class="headerlink" title="工艺映射"></a>工艺映射</h3><p><strong>工艺映射</strong>：将不依赖于任何工艺的门级网表转换为由特定FPGA逻辑单元所表示的网表的过程</p>
<p>人话：把网表翻译成用FPGA内部逻辑单元组成的电路</p>
<p>ASIC设计中并不需要这一步，而是直接将综合后的RTL文件映射为器件，之后就是版图设计师的任务了</p>
<p>工艺映射的步骤有两个：</p>
<h4 id="分解"><a href="#分解" class="headerlink" title="分解"></a>分解</h4><p><strong>门级网络实际上是用布尔网络</strong>（基于<em>有向图DAG</em>的门级网表的表现方式，各个节点表示逻辑门或逻辑门的组合逻辑，有向边则表示输入/输出信号）<strong>的形式来表示的，在这一步里要将布尔网络的各个节点分解直到输入数小于查找表的输入数k</strong></p>
<h4 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h4><p>使用某种基准对分解得到的布尔网络进行切分，使用k-LUT覆盖多个节点</p>
<p>实际上这个过程是一种可以在多项式时间内找到逻辑层数最优解的方法^[1]^</p>
<p>一种执行覆盖的方法<strong>FlowMap</strong>如下：</p>
<ol>
<li>获取分解得到的最小电路</li>
<li>获取输出信号对应的最后一个器件，该器件被抽象为有2个输入、1个输出的节点</li>
<li>将所有输入节点标号为0</li>
<li>从输出节点开始，以遍历树的方式寻找对应的上一层节点，将其输入切分出来</li>
<li>在上一层中标注标签最大的数字，再加上当前节点的层数（以最后一层的遍历为例，上一层标签为0+1=1）</li>
<li>顺序计算已经标注节点的相邻节点，如果遇到还未标注的节点，先对其进行计算标注</li>
<li>在当前层（切分点以下）所有相关标签都计算完毕后，再计算第二层节点的标签</li>
<li>反复计算所有结点的标签</li>
<li>每一层的逻辑都可以让单个查找表实现</li>
<li>执行逻辑打包</li>
</ol>
<p>术语介绍：</p>
<ul>
<li><p>节点（node）：使用布尔网络表示DAG时基于2输入逻辑门模型表示的基本构成要素——电路网络中的逻辑门全部用2输入1输出的节点来建模表示</p>
</li>
<li><p>标签：标签的数值用于表示网络的深度，即从各个节点到主输入按照最小深度映射时的逻辑层数</p>
</li>
<li><p>切分集：按照k输入进行工艺映射时可能实现的切分集合</p>
<p>  切分：将节点划分为总输入在k之内、可以使用查找表实现的节点集合</p>
</li>
</ul>
<h3 id="逻辑打包"><a href="#逻辑打包" class="headerlink" title="逻辑打包"></a>逻辑打包</h3><p><strong>逻辑打包</strong>：将多个查找表和触发器集合到同一个逻辑块的过程</p>
<p>目前主流的FPGA逻辑块都有多个查找表，所以需要高效地将查找表打包到逻辑块</p>
<p>逻辑打包的要点如下：</p>
<ol>
<li>逻辑块内部布线（局部布线）和逻辑块外部布线（布线通道）的延迟相差较大，所以需要平衡并缩短延迟</li>
<li>如果逻辑块中有查找表空闲，资源使用率就会降低，所以需要增加逻辑块使用量</li>
</ol>
<p>一种早期的执行逻辑打包的方法^[2]^如下：</p>
<ol>
<li>选择输入占用最多的LUT作为逻辑块的种子</li>
<li>将具有最多共同输入信号的LUT装填到当前逻辑块</li>
</ol>
<p>这种方法无法考虑逻辑布线的延时差，所以有以下改进版本^[3]^：</p>
<p>采用Timing-driven（延时驱动）的装箱算法<strong>T-VPack</strong></p>
<ol>
<li><p>选择关键路径上输入最多的LUT作为逻辑块的种子</p>
</li>
<li><p>考虑连接重要度和影响路径数</p>
<p> 连接重要度使用slack（延迟余裕）值计算而来，用于判断当前路径对时序影响的大小和是否是关键路径</p>
<p> slack值越小，该路径就越接近关键路径</p>
<p> 影响路径数指的是当前LUT所影响的关键路径的数目，即输入和当前LUT之间关键路径的总和，该指标表明了当前查找表的延迟一旦改善，总共会有多少路径可以随之得到改善</p>
</li>
<li><p>考虑共同信号数量</p>
</li>
<li><p>连接重要度大、延迟余裕小、共同信号数量多的逻辑打包到同一个查找表</p>
</li>
</ol>
<p>这种算法很好的考虑到布线延迟和逻辑块使用量的均衡</p>
<p>近年来的自适应查找表也对装箱算法有很大影响</p>
<p>较为现代化的算法有AAPack等</p>
<h3 id="布局布线"><a href="#布局布线" class="headerlink" title="布局布线"></a>布局布线</h3><p><strong>布局</strong>：决定逻辑块的物理位置</p>
<p><strong>布线</strong>：决定逻辑块的信号连接路径</p>
<p>多数FPGA的逻辑块都成二维阵列状排列，因此<strong>逻辑块布局问题可以被视为二次分配问题</strong>，这类问题也被公认为NP问题（具有和计算复杂度理论中的NP（Non-deterministic Polynomial Time，非确定性多项式时间）类问题同等或同等以上难度的问题，二次分配问题是具有NP难度的组合优化问题中非常难解的一种问题），通常只能使用SA（Simulated Annealing）等算法获取近似解</p>
<p>布线过程中主要使用两种布线方法：全局布线和详细布线</p>
<p>全局布线主要决定线网的布线路径；详细布线则基于全局布线所得信息确定路径具体使用了哪些布线资源、通过了哪些开关等</p>
<p>这一步FPGA开发和ASIC设计采用的思路都差不多：==瞎蒙==</p>
<p>具体来说使用VPR工具步骤如下：</p>
<ol>
<li>随机放置逻辑块、IO块</li>
<li>计算当前布局的布线拥挤度</li>
<li>随机选择两个逻辑块并对调位置</li>
<li>比较对调后的布线拥挤度</li>
<li>比较对调前后拥挤度的数指，决定是否接受新的布局</li>
</ol>
<h1 id="硬件算法简介"><a href="#硬件算法简介" class="headerlink" title="硬件算法简介"></a>硬件算法简介</h1><p>对于FPGA，或者说ASIC而言，对比CPU最大的优势就是可以实现并行计算，同时能够针对特定问题、特定算法进行优化</p>
<h2 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h2><p>将一个连续的硬件电路拆分为n个均等的阶段，每个阶段的输出作为下一个阶段的输入，下一个阶段执行必须等待前一个阶段完成，每个阶段称为流水线的“级”。对于一个非流水线结构中的运算，完成时间为L，则加入n级流水线后，每L/n个单位时间就可以完成1个运算，这样就将同时在电路运算中的数据量增大了n倍，即<strong>吞吐量</strong>增大了n倍。</p>
<p>实际运算中，n级流水线并不一定能够得到n倍的速度提升</p>
<p>对于n级流水线结构，完成N个运算所需时间为<br>$$<br>T_{pipe}(N)=L+\frac{(N-1)L}{n}=\frac{n+N-1}{n}<br>$$<br>其中完成一个运算所需时间为L</p>
<p>速度提升率为<br>$$<br>S_{pipe}(N)=\frac{T(N)}{T_{pipe}(N)}=\frac{nN}{n+N-1}=\frac{n}{1+\frac{n-1}{N}}<br>$$<br>当$n\ll N$时，有$S_{pipe}(N)\cong n$</p>
<p>流水线结构和非流水线结构相比所得的速度提升和级数成正比，系数为n</p>
<p>这里要注意的是：全部N个运算的时间被缩短，但每个运算从刚开始到结束的时间没有变化，且在刚开始计算时，也就是流水线没有完全开始工作时的<strong>载入过程</strong>，还有结束计算时的<strong>清空过程</strong>无法省略且难以获得吞吐量增益。</p>
<p>流水线结构设计中，还要注意时钟周期限制，在寄存器与寄存器之间存在传输延迟、关键电路延迟。当将非流水线硬件改为流水线结构设计时，需要考虑各个部分的延迟。考虑不周很可能发生前一级完成传输时后一级的传输还在进行，就会产生电路错误</p>
<p>对于两个寄存器之间的延迟，$时钟周期&gt;传输延迟+组合逻辑电路的关键电路延迟+建立时间$，这一时钟周期对应频率的极限就是电路时钟频率的最大值</p>
<p>当级数增多时，流水线寄存器延迟、建立时间、寄存器输入时钟信号偏移、各级之间处理延迟的不同导致的问题越发显著，虽然引入流水线可以在一定程度上增加总体处理速率，增大吞吐量，但是会引入更多需要考虑的因素</p>
<h2 id="并行计算与Flynn"><a href="#并行计算与Flynn" class="headerlink" title="并行计算与Flynn"></a>并行计算与Flynn</h2><p>Michel.J.Flynn在1965年提出了称为<strong>Flynn分类</strong>的并行计算架构分类方法</p>
<p>在通用计算机架构中存在用于控制的<em>指令流</em>和作为运算对象的<em>数据流</em>，Flynn根据基于指令流和数据流的并行度对架构进行分类，分成SISD、SIMD、MISD、MIMD四类，将计算机模型抽象为运算单元PU、控制单元CU、数据存储器、指令存储器四个部分</p>
<ul>
<li><p>SISD架构</p>
<p>  单一CU从指令存储器读取指令流来控制单一的PU，PU受CU控制，从数据存储器读取单一数据流进行计算处理</p>
<p>  这一架构代表基本的顺序计算，不具备并行计算能力</p>
</li>
<li><p>SIMD架构</p>
<p>  单一CU读取指令流的同时控制多个PU，<strong>各个PU接受相同的控制，各自对不同的数据流进行相同的计算处理</strong>，各个PU可以有自己的本地存储器，也可以所有PU访问同一个共享存储器</p>
<p>  该架构中的PU常常被用于图像处理等ASIC中</p>
<p>  通常处理器还会提供SIMD指令来实现数据并行计算，经典的浮点数SIMD指令就是其中之一</p>
</li>
<li><p>MISD架构</p>
<p>  多个CU各自读取不同的指令流并控制多个PU，各个PU根据不同的控制指令对单一数据流进行操作，操作完成后前一阶段的PU将计算结果交付给下一阶段的PU，这样就形成了类似流水线的结构。通过每个CU各自控制一个不同功能的PU来实现并行计算，一般和SIMD架构同时使用来提高效率</p>
</li>
<li><p>MIMD架构</p>
<p>  多个CU各自读取不同的指令流并控制多个PU，各个独立受控的PU对不同的数据流并行处理</p>
<p>  该架构通常应用于具有SMP等多个核心紧密结合的处理器，可以实现共享数据存储器或独立存储器的计算</p>
</li>
</ul>
<h2 id="脉动算法"><a href="#脉动算法" class="headerlink" title="脉动算法"></a>脉动算法</h2><p><strong>脉动算法</strong>：基于H.T.Kung所提倡的脉动阵列所实现并行处理算法的简称</p>
<p><strong>脉动阵列</strong>：由大量单一或多种构造的运算元件（PE）按规律排列的硬件架构，其中只有相邻的运算元件互相连接，运算元件只重复进行简单的数据处理和必要的数据收发，且由统一的时钟同步工作，数据每次只能在相邻运算原件之间移动；使用了总线等连接方式的架构称为半脉动阵列</p>
<p>脉动阵列中的运算元件也可以称为单元</p>
<p><strong>这种架构的系统性能可以随阵列规模扩大而成比例增加，非常适合在集成电路上实现</strong></p>
<h3 id="基于一维脉动阵列的部分排序"><a href="#基于一维脉动阵列的部分排序" class="headerlink" title="基于一维脉动阵列的部分排序"></a>基于一维脉动阵列的部分排序</h3><p>排序：将数据按照某种顺序重新排列的过程</p>
<p>一维排列上设计N个具有寄存器的PE，用于对N个数据进行排序</p>
<p>PE的寄存器用于保存临时最大值X<del>MAX</del>，当输入比临时最大值大时将临时最大值更新为输入值（使用两路数据选择器，输出较大的数据），在PE之间不断重复这个过程直到所有N个数据进入PE，数值最大的N个数据就会依次存储在各个PE的寄存器中，最后一起输出就完成了比较步骤</p>
<p>一般的硬件排序电路一般还具有_rst复位输入、mode模式选择输入、shiftRead从大到小逐次读出等输入端</p>
<p>这样的电路一般也可以当作移位寄存器</p>
<h3 id="基于一维和二维脉动阵列的矩阵向量相乘"><a href="#基于一维和二维脉动阵列的矩阵向量相乘" class="headerlink" title="基于一维和二维脉动阵列的矩阵向量相乘"></a>基于一维和二维脉动阵列的矩阵向量相乘</h3><p>矩阵向量相乘<strong>Y=AX</strong>的计算也可以采用一维脉动阵列实现，呈网格状排列的二位脉动阵列可以更直观地体现计算思路</p>
<ul>
<li><p>一维</p>
<p>  需要N个PE来实现N x N的矩阵运算，每个PE都是独立的加法器，矩阵X和A分别从左和从上输入阵列，PE会将两矩阵的对应行、列元素相加，并将结果暂存在各自的寄存器中。每个时钟周期都会进行运算并输出当前寄存器内的值</p>
<p>  需要注意在运算开始前应将寄存器初始化为0，即实现如下算法（C语言形式）</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>  每一步都会执行如下算法（C语言形式）</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y=y+a*x;</span><br></pre></td></tr></table></figure>

<p>  最后完成运算所需总步数为2N-1</p>
</li>
<li><p>二维</p>
<p>  二维矩阵只需要将两个输入矩阵错位，每个时钟周期输入一次即可</p>
<p>  运算所需总步数为3N-2</p>
</li>
</ul>
<h3 id="实现任意模板计算的可编程脉动阵列"><a href="#实现任意模板计算的可编程脉动阵列" class="headerlink" title="实现任意模板计算的可编程脉动阵列"></a>实现任意模板计算的可编程脉动阵列</h3><p>由</p>
<ul>
<li><p>运算器</p>
<p>  用于进行浮点数乘法和加法</p>
</li>
<li><p>本地存储器</p>
<p>  用于在脉动阵列电路内存储一部分运算数据</p>
</li>
<li><p>交换电路</p>
<p>  将当前位置的运算器和本地存储器中的数据运输到其他地方</p>
</li>
<li><p>可编程序列发生器</p>
<p>  控制整个脉动阵列，使用微程序进行操纵</p>
</li>
</ul>
<p>组成</p>
<p>通常一个脉动计算存储器阵列分为多个控制组，各控制组内的PE由统一序列发生器控制，按照SIMD架构并行处理</p>
<p>结合微程序控制交换电路对数据进行搬运，就可以实现任意模板计算</p>
<h2 id="数据流机"><a href="#数据流机" class="headerlink" title="数据流机"></a>数据流机</h2><p><strong>数据流机</strong>是一种只要输入数据就能进行计算的非冯诺依曼架构的计算机。这种运行方式被称为数据驱动方式</p>
<p>他将对象程序转化为数据流图后执行处理。一个典型的数据流机有以下节点：</p>
<ul>
<li>Fork复制数据到另一支路</li>
<li>Primitive Operation按描述进行两个数据的算术运算并输出结果</li>
<li>Branch控制数据流向多个分支中的哪一个分支</li>
<li>Merge根据条件信号的值选择输入数据并输出</li>
<li>令牌：被操作的数据</li>
</ul>
<p>数据流机可以简单地实现条件分支和循环</p>
<p>其中条件分支可以使用Branch和Merge的组合来实现，而循环则有两类实现方式</p>
<h3 id="静态数据流机"><a href="#静态数据流机" class="headerlink" title="静态数据流机"></a>静态数据流机</h3><p>将循环完全展开，全部以数据流的形式实现</p>
<p>优点：并行性很高</p>
<p>缺点：数据流图的规模庞大，对应的电路结构也无法避免地变大</p>
<p>常用于节点运算功能和运算数混合存在的场合，电路中一个命令单元对应一个运算器，运算器会通过控制网络向命令单元传输当前状态。处理完毕的数据进入分发网络送至命令单元，命令通过仲裁网络以操作包的形式发送到运算器，这样就实现了循环的控制</p>
<h3 id="动态数据流机"><a href="#动态数据流机" class="headerlink" title="动态数据流机"></a>动态数据流机</h3><p>只实现循环体的数据流，在之后的循环中复用同一组硬件搭配条件分支来实现</p>
<p>优点：</p>
<p>缺点：需要设置额外的控制电路，如果发生循环间令牌混乱的情况就难以保证计算的正确性</p>
<p>常用于节点运算功能和运算数分离的场合，可以使用<em>带标号的令牌</em>来实现循环处理</p>
<p>典型的电路结构如下：</p>
<p><img src="/2021/11/19/FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E3%80%90FPGA%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%93%E6%9E%84%E3%80%91/image-20210404102541269.png" alt="image-20210404102541269"></p>
<p>其中每个PE的结构如下：</p>
<p><img src="/2021/11/19/FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E3%80%90FPGA%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%93%E6%9E%84%E3%80%91/image-20210404103243188.png" alt="image-20210404103243188"></p>
<p>运算数据由标号令牌表示，程序和数据完全分离，每个PE都可以视作一个小型的冯诺依曼架构计算机，数据令牌则由存储位置指令的状态编号、自己的标号、存储位置指令的入口编号、存储位置指令的运算数组成，控制不同标号的运算数据进入不同的PE即可实现循环</p>
<p>PE中的I结构是一个为数组等简单数据结构提供等待功能的模块，在按数据驱动方式处理数组访问时，需要保证数据在写入之后再次被读取。一般的解决方法是对每一个元素设置一个存在标志位，指示数据是否已经被写入，I结构一般要内置该功能以加速简单数据结构的运算。</p>
<h3 id="Petri网"><a href="#Petri网" class="headerlink" title="Petri网"></a>Petri网</h3><p>表示信号输入/输出的图被称为Petri网，<strong>信号转换图</strong>是它的一个子类。可以用于描述并行系统和异步系统</p>
<p>Petri网是由<em>库所</em>（place）和<em>变迁</em>（transition）两类节点和有向弧组成的二分图</p>
<p>系统的状态或条件由库所表示，系统状态迁移的发生和完成等事件用变迁表示，库所-&gt;变迁的有向弧表示现象的发生及其前提条件，变迁-&gt;库所表示事件发生后的状态和成立条件的关系。</p>
<p>Petri网可以表示以下基本状态行为：</p>
<ul>
<li>并发</li>
<li>冲突</li>
<li>困惑</li>
<li>同步</li>
<li>资源共享</li>
<li>读取</li>
<li>有限容量</li>
</ul>
<p>常使用Petri网和数据流机共同描述一个算法，以便在HDL中进行有效的算法优化</p>
<h2 id="流处理思想及其实现"><a href="#流处理思想及其实现" class="headerlink" title="流处理思想及其实现"></a>流处理思想及其实现</h2><p><strong>流处理</strong>：针对逐个输入的数据序列，持续依次处理其中各个元素的方式</p>
<p>数据元素可以是单一标量数据，也可以是包含多个字的向量数据，但流处理每次只能处理一个元素，这就导致元素增多（数据流增长）时的处理时间会成比例增加，不过这也相当于<strong>只要付出时间就可以处理巨大的数据集</strong></p>
<p>流处理数据元素的处理单元称为处理核（kernal），流处理中可以只包含一个处理核也可以包含多个处理核</p>
<h3 id="硬件实现"><a href="#硬件实现" class="headerlink" title="硬件实现"></a>硬件实现</h3><p>如果有充足的硬件资源，可以实现多个处理核，每个处理核作为一级流水线相互连接，最终形成一个大型流水线设计，这样的系统能够达到吞吐量为1的流处理，每个时钟周期都可以进行数据的输入/输出；当硬件资源不充足时，可以将原数据流图折叠变小后映射到硬件，这种方法称为<strong>折叠法</strong>，该设计会导致处理周期增加，吞吐量降低，但可以节省硬件资源或在硬件资源有限的情况下实现流处理</p>
<p>对于某些硬件使用率不到100%的电路，也可以考虑使用折叠法来提高硬件使用率：在运算器输入处插入数据选择器，在需要提高硬件使用率的情况下将正常的流处理程序改变为折叠过后的流处理程序；如果连续处理的多个数据之间存在依赖关系，可以在流处理过程中插入延迟缓冲存储器，将上一步运算的结果暂存，在下一个时钟周期进行处理来实现流处理效果</p>
<h2 id="元胞自动机"><a href="#元胞自动机" class="headerlink" title="元胞自动机"></a>元胞自动机</h2><p><strong>元胞自动机</strong>是基于网格状单元核简单规则的离散计算模型，于冯诺依曼等人在20世纪40年代提出。</p>
<p>元胞自动机由具有有限个状态的元胞组成，经过离散时间后每个细胞的状态都会发生变化，某时刻t元胞的状态会受到上一个时刻元胞状态和其邻居元胞状态的影响。按照考虑邻居元胞的个数，分为冯诺依曼型（只考虑上下左右四个元胞的状态）和摩尔型（考虑全部八个周边元胞状态）</p>
<p>最著名的元胞自动机就是<em>生命游戏</em>，它的一种简单C语言实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单的状态机练习</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;LifeGame.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开始菜单</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CtrlGame</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> input=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Welcome to play LifeGame!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter p to start\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        input=getch();</span><br><span class="line">        <span class="keyword">if</span>(input==<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//游戏数据初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitGame</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>)); <span class="comment">//生成种子</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;HIGH;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;WIDTH;j++)</span><br><span class="line">            cell_map[i][j]=rand()%<span class="number">2</span>;<span class="comment">//细胞初始状态随机</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行游戏</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunGame</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cell_num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        system(<span class="string">&quot;cls&quot;</span>);<span class="comment">//清屏</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;HIGH;i++) <span class="comment">//打印本迭代细胞地图</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;WIDTH;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(cell_map[i][j]==<span class="number">1</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot; # &quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(cell_map[i][j]==<span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot; * &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算1个细胞周围8个格子内的活细胞总量并进行下一步判断</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;HIGH;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;WIDTH;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>) <span class="comment">//最上一行</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(j==<span class="number">0</span>) <span class="comment">//左上角</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        cell_num=</span><br><span class="line">                                                         cell_map[i][j+<span class="number">1</span>]+</span><br><span class="line">                                      cell_map[i+<span class="number">1</span>][j]+ cell_map[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(j==WIDTH<span class="number">-1</span>) <span class="comment">//右上角</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        cell_num=</span><br><span class="line">                                     cell_map[i][j<span class="number">-1</span>]+                     </span><br><span class="line">                                     cell_map[i+<span class="number">1</span>][j<span class="number">-1</span>]+ cell_map[i+<span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="comment">//其他</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        cell_num=</span><br><span class="line">                                     cell_map[i][j<span class="number">-1</span>]+                     cell_map[i][j+<span class="number">1</span>]+</span><br><span class="line">                                     cell_map[i+<span class="number">1</span>][j<span class="number">-1</span>]+ cell_map[i+<span class="number">1</span>][j]+ cell_map[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i==HIGH<span class="number">-1</span>) <span class="comment">//最下一行</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(j==<span class="number">0</span>) <span class="comment">//左下角</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        cell_num= cell_map[i<span class="number">-1</span>][j]+ cell_map[i<span class="number">-1</span>][j+<span class="number">1</span>]+</span><br><span class="line">                                                    cell_map[i][j+<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(j==WIDTH<span class="number">-1</span>) <span class="comment">//右下角</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        cell_num=cell_map[i<span class="number">-1</span>][j<span class="number">-1</span>]+ cell_map[i<span class="number">-1</span>][j]+ </span><br><span class="line">                                 cell_map[i][j<span class="number">-1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="comment">//其他</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        cell_num=cell_map[i<span class="number">-1</span>][j<span class="number">-1</span>]+ cell_map[i<span class="number">-1</span>][j]+ cell_map[i<span class="number">-1</span>][j+<span class="number">1</span>]+</span><br><span class="line">                                 cell_map[i][j<span class="number">-1</span>]+                     cell_map[i][j+<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>) <span class="comment">//除左上角和左下角的最左一列</span></span><br><span class="line">                &#123;</span><br><span class="line">                    cell_num=cell_map[i<span class="number">-1</span>][j]+ cell_map[i<span class="number">-1</span>][j+<span class="number">1</span>]+</span><br><span class="line">                                               cell_map[i][j+<span class="number">1</span>]+</span><br><span class="line">                             cell_map[i+<span class="number">1</span>][j]+ cell_map[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==WIDTH<span class="number">-1</span>) <span class="comment">//除右上角和右下角的最右一列</span></span><br><span class="line">                &#123;</span><br><span class="line">                    cell_num=cell_map[i<span class="number">-1</span>][j<span class="number">-1</span>]+ cell_map[i<span class="number">-1</span>][j]+</span><br><span class="line">                             cell_map[i][j<span class="number">-1</span>]+</span><br><span class="line">                             cell_map[i+<span class="number">1</span>][j<span class="number">-1</span>]+ cell_map[i+<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">//其他位置</span></span><br><span class="line">                &#123;</span><br><span class="line">                    cell_num=cell_map[i<span class="number">-1</span>][j<span class="number">-1</span>]+ cell_map[i<span class="number">-1</span>][j]+ cell_map[i<span class="number">-1</span>][j+<span class="number">1</span>]+</span><br><span class="line">                             cell_map[i][j<span class="number">-1</span>]+                     cell_map[i][j+<span class="number">1</span>]+</span><br><span class="line">                             cell_map[i+<span class="number">1</span>][j<span class="number">-1</span>]+ cell_map[i+<span class="number">1</span>][j]+ cell_map[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(cell_num==<span class="number">3</span>) <span class="comment">//当周围有3个活细胞时,该细胞下一代为活细胞</span></span><br><span class="line">                    new_cell_map[i][j]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(cell_num==<span class="number">2</span>) <span class="comment">//周围有2个活细胞时，该细胞下一代状态不变</span></span><br><span class="line">                    new_cell_map[i][j]=cell_map[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">//其它情况时，该细胞下一代转为死细胞</span></span><br><span class="line">                    new_cell_map[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;HIGH;i++) <span class="comment">//创建下一迭代</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;WIDTH;j++)</span><br><span class="line">                cell_map[i][j]=new_cell_map[i][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(CtrlGame()==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        InitGame();</span><br><span class="line">        RunGame();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LifeGame.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;windows.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//游戏尺寸</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HIGH 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDTH 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cell_map[HIGH][WIDTH]; <span class="comment">//初始状态细胞地图</span></span><br><span class="line"><span class="keyword">int</span> new_cell_map[HIGH][WIDTH]; <span class="comment">//下一代细胞地图</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CtrlGame</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//开始菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitGame</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//游戏数据初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunLifeGame</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//进行游戏</span></span><br></pre></td></tr></table></figure>

<h2 id="硬件排序算法"><a href="#硬件排序算法" class="headerlink" title="硬件排序算法"></a>硬件排序算法</h2><p><strong>排序</strong>：将由n个元素组成的乱序数列按升序或降序重新排列的过程</p>
<p>硬件上常常使用<strong>排序网络</strong>和<strong>归并排序树</strong></p>
<h3 id="基于冒泡排序的排序网络"><a href="#基于冒泡排序的排序网络" class="headerlink" title="基于冒泡排序的排序网络"></a>基于冒泡排序的排序网络</h3><p>特点：可以并行地对相邻两个元素进行排序</p>
<p>排序网络由连线和用于排序相邻元素的交换单元EU组成</p>
<p>连线的数量和元素的数量一致，每个元素最多通过n-1级EU，使用流水线可以提升吞吐量</p>
<p>缺点：面积大，占用硬件资源</p>
<p>在此基础上换用Batcher奇偶排序网络可实现高效排序</p>
<h3 id="归并排序树"><a href="#归并排序树" class="headerlink" title="归并排序树"></a>归并排序树</h3><p>使用二叉树结构连接各个EU，使用FIFO进行输入/输出实现电路内部和外部去耦</p>
<p>全部EU的排序处理可以并行执行，待排列的数列并行输入归并排序树，每层EU选出两个元素中较大（较小）的那个，每层EU将排序后的数列送到下一层的输入FIFO，依次执行最后可以串行输出排序后的数列</p>
<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p><strong>模式匹配</strong>：在数据中按照给定的模式进行搜索</p>
<h3 id="精确匹配"><a href="#精确匹配" class="headerlink" title="精确匹配"></a>精确匹配</h3><p>精确匹配中的模式长度固定，分成0、1、’dont care‘三种状态</p>
<p>可以使用CAM（Content Addressable Memory）存储器实现。在FPGA上常常实现CAM的索引生成单元（Index Generation Unit，IGU）</p>
<p>总体思路是将输入数据p存储到<em>主存储器</em>，主存储器输出索引生成函数f，使用辅助存储器存储f，将其和匹配输入X进行比较，输出q，使用q在辅助存储器查询得到X’，将X和X‘进行逻辑与运算，如果两者相同就输出q，否则输出0</p>
<p>IGU可以将2^n^个元素的集合映射到k+1个集合，内存占用量从O(2^n^)缩减到O(2^p^)，其中p是输入数据p的位数</p>
<h3 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h3><p>正则表达式由字符和描述字符集合的元字符组成。正则表达式匹配等价于使用同等功能的有穷自动机对字符串进行处理</p>
<p>对于确定的输入无法确定迁移状态的自动机称为<strong>非确定性有穷自动机（NFA）</strong>；对确定的输入能够确定迁移状态的自动机称为<strong>确定性有穷自动机（DFA）</strong>。采用DFA的硬件加速实现一般基于Aho-Corasick算法；采用NFA的硬件加速一般使用Prasanna方法</p>
<p>下面仅介绍NFA实现：</p>
<ul>
<li>电路使用存储器对单个字符进行检索，并将结果送入匹配单元ME</li>
<li>ME会模拟状态迁移过程并输出匹配信号</li>
</ul>
<p>总体上是利用一个解析元字符的ME来控制对整个字符串的检索</p>
<p>NFA和DFA两种并行硬件的比较如下</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>按位分割DFA</th>
<th>Prasanna-NFA</th>
</tr>
</thead>
<tbody><tr>
<td>空间复杂度</td>
<td>查找表数</td>
<td>O(1)</td>
<td>O(ms)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>存储器使用量</td>
<td>$O(\sum ^{ms})$</td>
<td>O(ms)</td>
</tr>
<tr>
<td>时间复杂度</td>
<td>处理周期</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>对于FPGA来说更适合NFA实现，因为DFA方法的存储器使用量呈指数型增加，而NFA方法的空间复杂度恒定</p>
<h3 id="近似匹配"><a href="#近似匹配" class="headerlink" title="近似匹配"></a>近似匹配</h3><p>近似字符串匹配：在文本中查找和模式相似的字符串的问题</p>
<p>近似匹配过程中往往伴随着对模式进行删除、置换、插入等处理</p>
<p>一个典型的近似匹配硬件加速架构如下：</p>
<ul>
<li>宿主PC将文本和模式发送到硬件部分</li>
<li>文本被发送到缓冲存储器，模式被发送到编辑距离运算电路</li>
<li>编辑距离运算电路从缓冲存储器读取一部分文本，并计算文本和模式的编辑距离。当且仅当编辑距离最小时，控制电路会将最小编辑距离和表示文本位置的地址输出到FIFO保存</li>
<li>文本每次移动一个字符并重复上一步</li>
<li>所有文本匹配完成时，会将结果发回宿主PC</li>
</ul>
<p>所有步骤中最复杂的就是计算编辑距离，在这里常常需要实现特殊的<strong>动态规划</strong>硬件算法</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1]Jason Cong,Yuzheng Ding. FlowMap: an optimal technology mapping  algorithm for delay optimization in lookup-table based FPGA designs.[J]. IEEE Trans. on CAD of Integrated Circuits and Systems,1994,13(1).</p>
<p>[2]VPack-Jonathan Rose.UToronto</p>
<p>[3]Alexander (Sandy) Marquardt,Vaughn Betz,Jonathan Rose. Using  cluster-based logic blocks and timing-driven packing to improve FPGA  speed and density[P]. Field programmable gate arrays,1999.</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">FPGA</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2021/11/19/FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E3%80%90FPGA%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%93%E6%9E%84%E3%80%91/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-STM32外设配置速查【QSPI】" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/19/STM32%E5%A4%96%E8%AE%BE%E9%85%8D%E7%BD%AE%E9%80%9F%E6%9F%A5%E3%80%90QSPI%E3%80%91/">STM32外设配置速查【QSPI】</a>
    </h1>
  

        
<!-- 显示阅读次数-->
<!--  -->
<!--显示阅读次数完毕 -->

        
        <a href="/2021/11/19/STM32%E5%A4%96%E8%AE%BE%E9%85%8D%E7%BD%AE%E9%80%9F%E6%9F%A5%E3%80%90QSPI%E3%80%91/" class="archive-article-date">
  	<time datetime="2021-11-19T08:07:03.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2021-11-19</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="QSPI协议"><a href="#QSPI协议" class="headerlink" title="QSPI协议"></a>QSPI协议</h1><p>QSPI是Queued SPI（队列串行外围接口）的缩写，是由摩托罗拉公司推出的SPI协议的一个扩展，比SPI应用更加广泛，现在的FLASH、SRAM等存储器大多支持QSPI协议——QSPI是一种==专用==的通信接口，可连接单、双或四线SPI存储器</p>
<p>QSPI在SPI协议的基础上增加了<strong>队列传输机制</strong>。</p>
<p>STM32将Queued SPI协议接口实现为QUADSPI接口。QSPI的实现和SPI基本相似，有部分不同点，在下面列出。</p>
<h2 id="物理连接"><a href="#物理连接" class="headerlink" title="物理连接"></a>物理连接</h2><p>QSPI是标准的四信号线SPI，MCU与外设之间由六根线连接：NSS、IO0、IO1、IO2、IO3、SCLK，其中IO0-3是数据线；NSS又称CS，是片选信号线；SCLK又称SCK，是SPI/QSPI的同步时钟线</p>
<h2 id="通信规则"><a href="#通信规则" class="headerlink" title="通信规则"></a>通信规则</h2><h3 id="读写命令"><a href="#读写命令" class="headerlink" title="读写命令"></a>读写命令</h3><p><strong>有且仅有一条数据线工作</strong></p>
<h3 id="读写数据"><a href="#读写数据" class="headerlink" title="读写数据"></a>读写数据</h3><p><strong>四条数据线同时工作</strong></p>
<p>读写地址位时四条数据线发送不同的地址，从机自行分辨，引导向各自的地址；读写具体数据时根据对应的地址读写</p>
<h1 id="STM32F1中的SPI特性"><a href="#STM32F1中的SPI特性" class="headerlink" title="STM32F1中的SPI特性"></a>STM32F1中的SPI特性</h1><ul>
<li>三线全双工同步传输</li>
<li>双线/三线单工同步传输</li>
<li>8位/16位传输帧格式选择</li>
<li>主从操作、支持多主模式</li>
<li>8个主模式波特率分频系数（最高可达$f_{PCLK}/2$）</li>
<li>硬件/软件可调的SS（CS片选信号）管理</li>
<li>相关底层配置可编程</li>
<li>可触发中断的发送/接收标志</li>
<li>SPI总线忙碌标志位</li>
<li>支持硬件CRC校验</li>
<li>支持DMA</li>
</ul>
<h1 id="STM32F4中的SPI实现"><a href="#STM32F4中的SPI实现" class="headerlink" title="STM32F4中的SPI实现"></a>STM32F4中的SPI实现</h1><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li><p>支持SPI的TI模式（主要是片选信号差异，用于TI系的IC）</p>
</li>
<li><p>支持F1的全部功能</p>
</li>
</ul>
<p>与F1的功能基本一致，满足SPI接口的使用需要</p>
<h2 id="硬件实现"><a href="#硬件实现" class="headerlink" title="硬件实现"></a>硬件实现</h2><ol>
<li>寄存器配置SPI设置</li>
<li>波特率发生器配置SCLK</li>
<li>MOSI、MISO通过移位寄存器进行收发数据，接收数据即将数据从移位寄存器中复制到RxFIFO；发送数据即将数据放入TxFIFO后送入移位寄存器</li>
<li>主控制逻辑电路和通信控制电路调配相关收发过程</li>
</ol>
<h2 id="HAL库实现"><a href="#HAL库实现" class="headerlink" title="HAL库实现"></a>HAL库实现</h2><p>直接<strong>将收发数据封装为库函数</strong></p>
<h1 id="STM32F7中的SPI特点"><a href="#STM32F7中的SPI特点" class="headerlink" title="STM32F7中的SPI特点"></a>STM32F7中的SPI特点</h1><ul>
<li><p>支持F4的所有功能</p>
</li>
<li><p>可调传输帧格式4位到16位（对应原来的8位/16位传输帧格式选择）</p>
</li>
<li><p>具有DMA功能的两个32位内置Rx、Tx FIFO缓存</p>
</li>
</ul>
<h1 id="STM32H7中的SPI实现"><a href="#STM32H7中的SPI实现" class="headerlink" title="STM32H7中的SPI实现"></a>STM32H7中的SPI实现</h1><h2 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h2><ul>
<li>支持F7的所有功能</li>
<li>数据帧格式大小可从4位到32位</li>
<li><strong>双时钟域</strong>，外设内核时钟可以独立于PCLK</li>
<li>更高的主频，8个主模式波特率预分频器（没有改动），主从模式频率均最高可达内核频率的1/2（$f_{FCLK}/2$）</li>
<li>保护配置和设置</li>
<li>数据之间的最小延时、SS与数据流之间的最小延时均可调</li>
<li>底层配置可编程，支持SS信号极性、时序可编程和MISOxMOSI交互功能</li>
<li>可调节的主器件接收器采样时间</li>
<li>配备停止模式（不向外设IP提供时钟）</li>
<li>具有停止模式下从器件发送/接收功能和低功耗唤醒功能</li>
<li>可编程的FIFO阈值（数据打包）</li>
<li>可编程的传输数据量</li>
<li>具有DMA功能的Rx、Tx FIFO容量扩大到16x8位或8x8位且可选</li>
<li>从模式下，下溢条件可配置，支持级联循环缓冲区</li>
</ul>
<p>H7的SPI控制器比之前版本的控制器自由度更高（但大部分情况下用不上）</p>
<h2 id="硬件实现-1"><a href="#硬件实现-1" class="headerlink" title="硬件实现"></a>硬件实现</h2><p>与之前的SPI控制器基本相同，但多了双时钟域的功能块：时钟寄存器控制时钟发生器工作，可以由SPI_PCLK或SPI_KER_CK提供时钟，SPI_KER_CK时钟直接提供给时钟发生器，进而用于SCK或MCK</p>
<h2 id="软件配置"><a href="#软件配置" class="headerlink" title="软件配置"></a>软件配置</h2><ol>
<li>在CubeMX中根据外设IC配置GPIO复用和SPI相关设定</li>
<li>CubeMX会使能外设时钟、配置SPI模式、地址、速率等参数并使能SPI外设；模式设定与f4设定基本类似，可参考【STM32F4外设配置速查总线协议部分】</li>
<li>编写对应外设IC的驱动程序</li>
<li>设置检验程序，上电后检验驱动程序及外设连接情况</li>
<li>编写应用程序</li>
</ol>
<h1 id="STM32F7-H7中的QSPI实现"><a href="#STM32F7-H7中的QSPI实现" class="headerlink" title="STM32F7/H7中的QSPI实现"></a>STM32F7/H7中的QSPI实现</h1><p>QUADSPI主要用于控制SPI FLASH器件（只要满足QSPI时序就可以控制其他器件），工作在以下三种模式：</p>
<ol>
<li>间接模式：使用QUADSPI寄存器执行全部操作</li>
<li><strong>状态轮询模式</strong>：周期性轮询外部FLASH状态寄存器，如果为1（擦除/烧写完毕）则引发中断</li>
<li><strong>内存映射模式</strong>：外部FLASH映射到MCU片上SRAM地址空间，系统将其视作<strong>内部FLASH</strong>存储器进行操作（==内部FLASH只读==）</li>
</ol>
<p>特别地，采用双闪存模式时，将<strong>同时访问两个QSPI FLASH，吞吐量和容量*2</strong></p>
<h2 id="特性-2"><a href="#特性-2" class="headerlink" title="特性"></a>特性</h2><ul>
<li>双闪存模式：并行访问两块FLASH，同时收发8位数据</li>
<li>支持SDR和DDR模式</li>
<li>集成接收/发送FIFO</li>
<li>允许8、16、32位数据访问</li>
<li>间接模式下可使用DMA</li>
<li>可使能的FIFO溢出、超时、操作完成、访问错误中断（异常）</li>
</ul>
<h2 id="硬件实现-2"><a href="#硬件实现-2" class="headerlink" title="硬件实现"></a>硬件实现</h2><p>可以实现单线、双线、四线SPI功能</p>
<p>与SPI控制器的不同点主要在于：FIFO和外设寄存器直接接入AHB总线</p>
<p>双闪存模式下，外设引脚复用可选择一个CS信号线或两个CS信号线</p>
<p>其他内容可参考MCU数据手册</p>
<h2 id="软件配置-1"><a href="#软件配置-1" class="headerlink" title="软件配置"></a>软件配置</h2><ol>
<li>基本配置同上</li>
</ol>
<p>外部SPI FLASH驱动代码如下，与上面的代码差别不大</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* W25Q256.h文件的函数声明 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;													<span class="comment">//初始化W25QXX</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Qspi_Enable</span><span class="params">(<span class="keyword">void</span>)</span></span>;											<span class="comment">//使能QSPI模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Qspi_Disable</span><span class="params">(<span class="keyword">void</span>)</span></span>;											<span class="comment">//关闭QSPI模式</span></span><br><span class="line"><span class="function">u16  <span class="title">NORFLASH_ReadID</span><span class="params">(<span class="keyword">void</span>)</span></span>;													<span class="comment">//读取FLASH ID</span></span><br><span class="line"><span class="function">u8 	 <span class="title">NORFLASH_ReadSR</span><span class="params">(u8 regno)</span></span>;												<span class="comment">//读取状态寄存器 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_4ByteAddr_Enable</span><span class="params">(<span class="keyword">void</span>)</span></span>;										<span class="comment">//使能4字节地址模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Write_SR</span><span class="params">(u8 regno,u8 sr)</span></span>;										<span class="comment">//写状态寄存器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Write_Enable</span><span class="params">(<span class="keyword">void</span>)</span></span>;  											<span class="comment">//写使能 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Write_Disable</span><span class="params">(<span class="keyword">void</span>)</span></span>;											<span class="comment">//写保护</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Write_NoCheck</span><span class="params">(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)</span></span>;	<span class="comment">//写flash,不校验</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Read</span><span class="params">(u8* pBuffer,u32 ReadAddr,u16 NumByteToRead)</span></span>;   			<span class="comment">//读取flash</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Write</span><span class="params">(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)</span></span>;			<span class="comment">//写入flash</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Erase_Chip</span><span class="params">(<span class="keyword">void</span>)</span></span>;    	  										<span class="comment">//整片擦除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Erase_Sector</span><span class="params">(u32 Dst_Addr)</span></span>;									<span class="comment">//扇区擦除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Wait_Busy</span><span class="params">(<span class="keyword">void</span>)</span></span>;           									<span class="comment">//等待空闲</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* W25Q256.c文件全部内容 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;norflash.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;qspi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;usart.h&quot;</span> </span></span><br><span class="line"></span><br><span class="line">u16 NORFLASH_TYPE=W25Q256;	<span class="comment">//使用W25Q256</span></span><br><span class="line">u8 NORFLASH_QPI_MODE=<span class="number">0</span>;		<span class="comment">//QSPI模式标志:0,SPI模式;1,QSPI模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 4Kbytes为一个Sector（扇区）</span></span><br><span class="line"><span class="comment"> * 16个扇区为1个Block（块）</span></span><br><span class="line"><span class="comment"> * W25Q64容量为8M字节,共有128个Block,2048个Sector，W25Q256刚好是它的4倍</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化SPI FLASH的IO口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	u8 temp;</span><br><span class="line">	QSPI_Init();						<span class="comment">//初始化QSPI</span></span><br><span class="line"> 	NORFLASH_Qspi_Enable();				<span class="comment">//使能QSPI模式</span></span><br><span class="line">	NORFLASH_TYPE=NORFLASH_ReadID();	<span class="comment">//读取FLASH ID</span></span><br><span class="line">	<span class="keyword">if</span>(NORFLASH_TYPE==W25Q64)</span><br><span class="line">	&#123;</span><br><span class="line">		NORFLASH_Write_Enable();		<span class="comment">//写使能</span></span><br><span class="line">		QSPI_Send_CMD(W25X_SetReadParam,<span class="number">0</span>,(<span class="number">3</span>&lt;&lt;<span class="number">6</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//QSPI设置读参数指令,地址为0,4线传数据_8位地址_无地址_4线传输指令,无空周期,1个字节数据</span></span><br><span class="line">		temp=<span class="number">3</span>&lt;&lt;<span class="number">4</span>;						<span class="comment">//设置P4&amp;P5=11,8个dummy clocks,104M</span></span><br><span class="line">		QSPI_Transmit(&amp;temp,<span class="number">1</span>);			<span class="comment">//发送1个字节</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ID:%x\r\n&quot;</span>,NORFLASH_TYPE);	<span class="comment">//打印FLASH参数</span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//W25QXX进入QSPI模式 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Qspi_Enable</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 stareg2=<span class="number">0</span>;</span><br><span class="line">	stareg2=NORFLASH_ReadSR(<span class="number">2</span>);			<span class="comment">//先读出状态寄存器2的原始值 </span></span><br><span class="line">	<span class="comment">//printf(&quot;stareg2:%x\r\n&quot;,stareg2);	//打印参数</span></span><br><span class="line">	<span class="keyword">if</span>((stareg2&amp;<span class="number">0X02</span>)==<span class="number">0</span>)				<span class="comment">//QE位未使能</span></span><br><span class="line">	&#123; </span><br><span class="line">		NORFLASH_Write_Enable();		<span class="comment">//写使能 </span></span><br><span class="line">		stareg2|=<span class="number">1</span>&lt;&lt;<span class="number">1</span>;					<span class="comment">//使能QE位		</span></span><br><span class="line">		NORFLASH_Write_SR(<span class="number">2</span>,stareg2);	<span class="comment">//写状态寄存器2</span></span><br><span class="line">	&#125;</span><br><span class="line">	QSPI_Send_CMD(W25X_EnterQPIMode,<span class="number">0</span>,(<span class="number">0</span>&lt;&lt;<span class="number">6</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//写command指令,地址为0,无数据_8位地址_无地址_单线传输指令,无空周期,0个字节数据</span></span><br><span class="line">	NORFLASH_QPI_MODE=<span class="number">1</span>;				<span class="comment">//标记QSPI模式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//W25QXX退出QSPI模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Qspi_Disable</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	QSPI_Send_CMD(W25X_ExitQPIMode,<span class="number">0</span>,(<span class="number">0</span>&lt;&lt;<span class="number">6</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//写command指令,地址为0,无数据_8位地址_无地址_4线传输指令,无空周期,0个字节数据</span></span><br><span class="line">	NORFLASH_QPI_MODE=<span class="number">0</span>;<span class="comment">//标记SPI模式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取W25QXX的状态寄存器 */</span></span><br><span class="line"><span class="comment">//W25QXX一共有3个状态寄存器</span></span><br><span class="line"><span class="comment">//状态寄存器1：</span></span><br><span class="line"><span class="comment">//BIT7  6   5   4   3   2   1   0</span></span><br><span class="line"><span class="comment">//SPR   RV  TB BP2 BP1 BP0 WEL BUSY</span></span><br><span class="line"><span class="comment">//SPR:默认0,状态寄存器保护位,配合WP使用</span></span><br><span class="line"><span class="comment">//TB,BP2,BP1,BP0:FLASH区域写保护设置</span></span><br><span class="line"><span class="comment">//WEL:写使能锁定</span></span><br><span class="line"><span class="comment">//BUSY:忙标记位(1,忙;0,空闲)</span></span><br><span class="line"><span class="comment">//默认:0x00</span></span><br><span class="line"><span class="comment">//状态寄存器2：</span></span><br><span class="line"><span class="comment">//BIT7  6   5   4   3   2   1   0</span></span><br><span class="line"><span class="comment">//SUS   CMP LB3 LB2 LB1 (R) QE  SRP1</span></span><br><span class="line"><span class="comment">//状态寄存器3：</span></span><br><span class="line"><span class="comment">//BIT7      6    5    4   3   2   1   0</span></span><br><span class="line"><span class="comment">//HOLD/RST  DRV1 DRV0 (R) (R) WPS ADP ADS</span></span><br><span class="line"><span class="comment">//regno:状态寄存器号，范:1~3</span></span><br><span class="line"><span class="comment">//返回值:状态寄存器值</span></span><br><span class="line"><span class="function">u8 <span class="title">NORFLASH_ReadSR</span><span class="params">(u8 regno)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	u8 byte=<span class="number">0</span>,command=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">switch</span>(regno)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            command=W25X_ReadStatusReg1;    <span class="comment">//读状态寄存器1指令</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            command=W25X_ReadStatusReg2;    <span class="comment">//读状态寄存器2指令</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            command=W25X_ReadStatusReg3;    <span class="comment">//读状态寄存器3指令</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            command=W25X_ReadStatusReg1;    </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">	<span class="keyword">if</span>(NORFLASH_QPI_MODE)</span><br><span class="line">        QSPI_Send_CMD(command,<span class="number">0</span>,(<span class="number">3</span>&lt;&lt;<span class="number">6</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">    	<span class="comment">//QSPI模式,写command指令,地址为0,4线传数据_8位地址_无地址_4线传输指令,无空周期,1个字节数据</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        QSPI_Send_CMD(command,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;<span class="number">6</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">    	<span class="comment">//SPI模式,写command指令,地址为0,单线传数据_8位地址_无地址_单线传输指令,无空周期,1个字节数据</span></span><br><span class="line">	QSPI_Receive(&amp;byte,<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> byte;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment">//写W25QXX状态寄存器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Write_SR</span><span class="params">(u8 regno,u8 sr)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    u8 command=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span>(regno)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            command=W25X_WriteStatusReg1;    <span class="comment">//写状态寄存器1指令</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            command=W25X_WriteStatusReg2;    <span class="comment">//写状态寄存器2指令</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            command=W25X_WriteStatusReg3;    <span class="comment">//写状态寄存器3指令</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            command=W25X_WriteStatusReg1;    </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">	<span class="keyword">if</span>(NORFLASH_QPI_MODE)</span><br><span class="line">        QSPI_Send_CMD(command,<span class="number">0</span>,(<span class="number">3</span>&lt;&lt;<span class="number">6</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">    	<span class="comment">//QPI,写command指令,地址为0,4线传数据_8位地址_无地址_4线传输指令,无空周期,1个字节数据</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        QSPI_Send_CMD(command,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;<span class="number">6</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//SPI,写command指令,地址为0,单线传数据_8位地址_无地址_单线传输指令,无空周期,1个字节数据</span></span><br><span class="line">	QSPI_Transmit(&amp;sr,<span class="number">1</span>);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//W25QXX写使能</span></span><br><span class="line"><span class="comment">//将S1寄存器的WEL置位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Write_Enable</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(NORFLASH_QPI_MODE)</span><br><span class="line">        QSPI_Send_CMD(W25X_WriteEnable,<span class="number">0</span>,(<span class="number">0</span>&lt;&lt;<span class="number">6</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">    	<span class="comment">//QPI,写使能指令,地址为0,无数据_8位地址_无地址_4线传输指令,无空周期,0个字节数据</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        QSPI_Send_CMD(W25X_WriteEnable,<span class="number">0</span>,(<span class="number">0</span>&lt;&lt;<span class="number">6</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">    	<span class="comment">//SPI,写使能指令,地址为0,无数据_8位地址_无地址_单线传输指令,无空周期,0个字节数据</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//W25QXX写禁止	</span></span><br><span class="line"><span class="comment">//将WEL清零  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Write_Disable</span><span class="params">(<span class="keyword">void</span>)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	<span class="keyword">if</span>(NORFLASH_QPI_MODE)</span><br><span class="line">        QSPI_Send_CMD(W25X_WriteDisable,<span class="number">0</span>,(<span class="number">0</span>&lt;&lt;<span class="number">6</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">    	<span class="comment">//QPI,写禁止指令,地址为0,无数据_8位地址_无地址_4线传输指令,无空周期,0个字节数据</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        QSPI_Send_CMD(W25X_WriteDisable,<span class="number">0</span>,(<span class="number">0</span>&lt;&lt;<span class="number">6</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">    	<span class="comment">//SPI,写禁止指令,地址为0,无数据_8位地址_无地址_单线传输指令,无空周期,0个字节数据 </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值如下:				   </span></span><br><span class="line"><span class="comment">//0XEF13,表示芯片型号为W25Q80  </span></span><br><span class="line"><span class="comment">//0XEF14,表示芯片型号为W25Q16    </span></span><br><span class="line"><span class="comment">//0XEF15,表示芯片型号为W25Q32  </span></span><br><span class="line"><span class="comment">//0XEF16,表示芯片型号为W25Q64 </span></span><br><span class="line"><span class="comment">//0XEF17,表示芯片型号为W25Q128 	  </span></span><br><span class="line"><span class="comment">//0XEF18,表示芯片型号为W25Q256</span></span><br><span class="line"><span class="function">u16 <span class="title">NORFLASH_ReadID</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 temp[<span class="number">2</span>];</span><br><span class="line">	u16 deviceid;</span><br><span class="line">	<span class="keyword">if</span>(NORFLASH_QPI_MODE)</span><br><span class="line">        QSPI_Send_CMD(W25X_ManufactDeviceID,<span class="number">0</span>,(<span class="number">3</span>&lt;&lt;<span class="number">6</span>)|(<span class="number">2</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">    	<span class="comment">//QPI,读id,地址为0,4线传输数据_24位地址_4线传输地址_4线传输指令,无空周期,2个字节数据</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        QSPI_Send_CMD(W25X_ManufactDeviceID,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;<span class="number">6</span>)|(<span class="number">2</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">    	<span class="comment">//SPI,读id,地址为0,单线传输数据_24位地址_单线传输地址_单线传输指令,无空周期,2个字节数据</span></span><br><span class="line">	QSPI_Receive(temp,<span class="number">2</span>);</span><br><span class="line">	deviceid=(temp[<span class="number">0</span>]&lt;&lt;<span class="number">8</span>)|temp[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> deviceid;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">//读取SPI FLASH,仅支持QSPI模式</span></span><br><span class="line"><span class="comment">//在指定地址开始读取指定长度的数据</span></span><br><span class="line"><span class="comment">//pBuffer:数据存储区</span></span><br><span class="line"><span class="comment">//ReadAddr:开始读取的地址(最大32bit)</span></span><br><span class="line"><span class="comment">//NumByteToRead:要读取的字节数(最大65535)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Read</span><span class="params">(u8* pBuffer,u32 ReadAddr,u16 NumByteToRead)</span>   </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	QSPI_Send_CMD(W25X_FastReadData,ReadAddr,(<span class="number">3</span>&lt;&lt;<span class="number">6</span>)|(<span class="number">2</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">0</span>),<span class="number">8</span>);</span><br><span class="line">    <span class="comment">//QPI,快速读数据,地址为ReadAddr,4线传输数据_24位地址_4线传输地址_4线传输指令,8空周期,NumByteToRead个数据</span></span><br><span class="line">	QSPI_Receive(pBuffer,NumByteToRead); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SPI在一页(0~65535)内写入少于256个字节的数据</span></span><br><span class="line"><span class="comment">//在指定地址开始写入最大256字节的数据</span></span><br><span class="line"><span class="comment">//pBuffer:数据存储区</span></span><br><span class="line"><span class="comment">//WriteAddr:开始写入的地址(最大32bit)</span></span><br><span class="line"><span class="comment">//NumByteToWrite:要写入的字节数(最大256),该数不应该超过该页的剩余字节数!!!	 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Write_Page</span><span class="params">(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	NORFLASH_Write_Enable();<span class="comment">//写使能</span></span><br><span class="line">	QSPI_Send_CMD(W25X_PageProgram,WriteAddr,(<span class="number">3</span>&lt;&lt;<span class="number">6</span>)|(<span class="number">2</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//QPI,页写指令,地址为WriteAddr,4线传输数据_24位地址_4线传输地址_4线传输指令,无空周期,NumByteToWrite个数据</span></span><br><span class="line">	QSPI_Transmit(pBuffer,NumByteToWrite);</span><br><span class="line">	NORFLASH_Wait_Busy();<span class="comment">//等待写入结束</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//无检验写SPI FLASH</span></span><br><span class="line"><span class="comment">//必须确保所写的地址范围内的数据全部为0XFF,否则在非0XFF处写入的数据将失败!</span></span><br><span class="line"><span class="comment">//具有自动换页功能</span></span><br><span class="line"><span class="comment">//在指定地址开始写入指定长度的数据,但是要确保地址不越界!</span></span><br><span class="line"><span class="comment">//pBuffer:数据存储区</span></span><br><span class="line"><span class="comment">//WriteAddr:开始写入的地址(最大32bit)</span></span><br><span class="line"><span class="comment">//NumByteToWrite:要写入的字节数(最大65535)</span></span><br><span class="line"><span class="comment">//CHECK OK</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Write_NoCheck</span><span class="params">(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)</span>   </span></span><br><span class="line"><span class="function"></span>&#123; 			 		 </span><br><span class="line">	u16 pageremain;	   </span><br><span class="line">	pageremain=<span class="number">256</span>-WriteAddr%<span class="number">256</span>;<span class="comment">//单页剩余的字节数		 	    </span></span><br><span class="line">	<span class="keyword">if</span>(NumByteToWrite&lt;=pageremain)pageremain=NumByteToWrite;<span class="comment">//不大于256个字节</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;	   </span><br><span class="line">		NORFLASH_Write_Page(pBuffer,WriteAddr,pageremain);</span><br><span class="line">		<span class="keyword">if</span>(NumByteToWrite==pageremain)</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//写入结束</span></span><br><span class="line">	 	<span class="keyword">else</span><span class="comment">//NumByteToWrite&gt;pageremain</span></span><br><span class="line">		&#123;</span><br><span class="line">			pBuffer+=pageremain;</span><br><span class="line">			WriteAddr+=pageremain;	</span><br><span class="line"></span><br><span class="line">			NumByteToWrite-=pageremain;<span class="comment">//减去已经写入了的字节数</span></span><br><span class="line">			<span class="keyword">if</span>(NumByteToWrite&gt;<span class="number">256</span>)</span><br><span class="line">                pageremain=<span class="number">256</span>;<span class="comment">//一次可以写入256个字节</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">                pageremain=NumByteToWrite;<span class="comment">//不够256个字节了</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;   </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//写SPI FLASH</span></span><br><span class="line"><span class="comment">//在指定地址开始写入指定长度的数据</span></span><br><span class="line"><span class="comment">//该函数带擦除操作!</span></span><br><span class="line"><span class="comment">//pBuffer:数据存储区</span></span><br><span class="line"><span class="comment">//WriteAddr:开始写入的地址(最大32bit)</span></span><br><span class="line"><span class="comment">//NumByteToWrite:要写入的字节数(最大65535)</span></span><br><span class="line">u8 NORFLASH_BUFFER[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Write</span><span class="params">(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)</span>   </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	u32 secpos;</span><br><span class="line">	u16 secoff;</span><br><span class="line">	u16 secremain;</span><br><span class="line"> 	u16 i;</span><br><span class="line">	u8 * NORFLASH_BUF;</span><br><span class="line"></span><br><span class="line">	NORFLASH_BUF=NORFLASH_BUFFER;</span><br><span class="line"> 	secpos=WriteAddr/<span class="number">4096</span>;<span class="comment">//扇区基地址</span></span><br><span class="line">	secoff=WriteAddr%<span class="number">4096</span>;<span class="comment">//偏移地址</span></span><br><span class="line">	secremain=<span class="number">4096</span>-secoff;<span class="comment">//扇区剩余空间大小</span></span><br><span class="line">    </span><br><span class="line"> 	<span class="comment">//printf(&quot;ad:%X,nb:%X\r\n&quot;,WriteAddr,NumByteToWrite);//测试用</span></span><br><span class="line"> 	<span class="keyword">if</span>(NumByteToWrite&lt;=secremain)</span><br><span class="line">        secremain=NumByteToWrite;<span class="comment">//如果待写入字节不大于4096个字节，将待写入大小限制为一个块大小</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		NORFLASH_Read(NORFLASH_BUF,secpos*<span class="number">4096</span>,<span class="number">4096</span>);<span class="comment">//读出整个扇区的内容</span></span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;secremain;i++)<span class="comment">//校验数据</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(NORFLASH_BUF[secoff+i]!=<span class="number">0XFF</span>)<span class="comment">//如果存在非空区域</span></span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//需要擦除</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;secremain)<span class="comment">//如果待写入字节小于剩余空间，需要擦除</span></span><br><span class="line">		&#123;</span><br><span class="line">			NORFLASH_Erase_Sector(secpos);<span class="comment">//擦除这个扇区</span></span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;secremain;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				NORFLASH_BUF[i+secoff]=pBuffer[i];<span class="comment">//将写入内容复制到FLASH	  </span></span><br><span class="line">			&#125;</span><br><span class="line">			NORFLASH_Write_NoCheck(NORFLASH_BUF,secpos*<span class="number">4096</span>,<span class="number">4096</span>);<span class="comment">//写入整个扇区   </span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//如果不需要擦除</span></span><br><span class="line">            NORFLASH_Write_NoCheck(pBuffer,WriteAddr,secremain);<span class="comment">//直接写入扇区剩余空区间</span></span><br><span class="line">        </span><br><span class="line">		<span class="keyword">if</span>(NumByteToWrite==secremain)</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//写入结束</span></span><br><span class="line">		<span class="keyword">else</span><span class="comment">//写入未结束，接着写下一个扇区</span></span><br><span class="line">		&#123;</span><br><span class="line">			secpos++;<span class="comment">//扇区地址增1</span></span><br><span class="line">			secoff=<span class="number">0</span>;<span class="comment">//偏移位置为0 	 </span></span><br><span class="line"></span><br><span class="line">			pBuffer+=secremain;<span class="comment">//指针偏移</span></span><br><span class="line">			WriteAddr+=secremain;<span class="comment">//写地址偏移</span></span><br><span class="line">			NumByteToWrite-=secremain;<span class="comment">//字节数递减</span></span><br><span class="line">			<span class="keyword">if</span>(NumByteToWrite&gt;<span class="number">4096</span>)</span><br><span class="line">                secremain=<span class="number">4096</span>;<span class="comment">//下一个扇区还是写不完</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">                secremain=NumByteToWrite;<span class="comment">//下一个扇区可以写完了</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全片擦除</span></span><br><span class="line"><span class="comment">//等待时间会很长</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Erase_Chip</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	NORFLASH_Write_Enable();<span class="comment">//WEL置位</span></span><br><span class="line">	NORFLASH_Wait_Busy();</span><br><span class="line">	QSPI_Send_CMD(W25X_ChipErase,<span class="number">0</span>,(<span class="number">0</span>&lt;&lt;<span class="number">6</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//QPI,写全片擦除指令,地址为0,无数据_8位地址_无地址_4线传输指令,无空周期,0个字节数据</span></span><br><span class="line">	NORFLASH_Wait_Busy();<span class="comment">//等待芯片擦除结束</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//擦除一个扇区</span></span><br><span class="line"><span class="comment">//Dst_Addr:扇区地址 根据实际容量设置</span></span><br><span class="line"><span class="comment">//擦除一个扇区的最少时间:150ms</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Erase_Sector</span><span class="params">(u32 Dst_Addr)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//printf(&quot;fe:%x\r\n&quot;,Dst_Addr);//监视falsh擦除情况,测试用  	  </span></span><br><span class="line">	Dst_Addr*=<span class="number">4096</span>;</span><br><span class="line">	NORFLASH_Write_Enable();<span class="comment">//WEL置位</span></span><br><span class="line">	NORFLASH_Wait_Busy();</span><br><span class="line">	QSPI_Send_CMD(W25X_SectorErase,Dst_Addr,(<span class="number">0</span>&lt;&lt;<span class="number">6</span>)|(<span class="number">2</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//QPI,写扇区擦除指令,地址为0,无数据_24位地址_4线传输地址_4线传输指令,无空周期,0个字节数据</span></span><br><span class="line">	NORFLASH_Wait_Busy();<span class="comment">//等待擦除完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待空闲</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Wait_Busy</span><span class="params">(<span class="keyword">void</span>)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>((NORFLASH_ReadSR(<span class="number">1</span>)&amp;<span class="number">0x01</span>)==<span class="number">0x01</span>);	<span class="comment">// 等待BUSY位清空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置QSPI</li>
</ol>
<p>这里写的驱动代码是纯HAL库函数实现，外设IC是W25Q64 8MB大小</p>
<p>w25q64.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> w25q64_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> w25q64_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stm32h7xx_hal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------------------------------------------- 命名参数宏 -------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QSPI_W25Qxx_OK           		0			<span class="comment">// W25Qxx通信正常</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_ERROR_INIT         		-1			<span class="comment">// 初始化错误</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_ERROR_WriteEnable       -2			<span class="comment">// 写使能错误</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_ERROR_AUTOPOLLING       -3			<span class="comment">// 轮询等待错误，无响应</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_ERROR_Erase         		-4			<span class="comment">// 擦除错误</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_ERROR_TRANSMIT         	-5			<span class="comment">// 传输错误</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_ERROR_MemoryMapped		-6    		<span class="comment">// 内存映射模式错误</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_CMD_EnableReset  		0x66		<span class="comment">// 使能复位</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_CMD_ResetDevice   		0x99		<span class="comment">// 复位器件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_CMD_JedecID 				0x9F		<span class="comment">// JEDEC ID  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_CMD_WriteEnable			0X06		<span class="comment">// 写使能</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_CMD_SectorErase 			0x20		<span class="comment">// 扇区擦除，4K字节， 参考擦除时间 45ms</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_CMD_BlockErase_32K 		0x52		<span class="comment">// 块擦除，  32K字节，参考擦除时间 120ms</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_CMD_BlockErase_64K 		0xD8		<span class="comment">// 块擦除，  64K字节，参考擦除时间 150ms</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_CMD_ChipErase 			0xC7		<span class="comment">// 整片擦除，参考擦除时间 20S</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_CMD_QuadInputPageProgram  	0x32  	<span class="comment">// 1-1-4模式下(1线指令1线地址4线数据)，页编程指令，参考写入时间 0.4ms </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_CMD_FastReadQuad_IO       	0xEB  	<span class="comment">// 1-4-4模式下(1线指令4线地址4线数据)，快速读取指令</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_CMD_ReadStatus_REG1			0X05	<span class="comment">// 读状态寄存器1</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_Status_REG1_BUSY  			0x01	<span class="comment">// 读状态寄存器1的第0位（只读），Busy标志位，当正在擦除/写入数据/写命令时会被置1</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_Status_REG1_WEL  			0x02	<span class="comment">// 读状态寄存器1的第1位（只读），WEL写使能标志位，该标志位为1时，代表可以进行写操作</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_PageSize       				256			<span class="comment">// 页大小，256字节</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_FlashSize       				0x800000	<span class="comment">// W25Q64大小，8M字节</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_FLASH_ID           			0Xef4017    <span class="comment">// W25Q64 JEDEC ID</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_ChipErase_TIMEOUT_MAX		100000U		<span class="comment">// 超时等待时间，W25Q64整片擦除所需最大时间是100S</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_Mem_Addr						0x90000000 	<span class="comment">// 内存映射模式的地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------------------------------------------- 引脚配置宏 ------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUADSPI_CLK_PIN				GPIO_PIN_2						<span class="comment">// QUADSPI_CLK 引脚</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	QUADSPI_CLK_PORT			GPIOB							<span class="comment">// QUADSPI_CLK 引脚端口</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	QUADSPI_CLK_AF				GPIO_AF9_QUADSPI				<span class="comment">// QUADSPI_CLK IO口复用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_QUADSPI_CLK_ENABLE     __HAL_RCC_GPIOB_CLK_ENABLE()	<span class="comment">// QUADSPI_CLK 引脚时钟使能</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUADSPI_BK1_NCS_PIN			GPIO_PIN_6						<span class="comment">// QUADSPI_BK1_NCS 引脚</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	QUADSPI_BK1_NCS_PORT		GPIOB							<span class="comment">// QUADSPI_BK1_NCS 引脚端口</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	QUADSPI_BK1_NCS_AF			GPIO_AF10_QUADSPI				<span class="comment">// QUADSPI_BK1_NCS IO口复用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_QUADSPI_BK1_NCS_ENABLE __HAL_RCC_GPIOB_CLK_ENABLE()	<span class="comment">// QUADSPI_BK1_NCS 引脚时钟使能</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUADSPI_BK1_IO0_PIN			GPIO_PIN_11						<span class="comment">// QUADSPI_BK1_IO0 引脚</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	QUADSPI_BK1_IO0_PORT		GPIOD							<span class="comment">// QUADSPI_BK1_IO0 引脚端口</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	QUADSPI_BK1_IO0_AF			GPIO_AF9_QUADSPI				<span class="comment">// QUADSPI_BK1_IO0 IO口复用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_QUADSPI_BK1_IO0_ENABLE __HAL_RCC_GPIOD_CLK_ENABLE()	<span class="comment">// QUADSPI_BK1_IO0 引脚时钟使能</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUADSPI_BK1_IO1_PIN			GPIO_PIN_2						<span class="comment">// QUADSPI_BK1_IO1 引脚</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	QUADSPI_BK1_IO1_PORT		GPIOE							<span class="comment">// QUADSPI_BK1_IO1 引脚端口</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	QUADSPI_BK1_IO1_AF			GPIO_AF9_QUADSPI				<span class="comment">// QUADSPI_BK1_IO1 IO口复用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_QUADSPI_BK1_IO1_ENABLE __HAL_RCC_GPIOE_CLK_ENABLE()	<span class="comment">// QUADSPI_BK1_IO1 引脚时钟使能</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUADSPI_BK1_IO2_PIN			GPIO_PIN_12						<span class="comment">// QUADSPI_BK1_IO2 引脚</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	QUADSPI_BK1_IO2_PORT		GPIOD							<span class="comment">// QUADSPI_BK1_IO2 引脚端口</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	QUADSPI_BK1_IO2_AF			GPIO_AF9_QUADSPI				<span class="comment">// QUADSPI_BK1_IO2 IO口复用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_QUADSPI_BK1_IO2_ENABLE __HAL_RCC_GPIOD_CLK_ENABLE()	<span class="comment">// QUADSPI_BK1_IO2 引脚时钟使能</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUADSPI_BK1_IO3_PIN			GPIO_PIN_13						<span class="comment">// QUADSPI_BK1_IO3 引脚</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	QUADSPI_BK1_IO3_PORT		GPIOD							<span class="comment">// QUADSPI_BK1_IO3 引脚端口</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	QUADSPI_BK1_IO3_AF			GPIO_AF9_QUADSPI				<span class="comment">// QUADSPI_BK1_IO3 IO口复用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_QUADSPI_BK1_IO3_ENABLE __HAL_RCC_GPIOD_CLK_ENABLE()	<span class="comment">// QUADSPI_BK1_IO3 引脚时钟使能</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------------------------------------------- 函数声明 --------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span>	<span class="title">QSPI_W25Qxx_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;						<span class="comment">// W25Qxx初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> 	<span class="title">QSPI_W25Qxx_Reset</span><span class="params">(<span class="keyword">void</span>)</span></span>;					<span class="comment">// 复位器件</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">QSPI_W25Qxx_ReadID</span><span class="params">(<span class="keyword">void</span>)</span></span>;					<span class="comment">// 读取器件ID</span></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> 	<span class="title">QSPI_W25Qxx_MemoryMappedMode</span><span class="params">(<span class="keyword">void</span>)</span></span>;			<span class="comment">// 进入内存映射模式</span></span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> 	<span class="title">QSPI_W25Qxx_SectorErase</span><span class="params">(<span class="keyword">uint32_t</span> SectorAddress)</span></span>;		<span class="comment">// 扇区擦除，4K字节，参考擦除时间 45ms</span></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> 	<span class="title">QSPI_W25Qxx_BlockErase_32K</span> <span class="params">(<span class="keyword">uint32_t</span> SectorAddress)</span></span>;	<span class="comment">// 块擦除，32K字节，参考擦除时间 120ms</span></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> 	<span class="title">QSPI_W25Qxx_BlockErase_64K</span> <span class="params">(<span class="keyword">uint32_t</span> SectorAddress)</span></span>;	<span class="comment">// 块擦除，64K字节，参考擦除时间 150ms，实际使用建议使用64K擦除，擦除的时间最快</span></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> 	<span class="title">QSPI_W25Qxx_ChipErase</span> <span class="params">(<span class="keyword">void</span>)</span></span>;                         	<span class="comment">// 整片擦除，参考擦除时间 20S</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按页写入，最大256字节</span></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span>	<span class="title">QSPI_W25Qxx_WritePage</span><span class="params">(<span class="keyword">uint8_t</span>* pBuffer, <span class="keyword">uint32_t</span> WriteAddr, <span class="keyword">uint16_t</span> NumByteToWrite)</span></span>;</span><br><span class="line"><span class="comment">// 写入数据，最大不能超过flash芯片的大小</span></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span>	<span class="title">QSPI_W25Qxx_WriteBuffer</span><span class="params">(<span class="keyword">uint8_t</span>* pData, <span class="keyword">uint32_t</span> WriteAddr, <span class="keyword">uint32_t</span> Size)</span></span>;</span><br><span class="line"><span class="comment">// 读取数据，最大不能超过flash芯片的大小</span></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> 	<span class="title">QSPI_W25Qxx_ReadBuffer</span><span class="params">(<span class="keyword">uint8_t</span>* pBuffer, <span class="keyword">uint32_t</span> ReadAddr, <span class="keyword">uint32_t</span> NumByteToRead)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>w25q64.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;w25q64.h&quot;</span></span></span><br><span class="line">QSPI_HandleTypeDef hqspi;<span class="comment">//定义QSPI句柄，这里保留使用cubeMX生成的变量命名，方便用户参考和移植</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* QSPI初始化 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_QSPI_MspInit</span><span class="params">(QSPI_HandleTypeDef* hqspi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">if</span>(hqspi-&gt;Instance==QUADSPI)</span><br><span class="line">	&#123;</span><br><span class="line">		__HAL_RCC_QSPI_CLK_ENABLE();	<span class="comment">// 使能QSPI时钟</span></span><br><span class="line"></span><br><span class="line">		GPIO_QUADSPI_CLK_ENABLE;		<span class="comment">// 使能 QUADSPI_CLK IO口时钟</span></span><br><span class="line">		GPIO_QUADSPI_BK1_NCS_ENABLE;	<span class="comment">// 使能 QUADSPI_BK1_NCS IO口时钟</span></span><br><span class="line">		GPIO_QUADSPI_BK1_IO0_ENABLE;	<span class="comment">// 使能 QUADSPI_BK1_IO0 IO口时钟</span></span><br><span class="line">		GPIO_QUADSPI_BK1_IO1_ENABLE;	<span class="comment">// 使能 QUADSPI_BK1_IO1 IO口时钟</span></span><br><span class="line">		GPIO_QUADSPI_BK1_IO2_ENABLE;	<span class="comment">// 使能 QUADSPI_BK1_IO2 IO口时钟</span></span><br><span class="line">		GPIO_QUADSPI_BK1_IO3_ENABLE;	<span class="comment">// 使能 QUADSPI_BK1_IO3 IO口时钟</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">/******************************************************  </span></span><br><span class="line"><span class="comment">		PB2     ------&gt; QUADSPI_CLK	</span></span><br><span class="line"><span class="comment">		PB6     ------&gt; QUADSPI_BK1_NCS 		</span></span><br><span class="line"><span class="comment">		PD11    ------&gt; QUADSPI_BK1_IO0</span></span><br><span class="line"><span class="comment">		PD12    ------&gt; QUADSPI_BK1_IO1		</span></span><br><span class="line"><span class="comment">		PE2     ------&gt; QUADSPI_BK1_IO2	</span></span><br><span class="line"><span class="comment">		PD13    ------&gt; QUADSPI_BK1_IO3</span></span><br><span class="line"><span class="comment">		*******************************************************/</span></span><br><span class="line">		</span><br><span class="line">		GPIO_InitStruct.Mode 		= GPIO_MODE_AF_PP;				<span class="comment">// 复用推挽输出模式</span></span><br><span class="line">		GPIO_InitStruct.Pull 		= GPIO_NOPULL;					<span class="comment">// 无上下拉</span></span><br><span class="line">		GPIO_InitStruct.Speed 		= GPIO_SPEED_FREQ_VERY_HIGH;	<span class="comment">// 超高速IO口速度</span></span><br><span class="line">		</span><br><span class="line">		GPIO_InitStruct.Pin 			= QUADSPI_CLK_PIN;			<span class="comment">// QUADSPI_CLK 引脚</span></span><br><span class="line">		GPIO_InitStruct.Alternate 	= QUADSPI_CLK_AF;				<span class="comment">// QUADSPI_CLK 复用</span></span><br><span class="line">		HAL_GPIO_Init(QUADSPI_CLK_PORT, &amp;GPIO_InitStruct);			<span class="comment">// 初始化 QUADSPI_CLK 引脚</span></span><br><span class="line"></span><br><span class="line">		GPIO_InitStruct.Pin 			= QUADSPI_BK1_NCS_PIN;		<span class="comment">// QUADSPI_BK1_NCS 引脚</span></span><br><span class="line">		GPIO_InitStruct.Alternate 	= QUADSPI_BK1_NCS_AF;			<span class="comment">// QUADSPI_BK1_NCS 复用</span></span><br><span class="line">		HAL_GPIO_Init(QUADSPI_BK1_NCS_PORT, &amp;GPIO_InitStruct);   	<span class="comment">// 初始化 QUADSPI_BK1_NCS 引脚</span></span><br><span class="line">		</span><br><span class="line">		GPIO_InitStruct.Pin 			= QUADSPI_BK1_IO0_PIN;		<span class="comment">// QUADSPI_BK1_IO0 引脚</span></span><br><span class="line">		GPIO_InitStruct.Alternate 	= QUADSPI_BK1_IO0_AF;			<span class="comment">// QUADSPI_BK1_IO0 复用</span></span><br><span class="line">		HAL_GPIO_Init(QUADSPI_BK1_IO0_PORT, &amp;GPIO_InitStruct);		<span class="comment">// 初始化 QUADSPI_BK1_IO0 引脚	</span></span><br><span class="line">		</span><br><span class="line">		GPIO_InitStruct.Pin 			= QUADSPI_BK1_IO1_PIN;		<span class="comment">// QUADSPI_BK1_IO1 引脚</span></span><br><span class="line">		GPIO_InitStruct.Alternate 	= QUADSPI_BK1_IO1_AF;			<span class="comment">// QUADSPI_BK1_IO1 复用</span></span><br><span class="line">		HAL_GPIO_Init(QUADSPI_BK1_IO1_PORT, &amp;GPIO_InitStruct);   	<span class="comment">// 初始化 QUADSPI_BK1_IO1 引脚</span></span><br><span class="line">		</span><br><span class="line">		GPIO_InitStruct.Pin 			= QUADSPI_BK1_IO2_PIN;		<span class="comment">// QUADSPI_BK1_IO2 引脚</span></span><br><span class="line">		GPIO_InitStruct.Alternate 	= QUADSPI_BK1_IO2_AF;			<span class="comment">// QUADSPI_BK1_IO2 复用</span></span><br><span class="line">		HAL_GPIO_Init(QUADSPI_BK1_IO2_PORT, &amp;GPIO_InitStruct);		<span class="comment">// 初始化 QUADSPI_BK1_IO2 引脚</span></span><br><span class="line">		</span><br><span class="line">		GPIO_InitStruct.Pin 			= QUADSPI_BK1_IO3_PIN;		<span class="comment">// QUADSPI_BK1_IO3 引脚</span></span><br><span class="line">		GPIO_InitStruct.Alternate 	= QUADSPI_BK1_IO3_AF;			<span class="comment">// QUADSPI_BK1_IO3 复用</span></span><br><span class="line">		HAL_GPIO_Init(QUADSPI_BK1_IO3_PORT, &amp;GPIO_InitStruct);		<span class="comment">// 初始化 QUADSPI_BK1_IO3 引脚</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MX_QUADSPI_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	hqspi.Instance 					= QUADSPI;									<span class="comment">// QSPI外设</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* QSPI的内核时钟设置为PLL2CLK，速度250M，经过2分频得到125M驱动时钟 */</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 当使用内存映射模式时,这里的分频系数不能设置为0,否则会读取错误</span></span><br><span class="line">	hqspi.Init.ClockPrescaler= <span class="number">1</span>;<span class="comment">// 时钟分频值，将QSPI内核时钟进行 1+1 分频得到QSPI通信驱动时钟</span></span><br><span class="line">	hqspi.Init.FifoThreshold= <span class="number">32</span>;<span class="comment">// FIFO阈值</span></span><br><span class="line">	hqspi.Init.SampleShifting= QSPI_SAMPLE_SHIFTING_HALFCYCLE;<span class="comment">// 半个CLK周期之后进行采样</span></span><br><span class="line">	hqspi.Init.FlashSize= <span class="number">22</span>;<span class="comment">// flash大小，FLASH 中的字节数=2^[FSIZE+1]，对于8MB的W25Q64设置为22</span></span><br><span class="line">	hqspi.Init.ChipSelectHighTime=QSPI_CS_HIGH_TIME_1_CYCLE;<span class="comment">// 片选保持高电平的时间</span></span><br><span class="line">	hqspi.Init.ClockMode=QSPI_CLOCK_MODE_3;<span class="comment">// 模式3</span></span><br><span class="line">	hqspi.Init.FlashID=QSPI_FLASH_ID_1;<span class="comment">// 使用QSPI1</span></span><br><span class="line">	hqspi.Init.DualFlash=QSPI_DUALFLASH_DISABLE;<span class="comment">// 关闭双闪存模式</span></span><br><span class="line">	<span class="comment">// 应用配置</span></span><br><span class="line">	HAL_QSPI_Init(&amp;hqspi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检查W25Q64 */</span></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> <span class="title">QSPI_W25Qxx_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> Device_ID;</span><br><span class="line">	</span><br><span class="line">	MX_QUADSPI_Init();<span class="comment">//初始化QSPI</span></span><br><span class="line">	QSPI_W25Qxx_Reset();<span class="comment">//复位</span></span><br><span class="line">	Device_ID = QSPI_W25Qxx_ReadID();<span class="comment">//读取ID</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(Device_ID == W25Qxx_FLASH_ID )<span class="comment">//检查外设器件</span></span><br><span class="line">	&#123;</span><br><span class="line">		STM_printf (<span class="string">&quot;W25Q64 OK,flash ID:%X\r\n&quot;</span>,Device_ID);<span class="comment">//初始化成功，打印debug信息</span></span><br><span class="line">		<span class="keyword">return</span> QSPI_W25Qxx_OK;<span class="comment">//返回成功标志		</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		STM_printf (<span class="string">&quot;W25Q64 ERROR!!!!!  ID:%X\r\n&quot;</span>,Device_ID);<span class="comment">//初始化失败	</span></span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_INIT;<span class="comment">//返回错误标志</span></span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//轮询确认FLASH是否空闲（用于等待通讯结束等）</span></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> <span class="title">QSPI_W25Qxx_AutoPollingMemReady</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QSPI_CommandTypeDef     s_command;	   						<span class="comment">// 	QSPI传输配置</span></span><br><span class="line">	QSPI_AutoPollingTypeDef s_config;							<span class="comment">// 	轮询比较相关配置参数</span></span><br><span class="line"></span><br><span class="line">	s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;		<span class="comment">// 	1线指令模式</span></span><br><span class="line">	s_command.AddressMode       = QSPI_ADDRESS_NONE;			<span class="comment">// 	无地址模式</span></span><br><span class="line">	s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;	<span class="comment">//	无交替字节 </span></span><br><span class="line">	s_command.DdrMode           = QSPI_DDR_MODE_DISABLE;	    <span class="comment">// 	禁止DDR模式</span></span><br><span class="line">	s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;	<span class="comment">// 	DDR模式中数据延迟，这里用不到</span></span><br><span class="line">	s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;	   	<span class="comment">//	每次传输数据都发送指令	</span></span><br><span class="line">	s_command.DataMode          = QSPI_DATA_1_LINE;				<span class="comment">// 	1线数据模式</span></span><br><span class="line">	s_command.DummyCycles       = <span class="number">0</span>;							<span class="comment">//	空周期个数</span></span><br><span class="line">	s_command.Instruction       = W25Qxx_CMD_ReadStatus_REG1;	<span class="comment">// 	读状态信息寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不停查询 W25Qxx_CMD_ReadStatus_REG1 寄存器，将读取到的状态字节中的 W25Qxx_Status_REG1_BUSY 与0作比较</span></span><br><span class="line"><span class="comment">// 读状态寄存器1的第0位（只读），Busy标志位，当正在擦除/写入数据/写命令时会被置1，空闲或通信结束为0</span></span><br><span class="line">    s_config.Match           = <span class="number">0</span>;   							<span class="comment">//	匹配值</span></span><br><span class="line">	s_config.MatchMode       = QSPI_MATCH_MODE_AND;	      		<span class="comment">//	与运算</span></span><br><span class="line">	s_config.Interval        = <span class="number">0x10</span>;	                     	<span class="comment">//	轮询间隔</span></span><br><span class="line">	s_config.AutomaticStop   = QSPI_AUTOMATIC_STOP_ENABLE;		<span class="comment">// 自动停止模式</span></span><br><span class="line">	s_config.StatusBytesSize = <span class="number">1</span>;	                        	<span class="comment">//	状态字节数</span></span><br><span class="line">	s_config.Mask=W25Qxx_Status_REG1_BUSY;<span class="comment">//对在轮询模式下接收的状态字节进行屏蔽，只比较需要用到的位</span></span><br><span class="line">		</span><br><span class="line">	<span class="comment">// 发送轮询等待命令</span></span><br><span class="line">	<span class="keyword">if</span> (HAL_QSPI_AutoPolling(&amp;hqspi, &amp;s_command, &amp;s_config, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_AUTOPOLLING; <span class="comment">// 轮询等待无响应</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> QSPI_W25Qxx_OK; <span class="comment">// 通信正常结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FLASH软件复位</span></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> <span class="title">QSPI_W25Qxx_Reset</span><span class="params">(<span class="keyword">void</span>)</span>	</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QSPI_CommandTypeDef s_command;<span class="comment">// QSPI传输配置</span></span><br><span class="line"></span><br><span class="line">	s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;   	<span class="comment">// 1线指令模式</span></span><br><span class="line">	s_command.AddressMode 		= QSPI_ADDRESS_NONE;   			<span class="comment">// 无地址模式</span></span><br><span class="line">	s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE; 	<span class="comment">// 无交替字节 </span></span><br><span class="line">	s_command.DdrMode           = QSPI_DDR_MODE_DISABLE;     	<span class="comment">// 禁止DDR模式</span></span><br><span class="line">	s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY; 	<span class="comment">// DDR模式中数据延迟，这里用不到</span></span><br><span class="line">	s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;	 	<span class="comment">// 每次传输数据都发送指令</span></span><br><span class="line">	s_command.DataMode 			= QSPI_DATA_NONE;       		<span class="comment">// 无数据模式	</span></span><br><span class="line">	s_command.DummyCycles 		= <span class="number">0</span>;                     		<span class="comment">// 空周期个数</span></span><br><span class="line">	s_command.Instruction 		= W25Qxx_CMD_EnableReset;       <span class="comment">// 执行复位使能命令</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发送复位使能命令</span></span><br><span class="line">	<span class="keyword">if</span> (HAL_QSPI_Command(&amp;hqspi, &amp;s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) </span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_INIT;<span class="comment">//如果发送失败，返回错误信息</span></span><br><span class="line">	<span class="comment">// 使用自动轮询标志位，等待通信结束</span></span><br><span class="line">	<span class="keyword">if</span> (QSPI_W25Qxx_AutoPollingMemReady() != QSPI_W25Qxx_OK)</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_AUTOPOLLING;<span class="comment">// 轮询等待无响应</span></span><br><span class="line"></span><br><span class="line">	s_command.Instruction  = W25Qxx_CMD_ResetDevice;<span class="comment">//复位器件命令    </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//发送复位器件命令</span></span><br><span class="line">	<span class="keyword">if</span> (HAL_QSPI_Command(&amp;hqspi, &amp;s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) </span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_INIT;<span class="comment">// 如果发送失败，返回错误信息</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 使用自动轮询标志位，等待通信结束</span></span><br><span class="line">	<span class="keyword">if</span> (QSPI_W25Qxx_AutoPollingMemReady() != QSPI_W25Qxx_OK)</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_AUTOPOLLING;<span class="comment">// 轮询等待无响应</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> QSPI_W25Qxx_OK;<span class="comment">// 复位成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">QSPI_W25Qxx_ReadID</span><span class="params">(<span class="keyword">void</span>)</span>	</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QSPI_CommandTypeDef s_command;<span class="comment">// QSPI传输配置</span></span><br><span class="line">	<span class="keyword">uint8_t</span>	QSPI_ReceiveBuff[<span class="number">3</span>];<span class="comment">// 存储QSPI读到的数据</span></span><br><span class="line">	<span class="keyword">uint32_t</span> W25Qxx_ID;<span class="comment">// 器件的ID</span></span><br><span class="line"></span><br><span class="line">	s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;    	<span class="comment">// 1线指令模式</span></span><br><span class="line">	s_command.AddressSize       = QSPI_ADDRESS_24_BITS;     	<span class="comment">// 24位地址</span></span><br><span class="line">	s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;  	<span class="comment">// 无交替字节 </span></span><br><span class="line">	s_command.DdrMode           = QSPI_DDR_MODE_DISABLE;      	<span class="comment">// 禁止DDR模式</span></span><br><span class="line">	s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;  	<span class="comment">// DDR模式中数据延迟，这里用不到</span></span><br><span class="line">	s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;	 	<span class="comment">// 每次传输数据都发送指令</span></span><br><span class="line">	s_command.AddressMode		= QSPI_ADDRESS_NONE;   			<span class="comment">// 无地址模式</span></span><br><span class="line">	s_command.DataMode			= QSPI_DATA_1_LINE;       	 	<span class="comment">// 1线数据模式</span></span><br><span class="line">	s_command.DummyCycles 		= <span class="number">0</span>;                   			<span class="comment">// 空周期个数</span></span><br><span class="line">	s_command.NbData 			= <span class="number">3</span>;                       		<span class="comment">// 传输数据的长度</span></span><br><span class="line">	s_command.Instruction 		= W25Qxx_CMD_JedecID;         	<span class="comment">// 执行读器件ID命令</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发送指令</span></span><br><span class="line">	<span class="keyword">if</span> (HAL_QSPI_Command(&amp;hqspi, &amp;s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) </span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_INIT;<span class="comment">// 如果发送失败，返回错误信息</span></span><br><span class="line">	<span class="comment">// 接收数据</span></span><br><span class="line">	<span class="keyword">if</span> (HAL_QSPI_Receive(&amp;hqspi, QSPI_ReceiveBuff, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) </span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_TRANSMIT;<span class="comment">// 如果接收失败，返回错误信息</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 将得到的数据组合成ID</span></span><br><span class="line">	W25Qxx_ID = (QSPI_ReceiveBuff[<span class="number">0</span>] &lt;&lt; <span class="number">16</span>) | (QSPI_ReceiveBuff[<span class="number">1</span>] &lt;&lt; <span class="number">8</span> ) | QSPI_ReceiveBuff[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">return</span> W25Qxx_ID;<span class="comment">// 返回ID</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置QSPI为内存映射模式</span></span><br><span class="line"><span class="comment">//此模式为只读状态，无法写入</span></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> <span class="title">QSPI_W25Qxx_MemoryMappedMode</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QSPI_CommandTypeDef s_command;<span class="comment">// QSPI传输配置</span></span><br><span class="line">	QSPI_MemoryMappedTypeDef s_mem_mapped_cfg;<span class="comment">// 内存映射访问参数</span></span><br><span class="line"></span><br><span class="line">	s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;    		<span class="comment">// 1线指令模式</span></span><br><span class="line">	s_command.AddressSize       = QSPI_ADDRESS_24_BITS;            	<span class="comment">// 24位地址</span></span><br><span class="line">	s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;  		<span class="comment">// 无交替字节 </span></span><br><span class="line">	s_command.DdrMode           = QSPI_DDR_MODE_DISABLE;     		<span class="comment">// 禁止DDR模式</span></span><br><span class="line">	s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY; 		<span class="comment">// DDR模式中数据延迟，这里用不到</span></span><br><span class="line">	s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;			<span class="comment">// 每次传输数据都发送指令	</span></span><br><span class="line">	s_command.AddressMode 		= QSPI_ADDRESS_4_LINES; 			<span class="comment">// 4线地址模式</span></span><br><span class="line">	s_command.DataMode    		= QSPI_DATA_4_LINES;    			<span class="comment">// 4线数据模式</span></span><br><span class="line">	s_command.DummyCycles 		= <span class="number">6</span>;                    			<span class="comment">// 空周期个数</span></span><br><span class="line">	s_command.Instruction 		= W25Qxx_CMD_FastReadQuad_IO; 		<span class="comment">// 1-4-4模式下(1线指令4线地址4线数据)，快速读取指令</span></span><br><span class="line">	</span><br><span class="line">	s_mem_mapped_cfg.TimeOutActivation = QSPI_TIMEOUT_COUNTER_DISABLE; <span class="comment">// 禁用超时计数器, nCS 保持激活状态</span></span><br><span class="line">	s_mem_mapped_cfg.TimeOutPeriod     = <span class="number">0</span>;							   <span class="comment">// 超时判断周期</span></span><br><span class="line"></span><br><span class="line">	QSPI_W25Qxx_Reset();<span class="comment">// 复位W25Qxx</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (HAL_QSPI_MemoryMapped(&amp;hqspi, &amp;s_command, &amp;s_mem_mapped_cfg) != HAL_OK)<span class="comment">// 进行配置</span></span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_MemoryMapped;<span class="comment">// 设置内存映射模式错误</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> QSPI_W25Qxx_OK; <span class="comment">// 配置成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写使能</span></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> <span class="title">QSPI_W25Qxx_WriteEnable</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QSPI_CommandTypeDef     s_command;	   	<span class="comment">// QSPI传输配置</span></span><br><span class="line">	QSPI_AutoPollingTypeDef s_config;		<span class="comment">// 轮询比较相关配置参数</span></span><br><span class="line"></span><br><span class="line">	s_command.InstructionMode   	= QSPI_INSTRUCTION_1_LINE;    	<span class="comment">// 1线指令模式</span></span><br><span class="line">	s_command.AddressMode 			= QSPI_ADDRESS_NONE;   		    <span class="comment">// 无地址模式</span></span><br><span class="line">	s_command.AlternateByteMode 	= QSPI_ALTERNATE_BYTES_NONE;  	<span class="comment">// 无交替字节 </span></span><br><span class="line">	s_command.DdrMode           	= QSPI_DDR_MODE_DISABLE;      	<span class="comment">// 禁止DDR模式</span></span><br><span class="line">	s_command.DdrHoldHalfCycle  	= QSPI_DDR_HHC_ANALOG_DELAY;  	<span class="comment">// DDR模式中数据延迟，这里用不到</span></span><br><span class="line">	s_command.SIOOMode          	= QSPI_SIOO_INST_EVERY_CMD;		<span class="comment">// 每次传输数据都发送指令	</span></span><br><span class="line">	s_command.DataMode 				= QSPI_DATA_NONE;       	    <span class="comment">// 无数据模式</span></span><br><span class="line">	s_command.DummyCycles 			= <span class="number">0</span>;                   	        <span class="comment">// 空周期个数</span></span><br><span class="line">	s_command.Instruction	 		= W25Qxx_CMD_WriteEnable;      	<span class="comment">// 发送写使能命令</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发送写使能命令</span></span><br><span class="line">	<span class="keyword">if</span> (HAL_QSPI_Command(&amp;hqspi, &amp;s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) </span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_WriteEnable;</span><br><span class="line"><span class="comment">// 不停的查询W25Qxx_CMD_ReadStatus_REG1寄存器，将读取到的状态字节中的W25Qxx_Status_REG1_WEL与0x02作比较</span></span><br><span class="line"><span class="comment">// 读状态寄存器1的第1位（只读），WEL写使能标志位，该标志位为1时，代表可以进行写操作</span></span><br><span class="line">	</span><br><span class="line">	s_config.Match           = <span class="number">0x02</span>;  								<span class="comment">// 匹配值</span></span><br><span class="line">	s_config.Mask			 = W25Qxx_Status_REG1_WEL;				<span class="comment">// 读状态寄存器1的第1位（只读），WEL写使能标志位，该标志位为1时，代表可以进行写操作</span></span><br><span class="line">	s_config.MatchMode       = QSPI_MATCH_MODE_AND;			 		<span class="comment">// 与运算</span></span><br><span class="line">	s_config.StatusBytesSize = <span class="number">1</span>;									<span class="comment">// 状态字节数</span></span><br><span class="line">	s_config.Interval        = <span class="number">0x10</span>;							 	<span class="comment">// 轮询间隔</span></span><br><span class="line">	s_config.AutomaticStop   = QSPI_AUTOMATIC_STOP_ENABLE;			<span class="comment">// 自动停止模式</span></span><br><span class="line"></span><br><span class="line">	s_command.Instruction    = W25Qxx_CMD_ReadStatus_REG1;			<span class="comment">// 读状态信息寄存器</span></span><br><span class="line">	s_command.DataMode       = QSPI_DATA_1_LINE;					<span class="comment">// 1线数据模式</span></span><br><span class="line">	s_command.NbData         = <span class="number">1</span>;									<span class="comment">// 数据长度</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发送轮询等待命令	</span></span><br><span class="line">	<span class="keyword">if</span> (HAL_QSPI_AutoPolling(&amp;hqspi, &amp;s_command, &amp;s_config, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_AUTOPOLLING;<span class="comment">// 轮询等待无响应，返回错误</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> QSPI_W25Qxx_OK;<span class="comment">// 通信正常结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 擦除 */</span></span><br><span class="line"><span class="comment">//这里照搬原文档，指令都是重复的，不作注释</span></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> <span class="title">QSPI_W25Qxx_SectorErase</span><span class="params">(<span class="keyword">uint32_t</span> SectorAddress)</span>	</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QSPI_CommandTypeDef s_command;	<span class="comment">// QSPI传输配置</span></span><br><span class="line">	</span><br><span class="line">	s_command.InstructionMode   	= QSPI_INSTRUCTION_1_LINE;    <span class="comment">// 1线指令模式</span></span><br><span class="line">	s_command.AddressSize       	= QSPI_ADDRESS_24_BITS;       <span class="comment">// 24位地址模式</span></span><br><span class="line">	s_command.AlternateByteMode 	= QSPI_ALTERNATE_BYTES_NONE;  <span class="comment">//	无交替字节 </span></span><br><span class="line">	s_command.DdrMode           	= QSPI_DDR_MODE_DISABLE;      <span class="comment">// 禁止DDR模式</span></span><br><span class="line">	s_command.DdrHoldHalfCycle  	= QSPI_DDR_HHC_ANALOG_DELAY;  <span class="comment">// DDR模式中数据延迟，这里用不到</span></span><br><span class="line">	s_command.SIOOMode          	= QSPI_SIOO_INST_EVERY_CMD;	<span class="comment">// 每次传输数据都发送指令</span></span><br><span class="line">	s_command.AddressMode 			= QSPI_ADDRESS_1_LINE;        <span class="comment">// 1线地址模式</span></span><br><span class="line">	s_command.DataMode 				= QSPI_DATA_NONE;             <span class="comment">// 无数据</span></span><br><span class="line">	s_command.DummyCycles 			= <span class="number">0</span>;                          <span class="comment">// 空周期个数</span></span><br><span class="line">	s_command.Address           	= SectorAddress;              <span class="comment">// 要擦除的地址</span></span><br><span class="line">	s_command.Instruction	 		= W25Qxx_CMD_SectorErase;     <span class="comment">// 扇区擦除命令</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发送写使能</span></span><br><span class="line">	<span class="keyword">if</span> (QSPI_W25Qxx_WriteEnable() != QSPI_W25Qxx_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_WriteEnable;		<span class="comment">// 写使能失败</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 发出擦除命令</span></span><br><span class="line">	<span class="keyword">if</span> (HAL_QSPI_Command(&amp;hqspi, &amp;s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_Erase;				<span class="comment">// 擦除失败</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 使用自动轮询标志位，等待擦除的结束 </span></span><br><span class="line">	<span class="keyword">if</span> (QSPI_W25Qxx_AutoPollingMemReady() != QSPI_W25Qxx_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_AUTOPOLLING;		<span class="comment">// 轮询等待无响应</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> QSPI_W25Qxx_OK; <span class="comment">// 擦除成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> <span class="title">QSPI_W25Qxx_BlockErase_32K</span> <span class="params">(<span class="keyword">uint32_t</span> SectorAddress)</span>	</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QSPI_CommandTypeDef s_command;	<span class="comment">// QSPI传输配置</span></span><br><span class="line">	</span><br><span class="line">	s_command.InstructionMode   	= QSPI_INSTRUCTION_1_LINE;    <span class="comment">// 1线指令模式</span></span><br><span class="line">	s_command.AddressSize       	= QSPI_ADDRESS_24_BITS;       <span class="comment">// 24位地址模式</span></span><br><span class="line">	s_command.AlternateByteMode 	= QSPI_ALTERNATE_BYTES_NONE;  <span class="comment">//	无交替字节 </span></span><br><span class="line">	s_command.DdrMode           	= QSPI_DDR_MODE_DISABLE;      <span class="comment">// 禁止DDR模式</span></span><br><span class="line">	s_command.DdrHoldHalfCycle  	= QSPI_DDR_HHC_ANALOG_DELAY;  <span class="comment">// DDR模式中数据延迟，这里用不到</span></span><br><span class="line">	s_command.SIOOMode          	= QSPI_SIOO_INST_EVERY_CMD;	<span class="comment">// 每次传输数据都发送指令</span></span><br><span class="line">	s_command.AddressMode 			= QSPI_ADDRESS_1_LINE;        <span class="comment">// 1线地址模式</span></span><br><span class="line">	s_command.DataMode 				= QSPI_DATA_NONE;             <span class="comment">// 无数据</span></span><br><span class="line">	s_command.DummyCycles 			= <span class="number">0</span>;                          <span class="comment">// 空周期个数</span></span><br><span class="line">	s_command.Address           	= SectorAddress;              <span class="comment">// 要擦除的地址</span></span><br><span class="line">	s_command.Instruction	 		= W25Qxx_CMD_BlockErase_32K;  <span class="comment">// 块擦除命令，每次擦除32K字节</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发送写使能	</span></span><br><span class="line">	<span class="keyword">if</span> (QSPI_W25Qxx_WriteEnable() != QSPI_W25Qxx_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_WriteEnable;		<span class="comment">// 写使能失败</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 发出擦除命令</span></span><br><span class="line">	<span class="keyword">if</span> (HAL_QSPI_Command(&amp;hqspi, &amp;s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_Erase;				<span class="comment">// 擦除失败</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 使用自动轮询标志位，等待擦除的结束 </span></span><br><span class="line">	<span class="keyword">if</span> (QSPI_W25Qxx_AutoPollingMemReady() != QSPI_W25Qxx_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_AUTOPOLLING;		<span class="comment">// 轮询等待无响应</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> QSPI_W25Qxx_OK;	<span class="comment">// 擦除成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> <span class="title">QSPI_W25Qxx_BlockErase_64K</span> <span class="params">(<span class="keyword">uint32_t</span> SectorAddress)</span>	</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QSPI_CommandTypeDef s_command;	<span class="comment">// QSPI传输配置</span></span><br><span class="line">	</span><br><span class="line">	s_command.InstructionMode   	= QSPI_INSTRUCTION_1_LINE;    <span class="comment">// 1线指令模式</span></span><br><span class="line">	s_command.AddressSize       	= QSPI_ADDRESS_24_BITS;       <span class="comment">// 24位地址模式</span></span><br><span class="line">	s_command.AlternateByteMode 	= QSPI_ALTERNATE_BYTES_NONE;  <span class="comment">//	无交替字节 </span></span><br><span class="line">	s_command.DdrMode           	= QSPI_DDR_MODE_DISABLE;      <span class="comment">// 禁止DDR模式</span></span><br><span class="line">	s_command.DdrHoldHalfCycle  	= QSPI_DDR_HHC_ANALOG_DELAY;  <span class="comment">// DDR模式中数据延迟，这里用不到</span></span><br><span class="line">	s_command.SIOOMode          	= QSPI_SIOO_INST_EVERY_CMD;	<span class="comment">// 每次传输数据都发送指令</span></span><br><span class="line">	s_command.AddressMode 			= QSPI_ADDRESS_1_LINE;        <span class="comment">// 1线地址模式</span></span><br><span class="line">	s_command.DataMode 				= QSPI_DATA_NONE;             <span class="comment">// 无数据</span></span><br><span class="line">	s_command.DummyCycles 			= <span class="number">0</span>;                          <span class="comment">// 空周期个数</span></span><br><span class="line">	s_command.Address           	= SectorAddress;              <span class="comment">// 要擦除的地址</span></span><br><span class="line">	s_command.Instruction	 		= W25Qxx_CMD_BlockErase_64K;  <span class="comment">// 块擦除命令，每次擦除64K字节	</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发送写使能</span></span><br><span class="line">	<span class="keyword">if</span> (QSPI_W25Qxx_WriteEnable() != QSPI_W25Qxx_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_WriteEnable;	<span class="comment">// 写使能失败</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 发出擦除命令</span></span><br><span class="line">	<span class="keyword">if</span> (HAL_QSPI_Command(&amp;hqspi, &amp;s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_Erase;			<span class="comment">// 擦除失败</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 使用自动轮询标志位，等待擦除的结束 </span></span><br><span class="line">	<span class="keyword">if</span> (QSPI_W25Qxx_AutoPollingMemReady() != QSPI_W25Qxx_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_AUTOPOLLING;	<span class="comment">// 轮询等待无响应</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> QSPI_W25Qxx_OK;		<span class="comment">// 擦除成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> <span class="title">QSPI_W25Qxx_ChipErase</span> <span class="params">(<span class="keyword">void</span>)</span>	</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QSPI_CommandTypeDef s_command;		<span class="comment">// QSPI传输配置</span></span><br><span class="line">	QSPI_AutoPollingTypeDef s_config;	<span class="comment">// 轮询等待配置参数</span></span><br><span class="line"></span><br><span class="line">	s_command.InstructionMode   	= QSPI_INSTRUCTION_1_LINE;    <span class="comment">// 1线指令模式</span></span><br><span class="line">	s_command.AddressSize       	= QSPI_ADDRESS_24_BITS;       <span class="comment">// 24位地址模式</span></span><br><span class="line">	s_command.AlternateByteMode 	= QSPI_ALTERNATE_BYTES_NONE;  <span class="comment">//	无交替字节 </span></span><br><span class="line">	s_command.DdrMode           	= QSPI_DDR_MODE_DISABLE;      <span class="comment">// 禁止DDR模式</span></span><br><span class="line">	s_command.DdrHoldHalfCycle  	= QSPI_DDR_HHC_ANALOG_DELAY;  <span class="comment">// DDR模式中数据延迟，这里用不到</span></span><br><span class="line">	s_command.SIOOMode          	= QSPI_SIOO_INST_EVERY_CMD;	<span class="comment">// 每次传输数据都发送指令</span></span><br><span class="line">	s_command.AddressMode 			= QSPI_ADDRESS_NONE;       	<span class="comment">// 无地址</span></span><br><span class="line">	s_command.DataMode 				= QSPI_DATA_NONE;             <span class="comment">// 无数据</span></span><br><span class="line">	s_command.DummyCycles 			= <span class="number">0</span>;                          <span class="comment">// 空周期个数</span></span><br><span class="line">	s_command.Instruction	 		= W25Qxx_CMD_ChipErase;       <span class="comment">// 擦除命令，进行整片擦除</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发送写使能	</span></span><br><span class="line">	<span class="keyword">if</span> (QSPI_W25Qxx_WriteEnable() != QSPI_W25Qxx_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_WriteEnable;	<span class="comment">// 写使能失败</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 发出擦除命令</span></span><br><span class="line">	<span class="keyword">if</span> (HAL_QSPI_Command(&amp;hqspi, &amp;s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_Erase;		 <span class="comment">// 擦除失败</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不停的查询 W25Qxx_CMD_ReadStatus_REG1 寄存器，将读取到的状态字节中的 W25Qxx_Status_REG1_BUSY 不停的与0作比较</span></span><br><span class="line"><span class="comment">// 读状态寄存器1的第0位（只读），Busy标志位，当正在擦除/写入数据/写命令时会被置1，空闲或通信结束为0</span></span><br><span class="line">	</span><br><span class="line">	s_config.Match           = <span class="number">0</span>;   									<span class="comment">//	匹配值</span></span><br><span class="line">	s_config.MatchMode       = QSPI_MATCH_MODE_AND;	      	<span class="comment">//	与运算</span></span><br><span class="line">	s_config.Interval        = <span class="number">0x10</span>;	                     	<span class="comment">//	轮询间隔</span></span><br><span class="line">	s_config.AutomaticStop   = QSPI_AUTOMATIC_STOP_ENABLE;	<span class="comment">// 自动停止模式</span></span><br><span class="line">	s_config.StatusBytesSize = <span class="number">1</span>;	                        	<span class="comment">//	状态字节数</span></span><br><span class="line">	s_config.Mask            = W25Qxx_Status_REG1_BUSY;	   <span class="comment">// 对在轮询模式下接收的状态字节进行屏蔽，只比较需要用到的位</span></span><br><span class="line">	</span><br><span class="line">	s_command.Instruction    = W25Qxx_CMD_ReadStatus_REG1;	<span class="comment">// 读状态信息寄存器</span></span><br><span class="line">	s_command.DataMode       = QSPI_DATA_1_LINE;					<span class="comment">// 1线数据模式</span></span><br><span class="line">	s_command.NbData         = <span class="number">1</span>;										<span class="comment">// 数据长度</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// W25Q64整片擦除的典型参考时间为20s，最大时间为100s，这里的超时等待值 W25Qxx_ChipErase_TIMEOUT_MAX 为 100S</span></span><br><span class="line">	<span class="keyword">if</span> (HAL_QSPI_AutoPolling(&amp;hqspi, &amp;s_command, &amp;s_config, W25Qxx_ChipErase_TIMEOUT_MAX) != HAL_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_AUTOPOLLING;	 <span class="comment">// 轮询等待无响应</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> QSPI_W25Qxx_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写入 */</span></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> <span class="title">QSPI_W25Qxx_WritePage</span><span class="params">(<span class="keyword">uint8_t</span>* pBuffer, <span class="keyword">uint32_t</span> WriteAddr, <span class="keyword">uint16_t</span> NumByteToWrite)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QSPI_CommandTypeDef s_command;	<span class="comment">// QSPI传输配置	</span></span><br><span class="line">	</span><br><span class="line">	s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;    		<span class="comment">// 1线指令模式</span></span><br><span class="line">	s_command.AddressSize       = QSPI_ADDRESS_24_BITS;            <span class="comment">// 24位地址</span></span><br><span class="line">	s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;  		<span class="comment">// 无交替字节 </span></span><br><span class="line">	s_command.DdrMode           = QSPI_DDR_MODE_DISABLE;     		<span class="comment">// 禁止DDR模式</span></span><br><span class="line">	s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY; 		<span class="comment">// DDR模式中数据延迟，这里用不到</span></span><br><span class="line">	s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;			<span class="comment">// 每次传输数据都发送指令	</span></span><br><span class="line">	s_command.AddressMode 		 = QSPI_ADDRESS_1_LINE; 				<span class="comment">// 1线地址模式</span></span><br><span class="line">	s_command.DataMode    		 = QSPI_DATA_4_LINES;    				<span class="comment">// 4线数据模式</span></span><br><span class="line">	s_command.DummyCycles 		 = <span class="number">0</span>;                    				<span class="comment">// 空周期个数</span></span><br><span class="line">	s_command.NbData      		 = NumByteToWrite;      			   <span class="comment">// 数据长度，最大只能256字节</span></span><br><span class="line">	s_command.Address     		 = WriteAddr;         					<span class="comment">// 要写入 W25Qxx 的地址</span></span><br><span class="line">	s_command.Instruction 		 = W25Qxx_CMD_QuadInputPageProgram; <span class="comment">// 1-1-4模式下(1线指令1线地址4线数据)，页编程指令</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 写使能</span></span><br><span class="line">	<span class="keyword">if</span> (QSPI_W25Qxx_WriteEnable() != QSPI_W25Qxx_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_WriteEnable;	<span class="comment">// 写使能失败</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 写命令</span></span><br><span class="line">	<span class="keyword">if</span> (HAL_QSPI_Command(&amp;hqspi, &amp;s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_TRANSMIT;		<span class="comment">// 传输数据错误</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 开始传输数据</span></span><br><span class="line">	<span class="keyword">if</span> (HAL_QSPI_Transmit(&amp;hqspi, pBuffer, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_TRANSMIT;		<span class="comment">// 传输数据错误</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 使用自动轮询标志位，等待写入的结束 </span></span><br><span class="line">	<span class="keyword">if</span> (QSPI_W25Qxx_AutoPollingMemReady() != QSPI_W25Qxx_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_AUTOPOLLING; <span class="comment">// 轮询等待无响应</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> QSPI_W25Qxx_OK;	<span class="comment">// 写数据成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> <span class="title">QSPI_W25Qxx_WriteBuffer</span><span class="params">(<span class="keyword">uint8_t</span>* pBuffer, <span class="keyword">uint32_t</span> WriteAddr, <span class="keyword">uint32_t</span> Size)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="keyword">uint32_t</span> end_addr, current_size, current_addr;</span><br><span class="line">	<span class="keyword">uint8_t</span> *write_data;  <span class="comment">// 要写入的数据</span></span><br><span class="line"></span><br><span class="line">	current_size = W25Qxx_PageSize - (WriteAddr % W25Qxx_PageSize); <span class="comment">// 计算当前页还剩余的空间</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (current_size &gt; Size)	<span class="comment">// 判断当前页剩余的空间是否足够写入所有数据</span></span><br><span class="line">	&#123;</span><br><span class="line">		current_size = Size;		<span class="comment">// 如果足够，则直接获取当前长度</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	current_addr = WriteAddr;		<span class="comment">// 获取要写入的地址</span></span><br><span class="line">	end_addr = WriteAddr + Size;	<span class="comment">// 计算结束地址</span></span><br><span class="line">	write_data = pBuffer;			<span class="comment">// 获取要写入的数据</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 发送写使能</span></span><br><span class="line">		<span class="keyword">if</span> (QSPI_W25Qxx_WriteEnable() != QSPI_W25Qxx_OK)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> W25Qxx_ERROR_WriteEnable;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 按页写入数据</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(QSPI_W25Qxx_WritePage(write_data, current_addr, current_size) != QSPI_W25Qxx_OK)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> W25Qxx_ERROR_TRANSMIT;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 使用自动轮询标志位，等待写入的结束 </span></span><br><span class="line">		<span class="keyword">else</span> 	<span class="keyword">if</span> (QSPI_W25Qxx_AutoPollingMemReady() != QSPI_W25Qxx_OK)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> W25Qxx_ERROR_AUTOPOLLING;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span> <span class="comment">// 按页写入数据成功，进行下一次写数据的准备工作</span></span><br><span class="line">		&#123;</span><br><span class="line">			current_addr += current_size;	<span class="comment">// 计算下一次要写入的地址</span></span><br><span class="line">			write_data += current_size;	<span class="comment">// 获取下一次要写入的数据存储区地址</span></span><br><span class="line">			<span class="comment">// 计算下一次写数据的长度</span></span><br><span class="line">			current_size = ((current_addr + W25Qxx_PageSize) &gt; end_addr) ? (end_addr - current_addr) : W25Qxx_PageSize;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (current_addr &lt; end_addr) ; <span class="comment">// 判断数据是否全部写入完毕</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> QSPI_W25Qxx_OK;	<span class="comment">// 写入数据成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取 */</span></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> <span class="title">QSPI_W25Qxx_ReadBuffer</span><span class="params">(<span class="keyword">uint8_t</span>* pBuffer, <span class="keyword">uint32_t</span> ReadAddr, <span class="keyword">uint32_t</span> NumByteToRead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QSPI_CommandTypeDef s_command;	<span class="comment">// QSPI传输配置</span></span><br><span class="line">	</span><br><span class="line">	s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;    		<span class="comment">// 1线指令模式</span></span><br><span class="line">	s_command.AddressSize       = QSPI_ADDRESS_24_BITS;            <span class="comment">// 24位地址</span></span><br><span class="line">	s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;  		<span class="comment">// 无交替字节 </span></span><br><span class="line">	s_command.DdrMode           = QSPI_DDR_MODE_DISABLE;     		<span class="comment">// 禁止DDR模式</span></span><br><span class="line">	s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY; 		<span class="comment">// DDR模式中数据延迟，这里用不到</span></span><br><span class="line">	s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;			<span class="comment">// 每次传输数据都发送指令	</span></span><br><span class="line">	s_command.AddressMode 		 = QSPI_ADDRESS_4_LINES; 				<span class="comment">// 4线地址模式</span></span><br><span class="line">	s_command.DataMode    		 = QSPI_DATA_4_LINES;    				<span class="comment">// 4线数据模式</span></span><br><span class="line">	s_command.DummyCycles 		 = <span class="number">6</span>;                    				<span class="comment">// 空周期个数</span></span><br><span class="line">	s_command.NbData      		 = NumByteToRead;      			   	<span class="comment">// 数据长度，最大不能超过flash芯片的大小</span></span><br><span class="line">	s_command.Address     		 = ReadAddr;         					<span class="comment">// 要读取 W25Qxx 的地址</span></span><br><span class="line">	s_command.Instruction 		 = W25Qxx_CMD_FastReadQuad_IO; 		<span class="comment">// 1-4-4模式下(1线指令4线地址4线数据)，快速读取指令</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 发送读取命令</span></span><br><span class="line">	<span class="keyword">if</span> (HAL_QSPI_Command(&amp;hqspi, &amp;s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_TRANSMIT;		<span class="comment">// 传输数据错误</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//	接收数据</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (HAL_QSPI_Receive(&amp;hqspi, pBuffer, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_TRANSMIT;		<span class="comment">// 传输数据错误</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用自动轮询标志位，等待接收的结束 </span></span><br><span class="line">	<span class="keyword">if</span> (QSPI_W25Qxx_AutoPollingMemReady() != QSPI_W25Qxx_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_AUTOPOLLING; <span class="comment">// 轮询等待无响应</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> QSPI_W25Qxx_OK;	<span class="comment">// 读取数据成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，使用HAL库函数调用QSPI执行简单读写的基本方式是**==【QSPI传输配置】——【发送相关命令】——【读取回复】——【执行操作】——【等待接收完毕】==**</p>
<p>简单读写一般采用下面的方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QSPI_Status=QSPI_W25Qxx_ReadBuffer(W25Qxx_ReadBuffer,W25Qxx_TestAddr,W25Qxx_NumByteToTest);<span class="comment">//读取数据</span></span><br><span class="line">QSPI_Status=QSPI_W25Qxx_BlockErase_32K(W25Qxx_TestAddr);<span class="comment">//擦除32K字节,也可以调用上面.c文件里的其他擦除函数</span></span><br><span class="line">QSPI_Status=QSPI_W25Qxx_WriteBuffer(W25Qxx_WriteBuffer,W25Qxx_TestAddr,W25Qxx_NumByteToTest);<span class="comment">//写入数据</span></span><br></pre></td></tr></table></figure>

<p>在软件中加入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QSPI_Status = QSPI_W25Qxx_MemoryMappedMode();</span><br></pre></td></tr></table></figure>

<p>即可在各模式之间切换，应当注意：<strong>内存映射模式下，SPI FLASH只读</strong>，使用以下指令进行读取</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(W25Qxx_ReadBuffer,(<span class="keyword">uint8_t</span> *)W25Qxx_Mem_Addr+W25Qxx_TestAddr,W25Qxx_NumByteToTest);</span><br><span class="line"><span class="comment">//从 QSPI_Mem_Addr +W25Qxx_TestAddr 地址处复制数据到 W25Qxx_ReadBuffer</span></span><br></pre></td></tr></table></figure>

<p>如果需要开启DMA，在.c文件中加入MDMA相关配置即可，如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">MDMA_HandleTypeDef QSPI_MDMA_Handle;<span class="comment">//定义MDMA句柄</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MX_MDMA_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__HAL_RCC_MDMA_CLK_ENABLE(); <span class="comment">// 开启MDMA化时钟</span></span><br><span class="line"></span><br><span class="line">	QSPI_MDMA_Handle.Instance = MDMA_Channel1; <span class="comment">// 使用通道1</span></span><br><span class="line">	QSPI_MDMA_Handle.Init.TransferTriggerMode = MDMA_BUFFER_TRANSFER; <span class="comment">// 使用缓冲区传输	</span></span><br><span class="line">	QSPI_MDMA_Handle.Init.BufferTransferLength 	= <span class="number">128</span>; <span class="comment">// 缓冲区单次传输数据长度，最大128字节</span></span><br><span class="line">	QSPI_MDMA_Handle.Init.Priority = MDMA_PRIORITY_VERY_HIGH; <span class="comment">// 优先级最高</span></span><br><span class="line">	QSPI_MDMA_Handle.Init.Request = MDMA_REQUEST_QUADSPI_FIFO_TH; <span class="comment">// FIFO阈值触发中断请求</span></span><br><span class="line">	QSPI_MDMA_Handle.Init.Endianness = MDMA_LITTLE_ENDIANNESS_PRESERVE; <span class="comment">// 小端字节格式，不使用交换</span></span><br><span class="line">	QSPI_MDMA_Handle.Init.DataAlignment = MDMA_DATAALIGN_PACKENABLE; <span class="comment">// 所有字节右对齐，使用小端格式	</span></span><br><span class="line">	QSPI_MDMA_Handle.Init.SourceInc = MDMA_SRC_INC_BYTE; <span class="comment">// 源地址按照字节递增(8 bits)</span></span><br><span class="line">	QSPI_MDMA_Handle.Init.SourceDataSize = MDMA_SRC_DATASIZE_BYTE; <span class="comment">// 源地址数据宽度为1字节(8 bits)</span></span><br><span class="line">	QSPI_MDMA_Handle.Init.SourceBurst = MDMA_SOURCE_BURST_SINGLE; <span class="comment">// 源数据单次突发传输</span></span><br><span class="line">	QSPI_MDMA_Handle.Init.DestinationInc = MDMA_DEST_INC_DISABLE; <span class="comment">// 禁止目标地址自增 </span></span><br><span class="line">	QSPI_MDMA_Handle.Init.DestDataSize = MDMA_DEST_DATASIZE_BYTE; <span class="comment">// 目标地址数据宽度为1字节(8 bits)</span></span><br><span class="line">	QSPI_MDMA_Handle.Init.DestBurst = MDMA_DEST_BURST_SINGLE; <span class="comment">// 目标数据单次突发传输</span></span><br><span class="line"></span><br><span class="line">	__HAL_LINKDMA(&amp;hqspi, hmdma, QSPI_MDMA_Handle); <span class="comment">// 关联MDMA句柄</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 应用配置</span></span><br><span class="line">	HAL_MDMA_Init(&amp;QSPI_MDMA_Handle);</span><br><span class="line"></span><br><span class="line">	HAL_NVIC_SetPriority(MDMA_IRQn, <span class="number">0x0E</span>, <span class="number">0</span>); <span class="comment">// 设置MDMA中断优先级</span></span><br><span class="line">	HAL_NVIC_EnableIRQ(MDMA_IRQn); <span class="comment">// 使能MDMA中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在QSPI_W25Qxx_Init()中加入MDMA初始化</span></span><br><span class="line">MX_MDMA_Init();<span class="comment">// MDMA初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//加入MDMA中断回调函数用于标识QSPI接收结束</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_QSPI_RxCpltCallback</span><span class="params">(QSPI_HandleTypeDef *hqspi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QSPI_RX_Status = <span class="number">1</span>;  <span class="comment">// 当进入此中断函数时，说明QSPI接收完成，将标志变量置1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将接收函数的if (HAL_QSPI_Receive(&amp;hqspi, pBuffer, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)都改成if (HAL_QSPI_Receive_DMA(&amp;hqspi, pBuffer) != HAL_OK)或类似形式，相当于把基本读取方式改变为等待DMA中断，DMA一旦中断就表明数据收取完毕，CPU再接管数据</span></span><br></pre></td></tr></table></figure>

<p>MDMA中断下，收发数据的应用层接口不变</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QSPI_Status=QSPI_W25Qxx_WriteBuffer(W25Qxx_WriteBuffer,W25Qxx_TestAddr,W25Qxx_NumByteToTest);<span class="comment">//写入数据</span></span><br><span class="line">QSPI_Status=QSPI_W25Qxx_BlockErase_32K(W25Qxx_TestAddr);<span class="comment">//擦除32K字节</span></span><br><span class="line">QSPI_Status=QSPI_W25Qxx_ReadBuffer(W25Qxx_ReadBuffer,W25Qxx_TestAddr,W25Qxx_NumByteToTest);<span class="comment">//读取数据</span></span><br></pre></td></tr></table></figure>

<h2 id="HAL库的QSPI使用总结"><a href="#HAL库的QSPI使用总结" class="headerlink" title="HAL库的QSPI使用总结"></a>HAL库的QSPI使用总结</h2><ol>
<li>间接模式下，使用QSPI<strong>与使用其他外设一样</strong>，通过寄存器配置，与SPI的使用方法大同小异</li>
<li>自动轮询模式下，通过查询SPI FLASH的状态寄存器来使用，当读取/写入完成后轮询得到器件空闲，即可进行新一轮写入，可以配合MDMA使用，让其自动写入，CPU在中间还能做其他任务，轮询得到可以继续写入后再向buffer中填充写入数据或读取buffer中数据。可以使用<strong>掩码</strong>功能来<strong>匹配状态位</strong></li>
<li>内存映射模式下，将SPI FLASH视为STM32的片上FLASH，可以利用这个功能在片外SPI FLASH中存储程序。读取时使用指针即可，但SPI FLASH==<strong>只读</strong>==</li>
</ol>
<h1 id="W25Qxx系列SPI-FLASH特性"><a href="#W25Qxx系列SPI-FLASH特性" class="headerlink" title="W25Qxx系列SPI FLASH特性"></a>W25Qxx系列SPI FLASH特性</h1><p>详见芯片手册</p>
<p><img src="/2021/11/19/STM32%E5%A4%96%E8%AE%BE%E9%85%8D%E7%BD%AE%E9%80%9F%E6%9F%A5%E3%80%90QSPI%E3%80%91/W25Q64(3).jpg" alt="W25Q64(3)"></p>
<p><img src="/2021/11/19/STM32%E5%A4%96%E8%AE%BE%E9%85%8D%E7%BD%AE%E9%80%9F%E6%9F%A5%E3%80%90QSPI%E3%80%91/W25Q64(1).jpg" alt="W25Q64(1)"></p>
<p><img src="/2021/11/19/STM32%E5%A4%96%E8%AE%BE%E9%85%8D%E7%BD%AE%E9%80%9F%E6%9F%A5%E3%80%90QSPI%E3%80%91/W25Q64(2).jpg" alt="W25Q64(2)"></p>
<ul>
<li>支持标准摩托罗拉SPI协议</li>
<li>支持双线/四线SPI，通过写入IC内部的控制寄存器相关控制位，可将WP和Hold引脚作为IO2、IO3使用</li>
</ul>
<p>相关指令如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写保护</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_WriteEnable		0x06 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_WriteDisable		0x04 </span></span><br><span class="line"><span class="comment">//读写W25Qxx状态寄存器</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_ReadStatusReg1		0x05 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_ReadStatusReg2		0x35 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_ReadStatusReg3		0x15 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_WriteStatusReg1    0x01 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_WriteStatusReg2    0x31 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_WriteStatusReg3    0x11 </span></span><br><span class="line"><span class="comment">//读数据</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_ReadData			0x03 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_FastReadData		0x0B </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_FastReadDual		0x3B </span></span><br><span class="line"><span class="comment">//按页写入</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_PageProgram		0x02 </span></span><br><span class="line"><span class="comment">//擦除</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_BlockErase			0xD8 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_SectorErase		0x20 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_ChipErase			0xC7 </span></span><br><span class="line"><span class="comment">//关闭/低功耗</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_PowerDown			0xB9 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_ReleasePowerDown	0xAB </span></span><br><span class="line"><span class="comment">//ID相关</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_DeviceID			0xAB </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_ManufactDeviceID	0x90 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_JedecDeviceID		0x9F </span></span><br><span class="line"><span class="comment">//4字节地址模式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_Enable4ByteAddr    0xB7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_Exit4ByteAddr      0xE9</span></span><br><span class="line"><span class="comment">//设置读取参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_SetReadParam		0xC0 </span></span><br><span class="line"><span class="comment">//是否使用QSPI模式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_EnterQPIMode       0x38</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_ExitQPIMode        0xFF</span></span><br></pre></td></tr></table></figure>

<p>四字节地址模式：<strong>使用该模式可以访问到W25Q256的所有空间</strong>，对于容量小于等于16MB的SPI FLASH并不需要开启此模式（仅W25Q256可用此模式）</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">stm32</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2021/11/19/STM32%E5%A4%96%E8%AE%BE%E9%85%8D%E7%BD%AE%E9%80%9F%E6%9F%A5%E3%80%90QSPI%E3%80%91/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-STM32外设配置速查【板级总线协议】" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/19/STM32%E5%A4%96%E8%AE%BE%E9%85%8D%E7%BD%AE%E9%80%9F%E6%9F%A5%E3%80%90%E6%9D%BF%E7%BA%A7%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE%E3%80%91/">STM32外设配置速查【板级总线协议】</a>
    </h1>
  

        
<!-- 显示阅读次数-->
<!--  -->
<!--显示阅读次数完毕 -->

        
        <a href="/2021/11/19/STM32%E5%A4%96%E8%AE%BE%E9%85%8D%E7%BD%AE%E9%80%9F%E6%9F%A5%E3%80%90%E6%9D%BF%E7%BA%A7%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE%E3%80%91/" class="archive-article-date">
  	<time datetime="2021-11-19T08:05:39.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2021-11-19</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="总线协议"><a href="#总线协议" class="headerlink" title="总线协议"></a>总线协议</h1><h2 id="I2C-（又称I-2-C、IIC等）"><a href="#I2C-（又称I-2-C、IIC等）" class="headerlink" title="I2C （又称I^2^C、IIC等）"></a>I2C （又称I^2^C、IIC等）</h2><p>I2C（Integrated Circuit）是<strong>两线</strong>式<strong>半双工串行</strong>总线</p>
<p>由数据线<strong>SDA</strong>和时钟<strong>SCL</strong>构成</p>
<p>一般可达400kbps以上</p>
<h3 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h3><h4 id="底层硬件"><a href="#底层硬件" class="headerlink" title="底层硬件"></a>底层硬件</h4><p>SDA和SCL分别上拉到VCC，同时接入设备</p>
<p>主设备操纵SCL，可以接收/发送SDA</p>
<p>从设备可以发送/接收SDA</p>
<h3 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h3><h5 id="空闲（释放总线）"><a href="#空闲（释放总线）" class="headerlink" title="空闲（释放总线）"></a>空闲（释放总线）</h5><p>SDA=1    SCL=1</p>
<h5 id="起止信号"><a href="#起止信号" class="headerlink" title="起止信号"></a>起止信号</h5><p>起始信号：SCL=1    SDA下降沿</p>
<p>停止信号：SCL=1    SDA上升沿</p>
<h5 id="应答信号ACK"><a href="#应答信号ACK" class="headerlink" title="应答信号ACK"></a>应答信号ACK</h5><p>发送器<strong>每发送一个字节</strong>，就在时钟9器件释放SDA，由接收器反馈一个应答信号</p>
<p><strong>0为有效应答</strong>，ACK称为应答位，表示接收器已接收</p>
<p><strong>1为非应答</strong>，NACK称为非应答位，表示接收器接收该字节没有成功</p>
<p>从设备要求：</p>
<p>在==第9个==时钟脉冲之前的低电平期间==将SDA拉低==，并确保在该时钟高电平期间位稳定的低电平</p>
<p>主设备要求：</p>
<p>在==收到最后一个字节后发送一个NACK信号==以通知被控发送器结束数据发送，并SDA=1（释放SDA），以便从设备发送停止信号P</p>
<h5 id="数据有效性确认"><a href="#数据有效性确认" class="headerlink" title="数据有效性确认"></a>数据有效性确认</h5><p>SCL=1期间，SDA上的数据必须保持稳定，只有在SCL=0时，SDA才允许变化</p>
<p>即<em><strong>数据在SCL上升沿到来前就要准备好，并在下降沿到来前必须稳定</strong></em></p>
<h5 id="stm32实现"><a href="#stm32实现" class="headerlink" title="stm32实现"></a>stm32实现</h5><p>stm32自带I2C不稳定，通常使用GPIO模拟I2C</p>
<p>iic.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __IIC_H</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> __IIC_H</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//定义模拟线</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> IIC_SCL GPIO_Pin_8<span class="comment">//以PB8、PB9作为I2C模拟线</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> IIC_SDA GPIO_Pin_9</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//设置端口操作</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> IIC_SCL_WRITE PBout(8)<span class="comment">//PB8模拟SCL输出</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> IIC_SDA_WRITE PBout(9)<span class="comment">//PB9模拟SDA输出</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> IIC_SDA_READ PBin(9)<span class="comment">//PB9模拟SDA输入</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//设置端口输入输出模式</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> IIC_SDA_IN() &#123;GPIOB-&gt;MODER&amp;=~(3<span class="meta-string">&lt;&lt;(9*2));GPIOB-&gt;</span>MODER|=0&lt;&lt;9*2;&#125; <span class="comment">//PB9输入模式</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> IIC_SDA_OUT() &#123;GPIOB-&gt;MODER&amp;=~(3<span class="meta-string">&lt;&lt;(9*2));GPIOB-&gt;</span>MODER|=1&lt;&lt;9*2;&#125; <span class="comment">//PB9输出模式</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">IIC_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//产生IIC起始信号</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">IIC_stop</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//产生IIC停止信号</span></span><br><span class="line">	<span class="function">u8 <span class="title">IIC_wait_ACK</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//等待应答信号</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">IIC_ACK</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//产生ACK应答</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">IIC_NACK</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//不产生ACK应答</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">IIC_send_byte</span><span class="params">(u8 txd)</span></span>;<span class="comment">//IIC发送一个字节</span></span><br><span class="line">	<span class="function">u8 <span class="title">IIC_read_byte</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> ACK)</span></span>;<span class="comment">//IIC读取一个字节</span></span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>iic.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;iic.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化IIC</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	</span><br><span class="line">	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB,ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_OUT;<span class="comment">//普通输出模式</span></span><br><span class="line">	GPIO_InitStructure.GPIO_OType=GPIO_OType_PP;<span class="comment">//推挽输出</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin=IIC_SCL|IIC_SDA;<span class="comment">//模拟IIC</span></span><br><span class="line">	GPIO_InitStructure.GPIO_PuPd=GPIO_PuPd_UP;<span class="comment">//内部上拉</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_100MHz;<span class="comment">//100MHz</span></span><br><span class="line">	<span class="comment">//应用设置</span></span><br><span class="line">	GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">	IIC_SCL_WRITE=<span class="number">1</span>;</span><br><span class="line">	IIC_SDA_WRITE=<span class="number">1</span>;<span class="comment">//默认拉高总线</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产生IIC起始信号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_start</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	IIC_SDA_OUT();<span class="comment">//SDA输出</span></span><br><span class="line">	</span><br><span class="line">	IIC_SDA_WRITE=<span class="number">1</span>;</span><br><span class="line">	IIC_SCL_WRITE=<span class="number">1</span>;</span><br><span class="line">	delay_us(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	IIC_SDA_WRITE=<span class="number">0</span>;<span class="comment">//开始信号为SDA上升沿</span></span><br><span class="line">	delay_us(<span class="number">4</span>);</span><br><span class="line">	</span><br><span class="line">	IIC_SCL_WRITE=<span class="number">0</span>;<span class="comment">//拉低SCL，准备接收或发送数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产生IIC停止信号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_stop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	IIC_SDA_OUT();<span class="comment">//SDA输出</span></span><br><span class="line">	</span><br><span class="line">	IIC_SCL_WRITE=<span class="number">0</span>;</span><br><span class="line">	IIC_SDA_WRITE=<span class="number">0</span>;</span><br><span class="line">	delay_us(<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">	IIC_SCL_WRITE=<span class="number">1</span>;</span><br><span class="line">	IIC_SDA_WRITE=<span class="number">1</span>;<span class="comment">//停止信号为SDA下降沿</span></span><br><span class="line">	delay_us(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待应答信号</span></span><br><span class="line"><span class="comment">//返回1：接收应答失败</span></span><br><span class="line"><span class="comment">//返回0：接收应答成功</span></span><br><span class="line"><span class="function">u8 <span class="title">IIC_wait_ACK</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 Err_time=<span class="number">0</span>;</span><br><span class="line">	IIC_SDA_IN();<span class="comment">//SDA输入</span></span><br><span class="line">	</span><br><span class="line">	IIC_SDA_WRITE=<span class="number">1</span>;<span class="comment">//等待接收应答</span></span><br><span class="line">	delay_us(<span class="number">1</span>);</span><br><span class="line">	IIC_SCL_WRITE=<span class="number">1</span>;</span><br><span class="line">	delay_us(<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(IIC_SDA_READ)<span class="comment">//获取SDA的信号</span></span><br><span class="line">	&#123;</span><br><span class="line">		Err_time++;<span class="comment">//每读取一次高电平则+1</span></span><br><span class="line">		<span class="keyword">if</span>(Err_time&gt;<span class="number">250</span>)<span class="comment">//若一直读到高电平则接收应答失败</span></span><br><span class="line">		&#123;</span><br><span class="line">			IIC_stop();</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	IIC_SCL_WRITE=<span class="number">0</span>;<span class="comment">//一直读到低电平则为有效应答</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产生ACK应答</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_ACK</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	IIC_SDA_OUT();<span class="comment">//SDA输出</span></span><br><span class="line">	</span><br><span class="line">	IIC_SCL_WRITE=<span class="number">0</span>;<span class="comment">//SCL上升沿时SDA=0</span></span><br><span class="line">	IIC_SDA_WRITE=<span class="number">0</span>;</span><br><span class="line">	delay_us(<span class="number">2</span>);</span><br><span class="line">	IIC_SCL_WRITE=<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">	delay_us(<span class="number">2</span>);</span><br><span class="line">	IIC_SDA_WRITE=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不产生ACK应答</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_NACK</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	IIC_SDA_OUT();<span class="comment">//SDA输出</span></span><br><span class="line">	</span><br><span class="line">	IIC_SCL_WRITE=<span class="number">0</span>;<span class="comment">//SCL上升沿时SDA=1</span></span><br><span class="line">	IIC_SDA_WRITE=<span class="number">1</span>;</span><br><span class="line">	delay_us(<span class="number">2</span>);</span><br><span class="line">	IIC_SCL_WRITE=<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">	delay_us(<span class="number">2</span>);</span><br><span class="line">	IIC_SCL_WRITE=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IIC发送一个字节</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_send_byte</span><span class="params">(u8 txd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 t;</span><br><span class="line"></span><br><span class="line">	IIC_SDA_OUT();<span class="comment">//SDA输出</span></span><br><span class="line">	IIC_SCL_WRITE=<span class="number">0</span>;<span class="comment">//拉低SCL准备输出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送数据以SDA电平为准</span></span><br><span class="line">	<span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;<span class="number">8</span>;t++)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//SDA早来晚走</span></span><br><span class="line">		IIC_SDA_WRITE=(txd &amp; <span class="number">0x80</span>)&gt;&gt;<span class="number">7</span>;<span class="comment">//取最高位发送</span></span><br><span class="line">		txd&lt;&lt;=<span class="number">1</span>;<span class="comment">//待发送数据向左移位，次高位变成最高位，获取下一个待发送的位</span></span><br><span class="line">		delay_us(<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//SCL晚来早走</span></span><br><span class="line">		IIC_SCL_WRITE=<span class="number">1</span>;</span><br><span class="line">		delay_us(<span class="number">2</span>);</span><br><span class="line">		IIC_SCL_WRITE=<span class="number">0</span>;</span><br><span class="line">		delay_us(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IIC读取一个字节</span></span><br><span class="line"><span class="comment">//ack_flag=1时发送ACK</span></span><br><span class="line"><span class="comment">//ack_flag=0时发送NACK</span></span><br><span class="line"><span class="function">u8 <span class="title">IIC_read_byte</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> ACK)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> i,receive=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	IIC_SDA_IN();<span class="comment">//SDA输入</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		IIC_SCL_WRITE=<span class="number">0</span>;<span class="comment">//SCL上升沿</span></span><br><span class="line">		delay_us(<span class="number">2</span>);</span><br><span class="line">		IIC_SCL_WRITE=<span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		receive&lt;&lt;=<span class="number">1</span>;<span class="comment">//读取1位</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(IIC_SDA_READ)</span><br><span class="line">			receive++;</span><br><span class="line">		delay_us(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!ACK)</span><br><span class="line">		IIC_NACK();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		IIC_ACK();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> receive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>示例程序：I2C驱动24C01（EEPROM）</p>
<p>24C02规格：总容量2K=256B*8</p>
<p>引脚定义如下：【1-A0 2-A1 3-A2】（地址线） 4-GND 【5-SDA 6-SCL】（I2C控制线） 7-WP（写保护） 8-VCC</p>
<p>在此A0=A1=A2=0</p>
<p>SCL==PB8    SDA==PB9</p>
<p><strong>详细内容参考芯片手册即可</strong></p>
<h6 id="写时序"><a href="#写时序" class="headerlink" title="写时序"></a>写时序</h6><p>start-&gt;片选-&gt;选择地址-&gt;wait-&gt;传输数据-&gt;stop</p>
<h6 id="读时序"><a href="#读时序" class="headerlink" title="读时序"></a>读时序</h6><p> start-&gt;片选-&gt;选择地址线-&gt;start-&gt;选择地址线-&gt;wait-&gt;读取数据-&gt;stop</p>
<p><strong>程序读者自写</strong></p>
<h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><p>SPI（Serial Peripheral interface）串行外围设备接口，是一种<strong>四线</strong>、<strong>高速</strong>、<strong>全双工</strong>、<strong>同步</strong>通信总线</p>
<p>==应用广泛==</p>
<p>四条通信线：</p>
<p><strong>MISO</strong>：（Master input &amp; Slave output）主设备数据输入、从设备数据输出 即 <strong>从设备-&gt;主设备</strong></p>
<p><strong>MOSI</strong>：（Master output &amp; Slave input）主设备数据输出、从设备数据输入 即 <strong>主设备-&gt;从设备</strong></p>
<p><strong>SCLK</strong>：时钟信号，由主设备产生</p>
<p><strong>CS</strong>：片选信号，由主设备控制</p>
<h3 id="协议栈-1"><a href="#协议栈-1" class="headerlink" title="协议栈"></a>协议栈</h3><h4 id="底层硬件-1"><a href="#底层硬件-1" class="headerlink" title="底层硬件"></a>底层硬件</h4><p>stm32f4自带SPI接口，相关内容参考芯片手册即可</p>
<p>基本原理</p>
<ol>
<li>4线总线</li>
<li>主机从机各有一个串行移位寄存器（以下简称SPI寄存器），主机通过向它的SPI寄存器写入一个字节来发起一次传输</li>
<li>SPI寄存器通过MOSI线将字节传输给从机，从机也将自己SPI寄存器中的内容通过MISO线返回主机，最终<strong>两个移位寄存器中的内容被交换</strong></li>
<li><strong>外设读写操作同步完成</strong>，如果<strong>只进行写操作，主机忽略收到数据</strong>即可；若<strong>只进行读操作，需要发送一个空字节来引发从机的传输</strong></li>
</ol>
<p>外设SPI的MISO、MOSI、SCLK可直接挂载到总线上，但CS线需要单独连接到stm32的GPIO模拟CS引脚，当对应GPIOxPinx&lt;-&gt;CS拉低时表示选中该外设，才可进行通信</p>
<h4 id="驱动-1"><a href="#驱动-1" class="headerlink" title="驱动"></a>驱动</h4><p>驱动由stm32f4 STL提供，只需调用库函数即可</p>
<h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><p>SPI应用过程</p>
<ol>
<li>使能SPIx和GPIO时钟</li>
<li>初始化GPIO为复用功能</li>
<li>设置引脚复用为映射</li>
<li>初始化SPIx，设置SPIx工作模式</li>
<li>使能SPIx</li>
<li>SPI传输数据</li>
<li>查看SPI传输状态</li>
</ol>
<p>示例程序：SPI驱动W25Q128</p>
<p>W25Q128规格：<strong>总容量16M</strong>    分成256块64K    每个块分成16扇区，每个扇区4K</p>
<p>擦写周期多达10W次，具有20年的数据保存期限</p>
<p>==支持电压2.7-3.6V==</p>
<p>最小擦除单位为一个扇区，也就是<strong>每次必须擦除4K个字节</strong></p>
<p>需要给W25Q128开辟一个至少4K的缓存区</p>
<p>支持标准SPI协议，还支持双输出/四输出的SPI，最大SPI时钟可以到80MHz（双输出时相当于160MHz，四输出时相当于320MHz）</p>
<p>引脚定义如下：</p>
<p>1 片选信号CS    2 MISO线SO    3 使能引脚WP#    4 接地GND    5 MOSI线SI    6 SCK线CLK    7 保持位HOLD    8 接电源VCC</p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>spi.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;spi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//SPI1初始化，配置为主机</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPI1_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	SPI_InitTypeDef SPI_InitStructure;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1. 使能GPIOA/GPIOB时钟与SPI1时钟</span></span><br><span class="line">	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,ENABLE);<span class="comment">//w25qxx</span></span><br><span class="line">	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB,ENABLE);<span class="comment">//SPI通信</span></span><br><span class="line">	RCC_AHB1PeriphClockCmd(RCC_APB2Periph_SPI1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2. 初始化GPIOF</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF;<span class="comment">//引脚复用</span></span><br><span class="line">	GPIO_InitStructure.GPIO_OType=GPIO_OType_PP;<span class="comment">//推挽输出</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_3|GPIO_Pin_4|GPIO_Pin_5;<span class="comment">//GPIO3、4、5复用输出</span></span><br><span class="line">	GPIO_InitStructure.GPIO_PuPd=GPIO_PuPd_UP;<span class="comment">//内部上拉</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_100MHz;<span class="comment">//100MHz</span></span><br><span class="line">	<span class="comment">//应用设置</span></span><br><span class="line">	GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3. GPIOB引脚复用为SPI1输出端</span></span><br><span class="line">	GPIO_PinAFConfig(GPIOB,GPIO_PinSource3,GPIO_AF_SPI1);</span><br><span class="line">	GPIO_PinAFConfig(GPIOB,GPIO_PinSource4,GPIO_AF_SPI1);</span><br><span class="line">	GPIO_PinAFConfig(GPIOB,GPIO_PinSource5,GPIO_AF_SPI1);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//4. 初始化SPI口</span></span><br><span class="line">	RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1,DISABLE);<span class="comment">//复位SPI1</span></span><br><span class="line">	RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1,DISABLE);<span class="comment">//停止复位</span></span><br><span class="line">	</span><br><span class="line">	SPI_InitStructure.SPI_Direction=SPI_Direction_2Lines_FullDuplex;<span class="comment">//双线全双工</span></span><br><span class="line">	SPI_InitStructure.SPI_Mode=SPI_Mode_Master;<span class="comment">//主机模式</span></span><br><span class="line">	SPI_InitStructure.SPI_DataSize=SPI_DataSize_8b;<span class="comment">//SPI发送接收8位帧结构</span></span><br><span class="line">	SPI_InitStructure.SPI_CPOL=SPI_CPOL_High;<span class="comment">//SCLK空闲状态为高电平</span></span><br><span class="line">	SPI_InitStructure.SPI_CPHA=SPI_CPHA_2Edge;<span class="comment">//SCLK第二个跳变沿数据被采样</span></span><br><span class="line">	SPI_InitStructure.SPI_NSS=SPI_NSS_Soft;<span class="comment">//NSS信号由硬件（NSS管脚）还是软件（使用SSI位管理）：硬件管理</span></span><br><span class="line">	SPI_InitStructure.SPI_BaudRatePrescaler=SPI_BaudRatePrescaler_256;<span class="comment">//预分频256</span></span><br><span class="line">	SPI_InitStructure.SPI_FirstBit=SPI_FirstBit_MSB;<span class="comment">//指定数据传输从MSB位还是LSB位开始：数据传输从MSB位开始</span></span><br><span class="line">	SPI_InitStructure.SPI_CRCPolynomial=<span class="number">7</span>;<span class="comment">//CRC计算的多项式</span></span><br><span class="line">	<span class="comment">//应用设置</span></span><br><span class="line">	SPI_Init(SPI1,&amp;SPI_InitStructure);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//5. 使能SPI</span></span><br><span class="line">	SPI_Cmd(SPI1,ENABLE);</span><br><span class="line">	<span class="comment">//6. 主机发送0xff，维持MOSI为高电平，启动SPI传输</span></span><br><span class="line">	SPI1_RW_byte(<span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置SPI1波特率</span></span><br><span class="line"><span class="comment">//SPI速率=f_&#123;APB2&#125;/分频系数</span></span><br><span class="line"><span class="comment">//f_&#123;APB2&#125;一般为84MHz</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPI1_set_speed</span><span class="params">(u8 SPI_BaudRatePrescaler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_BaudRatePrescaler));<span class="comment">//判断有效性</span></span><br><span class="line">	SPI1-&gt;CR1 &amp;= <span class="number">0xFFC7</span>;<span class="comment">//位3-5清零，设置波特率</span></span><br><span class="line">	SPI1-&gt;CR1 |= SPI_BaudRatePrescaler;<span class="comment">//设置波特率</span></span><br><span class="line">	SPI_Cmd(SPI1,ENABLE);<span class="comment">//使能SPI1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过SPI1总线读写一个字节</span></span><br><span class="line"><span class="comment">//tx_data：发送字节</span></span><br><span class="line"><span class="comment">//返回接收字节</span></span><br><span class="line"><span class="function">u8 <span class="title">SPI1_RW_byte</span><span class="params">(u8 tx_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_TXE)==RESET);<span class="comment">//等待发送区清空</span></span><br><span class="line">	SPI_I2S_SendData(SPI1,tx_data);<span class="comment">//发送数据</span></span><br><span class="line">	<span class="keyword">while</span>(SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_RXNE)==RESET)<span class="comment">//等待接收完一个字节</span></span><br><span class="line">	<span class="keyword">return</span> SPI_I2S_ReceiveData(SPI1);<span class="comment">//返回最近接收的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>spi.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SPI_H</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> __SPI_H</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SPI1_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//初始化SPI1</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SPI1_set_speed</span><span class="params">(u8 SPI_BaudRatePrescaler)</span></span>;<span class="comment">//设置SPI1波特率</span></span><br><span class="line">	<span class="function">u8 <span class="title">SPI1_RW_byte</span><span class="params">(u8 tx_data)</span></span>;<span class="comment">//通过SPI1总线读写一个字节（读写同时进行）</span></span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>W25Q128.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br></pre></td><td class="code"><pre><span class="line">u16 W25QXX_TYPE;<span class="comment">//FLASH型号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//FLASH初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">W25QXX_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1. 使能GPIOB与GPIOG时钟</span></span><br><span class="line">	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB,ENABLE);<span class="comment">//GPIOB</span></span><br><span class="line">	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOG,ENABLE);<span class="comment">//GPIOG</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2. 初始化GPIOF</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_OUT;<span class="comment">//普通输出</span></span><br><span class="line">	GPIO_InitStructure.GPIO_OType=GPIO_OType_PP;<span class="comment">//推挽输出</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_14;<span class="comment">//PB14输出</span></span><br><span class="line">	GPIO_InitStructure.GPIO_PuPd=GPIO_PuPd_UP;<span class="comment">//内部上拉</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_100MHz;<span class="comment">//100MHz</span></span><br><span class="line">	<span class="comment">//应用设置</span></span><br><span class="line">	GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_7;<span class="comment">//PG7</span></span><br><span class="line">	<span class="comment">//应用设置</span></span><br><span class="line">	GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	GPIO_SetBits(GPIOG,GPIO_Pin_7);<span class="comment">//PG7连接到NRF，会同时连接到SPI，令PG7输出1，防止NRF干扰SPI FLASH通信</span></span><br><span class="line">	W25QXX_CS=<span class="number">1</span>;<span class="comment">//不选中FLASH</span></span><br><span class="line">	SPI1_init();<span class="comment">//初始化SPI</span></span><br><span class="line">	SPI1_set_speed(SPI_BaudRatePrescaler_2);<span class="comment">//1/2分频，时钟频率为42MHz，高速模式</span></span><br><span class="line">	W25QXX_TYPE=W25QXX_ReadID();<span class="comment">//读取FLASH ID</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取FLASH ID</span></span><br><span class="line"><span class="function">u16  <span class="title">W25QXX_ReadID</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u16 ID_Temp=<span class="number">0</span>;</span><br><span class="line">	W25QXX_CS=<span class="number">0</span>;<span class="comment">//片选</span></span><br><span class="line">	SPI1_RW_byte(<span class="number">0x90</span>);<span class="comment">//发送读取ID命令</span></span><br><span class="line">	SPI1_RW_byte(<span class="number">0x00</span>);</span><br><span class="line">	SPI1_RW_byte(<span class="number">0x00</span>);</span><br><span class="line">	SPI1_RW_byte(<span class="number">0x00</span>);</span><br><span class="line">	</span><br><span class="line">	ID_Temp |= SPI1_RW_byte(<span class="number">0xFF</span>)&lt;&lt;<span class="number">8</span>;</span><br><span class="line">	ID_Temp |= SPI1_RW_byte(<span class="number">0xFF</span>);</span><br><span class="line">	W25QXX_CS=<span class="number">0</span>;<span class="comment">//取消片选</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> ID_Temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取状态寄存器</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	BIT 6 	5 	4 	3 	2 	1 	0</span></span><br><span class="line"><span class="comment">	SPR RV TB BP2 BP1 BP0 WEL BUSY</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	SPR默认0，状态寄存器保护位，配合WP使用</span></span><br><span class="line"><span class="comment">	TB、BP2、BP1、BP0：FLASH区域写保护设置</span></span><br><span class="line"><span class="comment">	WEL写使能锁定		BUSY忙标记位，1为忙，0为空闲</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	默认0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">u8 <span class="title">W25QXX_ReadSR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 byte=<span class="number">0</span>;</span><br><span class="line">	W25QXX_CS=<span class="number">0</span>;<span class="comment">//片选</span></span><br><span class="line">	SPI1_RW_byte(W25X_ReadStatusReg);<span class="comment">//发送读取寄存器命令</span></span><br><span class="line">	byte=SPI1_RW_byte(<span class="number">0xff</span>);<span class="comment">//读取一个字节</span></span><br><span class="line">	W25QXX_CS=<span class="number">1</span>;<span class="comment">//取消片选</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> byte;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写状态寄存器</span></span><br><span class="line"><span class="comment">//只能写入SPR、TB、BP2、BP1、BP0(bit 7,5,4,3,2)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Write_SR</span><span class="params">(u8 sr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	W25QXX_CS=<span class="number">0</span>;<span class="comment">//片选</span></span><br><span class="line">	SPI1_RW_byte(W25X_WriteStatusReg);<span class="comment">//发送写寄存器命令</span></span><br><span class="line">	SPI1_RW_byte(sr);<span class="comment">//读取一个字节</span></span><br><span class="line">	W25QXX_CS=<span class="number">1</span>;<span class="comment">//取消片选</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写使能	将WEL置位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Write_Enable</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	W25QXX_CS=<span class="number">0</span>;<span class="comment">//片选</span></span><br><span class="line">	SPI1_RW_byte(W25X_WriteEnable);<span class="comment">//发送写使能命令</span></span><br><span class="line">	W25QXX_CS=<span class="number">1</span>;<span class="comment">//取消片选</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写保护	将WEL清零</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Write_Disable</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	W25QXX_CS=<span class="number">0</span>;<span class="comment">//片选</span></span><br><span class="line">	SPI1_RW_byte(W25X_WriteDisable);<span class="comment">//发送写禁止命令</span></span><br><span class="line">	W25QXX_CS=<span class="number">1</span>;<span class="comment">//取消片选</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待空闲</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Wait_Busy</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>((W25QXX_ReadSR()&amp;<span class="number">0x01</span>)==<span class="number">0x01</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进入掉电模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">W25QXX_PowerDown</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	W25QXX_CS=<span class="number">0</span>;<span class="comment">//片选</span></span><br><span class="line">	SPI1_RW_byte(W25X_PowerDown);<span class="comment">//发送掉电命令</span></span><br><span class="line">	W25QXX_CS=<span class="number">1</span>;<span class="comment">//取消片选</span></span><br><span class="line">	delay_us(<span class="number">3</span>);<span class="comment">//等待TPD</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">W25QXX_WAKEUP</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	W25QXX_CS=<span class="number">0</span>;<span class="comment">//片选</span></span><br><span class="line">	SPI1_RW_byte(W25X_ReleasePowerDown);<span class="comment">//发送唤醒命令</span></span><br><span class="line">	W25QXX_CS=<span class="number">1</span>;<span class="comment">//取消片选</span></span><br><span class="line">	delay_us(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//按页写入FLASH</span></span><br><span class="line"><span class="comment">//在指定地址开始写入最大256字节的数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Write_Page</span><span class="params">(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u16 i;</span><br><span class="line">	</span><br><span class="line">	W25QXX_Write_Enable();<span class="comment">//WEL置位</span></span><br><span class="line">	W25QXX_CS=<span class="number">0</span>;<span class="comment">//片选</span></span><br><span class="line">	SPI1_RW_byte(W25X_PageProgram);<span class="comment">//发送写页命令</span></span><br><span class="line">	SPI1_RW_byte((u8)((WriteAddr)&gt;&gt;<span class="number">16</span>));<span class="comment">//发送24位地址</span></span><br><span class="line">	SPI1_RW_byte((u8)((WriteAddr)&gt;&gt;<span class="number">8</span>));</span><br><span class="line">	SPI1_RW_byte((u8)WriteAddr);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;NumByteToWrite;i++)<span class="comment">//循环写入</span></span><br><span class="line">		SPI1_RW_byte(pBuffer[i]);</span><br><span class="line">	W25QXX_CS=<span class="number">1</span>;<span class="comment">//取消片选</span></span><br><span class="line">	W25QXX_Wait_Busy();<span class="comment">//等待写入结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//无保护写入FLASH</span></span><br><span class="line"><span class="comment">//必须确保所写地址内数据为0xFF</span></span><br><span class="line"><span class="comment">//可自动换页</span></span><br><span class="line"><span class="comment">//在指定地址开始写入指定长度的数据，但要确保地址不越界</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Write_NoCheck</span><span class="params">(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u16 page_remain;</span><br><span class="line">	page_remain=<span class="number">256</span>-WriteAddr%<span class="number">256</span>;<span class="comment">//单页剩余的字节数</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(NumByteToWrite&lt;=page_remain)<span class="comment">//待写入字节不大于单页剩余字节</span></span><br><span class="line">		page_remain=NumByteToWrite;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		W25QXX_Write_Page(pBuffer,WriteAddr,page_remain);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(NumByteToWrite==page_remain)</span><br><span class="line">			<span class="keyword">break</span>;<span class="comment">//写入结束</span></span><br><span class="line">		<span class="keyword">else</span><span class="comment">//若待写入字节数比单页剩余字节数大</span></span><br><span class="line">		&#123;</span><br><span class="line">			pBuffer+=page_remain;</span><br><span class="line">			WriteAddr+=page_remain;</span><br><span class="line">			</span><br><span class="line">			NumByteToWrite-=page_remain;<span class="comment">//减去已经写入的字节数</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(NumByteToWrite&gt;<span class="number">256</span>)<span class="comment">//若剩余字节数大于一页字节数</span></span><br><span class="line">				page_remain=<span class="number">256</span>;<span class="comment">//下页能写满</span></span><br><span class="line">			<span class="keyword">else</span><span class="comment">//若不够256个字节</span></span><br><span class="line">				page_remain=NumByteToWrite;<span class="comment">//下页不能写满</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取SPI FLASH</span></span><br><span class="line"><span class="comment">//在指定地址读取指定长度的数据</span></span><br><span class="line"><span class="comment">//pBuffer：数据储存区</span></span><br><span class="line"><span class="comment">//ReadAddr：开始读取的地址（24位）</span></span><br><span class="line"><span class="comment">//NumByteToRead：要读取的最大字节数（&lt;=65535）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Read</span><span class="params">(u8* pBuffer,u32 ReadAddr,u16 NumByteToRead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u16 i;</span><br><span class="line">	W25QXX_CS=<span class="number">0</span>;<span class="comment">//片选</span></span><br><span class="line">	SPI1_RW_byte(W25X_ReadData);<span class="comment">//发送读取命令</span></span><br><span class="line">	SPI1_RW_byte((u8)((ReadAddr)&gt;&gt;<span class="number">16</span>));<span class="comment">//发送24位地址</span></span><br><span class="line">	SPI1_RW_byte((u8)((ReadAddr)&gt;&gt;<span class="number">8</span>));</span><br><span class="line">	SPI1_RW_byte((u8)ReadAddr);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;NumByteToRead;i++)</span><br><span class="line">		pBuffer[i]=SPI1_RW_byte(<span class="number">0xFF</span>);<span class="comment">//循环从FLASH中读数</span></span><br><span class="line">	</span><br><span class="line">	W25QXX_CS=<span class="number">1</span>;<span class="comment">//取消片选</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//写入FLASH</span></span><br><span class="line"><span class="comment">//在指定地址带擦除地开始写入指定长度的数据</span></span><br><span class="line"><span class="comment">//pBuffer：数据存储区</span></span><br><span class="line"><span class="comment">//ReadAddr：开始写入的地址（24位）</span></span><br><span class="line"><span class="comment">//NumByteToRead：要写入的最大字节数（&lt;=65535）</span></span><br><span class="line">u8 W25QXX_BUFFER[<span class="number">4096</span>];<span class="comment">//缓存：保存芯片内不为空的数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Write</span><span class="params">(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u32 sec_pos;</span><br><span class="line">	u16 sec_off;</span><br><span class="line">	u16 sec_remain;</span><br><span class="line">	u16 i;</span><br><span class="line">	u8* W25QXX_BUF;</span><br><span class="line">	</span><br><span class="line">	W25QXX_BUF=W25QXX_BUFFER;</span><br><span class="line">	</span><br><span class="line">	sec_pos=WriteAddr/<span class="number">4096</span>;<span class="comment">//扇区基地址</span></span><br><span class="line">	sec_off=WriteAddr%<span class="number">4096</span>;<span class="comment">//偏移地址</span></span><br><span class="line">	sec_remain=<span class="number">4096</span>-sec_off;<span class="comment">//扇区剩余空间</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(NumByteToWrite&lt;sec_remain)</span><br><span class="line">		sec_remain=NumByteToWrite;<span class="comment">//剩余地址不大于4096个字节</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//反复执行直到完成擦除</span></span><br><span class="line">	&#123;</span><br><span class="line">		W25QXX_Read(W25QXX_BUF,sec_pos*<span class="number">4096</span>,<span class="number">4096</span>);<span class="comment">//读出全扇区内容</span></span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;sec_remain;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(W25QXX_BUF[sec_off+i]!=<span class="number">0xFF</span>)<span class="comment">//若存在非空地址</span></span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">//需要擦除</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;sec_remain)<span class="comment">//如果需要擦除</span></span><br><span class="line">		&#123;</span><br><span class="line">			W25QXX_Erase_Sector(sec_pos);<span class="comment">//那么擦除这个扇区</span></span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;sec_remain;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				W25QXX_BUF[sec_off+i]=pBuffer[i];<span class="comment">//指针指向地址为扇区基地址+偏移地址</span></span><br><span class="line">			&#125;</span><br><span class="line">			W25QXX_Write_NoCheck(W25QXX_BUF,sec_pos*<span class="number">4096</span>,<span class="number">4096</span>);<span class="comment">//写入需要的部分</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//如果不需要擦除（检查到的部分都为空）</span></span><br><span class="line">			W25QXX_Write_NoCheck(W25QXX_BUF,sec_pos*<span class="number">4096</span>,<span class="number">4096</span>);<span class="comment">//直接写入扇区区间</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(NumByteToWrite==sec_remain)<span class="comment">//若待写字节数等于扇区剩余字节数（写完惹）</span></span><br><span class="line">			<span class="keyword">break</span>;<span class="comment">//结束写入</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			sec_pos++;<span class="comment">//扇区地址+1</span></span><br><span class="line">			sec_off=<span class="number">0</span>;<span class="comment">//偏移地址为0，定位到扇区头部</span></span><br><span class="line">			</span><br><span class="line">			pBuffer+=sec_remain;<span class="comment">//指针偏移</span></span><br><span class="line">			WriteAddr+=sec_remain;<span class="comment">//写入地址偏移</span></span><br><span class="line">			NumByteToWrite-=sec_remain;<span class="comment">//待写字节数递减</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(NumByteToWrite&gt;<span class="number">4096</span>)<span class="comment">//若待写字节数比一个扇区空间大</span></span><br><span class="line">				sec_remain=<span class="number">4096</span>;<span class="comment">//下个扇区还是写不完</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				sec_remain=NumByteToWrite;<span class="comment">//下个扇区就可以写完</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整片擦除</span></span><br><span class="line"><span class="comment">//注意：等待时间较长</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Erase_Chip</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ERASE ALL CHIP!&quot;</span>);<span class="comment">//显示警告</span></span><br><span class="line">	</span><br><span class="line">	W25QXX_Write_Enable();<span class="comment">//WEL置位并等待</span></span><br><span class="line">	W25QXX_Wait_Busy();</span><br><span class="line">	</span><br><span class="line">	W25QXX_CS=<span class="number">0</span>;<span class="comment">//片选</span></span><br><span class="line">	SPI1_RW_byte(W25X_ChipErase);</span><br><span class="line">	W25QXX_CS=<span class="number">1</span>;<span class="comment">//取消片选</span></span><br><span class="line">	W25QXX_Wait_Busy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//擦除一个扇区</span></span><br><span class="line"><span class="comment">//Dst_Addr为目标扇区地址</span></span><br><span class="line"><span class="comment">//擦除一个扇区最少用时150ms</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Erase_Sector</span><span class="params">(u32 Dst_Addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x will be erase!\r\n&quot;</span>,Dst_Addr);<span class="comment">//显示警告</span></span><br><span class="line">	</span><br><span class="line">	Dst_Addr*=<span class="number">4096</span>;</span><br><span class="line">	W25QXX_Write_Enable();<span class="comment">//WEL置位并等待</span></span><br><span class="line">	W25QXX_Wait_Busy();</span><br><span class="line">	</span><br><span class="line">	W25QXX_CS=<span class="number">0</span>;<span class="comment">//片选</span></span><br><span class="line">	SPI1_RW_byte(W25X_SectorErase);</span><br><span class="line">	SPI1_RW_byte((u8)((Dst_Addr)&gt;&gt;<span class="number">16</span>));</span><br><span class="line">	SPI1_RW_byte((u8)((Dst_Addr)&gt;&gt;<span class="number">8</span>));</span><br><span class="line">	SPI1_RW_byte((u8)Dst_Addr);</span><br><span class="line">	W25QXX_CS=<span class="number">1</span>;<span class="comment">//取消片选</span></span><br><span class="line">	W25QXX_Wait_Busy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>W25Q128.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前部分略	</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25Q80 	0XEF13</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25Q16 	0XEF14</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25Q32	0XEF15</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25Q64 	0XEF16</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25Q128 0XEF17</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*W35X系列/Q系列芯片列表</span></span><br><span class="line"><span class="comment">	W25Q80 0XEF13</span></span><br><span class="line"><span class="comment">	W25Q16 0XEF14</span></span><br><span class="line"><span class="comment">	W25Q32 0XEF15</span></span><br><span class="line"><span class="comment">	W25Q64 0XEF16</span></span><br><span class="line"><span class="comment">	W25Q128 0XEF17</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">extern</span> u16 W25QXX_TYPE;<span class="comment">//定义W25QXX芯片型号</span></span><br><span class="line">	</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25QXX_CS PBout(14)<span class="comment">//PB14输出W25QXX片选信号(软件片选)</span></span></span><br><span class="line">	</span><br><span class="line"><span class="comment">/***************************指令表***************************/</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25X_WriteEnable 			0x06</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25X_WriteDisable 			0x04</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25X_ReadStatusReg 			0x05</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25X_WriteStatusReg 		0x01</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25X_ReadData 				0x03</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25X_FastReadData 			0x0B</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25X_FastReadDual 			0x3B</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25X_PageProgram 			0x02</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25X_BlockErase 			0xD8</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25X_SectorErase 			0x20</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25X_ChipErase 				0xC7</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25X_PowerDown 				0xB9</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25X_ReleasePowerDown 		0xAB</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25X_DeviceID 				0xAB</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25X_ManufactDeviceID 		0x90</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25X_JedecDeviceID 			0x9F</span></span><br><span class="line"><span class="comment">/***************************指令表***************************/</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">W25QXX_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//FLASH初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="function">u16  <span class="title">W25QXX_ReadID</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//读取FLASH ID</span></span><br><span class="line">	<span class="function">u8 	 <span class="title">W25QXX_ReadSR</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//读取状态寄存器</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Write_SR</span><span class="params">(u8 sr)</span></span>;<span class="comment">//写状态寄存器</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Write_Enable</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//写使能</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Write_Disable</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//写保护</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Write_NoCheck</span><span class="params">(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Read</span><span class="params">(u8* pBuffer,u32 ReadAddr,u16 NumByteToRead)</span></span>;<span class="comment">//读取FLASH</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Write</span><span class="params">(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)</span></span>;<span class="comment">//写入FLASH</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Erase_Chip</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//整片擦除</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Erase_Sector</span><span class="params">(u32 Dst_Addr)</span></span>;<span class="comment">//扇区擦除</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Wait_Busy</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//等待空闲</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">W25QXX_PowerDown</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//进入掉电模式</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">W25QXX_WAKEUP</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//唤醒</span></span><br></pre></td></tr></table></figure>

<h2 id="CAN"><a href="#CAN" class="headerlink" title="CAN"></a>CAN</h2><h3 id="协议栈-2"><a href="#协议栈-2" class="headerlink" title="协议栈"></a>协议栈</h3><p>CAN(Controller Area Network)是ISO国际标准化的串行通信协议，由德国电气商博世公司在1986年率先提出。此后CAN通过ISO11898及ISO11519进行了标准化，<strong>可靠性高</strong></p>
<p>具有两个标准：</p>
<ol>
<li><p>ISO11898高速通信标准（速率125Kbps~1Mbps）</p>
</li>
<li><p>ISO11519-2低速通信标准（速率125Kbps以下）</p>
</li>
</ol>
<p>特点：</p>
<ul>
<li>多主控制</li>
</ul>
<p>总线空闲时所有单元都可发送消息，两个以上单元同时发送消息时，根据<strong>标识符</strong>（ID，<strong>不是地址</strong>）决定优先级。对各个消息ID的各个位进行逐个仲裁比较，<strong>仲裁获胜单元可继续发送消息，失利的单元需立刻停止发送而进行接收工作</strong></p>
<ul>
<li>系统柔软性</li>
</ul>
<p>连接总线的单元没有类似地址的信息，可以很方便地<strong>添加新单元，不需要改动旧设备</strong></p>
<ul>
<li>速度快，距离远</li>
</ul>
<p>速率最高1Mbps（距离&lt;40m），最远可达10km（速率&lt;5kbps）</p>
<ul>
<li>具有错误检测、错误通知和错误恢复功能</li>
</ul>
<p><strong>所有单元都能检测错误，检测到错误会立即通知所有其他单元，正在发送消息的单元一旦检测到出错会强制结束发送，并不断反复重新发送此消息直到发送成功</strong></p>
<ul>
<li>故障封闭功能</li>
</ul>
<p>可以判断出错误的类型是总线上暂时的数据错误还是持续的数据错误。当总线上发生持续数据错误时，可将引起此故障的单元从总线上隔离出去</p>
<ul>
<li>连接节点多</li>
</ul>
<p>可同时连接多个单元，理论上没有总数限制，但实际上可连接单元越多，通信速率越慢；通信速率越快，可连接单元数越少</p>
<h4 id="底层硬件-2"><a href="#底层硬件-2" class="headerlink" title="底层硬件"></a>底层硬件</h4><p>==使用ISO11898标准==</p>
<p>CAN控制器根据CAN_L和CAN_H上的电位差来判断总线电平</p>
<p>发送方通过使总线电平发生变化将消息发送给接收方</p>
<ul>
<li><p>显性电平对应逻辑0：CAN_H与CAN_L之差在2V左右</p>
</li>
<li><p>隐性电平对应逻辑1：CAN_H与CAN_L之差为0V</p>
</li>
</ul>
<p>总线电平必为二者之一，<strong>显性电平具有优先权</strong>，只要一个单元输出显性电平，总线上即为显性电平；只有所有单元都输出隐性电平，总线上才为隐性电平</p>
<p>单元在总线上呈并联，<strong>总线起止端各有一个120Ω的终端电阻</strong>（作用：阻抗匹配，减少回波反射）</p>
<p>stm32f407自带<strong>2个</strong>基本可扩展CAN外设（bxCAN），支持CAN协议2.0A和2.0B主动模式，波特率最高1Mbps，通过GPIO复用2个引脚输出，但需要接入<strong>TJA1050</strong>电平转换ic才能正常接入CAN总线</p>
<p>每个CAN具有3个3级深度（<strong>可同时存储三条有效报文</strong>）发送邮箱，互相独立；2个接收FIFO，最多28个可变筛选器组</p>
<p><strong>两个CAN分别拥有独立的发送邮箱和接收FIFO，但他们会共用28个筛选器</strong></p>
<h5 id="CAN标识符筛选器"><a href="#CAN标识符筛选器" class="headerlink" title="CAN标识符筛选器"></a>CAN标识符筛选器</h5><p><strong>CAN的标识符</strong>不表示目标地址而是<strong>表示发送优先级</strong>，接收节点根据标识符的值决定是否接受对应信息</p>
<p>STM32 CAN控制器每个筛选器组由2个32位寄存器组成，根据位宽不同，每个筛选器组可提供</p>
<ul>
<li>1个32位筛选器，包括STDID[10:0] EXTID[17:0] IDE RTR</li>
<li>2个16位筛选器，包括STDID[10:0] IDE RTR EXTID[17:15]</li>
</ul>
<p>应用程序不用的筛选器组应当保持禁用</p>
<p>筛选器编号从0开始</p>
<p>筛选器可配置为屏蔽位模式和标识符列表模式：</p>
<ul>
<li><p>屏蔽位模式下，标识符寄存器指定报文标识符哪一位“必须匹配”；屏蔽寄存器指定报文标识符哪一位“不用关心”</p>
<p>屏蔽寄存器置0的标识寄存器对应位会被忽略</p>
<p>类似“掩码”操作，一次筛选出<strong>一组</strong>标识符</p>
</li>
<li><p>标识符列表模式下，屏蔽寄存器也被当做标识符寄存器用，接受报文标识符的每一位都必须和筛选器标识符相同</p>
<p>一次过滤出<strong>一个</strong>标识符号</p>
</li>
</ul>
<p>==举例：1个32位筛选器-标识符屏蔽模式，设置CAN_F0R1=0xFFFF0000，CAN_F0R2=0xFF00FF00，则期望收到的id形式为0xFFFF0000，同时必须关心id形式为0xFF00FF00，即标记为F的四个位必须和F0R1中的对应位一模一样，另外的六个位可以一样也可以不一样，即收到的映像必须是0xFF??00??才算是正确的，并不关心标?的位是多少==</p>
<h4 id="驱动-2"><a href="#驱动-2" class="headerlink" title="驱动"></a>驱动</h4><h5 id="CAN通信"><a href="#CAN通信" class="headerlink" title="CAN通信"></a>CAN通信</h5><ul>
<li><p>数据帧：<strong>发送单元</strong>向接收单元<strong>传送数据</strong></p>
</li>
<li><p>遥控帧：<strong>接收单元</strong>向具有相同ID的发送单元<strong>请求数据</strong></p>
</li>
<li><p>错误帧：检测出错时<strong>向其他单元通知错误</strong></p>
</li>
<li><p>过载帧：接收单元通知其<strong>尚未做好接收准备</strong>（标记忙碌状态）</p>
</li>
<li><p>间隔帧：将数据帧和遥控帧与前面的帧<strong>分隔</strong>开的帧</p>
</li>
</ul>
<p><strong>数据帧</strong>和<strong>遥控帧</strong>有<strong>11位ID的标准格式</strong>和<strong>29位ID的拓展格式</strong></p>
<h6 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h6><p>由7个段组成，下面是标准格式的实现</p>
<ol>
<li>帧起始：1位显性电平</li>
<li>仲裁段：11位ID+1位RTR（显性电平）</li>
</ol>
<p>表示数据优先级。<strong>ID高位在前，低位在后</strong>，<strong>禁止高7位都是隐性</strong>（不能ID=1111111XXXX）</p>
<p>RTR：<strong>远程请求</strong>位——0表示数据帧，1表示远程帧</p>
<p>SRR：<strong>替代远程请求</strong>位——设置为1</p>
<p>IDE：<strong>标识符选择</strong>位——0表示标准标识符，1表示扩展标识符</p>
<ol start="3">
<li>控制段：1位IDE（显性电平）+1位r0（显性电平）+4位DLC</li>
</ol>
<p>r0、r1：<strong>保留位</strong>——必须以显性电平发送，但接收可以是隐性电平</p>
<p>DLC：<strong>数据长度码</strong>——0-8表示发送/接收的数据长度（字节）</p>
<ol start="4">
<li>数据段：0-64位（0-8个字节）的数据</li>
</ol>
<p><strong>从最高位开始输出</strong></p>
<ol start="5">
<li>CRC段：15位+1位RCR界定符（隐性电平）</li>
</ol>
<p>用于检查帧传输错误</p>
<p>CRC的值计算范围包括：帧起始、仲裁段、控制段、数据段</p>
<p>接收方和发送方以同样的算法计算CRC并进行比较，不一致时会通报错误</p>
<ol start="6">
<li>ACK段：1位ACK槽（发送位为隐性电平，接收位随接收成功与否变化）+1位ACK界定符（隐性电平）</li>
</ol>
<p>用来确认是否正常接收</p>
<p><strong>发送单元ACK段发送2个隐性电平</strong></p>
<p>接收单元ACK段：<strong>接收到正确消息的单元在ACK槽发送显性位</strong>，称之为发送ACK/返回ACK</p>
<p>发送ACK的时既不处于总线关闭态也不处于休眠态的所有接受单元中，接收到正常消息（不含填充错误、格式错误、CRC错误）的单元，<strong>发送单元不会发送ACK</strong></p>
<ol start="7">
<li>帧结束：7位EOF（7位隐性电平）</li>
</ol>
<h6 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="总线仲裁"></a>总线仲裁</h6><ol>
<li>总线空闲时最先发送的单元优先，一旦发送无法被抢占</li>
<li>多个单元同时发送，连续输出显性电平多的单元优先</li>
<li>先比较ID，若ID相同，就比较RTR、SRR等位</li>
</ol>
<h6 id="位时序（波特率）"><a href="#位时序（波特率）" class="headerlink" title="位时序（波特率）"></a>位时序（波特率）</h6><p>位速率：发送单元在非同步情况下发送的每秒钟位数称为位速率</p>
<p>一个位一般可以分成四段</p>
<p>这些段又由最小时间单位Time Quantum(Tq)组成</p>
<p>1位分4段，1段分多个Tq，即<strong>位时序</strong></p>
<p>$$位时间=\frac{1}{波特率}$$</p>
<p>可以任意设定位时序，多个单元可同时采样，也可任意设定采样点</p>
<ul>
<li>同步段 SS</li>
</ul>
<p>多个单元实现时序同步，1Tq</p>
<p>电平边沿跳变最好出现在此段中</p>
<ul>
<li>传播时间段 PTS</li>
</ul>
<p>吸收网络物理延迟</p>
<p>该段时间=2*(发送单元输出延迟+总线信号传播延迟+接受单元输入延迟)=1~8Tq</p>
<ul>
<li>相位缓冲段1 PBS1</li>
</ul>
<p>1~8Tq</p>
<ul>
<li>相位缓冲段2 PBS2</li>
</ul>
<p>2~8Tq</p>
<p>两段负责补偿未被包含在SS段的信号边沿；通过对相位缓冲段加减SJW吸收细微时钟误差，但会导致通信速度下降</p>
<ul>
<li>再同步补偿宽度 SJW</li>
</ul>
<p>1~4Tq</p>
<p>补偿时钟频率偏差/传输延迟等导致误差的最大值</p>
<h5 id="STM32F407的CAN控制器设置"><a href="#STM32F407的CAN控制器设置" class="headerlink" title="STM32F407的CAN控制器设置"></a>STM32F407的CAN控制器设置</h5><p>可分为三种模式</p>
<ul>
<li><p>工作模式，通过CAN_MCR寄存器控制</p>
<p>INRQ=1,SLEEP=0 初始化工作模式</p>
<p>INRQ=0,SLEEP=0 ==正常工作==</p>
<p>SLEEP=1 开启睡眠，降低功耗</p>
</li>
<li><p>测试模式，通过CAN_BTR控制</p>
<p>LBKM=0,SLIM=1 静默，CANtx恒为1（只接收不发送），可以监控总线数据</p>
<p>LBKM=1,SLIM=0 ==环回==，CANrx被阻塞（只发送不接收）</p>
<p>LBKM=1,SLIM=1 环回静默，CANrx、CANtx都被阻塞（不接收不发送）</p>
</li>
<li><p>调试模式</p>
</li>
</ul>
<h5 id="CAN发收流程"><a href="#CAN发收流程" class="headerlink" title="CAN发收流程"></a>CAN发收流程</h5><h6 id="CAN发送流程"><a href="#CAN发送流程" class="headerlink" title="CAN发送流程"></a>CAN发送流程</h6><ol>
<li>选择空置邮箱（TME=1）</li>
<li>设置标识符（ID）、数据长度、待发送的数据内容</li>
<li>设置CAN_TIxR的TXRQ位为1，请求发送</li>
<li>邮箱挂号，等待成为最高优先级才能够发送</li>
<li>预定发送，等待总线空闲</li>
<li>发送数据</li>
<li>邮箱空置</li>
</ol>
<p>可随时置ABRQ为1退出发送进入等待，如果发送失败则可以重新等待发送或重启发动流程</p>
<h6 id="CAN接收流程"><a href="#CAN接收流程" class="headerlink" title="CAN接收流程"></a>CAN接收流程</h6><ol>
<li>FIFO为空</li>
<li>收到有效报文（被正确接收（直到EOF都未出现错误）且通过标识符过滤的报文）</li>
<li>挂号1，存入FIFO的一个邮箱（此步骤由硬件完成）</li>
<li>收到有效报文</li>
<li>挂号2</li>
<li>收到有效报文</li>
<li>挂号3</li>
<li>收到有效报文</li>
<li>溢出，可设置是否锁定，锁定后新数据将被丢弃，不锁定则新数据会替代老数据</li>
</ol>
<p>通过读取CAN_RFxR的FMP寄存器获取FIFO中当前存储的数据条数，只要不为0则可以读取报文</p>
<h6 id="STM32-CAN位时序"><a href="#STM32-CAN位时序" class="headerlink" title="STM32 CAN位时序"></a>STM32 CAN位时序</h6><p>$波特率=\frac{1}{正常的位时间}$</p>
<p>$正常的位时间=1*t_q+t_{BS1}+t_{BS2}$</p>
<p>$t_{BS1}=t_q*(TS1[3:0]+1)$</p>
<p>$t_{BS2}=t_q*(TS2[2:0]+1)$</p>
<p>$t_q=(BRP[9:0]+1)*t_{PCLK}$</p>
<p>$t_q$代表1个时间单元，$t_{PCLK}$表示APB时钟的时钟周期</p>
<p>对于stm32f407，设置TS1=6,TS2=5,BRP=5</p>
<p>$波特率=\frac{42000}{[(7+6+1)*6]}=500Kbps$</p>
<h4 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h4><p>初始化流程</p>
<ol>
<li>配置引脚复用</li>
<li>使能CAN控制器时钟</li>
<li>设置CAN工作模式和波特率</li>
<li>设置过滤器</li>
<li>CAN自动开始工作</li>
</ol>
<p>can.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;can.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//CAN1初始化</span></span><br><span class="line"><span class="comment">//使用PA11、PA12引脚输入输出</span></span><br><span class="line"><span class="comment">/***********************************************</span></span><br><span class="line"><span class="comment">	Tsjw：重新同步跳跃时间单元，范围1Tq-4Tq CAN_BS1_1tq-CAN_BS1_16tq</span></span><br><span class="line"><span class="comment">	Tbs2：时间段2的时间单元，范围1Tq-8Tq CAN_BS2_1tq-CAN_BS2_8tq</span></span><br><span class="line"><span class="comment">	Tbs1：时间段1的时间单元，范围1Tq-16Tq</span></span><br><span class="line"><span class="comment">	brp：波特率分频器，范围1-1024	</span></span><br><span class="line"><span class="comment">	计算公式：1个时间单元Tq=(brp)*Tpclk1</span></span><br><span class="line"><span class="comment">	波特率=Fpclk1/(brp*(tbs1+1+tbs2+1+1))</span></span><br><span class="line"><span class="comment">	mode：CAN_Mode_Normal为普通模式，CAN_Mode_LoopBack为回环模式</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	Fpclk1时钟在初始化时设置为36MHz，</span></span><br><span class="line"><span class="comment">	如果设置sjw=1,bs2=8,bs1=9,brp=4,回环模式，则波特率为36M/((8+9+1)*4)=500Kbps</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	返回0则正常初始化，返回其他则初始化失败</span></span><br><span class="line"><span class="comment">************************************************/</span></span><br><span class="line"><span class="function">u8 <span class="title">CAN1_Mode_init</span><span class="params">(u8 Tsjw,u8 Tbs2,u8 Tbs1,u16 brp,u8 mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	CAN_InitTypeDef CAN_InitStruct;</span><br><span class="line">	CAN_FilterInitTypeDef CAN_FilterInitStruct;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//如果使能FIFO消息挂号中断则开启</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> CAN1_RX0_INT_ENABLE</span></span><br><span class="line">		NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">	</span><br><span class="line">		CAN_ITConfig(CAN1,CAN_IT_FMP0,ENABLE);<span class="comment">//使能FIFO消息挂号中断</span></span><br><span class="line">		NVIC_InitStructure.NVIC_IRQChannel=CAN1_RX0_IRQn;</span><br><span class="line">		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span>;<span class="comment">//抢占优先级为1</span></span><br><span class="line">		NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">0</span>;<span class="comment">//子优先级为0</span></span><br><span class="line">		NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;<span class="comment">//使能FIFO消息挂号中断</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1. 使能GPIO和CAN控制器时钟</span></span><br><span class="line">	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,ENABLE);</span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2. 初始化PA11、PA12</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF;<span class="comment">//引脚复用</span></span><br><span class="line">	GPIO_InitStructure.GPIO_OType=GPIO_OType_PP;<span class="comment">//推挽输出</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_11|GPIO_Pin_12;<span class="comment">//PA11、PA12</span></span><br><span class="line">	GPIO_InitStructure.GPIO_PuPd=GPIO_PuPd_UP;<span class="comment">//内部上拉</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_100MHz;<span class="comment">//100Mhz</span></span><br><span class="line">	<span class="comment">//应用设置</span></span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2. 设置引脚复用映射</span></span><br><span class="line">	GPIO_PinAFConfig(GPIOA,GPIO_PinSource11,GPIO_AF_CAN1);<span class="comment">//PA11复用为CAN1</span></span><br><span class="line">	GPIO_PinAFConfig(GPIOA,GPIO_PinSource12,GPIO_AF_CAN1);<span class="comment">//PA12复用为CAN1</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3. 设置CAN控制器</span></span><br><span class="line">		<span class="comment">//软件管理设定</span></span><br><span class="line">	CAN_InitStruct.CAN_TTCM=DISABLE;<span class="comment">//非时间触发 通信模式</span></span><br><span class="line">	CAN_InitStruct.CAN_ABOM=DISABLE;<span class="comment">//软件自动离线管理</span></span><br><span class="line">	CAN_InitStruct.CAN_AWUM=DISABLE;<span class="comment">//睡眠模式通过软件唤醒</span></span><br><span class="line">		<span class="comment">//报文相关设定</span></span><br><span class="line">	CAN_InitStruct.CAN_NART=ENABLE;<span class="comment">//禁止报文自动传送</span></span><br><span class="line">	CAN_InitStruct.CAN_RFLM=DISABLE;<span class="comment">//报文不锁定，新报文将覆盖堆积旧报文</span></span><br><span class="line">	CAN_InitStruct.CAN_TXFP=DISABLE;<span class="comment">//优先级由报文标识符决定</span></span><br><span class="line">		<span class="comment">//参数设置</span></span><br><span class="line">	CAN_InitStruct.CAN_Mode=mode;<span class="comment">//模式设置</span></span><br><span class="line">	CAN_InitStruct.CAN_SJW=Tsjw;<span class="comment">//同步跳跃宽度设置</span></span><br><span class="line">	CAN_InitStruct.CAN_BS1=Tbs1;<span class="comment">//Tbs1 设置为CAN_BS1_1tq-CAN_BS1_16tq</span></span><br><span class="line">	CAN_InitStruct.CAN_BS2=Tbs2;<span class="comment">//Tbs2 设置为CAN_BS2_1tq-CAN_BS2_8tq</span></span><br><span class="line">	CAN_InitStruct.CAN_Prescaler=brp;<span class="comment">//分频系数=brp+1</span></span><br><span class="line">	<span class="comment">//应用设置</span></span><br><span class="line">	CAN_Init(CAN1,&amp;CAN_InitStruct);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//4. 设置标识符过滤器</span></span><br><span class="line">		<span class="comment">//基础设置</span></span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterNumber=<span class="number">0</span>;<span class="comment">//使用过滤器0</span></span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterMode=CAN_FilterMode_IdMask;<span class="comment">//使用标识符屏蔽模式</span></span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterScale=CAN_FilterScale_32bit;<span class="comment">//使用32位寄存器模式</span></span><br><span class="line">		<span class="comment">//32位ID设置</span></span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterIdHigh=<span class="number">0x0000</span>;</span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterIdLow=<span class="number">0x0000</span>;</span><br><span class="line">		<span class="comment">//32位掩码设置</span></span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterMaskIdHigh=<span class="number">0x0000</span>;</span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterMaskIdLow=<span class="number">0x0000</span>;</span><br><span class="line">		<span class="comment">//应用过滤器和FIFO设置</span></span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterFIFOAssignment=CAN_Filter_FIFO0;<span class="comment">//使用FIFO0</span></span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterActivation=ENABLE;<span class="comment">//激活标识符过滤器0</span></span><br><span class="line">	<span class="comment">//应用设置</span></span><br><span class="line">	CAN_FilterInit(&amp;CAN_FilterInitStruct);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//完成初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果使能FIFO消息挂号中断则开启，负责接收剩余信息</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CAN1_RX0_INT_ENABLE</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">CAN1_RX0_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		CanRxMsg CAN_rx_massage;</span><br><span class="line">		<span class="keyword">int</span> CAN_rx_counter=<span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		CAN_Receive(CAN1,<span class="number">0</span>,&amp;CAN_rx_massage);</span><br><span class="line">		<span class="keyword">for</span>(CAN_rx_counter=<span class="number">0</span>;CAN_rx_counter&lt;<span class="number">8</span>;CAN_rx_counter++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;rxbuf[%d]:%d\r\n&quot;</span>,CAN_rx_counter,CAN_rx_massage.Data[CAN_rx_counter]);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//CAN发送数据</span></span><br><span class="line"><span class="comment">//固定格式：ID=0x12，标准帧，数据帧</span></span><br><span class="line"><span class="comment">//msg为数据指针，最大8个字节</span></span><br><span class="line"><span class="comment">//len为数据长度	0-8</span></span><br><span class="line"><span class="comment">//返回0表示成功，返回1表示失败</span></span><br><span class="line"><span class="function">u8 <span class="title">CAN1_tx_msg</span><span class="params">(u8* msg,u8 len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 mbox;</span><br><span class="line">	u16 i=<span class="number">0</span>;</span><br><span class="line">	CanTxMsg CAN_tx_massage;</span><br><span class="line">	</span><br><span class="line">	CAN_tx_massage.StdId=<span class="number">0x12</span>;<span class="comment">//标准标识符为0</span></span><br><span class="line">	CAN_tx_massage.ExtId=<span class="number">0x12</span>;<span class="comment">//设置29位扩展标识符</span></span><br><span class="line">	CAN_tx_massage.IDE=<span class="number">0</span>;<span class="comment">//使用扩展标识符</span></span><br><span class="line">	CAN_tx_massage.RTR=<span class="number">0</span>;<span class="comment">//消息类型：数据帧，1帧8位</span></span><br><span class="line">	CAN_tx_massage.DLC=len;<span class="comment">//发送2帧消息</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">		CAN_tx_massage.Data[i]=msg[i];<span class="comment">//发送信息</span></span><br><span class="line">	</span><br><span class="line">	mbox=CAN_Transmit(CAN1,&amp;CAN_tx_massage);</span><br><span class="line">	</span><br><span class="line">	i=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>((CAN_TransmitStatus(CAN1,mbox)==CAN_TxStatus_Failed)&amp;&amp;(i&lt;<span class="number">0xFFF</span>))</span><br><span class="line">		i++;</span><br><span class="line">	<span class="keyword">if</span>(i&gt;=<span class="number">0xfff</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CAN接收数据</span></span><br><span class="line"><span class="comment">//buf为数据缓存区</span></span><br><span class="line"><span class="comment">//返回0表示无数据被接收到，若接收到数据则返回接收的数据长度</span></span><br><span class="line"><span class="function">u8 <span class="title">CAN1_rx_msg</span><span class="params">(u8* buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u32 i;</span><br><span class="line">	CanRxMsg CAN_rx_massage;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(CAN_MessagePending(CAN1,CAN_FIFO0)==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	CAN_Receive(CAN1,CAN_FIFO0,&amp;CAN_rx_massage);<span class="comment">//读取数据</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;CAN_rx_massage.DLC;i++)</span><br><span class="line">		buf[i]=CAN_rx_massage.Data[i];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> CAN_rx_massage.DLC;<span class="comment">//返回接收到的数据长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>can.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __CAN_H</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> __CAN_H</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">	<span class="function">u8 <span class="title">CAN1_mode_init</span><span class="params">(u8 Tsjw,u8 Tbs2,u8 Tbs1,u16 brp,u8 mode)</span></span>;<span class="comment">//CAN1初始化函数</span></span><br><span class="line">	<span class="function">u8 <span class="title">CAN1_tx_msg</span><span class="params">(u8* msg,u8 len)</span></span>;<span class="comment">//CAN发送数据</span></span><br><span class="line">	<span class="function">u8 <span class="title">CAN1_rx_msg</span><span class="params">(u8* buf)</span></span>;<span class="comment">//CAN接收数据</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>main.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;dac.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;dht11.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;dma.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stmflash.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;can.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 key,res,i=<span class="number">0</span>,t=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">	u8 CAN_buf[<span class="number">8</span>];</span><br><span class="line">	u8 mode=<span class="number">1</span>;<span class="comment">//CAN工作模式：1为环回模式，0为普通模式</span></span><br><span class="line">	</span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//中断优先级分组2</span></span><br><span class="line">	</span><br><span class="line">	delay_init(<span class="number">168</span>);</span><br><span class="line">	uart_init(<span class="number">115200</span>);<span class="comment">//串口波特率115200</span></span><br><span class="line">	LED_init();</span><br><span class="line">	LCD_init();</span><br><span class="line">	KEY_init();</span><br><span class="line">	CAN1_mode_init(CAN_SJW_1tq,CAN_BS2_6tq,CAN_BS1_7tq,<span class="number">6</span>,CAN_Mode_LoopBack);<span class="comment">//初始化为环回模式，波特率500kbps</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		key=KEY_scan(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(key==KEY0_PRES)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				CAN_buf[i]=cnt+<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(i&lt;<span class="number">4</span>)</span><br><span class="line">					LCD_ShowxNum(<span class="number">30</span>+i*<span class="number">32</span>,<span class="number">210</span>,CAN_buf[i],<span class="number">3</span>,<span class="number">16</span>,<span class="number">0x80</span>);<span class="comment">//显示数据</span></span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					LCD_ShowxNum(<span class="number">30</span>+(i<span class="number">-4</span>)*<span class="number">32</span>,<span class="number">230</span>,CAN_buf[i],<span class="number">3</span>,<span class="number">16</span>,<span class="number">0x80</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			res=CAN1_tx_msg(CAN_buf,<span class="number">8</span>);<span class="comment">//发送8个字节</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(res)</span><br><span class="line">				LCD_ShowString(<span class="number">30</span>+<span class="number">80</span>,<span class="number">190</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;Failed&quot;</span>);<span class="comment">//发送失败</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				LCD_ShowString(<span class="number">30</span>+<span class="number">80</span>,<span class="number">190</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;OK    &quot;</span>);<span class="comment">//发送成功</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(KEY_init==WKUP_PRES)</span><br><span class="line">		&#123;</span><br><span class="line">			mode=!mode;</span><br><span class="line">			CAN1_mode_init(CAN_SJW_1tq,CAN_BS2_6tq,CAN_BS1_7tq,<span class="number">6</span>,mode);<span class="comment">//初始化为普通模式，波特率500kbps</span></span><br><span class="line">			</span><br><span class="line">			POINT_COLOR=RED;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(mode==<span class="number">0</span>)<span class="comment">//普通模式，使用两套开发板通信</span></span><br><span class="line">			&#123;</span><br><span class="line">				LCD_ShowString(<span class="number">30</span>,<span class="number">130</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;Normal Mode&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span><span class="comment">//环回模式</span></span><br><span class="line">			&#123;</span><br><span class="line">				LCD_ShowString(<span class="number">30</span>,<span class="number">130</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;LoopBack Mode&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		key=CAN1_rx_msg();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(key)</span><br><span class="line">		&#123;</span><br><span class="line">			LCD_Fill(<span class="number">30</span>,<span class="number">270</span>,<span class="number">160</span>,<span class="number">310</span>,WHITE);</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;key;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(i&lt;<span class="number">4</span>)</span><br><span class="line">					LCD_ShowxNum(<span class="number">30</span>+i*<span class="number">32</span>,<span class="number">270</span>,CAN_buf[i],<span class="number">3</span>,<span class="number">16</span>,<span class="number">0x80</span>);<span class="comment">//显示数据</span></span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					LCD_ShowxNum(<span class="number">30</span>+(i<span class="number">-4</span>)*<span class="number">32</span>,<span class="number">290</span>,CAN_buf[i],<span class="number">3</span>,<span class="number">16</span>,<span class="number">0x80</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		t++;</span><br><span class="line">		delay_ms(<span class="number">10</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(t==<span class="number">20</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			LED0=!LED0;</span><br><span class="line">			t=<span class="number">0</span>;</span><br><span class="line">			cnt++;</span><br><span class="line">			LCD_ShowxNum(<span class="number">30</span>+<span class="number">48</span>,<span class="number">170</span>,cnt,<span class="number">3</span>,<span class="number">16</span>,<span class="number">0x80</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">stm32</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2021/11/19/STM32%E5%A4%96%E8%AE%BE%E9%85%8D%E7%BD%AE%E9%80%9F%E6%9F%A5%E3%80%90%E6%9D%BF%E7%BA%A7%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE%E3%80%91/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-STM32外设配置速查【摄像头】" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/19/STM32%E5%A4%96%E8%AE%BE%E9%85%8D%E7%BD%AE%E9%80%9F%E6%9F%A5%E3%80%90%E6%91%84%E5%83%8F%E5%A4%B4%E3%80%91/">STM32外设配置速查【摄像头】</a>
    </h1>
  

        
<!-- 显示阅读次数-->
<!--  -->
<!--显示阅读次数完毕 -->

        
        <a href="/2021/11/19/STM32%E5%A4%96%E8%AE%BE%E9%85%8D%E7%BD%AE%E9%80%9F%E6%9F%A5%E3%80%90%E6%91%84%E5%83%8F%E5%A4%B4%E3%80%91/" class="archive-article-date">
  	<time datetime="2021-11-19T08:04:28.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2021-11-19</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="OV2640"><a href="#OV2640" class="headerlink" title="OV2640"></a>OV2640</h1><p>OV2640是OmniVision公司生产的1/4英寸CMOS UXGA(1632_1232分辨率)图像传感器</p>
<p>特点：</p>
<ul>
<li>体积小、工作电压低、灵敏度高</li>
<li>具有单片UXGA摄像头和影像处理器的所有功能</li>
<li>通过SCCB总线控制</li>
<li>可输出整帧、子采样、缩放、取窗口等方式各种分辨率的8/10位影像数据</li>
<li>最高帧数15帧/秒（SVGA可达30帧，CIF可达60帧）</li>
<li>用户定义图像质量、数据格式、传输方式等</li>
<li>所有图像处理功能都可以通过==SCCB接口==（行摄像机控制总线协议，相当于一个简易的I2C协议）编程</li>
<li>==兼容I2C接口==</li>
<li>支持RawRGB、RGB、GRB422、YUV和YCbCr输出格式</li>
<li>内置DSP，<strong>支持UXGA、SXGA、SVGA以及按比例缩小到从SXGA到40*30的任何尺寸</strong>，支持图像缩放</li>
<li>支持自动曝光控制、自动增益控制、自动白平衡、自动消除灯光条纹、自动黑电平校准等自动控制功能和色饱和度、色相、伽马、锐度等设置，支持闪光灯</li>
<li>支持图像压缩，可输出JPEG图像数据</li>
</ul>
<h2 id="SCCB时序"><a href="#SCCB时序" class="headerlink" title="SCCB时序"></a>SCCB时序</h2><p>SCCB（Serial Camera Control Bus串行摄像头控制总线）总线是由OV（OmniVision）公司定义和发展的三线式串行总线。现在SCCB总线大多采用两线式接口总线，接口总线包括SIOC串行时钟输入线和SIOD串行双向数据线，分别相当于IIC协议的SCL信号线和SDA信号线。<strong>SCCB就是个简化版的IIC</strong>，可以直接使用IIC的软件驱动代码改编成SCCB的驱动</p>
<h3 id="基本概念简介"><a href="#基本概念简介" class="headerlink" title="基本概念简介"></a>基本概念简介</h3><table>
<thead>
<tr>
<th>UXGA</th>
<th>1600*1200</th>
</tr>
</thead>
<tbody><tr>
<td>SXGA</td>
<td>1280*1024</td>
</tr>
<tr>
<td>XVGA</td>
<td>1280*960</td>
</tr>
<tr>
<td>WXGA</td>
<td>1280*800</td>
</tr>
<tr>
<td>XGA</td>
<td>1024*768</td>
</tr>
<tr>
<td>SVGA</td>
<td>800*600</td>
</tr>
<tr>
<td>VGA</td>
<td>640*480</td>
</tr>
<tr>
<td>QQVGA</td>
<td>160*120</td>
</tr>
<tr>
<td>CIF</td>
<td>352*288</td>
</tr>
<tr>
<td>PCLK</td>
<td>像素时钟：一个PCLK时钟，输出一个(Raw格式)或半个(RGB565格式)像素</td>
</tr>
<tr>
<td>VSYNC</td>
<td>帧同步信号</td>
</tr>
<tr>
<td>HREF/HSYNC</td>
<td>行同步信号</td>
</tr>
</tbody></table>
<p>ov2640的图像数据输出通过Y[9:0]寄存器输出，这里只使用一**字节(8位)**数据，再PCLK、VSYNC、HREF/HSYNC控制下进行</p>
<p>==对于Raw格式数据，$1<em>t_p=1</em>T_{PCLK}$==</p>
<p>==对于YUV/RGB格式数据，$1<em>t_p=2</em>T_{PCLK}$==</p>
<h3 id="行输出时序"><a href="#行输出时序" class="headerlink" title="行输出时序"></a>行输出时序</h3><p><strong>HREF高电平</strong>期间的<strong>PCLK上升沿</strong>进行输出，每个PCLK上升沿从Y[9:0]输出一个**字节(8位)**数据</p>
<p>PCLK最大可达36MHz</p>
<p>例：以<strong>UXGA(1600*1200)<strong>时序，采用</strong>RGB565</strong>格式输出，每2字节组成一个像素的颜色，且低字节在前高字节在后。这样<strong>每行</strong>输出总共有<strong>1600*2个PCLK周期</strong>，<strong>输出1600*2个字节</strong></p>
<h3 id="帧输出时序"><a href="#帧输出时序" class="headerlink" title="帧输出时序"></a>帧输出时序</h3><p><strong>输出开始时，VSYNC输出$4*t_{LINE}$有效电平</strong>（可自行设置为高/低）脉冲</p>
<p><strong>$27193*t_p$后，HREF拉高，开始输出行数据</strong>，每行数据输出之间以$322*t_p$为间隔，直到完成所有行输出</p>
<p>最后会有$57697*t_p$间隔才能进行下一帧输出</p>
<h3 id="JPEG时序"><a href="#JPEG时序" class="headerlink" title="JPEG时序"></a>JPEG时序</h3><p>JPEG输出时，PCLK大大减少，HREF不连续，数据流以0xFF、0xD8开头，以0xFF、0xD9结束，将此间数据保存为.jpg文件即可在电脑打开查看</p>
<h2 id="相关硬件配置"><a href="#相关硬件配置" class="headerlink" title="相关硬件配置"></a>相关硬件配置</h2><h3 id="OV2640传感器窗口设置"><a href="#OV2640传感器窗口设置" class="headerlink" title="OV2640传感器窗口设置"></a>OV2640传感器窗口设置</h3><p>传感器窗口设置允许用户设置整个传感器区域（1632*1220）的感兴趣部分，即<strong>在传感器里面开窗</strong>，开窗范围从2*2到1632*1220都可以设置，但<strong>要求这个窗口必须大于等于随后设置的图像尺寸</strong></p>
<p>详细内容可查看数据手册</p>
<h3 id="图像尺寸设置"><a href="#图像尺寸设置" class="headerlink" title="图像尺寸设置"></a>图像尺寸设置</h3><p>即<strong>DSP输出到LCD的图像最大尺寸</strong>，该尺寸要小于等于传感器窗口设置所设定的窗口尺寸</p>
<h3 id="图像窗口设置"><a href="#图像窗口设置" class="headerlink" title="图像窗口设置"></a>图像窗口设置</h3><p>在设置的图像尺寸里面再次设置窗口大小，该窗口必须小于等于前面设置的图像尺寸，<strong>该窗口设置后的图像范围将用于输出到外部</strong></p>
<h3 id="图像输出大小设置（缩放设置）"><a href="#图像输出大小设置（缩放设置）" class="headerlink" title="图像输出大小设置（缩放设置）"></a>图像输出大小设置（缩放设置）</h3><p><strong>控制最终输出到外部的图像尺寸</strong></p>
<p>该设置仅会对图像进行缩放处理，如果设置的图像输出大小不等于图像窗口设置图像大小，那么图像就会被缩放处理，<strong>只有两者大小一样（图像输出大小=图像窗口设置大小）时，输出比例才是1：1</strong></p>
<h3 id="OV2640模块参数"><a href="#OV2640模块参数" class="headerlink" title="OV2640模块参数"></a>OV2640模块参数</h3><ol>
<li>支持RGB565/JPEG数据输出</li>
<li>支持最大UXGA分辨率输出</li>
<li>支持图像任意缩放</li>
<li>自带24M有源晶振、3.3V稳压电路、带滤光片的感光红外镜头</li>
<li>支持手动对焦（旋下盖上螺丝调节镜头即可）</li>
</ol>
<p>引脚参数：</p>
<table>
<thead>
<tr>
<th>脚位</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>GND</td>
<td>接地</td>
</tr>
<tr>
<td>2</td>
<td>VCC3.3</td>
<td>接3.3V电源</td>
</tr>
<tr>
<td>3</td>
<td>OV_SCL</td>
<td>SCCB时钟线（I）</td>
</tr>
<tr>
<td>4</td>
<td>OV_VSYNC</td>
<td>帧同步信号（O）</td>
</tr>
<tr>
<td>5</td>
<td>OV_SDA</td>
<td>SCCB数据线（I/O）</td>
</tr>
<tr>
<td>6</td>
<td>OV_HREF</td>
<td>行同步信号（O）</td>
</tr>
<tr>
<td>8</td>
<td>OV_RESET</td>
<td>复位信号，低电平有效（I）</td>
</tr>
<tr>
<td>15</td>
<td>OV_PCLK</td>
<td>像素时钟（O）</td>
</tr>
<tr>
<td>17</td>
<td>OV_PWDN</td>
<td>掉电模式使能，高电平有效（I）</td>
</tr>
<tr>
<td>18</td>
<td>NC</td>
<td>空脚</td>
</tr>
<tr>
<td>7、9、10、11、12、13、14、16</td>
<td>OV_D0~D7</td>
<td>数据线（O）</td>
</tr>
</tbody></table>
<h2 id="OV2640模块使用过程"><a href="#OV2640模块使用过程" class="headerlink" title="OV2640模块使用过程"></a>OV2640模块使用过程</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ol>
<li>初始化IO口</li>
<li>上电、复位</li>
<li>读取传感器ID</li>
<li>执行初始化序列</li>
</ol>
<p>全部内容由OV2640公司提供源码</p>
<h3 id="MCU读取模块图像数据"><a href="#MCU读取模块图像数据" class="headerlink" title="MCU读取模块图像数据"></a>MCU读取模块图像数据</h3><ol>
<li>等待帧同步（等待VSYNC信号）</li>
<li>等待HRED为高电平</li>
<li>等待第一个PCLK上升沿</li>
<li>读取第一个像素的低字节</li>
<li>等待第二个PCLK上升沿</li>
<li>读取第一个像素的高字节</li>
<li>等待下一个PCLK上升沿</li>
<li>重复4-7步骤直到读完剩余像素</li>
<li>结束读取</li>
</ol>
<h1 id="DCMI接口"><a href="#DCMI接口" class="headerlink" title="DCMI接口"></a>DCMI接口</h1><p>DCMI(Digital Camera Interface)是STM32F4xx自带的数字摄像头接口，属于同步并行接口</p>
<p>特性：</p>
<ul>
<li><p>能够接受外部8、10、12、14位并行接口最高54MB/s的高速数据流</p>
</li>
<li><p>支持内嵌码/外部行同步/帧同步</p>
</li>
<li><p>支持连续模式或快照模式</p>
</li>
<li><p>支持裁剪功能</p>
</li>
<li><p>可支持不同数据格式：单色或原始拜尔（Bayer）格式、YCbCr 4:2:2逐行视频、RGB565逐行视频、压缩数据(JPEG)格式</p>
</li>
<li><p>接口通过FIFO和数据格式化器直接与AHB总线相连</p>
</li>
</ul>
<p>该接口包含14条数据线（D13-D0）和1条像素时钟线（PIXCLK），且像素时钟的有效电平可由用户程序决定，能在像素时钟的上升沿或下降沿捕获数据</p>
<p>DCMI接口包含以下信号：</p>
<table>
<thead>
<tr>
<th>DCMI接口</th>
<th>引脚</th>
<th>别名</th>
<th>对应OV2640接口</th>
<th>引脚</th>
</tr>
</thead>
<tbody><tr>
<td>数据流输入</td>
<td>D[0:13]</td>
<td></td>
<td>数据流输出</td>
<td>D[0:7]</td>
</tr>
<tr>
<td>水平同步</td>
<td>输入HREF/HSYNC</td>
<td>行同步</td>
<td>行同步信号</td>
<td>HREF/HSYNC</td>
</tr>
<tr>
<td>垂直同步</td>
<td>输入VSYNC</td>
<td>帧同步/场同步</td>
<td>帧同步信号</td>
<td>VSYNC</td>
</tr>
<tr>
<td>像素时钟输入</td>
<td>PIXCLK</td>
<td>像素时钟</td>
<td>像素时钟</td>
<td>PCLK</td>
</tr>
</tbody></table>
<h3 id="时序"><a href="#时序" class="headerlink" title="时序"></a>时序</h3><p>数据与PIXCLK同步，并根据像素时钟的极性在像素时钟上升沿/下降沿发生变化</p>
<p>HREF/HSYNC指示行的开始或结束，VSYNC指示帧的开始或结束</p>
<p>DCMI时序与上述OV2640时序基本一致，但DCMI的PIXCLK有效沿可自定义，且<strong>HSYNC、VSYNC有效状态对应指示数据在并行接口上无效时，HSYNC/VSYNC引脚上的引脚电平</strong>（人话：==和OV2640的有效状态相反==）</p>
<h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><p>DCMI接收到的数据存储在DCMI_DR 32位寄存器内，接入OV2640模块时采用8位数据宽度，所以<strong>每4个像素时钟才捕获完32位数据</strong>，第一个字节存放在LSB位置，第四个字节存放在MSB位置遵守<strong>低字节在前，高字节在后</strong></p>
<p>==<strong>DCMI支持DMA传输</strong>==，DCMI可被配置为每在其数据寄存器中收到一个完整的32位数据块时，发送一个DMA请求，由DMA将寄存器内的值搬运到目的地址（如LCD/SRAM）</p>
<p>注意：DCMI的DMA请求映射在<strong>DMA2 Channel1 Stream1</strong>上；如果使用DCMI-&gt;DMA-&gt;LCD的传输路径，因为LCD是16位宽（RGB565），但DCMI_DR是32位宽，所以一次<strong>DCMI引起的DMA请求将引发往LCD写2次数据</strong></p>
<h2 id="相关设置"><a href="#相关设置" class="headerlink" title="相关设置"></a>相关设置</h2><p>DCMI支持连续模式和快照模式，连续模式=录像；快照模式=照相</p>
<p>DCMI支持内嵌码同步和硬件同步，一般采用硬件同步 </p>
<p>硬件同步下使用HSYNC和VSYNC两个信号，系统会忽略两个信号有效电平期间接收的所有数据，即<strong>硬件同步模式下的HSYNC、VSYNC信号相当于消隐信号</strong></p>
<h2 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h2><ol>
<li>配置相关引脚复用为DCMI</li>
<li>使能DCMI时钟</li>
<li>设置DCMI工作模式和PCLK、HSYNC、VSYNC等参数</li>
<li>设置DMA搬运DCMI数据</li>
<li>使能DCMI传输</li>
</ol>
<h1 id="实际配置方法与代码"><a href="#实际配置方法与代码" class="headerlink" title="实际配置方法与代码"></a>实际配置方法与代码</h1><h2 id="硬件配置"><a href="#硬件配置" class="headerlink" title="硬件配置"></a>硬件配置</h2><p>OV2640模块-转接-DCMI接口 对应好即可</p>
<h2 id="软件配置"><a href="#软件配置" class="headerlink" title="软件配置"></a>软件配置</h2><ol>
<li>sccb协议驱动（与I2C协议类似）</li>
</ol>
<p>sccb.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SCCB_H</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> __SCCB_H</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line">	<span class="comment">//IO方向设置</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> SCCB_SDA_IN() &#123;GPIOD-&gt;MODER&amp;=~(3<span class="meta-string">&lt;&lt;(7*2));GPIOD-&gt;</span>MODER|=0&lt;&lt;7*2;&#125; <span class="comment">//PD7输入</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> SCCB_SDA_OUT() &#123;GPIOD-&gt;MODER&amp;=~(3<span class="meta-string">&lt;&lt;(7*2));GPIOD-&gt;</span>MODER|=1&lt;&lt;7*2;&#125; <span class="comment">//PD7输出</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//IO操作函数</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> SCCB_SCL PDout(6) <span class="comment">//PD6配置为SCL(仅输出)</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> SCCB_SDA PDout(7) <span class="comment">//SDA输出</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> SCCB_READ_SDA PDin(7) <span class="comment">//SDA输出</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> SCCB_ID 0X60 <span class="comment">//OV2640的ID</span></span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SCCB_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//SCCB接口初始化</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SCCB_Start</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//起始信号</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SCCB_Stop</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//停止信号</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SCCB_No_Ack</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//NA信号</span></span><br><span class="line">	<span class="function">u8 <span class="title">SCCB_WR_Byte</span><span class="params">(u8 dat)</span></span>;<span class="comment">//写数据</span></span><br><span class="line">	<span class="function">u8 <span class="title">SCCB_RD_Byte</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//读数据</span></span><br><span class="line">	<span class="function">u8 <span class="title">SCCB_WR_Reg</span><span class="params">(u8 reg,u8 data)</span></span>;<span class="comment">//写寄存器</span></span><br><span class="line">	<span class="function">u8 <span class="title">SCCB_RD_Reg</span><span class="params">(u8 reg)</span></span>;<span class="comment">//读寄存器</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>sccb.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sccb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化SCCB接口 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SCCB_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GPIO_InitTypeDef  GPIO_InitStructure;</span><br><span class="line"></span><br><span class="line">	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);<span class="comment">//使能GPIOD时钟</span></span><br><span class="line">    </span><br><span class="line">	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_6|GPIO_Pin_7;<span class="comment">//PD6、PD7</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_OUT;<span class="comment">//输出模式</span></span><br><span class="line">  	GPIO_InitStructure.GPIO_OType=GPIO_OType_PP;<span class="comment">//推挽输出</span></span><br><span class="line">  	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;<span class="comment">//100MHz</span></span><br><span class="line">  	GPIO_InitStructure.GPIO_PuPd=GPIO_PuPd_UP;<span class="comment">//内部上拉</span></span><br><span class="line">    <span class="comment">//应用设置</span></span><br><span class="line">  	GPIO_Init(GPIOD,&amp;GPIO_InitStructure);</span><br><span class="line"> </span><br><span class="line">	GPIO_SetBits(GPIOD,GPIO_Pin_6|GPIO_Pin_7);<span class="comment">//初始为高电平</span></span><br><span class="line">	SCCB_SDA_OUT();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SCCB起始信号</span></span><br><span class="line"><span class="comment">//时钟为高时,数据线下降沿,为SCCB起始信号</span></span><br><span class="line"><span class="comment">//在激活状态下,SDA和SCL均为低电平</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SCCB_Start</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SCCB_SDA=<span class="number">1</span>;<span class="comment">//数据线高电平	   </span></span><br><span class="line">    SCCB_SCL=<span class="number">1</span>;<span class="comment">//时钟线高时数据线下降沿</span></span><br><span class="line">    delay_us(<span class="number">50</span>);</span><br><span class="line">    SCCB_SDA=<span class="number">0</span>;</span><br><span class="line">    delay_us(<span class="number">50</span>);</span><br><span class="line">    SCCB_SCL=<span class="number">0</span>;<span class="comment">//数据线恢复低电平，单操作函数必要	  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SCCB停止信号</span></span><br><span class="line"><span class="comment">//时钟为高时,数据线上升沿,为SCCB停止信号</span></span><br><span class="line"><span class="comment">//空闲状况下,SDA,SCL均为高电平</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SCCB_Stop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SCCB_SDA=<span class="number">0</span>;</span><br><span class="line">    delay_us(<span class="number">50</span>);	 </span><br><span class="line">    SCCB_SCL=<span class="number">1</span>;<span class="comment">//数据线高电平</span></span><br><span class="line">    delay_us(<span class="number">50</span>);</span><br><span class="line">    SCCB_SDA=<span class="number">1</span>;<span class="comment">//时钟线高时数据线上升沿</span></span><br><span class="line">    delay_us(<span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NA信号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SCCB_No_Ack</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	delay_us(<span class="number">50</span>);</span><br><span class="line">	SCCB_SDA=<span class="number">1</span>;<span class="comment">//SDA、SCL都为高电平</span></span><br><span class="line">	SCCB_SCL=<span class="number">1</span>;</span><br><span class="line">	delay_us(<span class="number">50</span>);</span><br><span class="line">	SCCB_SCL=<span class="number">0</span>;</span><br><span class="line">	delay_us(<span class="number">50</span>);</span><br><span class="line">	SCCB_SDA=<span class="number">0</span>;</span><br><span class="line">	delay_us(<span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SCCB写入一个字节</span></span><br><span class="line"><span class="comment">//返回值:0,成功;1,失败</span></span><br><span class="line"><span class="function">u8 <span class="title">SCCB_WR_Byte</span><span class="params">(u8 dat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 j,res;	 </span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">8</span>;j++)<span class="comment">//循环8次发送数据</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(dat&amp;<span class="number">0x80</span>)</span><br><span class="line">            SCCB_SDA=<span class="number">1</span>;	</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">            SCCB_SDA=<span class="number">0</span>;</span><br><span class="line">		dat&lt;&lt;=<span class="number">1</span>;<span class="comment">//发送数据</span></span><br><span class="line">		delay_us(<span class="number">50</span>);</span><br><span class="line">		SCCB_SCL=<span class="number">1</span>;</span><br><span class="line">		delay_us(<span class="number">50</span>);</span><br><span class="line">		SCCB_SCL=<span class="number">0</span>;		   </span><br><span class="line">	&#125;</span><br><span class="line">	SCCB_SDA_IN();<span class="comment">//设置SDA为输入 </span></span><br><span class="line">	delay_us(<span class="number">50</span>);</span><br><span class="line">	SCCB_SCL=<span class="number">1</span>;<span class="comment">//接收第九位,判断是否发送成功</span></span><br><span class="line">	delay_us(<span class="number">50</span>);</span><br><span class="line">	<span class="keyword">if</span>(SCCB_READ_SDA)<span class="comment">//读取到NA数据</span></span><br><span class="line">        res=<span class="number">1</span>;<span class="comment">//SDA=1发送失败，返回1</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        res=<span class="number">0</span>;<span class="comment">//SDA=0发送成功，返回0</span></span><br><span class="line">	SCCB_SCL=<span class="number">0</span>;		 </span><br><span class="line">	SCCB_SDA_OUT();<span class="comment">//设置SDA为输出 </span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SCCB读取一个字节</span></span><br><span class="line"><span class="comment">//SCL上升沿,数据锁存</span></span><br><span class="line"><span class="comment">//返回值:读到的数据</span></span><br><span class="line"><span class="function">u8 <span class="title">SCCB_RD_Byte</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 temp=<span class="number">0</span>,j;</span><br><span class="line">	SCCB_SDA_IN();<span class="comment">//设置SDA为输入  </span></span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">8</span>;j&gt;<span class="number">0</span>;j--)<span class="comment">//循环8次接收数据</span></span><br><span class="line">	&#123;</span><br><span class="line">		delay_us(<span class="number">50</span>);</span><br><span class="line">		SCCB_SCL=<span class="number">1</span>;</span><br><span class="line">		temp=temp&lt;&lt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(SCCB_READ_SDA)</span><br><span class="line">            temp++;   </span><br><span class="line">		delay_us(<span class="number">50</span>);</span><br><span class="line">		SCCB_SCL=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	SCCB_SDA_OUT();<span class="comment">//设置SDA为输出    </span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写寄存器</span></span><br><span class="line"><span class="comment">//返回值:0,成功;1,失败.</span></span><br><span class="line"><span class="function">u8 <span class="title">SCCB_WR_Reg</span><span class="params">(u8 reg,u8 data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 res=<span class="number">0</span>;</span><br><span class="line">	SCCB_Start();<span class="comment">//启动SCCB传输</span></span><br><span class="line">	<span class="keyword">if</span>(SCCB_WR_Byte(SCCB_ID))</span><br><span class="line">        res=<span class="number">1</span>;<span class="comment">//写器件ID	  </span></span><br><span class="line">	delay_us(<span class="number">100</span>);</span><br><span class="line">  	<span class="keyword">if</span>(SCCB_WR_Byte(reg))</span><br><span class="line">        res=<span class="number">1</span>;<span class="comment">//写寄存器地址	  </span></span><br><span class="line">	delay_us(<span class="number">100</span>);</span><br><span class="line">  	<span class="keyword">if</span>(SCCB_WR_Byte(data))</span><br><span class="line">       res=<span class="number">1</span>;<span class="comment">//写数据	 </span></span><br><span class="line">  	SCCB_Stop();</span><br><span class="line">  	<span class="keyword">return</span></span><br><span class="line">        res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读寄存器</span></span><br><span class="line"><span class="comment">//返回值:读到的寄存器值</span></span><br><span class="line"><span class="function">u8 <span class="title">SCCB_RD_Reg</span><span class="params">(u8 reg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 val=<span class="number">0</span>;</span><br><span class="line">	SCCB_Start();<span class="comment">//启动SCCB传输</span></span><br><span class="line">	SCCB_WR_Byte(SCCB_ID);<span class="comment">//写器件ID</span></span><br><span class="line">	delay_us(<span class="number">100</span>);	 </span><br><span class="line">  	SCCB_WR_Byte(reg);<span class="comment">//写寄存器地址	  </span></span><br><span class="line">	delay_us(<span class="number">100</span>);	  </span><br><span class="line">	SCCB_Stop();   </span><br><span class="line">	delay_us(<span class="number">100</span>);	   </span><br><span class="line">	</span><br><span class="line">    <span class="comment">//设置寄存器地址后进行读操作</span></span><br><span class="line">	SCCB_Start();</span><br><span class="line">	SCCB_WR_Byte(SCCB_ID|<span class="number">0X01</span>);<span class="comment">//发送读命令	  </span></span><br><span class="line">	delay_us(<span class="number">100</span>);</span><br><span class="line">  	val=SCCB_RD_Byte();<span class="comment">//读取数据</span></span><br><span class="line">  	SCCB_No_Ack();</span><br><span class="line">  	SCCB_Stop();</span><br><span class="line">  	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>ov2640驱动</li>
</ol>
<p>ov2640.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _OV2640_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _OV2640_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sccb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_PWDN PGout(9) <span class="comment">//POWER_DOWN控制信号 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_RST PGout(15) <span class="comment">//复位控制信号 </span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*片内信息核对*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_MID 0X7FA2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_PID 0X2642</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//当选择DSP地址(0XFF=0X00)时,OV2640的DSP寄存器地址映射表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_R_BYPASS     0x05</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_Qs           0x44</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_CTRL         0x50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_HSIZE1       0x51</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_VSIZE1       0x52</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_XOFFL        0x53</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_YOFFL        0x54</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_VHYX         0x55</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_DPRP         0x56</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_TEST         0x57</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_ZMOW         0x5A</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_ZMOH         0x5B</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_ZMHH         0x5C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_BPADDR       0x7C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_BPDATA       0x7D</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_CTRL2        0x86</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_CTRL3        0x87</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_SIZEL        0x8C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_HSIZE2       0xC0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_VSIZE2       0xC1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_CTRL0        0xC2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_CTRL1        0xC3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_R_DVP_SP     0xD3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_IMAGE_MODE   0xDA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_RESET        0xE0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_MS_SP        0xF0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_SS_ID        0x7F</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_SS_CTRL      0xF8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_MC_BIST      0xF9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_MC_AL        0xFA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_MC_AH        0xFB</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_MC_D         0xFC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_P_STATUS     0xFE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_RA_DLMT      0xFF </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当选择传感器地址(0XFF=0X01)时,OV2640的DSP寄存器地址映射表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_GAIN       0x00</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_COM1       0x03</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_REG04      0x04</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_REG08      0x08</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_COM2       0x09</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_PIDH       0x0A</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_PIDL       0x0B</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_COM3       0x0C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_COM4       0x0D</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_AEC        0x10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_CLKRC      0x11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_COM7       0x12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_COM8       0x13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_COM9       0x14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_COM10      0x15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_HREFST     0x17</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_HREFEND    0x18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_VSTART     0x19</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_VEND       0x1A</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_MIDH       0x1C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_MIDL       0x1D</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_AEW        0x24</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_AEB        0x25</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_W          0x26</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_REG2A      0x2A</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_FRARL      0x2B</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_ADDVSL     0x2D</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_ADDVHS     0x2E</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_YAVG       0x2F</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_REG32      0x32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_ARCOM2     0x34</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_REG45      0x45</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_FLL        0x46</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_FLH        0x47</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_COM19      0x48</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_ZOOMS      0x49</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_COM22      0x4B</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_COM25      0x4E</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_BD50       0x4F</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_BD60       0x50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_REG5D      0x5D</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_REG5E      0x5E</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_REG5F      0x5F</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_REG60      0x60</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_HISTO_LOW  0x61</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_HISTO_HIGH 0x62</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*OV2640初始化函数*/</span></span><br><span class="line"><span class="function">u8 <span class="title">OV2640_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">/*OV2640选项调节函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OV2640_JPEG_Mode</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OV2640_RGB565_Mode</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OV2640_Auto_Exposure</span><span class="params">(u8 level)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OV2640_Light_Mode</span><span class="params">(u8 mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OV2640_Color_Saturation</span><span class="params">(u8 sat)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OV2640_Brightness</span><span class="params">(u8 bright)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OV2640_Contrast</span><span class="params">(u8 contrast)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OV2640_Special_Effects</span><span class="params">(u8 eft)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OV2640_Color_Bar</span><span class="params">(u8 sw)</span></span>;</span><br><span class="line"><span class="comment">/*OV2640硬件软件&quot;开窗&quot;函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OV2640_Window_Set</span><span class="params">(u16 sx,u16 sy,u16 width,u16 height)</span></span>;</span><br><span class="line"><span class="function">u8 <span class="title">OV2640_OutSize_Set</span><span class="params">(u16 width,u16 height)</span></span>;</span><br><span class="line"><span class="function">u8 <span class="title">OV2640_ImageWin_Set</span><span class="params">(u16 offx,u16 offy,u16 width,u16 height)</span></span>;</span><br><span class="line"><span class="function">u8 <span class="title">OV2640_ImageSize_Set</span><span class="params">(u16 width,u16 height)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>ov2640.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ov2640.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ov2640cfg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;timer.h“</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">#include &quot;</span>sccb.h<span class="meta-string">&quot;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">#include &quot;</span>delay.h<span class="meta-string">&quot;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">#include &quot;</span>usart.h<span class="meta-string">&quot;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//初始化OV2640 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//默认输出1600*1200尺寸的图片</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//返回值:0,成功</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//    其他,错误代码</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">u8 OV2640_Init(void)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u16 i=0;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u16 reg;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    /*设置IO连接OV2640*/</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	GPIO_InitTypeDef GPIO_InitStructure;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOG, ENABLE);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	//GPIOG9,15初始化设置</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_9|GPIO_Pin_15;//PG9,15</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_OUT; //普通输出模式</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	GPIO_InitStructure.GPIO_OType=GPIO_OType_PP;//推挽输出</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;//100MHz</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	GPIO_InitStructure.GPIO_PuPd=GPIO_PuPd_UP;//内部上拉</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    //应用设置</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	GPIO_Init(GPIOG,&amp;GPIO_InitStructure);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	OV2640_PWDN=0;//开始硬复位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	delay_ms(10);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	OV2640_RST=0;//复位OV2640</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	delay_ms(10);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	OV2640_RST=1;//结束复位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_Init();//初始化SCCB 的IO口	 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(OV2640_DSP_RA_DLMT,0x01);//操作sensor寄存器</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(OV2640_SENSOR_COM7,0x80);//开始软复位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	delay_ms(50);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	reg=SCCB_RD_Reg(OV2640_SENSOR_MIDH);//读取厂家ID 高八位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	reg&lt;&lt;=8;//存入寄存器</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	reg|=SCCB_RD_Reg(OV2640_SENSOR_MIDL);//读取厂家ID 低八位 并 存入寄存器</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	if(reg!=OV2640_MID)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		printf(&quot;</span>MID:%d\r\n<span class="meta-string">&quot;,reg);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		return 1;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	reg=SCCB_RD_Reg(OV2640_SENSOR_PIDH);//读取厂家ID 高八位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	reg&lt;&lt;=8;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	reg|=SCCB_RD_Reg(OV2640_SENSOR_PIDL);//读取厂家ID 低八位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	if(reg!=OV2640_PID)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		printf(&quot;</span>HID:%d\r\n<span class="meta-string">&quot;,reg);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		return 2;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	/*采用SXGA分辨率(1600*1200)初始化*/  </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	for(i=0;i&lt;sizeof(ov2640_sxga_init_reg_tbl)/2;i++)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		SCCB_WR_Reg(ov2640_sxga_init_reg_tbl[i][0],ov2640_sxga_init_reg_tbl[i][1]);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	return 0x00;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">/*参数选项函数*/</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//OV2640切换为JPEG模式</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">void OV2640_JPEG_Mode(void) </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u16 i=0;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	//设置:YUV422格式</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	for(i=0;i&lt;(sizeof(ov2640_yuv422_reg_tbl)/2);i++)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		SCCB_WR_Reg(ov2640_yuv422_reg_tbl[i][0],ov2640_yuv422_reg_tbl[i][1]); </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#125; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	//设置:输出JPEG数据</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	for(i=0;i&lt;(sizeof(ov2640_jpeg_reg_tbl)/2);i++)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		SCCB_WR_Reg(ov2640_jpeg_reg_tbl[i][0],ov2640_jpeg_reg_tbl[i][1]);  </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#125;  </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//OV2640切换为RGB565模式</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">void OV2640_RGB565_Mode(void) </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u16 i=0;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	//设置:RGB565输出</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	for(i=0;i&lt;(sizeof(ov2640_rgb565_reg_tbl)/2);i++)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		SCCB_WR_Reg(ov2640_rgb565_reg_tbl[i][0],ov2640_rgb565_reg_tbl[i][1]); </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#125; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//自动曝光设置参数表,支持5个等级</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">const static u8 OV2640_AUTOEXPOSURE_LEVEL[5][8]=</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0xFF,0x01,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0x24,0x20,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0x25,0x18,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0x26,0x60,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#125;,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0xFF,0x01,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0x24,0x34,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0x25,0x1c,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0x26,0x00,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#125;,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0xFF,0x01,	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0x24,0x3e,	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0x25,0x38,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0x26,0x81,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#125;,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0xFF,0x01,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0x24,0x48,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0x25,0x40,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0x26,0x81,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#125;,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0xFF,0x01,	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0x24,0x58,	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0x25,0x50,	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0x26,0x92,	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#125;,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//OV2640自动曝光等级设置</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//level:0~4</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">void OV2640_Auto_Exposure(u8 level)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;  </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u8 i;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u8* p=(u8*)OV2640_AUTOEXPOSURE_LEVEL[level];</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	for(i=0;i&lt;4;i++)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#123; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		SCCB_WR_Reg(p[i*2],p[i*2+1]); </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#125; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//白平衡设置</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//0:自动</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//1:太阳sunny</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//2,阴天cloudy</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//3,办公室office</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//4,家里home</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">void OV2640_Light_Mode(u8 mode)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u8 regccval=0X5E;//Sunny </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u8 regcdval=0X41;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u8 regceval=0X54;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	switch(mode)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#123; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		case 0://auto </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			SCCB_WR_Reg(0XFF,0X00);	 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			SCCB_WR_Reg(0XC7,0X10);//AWB ON </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			return;  	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		case 2://cloudy</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			regccval=0X65;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			regcdval=0X41;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			regceval=0X4F;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			break;	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		case 3://office</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			regccval=0X52;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			regcdval=0X41;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			regceval=0X66;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			break;	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		case 4://home</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			regccval=0X42;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			regcdval=0X3F;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			regceval=0X71;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			break;	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XFF,0X00);	 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XC7,0X40);	//AWB OFF </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XCC,regccval); </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XCD,regcdval); </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XCE,regceval);  </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//色度设置</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//0:-2</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//1:-1</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//2,0</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//3,+1</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//4,+2</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">void OV2640_Color_Saturation(u8 sat)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u8 reg7dval=((sat+2)&lt;&lt;4)|0X08;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XFF,0X00);		</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X7C,0X00);		</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X7D,0X02);				</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X7C,0X03);			</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X7D,reg7dval);			</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X7D,reg7dval); 		</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//亮度设置</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//0:(0X00)-2</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//1:(0X10)-1</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//2,(0X20) 0</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//3,(0X30)+1</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//4,(0X40)+2</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">void OV2640_Brightness(u8 bright)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  SCCB_WR_Reg(0xff, 0x00);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  SCCB_WR_Reg(0x7c, 0x00);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  SCCB_WR_Reg(0x7d, 0x04);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  SCCB_WR_Reg(0x7c, 0x09);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  SCCB_WR_Reg(0x7d, bright&lt;&lt;4); </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  SCCB_WR_Reg(0x7d, 0x00); </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//对比度设置</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//0:-2</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//1:-1</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//2,0</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//3,+1</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//4,+2</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">void OV2640_Contrast(u8 contrast)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u8 reg7d0val=0X20;//默认为普通模式</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u8 reg7d1val=0X20;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	switch(contrast)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		case 0://-2</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d0val=0X18;	 	 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d1val=0X34;	 	 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			break;	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		case 1://-1</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d0val=0X1C;	 	 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d1val=0X2A;	 	 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			break;	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		case 3://1</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d0val=0X24;	 	 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d1val=0X16;	 	 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			break;	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		case 4://2</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d0val=0X28;	 	 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d1val=0X0C;	 	 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			break;	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0xff,0x00);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0x7c,0x00);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0x7d,0x04);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0x7c,0x07);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0x7d,0x20);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0x7d,reg7d0val);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0x7d,reg7d1val);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0x7d,0x06);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//特效设置</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//0:普通模式    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//1,负片</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//2,黑白   </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//3,偏红色</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//4,偏绿色</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//5,偏蓝色</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//6,复古	    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">void OV2640_Special_Effects(u8 eft)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u8 reg7d0val=0X00;//默认为普通模式</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u8 reg7d1val=0X80;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u8 reg7d2val=0X80; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	switch(eft)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		case 1://负片</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d0val=0X40; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			break;	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		case 2://黑白</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d0val=0X18; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			break;	 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		case 3://偏红色</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d0val=0X18; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d1val=0X40;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d2val=0XC0; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			break;	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		case 4://偏绿色</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d0val=0X18; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d1val=0X40;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d2val=0X40; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			break;	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		case 5://偏蓝色</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d0val=0X18; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d1val=0XA0;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d2val=0X40; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			break;	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		case 6://复古</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d0val=0X18; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d1val=0X40;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d2val=0XA6; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			break;	 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0xff,0x00);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0x7c,0x00);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0x7d,reg7d0val);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0x7c,0x05);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0x7d,reg7d1val);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0x7d,reg7d2val); </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//彩条测试</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//sw:0,关闭彩条</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//   1,开启彩条(注意OV2640的彩条是叠加在图像上面的)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">void OV2640_Color_Bar(u8 sw)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u8 reg;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XFF,0X01);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	reg=SCCB_RD_Reg(0X12);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	reg&amp;=~(1&lt;&lt;1);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	if(sw)reg|=1&lt;&lt;1; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X12,reg);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">/*硬件软件窗口配置*/</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//设置图像输出窗口 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//sx,sy,起始地址</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//width,height:宽度(对应:horizontal)和高度(对应:vertical)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">void OV2640_Window_Set(u16 sx,u16 sy,u16 width,u16 height)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u16 endx;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u16 endy;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u8 temp; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	endx=sx+width/2;//V*2</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"> 	endy=sy+height/2;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XFF,0X01);			</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	temp=SCCB_RD_Reg(0X03);//读取Vref之前的值</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	temp&amp;=0XF0;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	temp|=((endy&amp;0X03)&lt;&lt;2)|(sy&amp;0X03);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X03,temp);//设置Vref的start和end的最低2位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X19,sy&gt;&gt;2);//设置Vref的start高8位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X1A,endy&gt;&gt;2);//设置Vref的end的高8位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	temp=SCCB_RD_Reg(0X32);//读取Href之前的值</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	temp&amp;=0XC0;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	temp|=((endx&amp;0X07)&lt;&lt;3)|(sx&amp;0X07);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X32,temp);//设置Href的start和end的最低3位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X17,sx&gt;&gt;3);//设置Href的start高8位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X18,endx&gt;&gt;3);//设置Href的end的高8位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//设置图像输出大小</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//OV2640输出图像的大小(分辨率),完全由改函数确定</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//width,height:宽度(对应:horizontal)和高度(对应:vertical),width和height必须是4的倍数</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//返回值:0,设置成功</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//    其他,设置失败</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">u8 OV2640_OutSize_Set(u16 width,u16 height)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u16 outh;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u16 outw;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u8 temp;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	if(width%4)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        return 1;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	if(height%4)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        return 2;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	outw=width/4;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	outh=height/4;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XFF,0X00);	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XE0,0X04);			</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X5A,outw&amp;0XFF);//设置OUTW的低八位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X5B,outh&amp;0XFF);//设置OUTH的低八位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	temp=(outw&gt;&gt;8)&amp;0X03;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	temp|=(outh&gt;&gt;6)&amp;0X04;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X5C,temp);//设置OUTH/OUTW的高位 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XE0,0X00);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	return 0;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//设置图像开窗大小</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//由:OV2640_ImageSize_Set确定传感器输出分辨率从大小.</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//该函数则在这个范围上面进行开窗,用于OV2640_OutSize_Set的输出</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//注意:本函数的宽度和高度,必须大于等于OV2640_OutSize_Set函数的宽度和高度</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//     OV2640_OutSize_Set设置的宽度和高度,根据本函数设置的宽度和高度,由DSP</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//     自动计算缩放比例,输出给外部设备.</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//width,height:宽度(对应:horizontal)和高度(对应:vertical),width和height必须是4的倍数</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//返回值:0,设置成功</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//    其他,设置失败</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">u8 OV2640_ImageWin_Set(u16 offx,u16 offy,u16 width,u16 height)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u16 hsize;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u16 vsize;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u8 temp;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	if(width%4)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        return 1;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	if(height%4)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        return 2;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	hsize=width/4;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	vsize=height/4;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XFF,0X00);	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XE0,0X04);					</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X51,hsize&amp;0XFF);//设置H_SIZE的低八位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X52,vsize&amp;0XFF);//设置V_SIZE的低八位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X53,offx&amp;0XFF);//设置offx的低八位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X54,offy&amp;0XFF);//设置offy的低八位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	temp=(vsize&gt;&gt;1)&amp;0X80;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	temp|=(offy&gt;&gt;4)&amp;0X70;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	temp|=(hsize&gt;&gt;5)&amp;0X08;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	temp|=(offx&gt;&gt;8)&amp;0X07; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X55,temp);//设置H_SIZE/V_SIZE/OFFX,OFFY的高位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X57,(hsize&gt;&gt;2)&amp;0X80);//设置H_SIZE/V_SIZE/OFFX,OFFY的高位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XE0,0X00);	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	return 0;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//该函数设置图像尺寸大小,也就是所选格式的输出分辨率</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//UXGA:1600*1200,SVGA:800*600,CIF:352*288</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//width,height:图像宽度和图像高度</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//返回值:0,设置成功</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//    其他,设置失败</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">u8 OV2640_ImageSize_Set(u16 width,u16 height)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u8 temp;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XFF,0X00);			</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XE0,0X04);			</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XC0,(width)&gt;&gt;3&amp;0XFF);//设置HSIZE的10:3位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XC1,(height)&gt;&gt;3&amp;0XFF);//设置VSIZE的10:3位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	temp=(width&amp;0X07)&lt;&lt;3;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	temp|=height&amp;0X07;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	temp|=(width&gt;&gt;4)&amp;0X80;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X8C,temp);	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XE0,0X00);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	return 0;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>ov2640cfg.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OV2640 SXGA初始化寄存器序列表</span></span><br><span class="line"><span class="comment">//模式选择</span></span><br><span class="line"><span class="comment">//内容过长，略去，详见正点原子教程</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>dcmi接口配置</li>
</ol>
<p>dcmi.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _DCMI_H</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> _DCMI_H</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">My_DCMI_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DCMI_DMA_Init</span><span class="params">(u32 DMA_Memory0BaseAddr,u16 DMA_BufferSize,u32 DMA_MemoryDataSize,u32 DMA_MemoryInc)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DCMI_Start</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DCMI_Stop</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DCMI_Set_Window</span><span class="params">(u16 sx,u16 sy,u16 width,u16 height)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DCMI_CR_Set</span><span class="params">(u8 pclk,u8 hsync,u8 vsync)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>dcmi.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;dcmi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;lcd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ov2640.h”</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">u8 ov_frame=0;//帧率</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">extern void jpeg_data_process(void);//JPEG数据处理函数</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">DCMI_InitTypeDef DCMI_InitStructure;//全局变量注意</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//DCMI中断服务函数</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">void DCMI_IRQHandler(void)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	if(DCMI_GetITStatus(DCMI_IT_FRAME)==SET)//捕获到一帧图像</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		jpeg_data_process();//jpeg数据处理	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		DCMI_ClearITPendingBit(DCMI_IT_FRAME);//清除帧中断</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		LED1=!LED1;//LED指示捕获到图像</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		ov_frame++;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		LCD_SetCursor(0,0);//重置LCD</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		LCD_WriteRAM_Prepare();//开始写入GRAM</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//DCMI DMA配置</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//DMA_Memory0BaseAddr:存储器地址——将要存储摄像头数据的内存地址(也可以是外设地址)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//DMA_BufferSize:存储器长度——0~65535</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//DMA_MemoryDataSize:存储器位宽</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//DMA_MemoryInc:存储器增长方式</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">void DCMI_DMA_Init(u32 DMA_Memory0BaseAddr,u16 DMA_BufferSize,u32 DMA_MemoryDataSize,u32 DMA_MemoryInc)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	DMA_InitTypeDef  DMA_InitStructure;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2,ENABLE);//使能DMA2时钟</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	DMA_DeInit(DMA2_Stream1);//清空流</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	while (DMA_GetCmdStatus(DMA2_Stream1)!=DISABLE);//等待DMA2Stream1可配置 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	/*配置DMA2 Stream1 Channel1*/</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	DMA_InitStructure.DMA_Channel=DMA_Channel_1;//DMA2Stream1Channel1</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	DMA_InitStructure.DMA_PeripheralBaseAddr=(u32)&amp;DCMI-&gt;DR;//外设地址:DCMI-&gt;DR</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	DMA_InitStructure.DMA_Memory0BaseAddr=DMA_Memory0BaseAddr;//DMA存储器0地址</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	DMA_InitStructure.DMA_DIR=DMA_DIR_PeripheralToMemory;//外设到存储器模式</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	DMA_InitStructure.DMA_BufferSize=DMA_BufferSize;//数据传输量 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	DMA_InitStructure.DMA_PeripheralInc=DMA_PeripheralInc_Disable;//外设非增量模式</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	DMA_InitStructure.DMA_MemoryInc=DMA_MemoryInc;//存储器增量模式</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	DMA_InitStructure.DMA_PeripheralDataSize=DMA_PeripheralDataSize_Word;//外设数据长度:32位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	DMA_InitStructure.DMA_MemoryDataSize=DMA_MemoryDataSize;//存储器数据长度</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	DMA_InitStructure.DMA_Mode=DMA_Mode_Circular;//使用循环模式 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	DMA_InitStructure.DMA_Priority=DMA_Priority_High;//高优先级</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	DMA_InitStructure.DMA_FIFOMode=DMA_FIFOMode_Enable;//使能FIFO        </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	DMA_InitStructure.DMA_FIFOThreshold=DMA_FIFOThreshold_Full;//使用全FIFO </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    DMA_InitStructure.DMA_MemoryBurst=DMA_MemoryBurst_Single;//外设突发单次传输</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	DMA_InitStructure.DMA_PeripheralBurst=DMA_PeripheralBurst_Single;//存储器突发单次传输</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    //应用设置</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	DMA_Init(DMA2_Stream1,&amp;DMA_InitStructure);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//DCMI初始化</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">void My_DCMI_Init(void)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	GPIO_InitTypeDef  GPIO_InitStructure;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	NVIC_InitTypeDef NVIC_InitStructure;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA|</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">                           RCC_AHB1Periph_GPIOB|</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">                       	   RCC_AHB1Periph_GPIOC|</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">                           RCC_AHB1Periph_GPIOE,ENABLE);//使能GPIOA B C E时钟</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_DCMI,ENABLE);//使能DCMI时钟</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    /*PA4、PA6、PB6、PB7、PC6、PC7、PC8、PC9、PC11、PE5、PE6设置为复用输出*/</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF; //复用功能</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	GPIO_InitStructure.GPIO_OType=GPIO_OType_PP;//推挽输出</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_100MHz;//100MHz</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	GPIO_InitStructure.GPIO_PuPd=GPIO_PuPd_UP;//内部上拉</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    GPIO_InitStructure.GPIO_Pin=GPIO_Pin_4|GPIO_Pin_6;//PA4、6复用输出</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    //应用设置</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_7|GPIO_Pin_6;//PB6、7复用输出</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    //应用设置</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_6|GPIO_Pin_7|GPIO_Pin_8|GPIO_Pin_9|GPIO_Pin_11;//PC6、7、8、9、11 复用输出</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    //应用设置</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	GPIO_Init(GPIOC, &amp;GPIO_InitStructure);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5|GPIO_Pin_6;//PE5、6复用输出</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    //应用设置</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	GPIO_Init(GPIOE, &amp;GPIO_InitStructure);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	GPIO_PinAFConfig(GPIOA,GPIO_PinSource4,GPIO_AF_DCMI);//PA4,AF13  DCMI_HSYNC</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	GPIO_PinAFConfig(GPIOA,GPIO_PinSource6,GPIO_AF_DCMI);//PA6,AF13  DCMI_PCLK  </span></span></span><br><span class="line"><span class="meta-string"><span class="meta"> 	GPIO_PinAFConfig(GPIOB,GPIO_PinSource7,GPIO_AF_DCMI);//PB7,AF13  DCMI_VSYNC </span></span></span><br><span class="line"><span class="meta-string"><span class="meta"> 	GPIO_PinAFConfig(GPIOC,GPIO_PinSource6,GPIO_AF_DCMI);//PC6,AF13  DCMI_D0  </span></span></span><br><span class="line"><span class="meta-string"><span class="meta"> 	GPIO_PinAFConfig(GPIOC,GPIO_PinSource7,GPIO_AF_DCMI);//PC7,AF13  DCMI_D1 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	GPIO_PinAFConfig(GPIOC,GPIO_PinSource8,GPIO_AF_DCMI);//PC8,AF13  DCMI_D2</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	GPIO_PinAFConfig(GPIOC,GPIO_PinSource9,GPIO_AF_DCMI);//PC9,AF13  DCMI_D3</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	GPIO_PinAFConfig(GPIOC,GPIO_PinSource11,GPIO_AF_DCMI);//PC11,AF13 DCMI_D4 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	GPIO_PinAFConfig(GPIOB,GPIO_PinSource6,GPIO_AF_DCMI);//PB6,AF13  DCMI_D5 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	GPIO_PinAFConfig(GPIOE,GPIO_PinSource5,GPIO_AF_DCMI);//PE5,AF13  DCMI_D6</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	GPIO_PinAFConfig(GPIOE,GPIO_PinSource6,GPIO_AF_DCMI);//PE6,AF13  DCMI_D7</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	DCMI_DeInit();//清除原来的设置</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	DCMI_InitStructure.DCMI_CaptureMode=DCMI_CaptureMode_Continuous;//连续模式</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	DCMI_InitStructure.DCMI_CaptureRate=DCMI_CaptureRate_All_Frame;//全帧捕获</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	DCMI_InitStructure.DCMI_ExtendedDataMode= DCMI_ExtendedDataMode_8b;//8位数据格式  </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	DCMI_InitStructure.DCMI_HSPolarity= DCMI_HSPolarity_Low;//HSYNC低电平有效</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    DCMI_InitStructure.DCMI_VSPolarity=DCMI_VSPolarity_Low;//VSYNC低电平有效</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	DCMI_InitStructure.DCMI_PCKPolarity= DCMI_PCKPolarity_Rising;//PCLK上升沿有效</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	DCMI_InitStructure.DCMI_SynchroMode= DCMI_SynchroMode_Hardware;//硬件同步HSYNC,VSYNC</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    //应用设置</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	DCMI_Init(&amp;DCMI_InitStructure);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	DCMI_ITConfig(DCMI_IT_FRAME,ENABLE);//使能帧中断 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	DCMI_Cmd(ENABLE);//使能DCMI</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	//此时不能捕获，还要启动传输</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    NVIC_InitStructure.NVIC_IRQChannel=DCMI_IRQn;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=0;//抢占优先级0</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	NVIC_InitStructure.NVIC_IRQChannelSubPriority=0;//子优先级0</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;//IRQ通道使能</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    //应用设置</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	NVIC_Init(&amp;NVIC_InitStructure);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//DCMI,启动传输</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">void DCMI_Start(void)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;  </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	LCD_SetCursor(0,0);//重置LCD</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	LCD_WriteRAM_Prepare();//开始写入GRAM</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	DMA_Cmd(DMA2_Stream1, ENABLE);//开启DMA2Stream1 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	DCMI_CaptureCmd(ENABLE);//使能DCMI捕获</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//DCMI,关闭传输</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">void DCMI_Stop(void)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	DCMI_CaptureCmd(DISABLE);//关闭DCMI捕获	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	while(DCMI-&gt;CR&amp;0X01);//等待传输结束</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	DMA_Cmd(DMA2_Stream1,DISABLE);//关闭DMA2Stream1</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;</span></span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>main()配置</li>
</ol>
<p>main.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;lcd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;usmart.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;usart2.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;timer.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ov2640.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;dcmi.h&quot;</span> </span></span><br><span class="line"></span><br><span class="line">u8 ov2640_mode=<span class="number">0</span>;<span class="comment">//工作模式:0,RGB565模式;1,JPEG模式</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> jpeg_buf_size 31*1024<span class="comment">//定义JPEG数据缓存jpeg_buf的大小(*4字节)</span></span></span><br><span class="line">__align(<span class="number">4</span>) u32 jpeg_buf[jpeg_buf_size];<span class="comment">//JPEG数据缓存buf</span></span><br><span class="line"><span class="keyword">volatile</span> u32 jpeg_data_len=<span class="number">0</span>;<span class="comment">//buf中的JPEG有效数据长度 </span></span><br><span class="line"><span class="keyword">volatile</span> u8 jpeg_data_ok=<span class="number">0</span>;<span class="comment">//JPEG数据采集完成标志 </span></span><br><span class="line">						   <span class="comment">//0,数据没有采集完;</span></span><br><span class="line">						   <span class="comment">//1,数据采集完了,但是还没处理;</span></span><br><span class="line">						   <span class="comment">//2,数据已经处理完成了,可以开始下一帧接收</span></span><br><span class="line"><span class="comment">//JPEG尺寸支持列表</span></span><br><span class="line"><span class="keyword">const</span> u16 jpeg_img_size_tbl[][<span class="number">2</span>]=</span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">176</span>,<span class="number">144</span>,	<span class="comment">//QCIF</span></span><br><span class="line">	<span class="number">160</span>,<span class="number">120</span>,	<span class="comment">//QQVGA</span></span><br><span class="line">	<span class="number">352</span>,<span class="number">288</span>,	<span class="comment">//CIF</span></span><br><span class="line">	<span class="number">320</span>,<span class="number">240</span>,	<span class="comment">//QVGA</span></span><br><span class="line">	<span class="number">640</span>,<span class="number">480</span>,	<span class="comment">//VGA</span></span><br><span class="line">	<span class="number">800</span>,<span class="number">600</span>,	<span class="comment">//SVGA</span></span><br><span class="line">	<span class="number">1024</span>,<span class="number">768</span>,	<span class="comment">//XGA</span></span><br><span class="line">	<span class="number">1280</span>,<span class="number">1024</span>,	<span class="comment">//SXGA</span></span><br><span class="line">	<span class="number">1600</span>,<span class="number">1200</span>,	<span class="comment">//UXGA</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">const</span> u8*EFFECTS_TBL[<span class="number">7</span>]=&#123;<span class="string">&quot;Normal&quot;</span>,<span class="string">&quot;Negative&quot;</span>,<span class="string">&quot;B&amp;W&quot;</span>,<span class="string">&quot;Redish&quot;</span>,<span class="string">&quot;Greenish&quot;</span>,<span class="string">&quot;Bluish&quot;</span>,<span class="string">&quot;Antique&quot;</span>&#125;;<span class="comment">//7种特效 </span></span><br><span class="line"><span class="keyword">const</span> u8*JPEG_SIZE_TBL[<span class="number">9</span>]=&#123;<span class="string">&quot;QCIF&quot;</span>,<span class="string">&quot;QQVGA&quot;</span>,<span class="string">&quot;CIF&quot;</span>,<span class="string">&quot;QVGA&quot;</span>,<span class="string">&quot;VGA&quot;</span>,<span class="string">&quot;SVGA&quot;</span>,<span class="string">&quot;XGA&quot;</span>,<span class="string">&quot;SXGA&quot;</span>,<span class="string">&quot;UXGA&quot;</span>&#125;;<span class="comment">//JPEG 9种尺寸 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//处理JPEG数据</span></span><br><span class="line"><span class="comment">//当采集完一帧JPEG数据后,调用此函数,切换JPEG BUF.开始下一帧采集.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jpeg_data_process</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ov2640_mode)<span class="comment">//只有在JPEG格式下,才需要做处理</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(jpeg_data_ok==<span class="number">0</span>)<span class="comment">//如果还未采集完数据</span></span><br><span class="line">		&#123;	</span><br><span class="line">			DMA_Cmd(DMA2_Stream1, DISABLE);<span class="comment">//停止当前传输 </span></span><br><span class="line">			<span class="keyword">while</span>(DMA_GetCmdStatus(DMA2_Stream1)!=DISABLE);<span class="comment">//等待DMA2_Stream1可配置  </span></span><br><span class="line">			jpeg_data_len=jpeg_buf_size-DMA_GetCurrDataCounter(DMA2_Stream1);<span class="comment">//得到此次数据传输的长度</span></span><br><span class="line">			jpeg_data_ok=<span class="number">1</span>;<span class="comment">//标记JPEG数据采集完成,等待其他函数处理</span></span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">if</span>(jpeg_data_ok==<span class="number">2</span>)<span class="comment">//如果jpeg数据已经被处理了</span></span><br><span class="line">		&#123;</span><br><span class="line">			DMA2_Stream1-&gt;NDTR=jpeg_buf_size;	</span><br><span class="line">			DMA_SetCurrDataCounter(DMA2_Stream1,jpeg_buf_size);<span class="comment">//传输长度为jpeg_buf_size*4字节</span></span><br><span class="line">			DMA_Cmd(DMA2_Stream1,ENABLE);<span class="comment">//重新传输</span></span><br><span class="line">			jpeg_data_ok=<span class="number">0</span>;<span class="comment">//标记数据未采集</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//JPEG测试</span></span><br><span class="line"><span class="comment">//JPEG数据,通过串口1发送给电脑.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jpeg_test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u32 i; </span><br><span class="line">	u8* p;</span><br><span class="line">	u8 key;</span><br><span class="line">	u8 effect=<span class="number">0</span>,saturation=<span class="number">2</span>,contrast=<span class="number">2</span>;</span><br><span class="line">	u8 size=<span class="number">3</span>;<span class="comment">//默认QVGA 320*240尺寸</span></span><br><span class="line">	u8 msgbuf[<span class="number">15</span>];<span class="comment">//消息缓存区 </span></span><br><span class="line">	LCD_Clear(WHITE);</span><br><span class="line">	POINT_COLOR=RED; </span><br><span class="line">	LCD_ShowString(<span class="number">30</span>,<span class="number">70</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;OV2640 JPEG Mode&quot;</span>);</span><br><span class="line">	LCD_ShowString(<span class="number">30</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;KEY0:Contrast&quot;</span>);<span class="comment">//对比度</span></span><br><span class="line">	<span class="comment">//LCD_ShowString(30,120,200,16,16,&quot;KEY1:Saturation&quot;);//色彩饱和度</span></span><br><span class="line">	<span class="comment">//LCD_ShowString(30,140,200,16,16,&quot;KEY2:Effects&quot;);//特效 </span></span><br><span class="line">	LCD_ShowString(<span class="number">30</span>,<span class="number">160</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;KEY_UP:Size&quot;</span>);<span class="comment">//分辨率设置 </span></span><br><span class="line">	<span class="built_in">sprintf</span>((<span class="keyword">char</span>*)msgbuf,<span class="string">&quot;JPEG Size:%s&quot;</span>,JPEG_SIZE_TBL[size]);</span><br><span class="line">	LCD_ShowString(<span class="number">30</span>,<span class="number">180</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,msgbuf);<span class="comment">//显示当前JPEG分辨率</span></span><br><span class="line">	</span><br><span class="line"> 	OV2640_JPEG_Mode();<span class="comment">//JPEG模式</span></span><br><span class="line">	My_DCMI_Init();<span class="comment">//初始化DCMI</span></span><br><span class="line">	DCMI_DMA_Init((u32)&amp;jpeg_buf,jpeg_buf_size,DMA_MemoryDataSize_Word,DMA_MemoryInc_Enable);<span class="comment">//初始化DMA</span></span><br><span class="line">	OV2640_OutSize_Set(jpeg_img_size_tbl[size][<span class="number">0</span>],jpeg_img_size_tbl[size][<span class="number">1</span>]);<span class="comment">//设置输出尺寸</span></span><br><span class="line">	DCMI_Start();<span class="comment">//启动传输</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(jpeg_data_ok==<span class="number">1</span>)<span class="comment">//若已经采集完一帧图像</span></span><br><span class="line">		&#123;  </span><br><span class="line">			p=(u8*)jpeg_buf;</span><br><span class="line">			LCD_ShowString(<span class="number">30</span>,<span class="number">210</span>,<span class="number">210</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;Sending JPEG data...&quot;</span>);<span class="comment">//提示正在传输数据</span></span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;jpeg_data_len*<span class="number">4</span>;i++)<span class="comment">//dma传输1次等于4字节,要乘4</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">while</span>((USART1-&gt;SR&amp;<span class="number">0X40</span>)==RESET);<span class="comment">//循环发送直到发送完毕  		</span></span><br><span class="line">				USART1-&gt;DR=p[i];</span><br><span class="line">				key=KEY_Scan(<span class="number">0</span>);</span><br><span class="line">				<span class="keyword">if</span>(key)</span><br><span class="line">                    <span class="keyword">break</span>;<span class="comment">//若按键按下则需要处理，跳至下部分</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(key)<span class="comment">//有按键按下,需要处理</span></span><br><span class="line">			&#123;  </span><br><span class="line">				LCD_ShowString(<span class="number">30</span>,<span class="number">210</span>,<span class="number">210</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;Quit Sending data&quot;</span>);<span class="comment">//提示退出数据传输</span></span><br><span class="line">                </span><br><span class="line">				<span class="keyword">switch</span>(key)</span><br><span class="line">				&#123;				    </span><br><span class="line">					<span class="keyword">case</span> KEY0_PRES:<span class="comment">//对比度设置</span></span><br><span class="line">						contrast++;</span><br><span class="line">						<span class="keyword">if</span>(contrast&gt;<span class="number">4</span>)contrast=<span class="number">0</span>;</span><br><span class="line">						OV2640_Contrast(contrast);</span><br><span class="line">						<span class="built_in">sprintf</span>((<span class="keyword">char</span>*)msgbuf,<span class="string">&quot;Contrast:%d&quot;</span>,(<span class="keyword">signed</span> <span class="keyword">char</span>)contrast<span class="number">-2</span>);</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> KEY1_PRES:<span class="comment">//饱和度Saturation</span></span><br><span class="line">						<span class="comment">//saturation++;</span></span><br><span class="line">						<span class="comment">//if(saturation&gt;4)saturation=0;</span></span><br><span class="line">						<span class="comment">//OV2640_Color_Saturation(saturation);</span></span><br><span class="line">						<span class="comment">//sprintf((char*)msgbuf,&quot;Saturation:%d&quot;,(signed char)saturation-2);</span></span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> KEY2_PRES:<span class="comment">//特效设置				 </span></span><br><span class="line">						<span class="comment">//effect++;</span></span><br><span class="line">						<span class="comment">//if(effect&gt;6)effect=0;</span></span><br><span class="line">						<span class="comment">//OV2640_Special_Effects(effect);//设置特效</span></span><br><span class="line">						<span class="comment">//sprintf((char*)msgbuf,&quot;%s&quot;,EFFECTS_TBL[effect]);</span></span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> WKUP_PRES:<span class="comment">//JPEG输出尺寸设置   </span></span><br><span class="line">						size++;  </span><br><span class="line">						<span class="keyword">if</span>(size&gt;<span class="number">8</span>)size=<span class="number">0</span>;   </span><br><span class="line">						OV2640_OutSize_Set(jpeg_img_size_tbl[size][<span class="number">0</span>],jpeg_img_size_tbl[size][<span class="number">1</span>]);<span class="comment">//设置输出尺寸  </span></span><br><span class="line">						<span class="built_in">sprintf</span>((<span class="keyword">char</span>*)msgbuf,<span class="string">&quot;JPEG Size:%s&quot;</span>,JPEG_SIZE_TBL[size]);</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">                </span><br><span class="line">				LCD_Fill(<span class="number">30</span>,<span class="number">180</span>,<span class="number">239</span>,<span class="number">190</span>+<span class="number">16</span>,WHITE);</span><br><span class="line">				LCD_ShowString(<span class="number">30</span>,<span class="number">180</span>,<span class="number">210</span>,<span class="number">16</span>,<span class="number">16</span>,msgbuf);<span class="comment">//显示提示内容</span></span><br><span class="line">				delay_ms(<span class="number">800</span>); 				  </span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                LCD_ShowString(<span class="number">30</span>,<span class="number">210</span>,<span class="number">210</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;Send data complete!!&quot;</span>);<span class="comment">//提示传输结束设置 </span></span><br><span class="line">			jpeg_data_ok=<span class="number">2</span>;	<span class="comment">//标记jpeg数据处理完毕,可以让DMA采集下一帧</span></span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;    </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//RGB565测试</span></span><br><span class="line"><span class="comment">//RGB数据直接显示在LCD上面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rgb565_test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	u8 key;</span><br><span class="line">	u8 effect=<span class="number">0</span>,saturation=<span class="number">2</span>,contrast=<span class="number">2</span>;</span><br><span class="line">	u8 scale=<span class="number">1</span>;<span class="comment">//默认是全尺寸缩放</span></span><br><span class="line">	u8 msgbuf[<span class="number">15</span>];<span class="comment">//消息缓存区</span></span><br><span class="line">    </span><br><span class="line">	LCD_Clear(WHITE);</span><br><span class="line">    POINT_COLOR=RED; </span><br><span class="line">	LCD_ShowString(<span class="number">30</span>,<span class="number">70</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;OV2640 RGB565 Mode&quot;</span>);</span><br><span class="line">	LCD_ShowString(<span class="number">30</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;KEY0:Contrast&quot;</span>);<span class="comment">//对比度</span></span><br><span class="line">	<span class="comment">//LCD_ShowString(30,130,200,16,16,&quot;KEY1:Saturation&quot;);//色彩饱和度</span></span><br><span class="line">	<span class="comment">//LCD_ShowString(30,150,200,16,16,&quot;KEY2:Effects&quot;);//特效 </span></span><br><span class="line">	LCD_ShowString(<span class="number">30</span>,<span class="number">170</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;KEY_UP:FullSize/Scale&quot;</span>);<span class="comment">//1:1尺寸(显示真实尺寸)/全尺寸缩放</span></span><br><span class="line">	</span><br><span class="line">	OV2640_RGB565_Mode();<span class="comment">//RGB565模式</span></span><br><span class="line">	My_DCMI_Init();<span class="comment">//DCMI配置</span></span><br><span class="line">	DCMI_DMA_Init((u32)&amp;LCD-&gt;LCD_RAM,<span class="number">1</span>,DMA_MemoryDataSize_HalfWord,DMA_MemoryInc_Disable);<span class="comment">//DCMI DMA配置  </span></span><br><span class="line"> 	OV2640_OutSize_Set(lcddev.width,lcddev.height); </span><br><span class="line">	DCMI_Start();<span class="comment">//启动传输</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		key=KEY_Scan(<span class="number">0</span>); </span><br><span class="line">		<span class="keyword">if</span>(key)</span><br><span class="line">		&#123; </span><br><span class="line">			DCMI_Stop();<span class="comment">//停止显示</span></span><br><span class="line">			<span class="keyword">switch</span>(key)</span><br><span class="line">			&#123;				    </span><br><span class="line">				<span class="keyword">case</span> KEY0_PRES:<span class="comment">//对比度设置</span></span><br><span class="line">					contrast++;</span><br><span class="line">					<span class="keyword">if</span>(contrast&gt;<span class="number">4</span>)contrast=<span class="number">0</span>;</span><br><span class="line">					OV2640_Contrast(contrast);</span><br><span class="line">					<span class="built_in">sprintf</span>((<span class="keyword">char</span>*)msgbuf,<span class="string">&quot;Contrast:%d&quot;</span>,(<span class="keyword">signed</span> <span class="keyword">char</span>)contrast<span class="number">-2</span>);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> KEY1_PRES:	<span class="comment">//饱和度Saturation</span></span><br><span class="line">					<span class="comment">//saturation++;</span></span><br><span class="line">					<span class="comment">//if(saturation&gt;4)saturation=0;</span></span><br><span class="line">					<span class="comment">//OV2640_Color_Saturation(saturation);</span></span><br><span class="line">					<span class="comment">//sprintf((char*)msgbuf,&quot;Saturation:%d&quot;,(signed char)saturation-2);</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> KEY2_PRES:<span class="comment">//特效设置				 </span></span><br><span class="line">					<span class="comment">//effect++;</span></span><br><span class="line">					<span class="comment">//if(effect&gt;6)effect=0;</span></span><br><span class="line">					<span class="comment">//OV2640_Special_Effects(effect);//设置特效</span></span><br><span class="line">					<span class="comment">//sprintf((char*)msgbuf,&quot;%s&quot;,EFFECTS_TBL[effect]);</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> WKUP_PRES:<span class="comment">//1:1尺寸(显示真实尺寸)/缩放	    </span></span><br><span class="line">					scale=!scale;  </span><br><span class="line">					</span><br><span class="line">                    <span class="keyword">if</span>(scale==<span class="number">0</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						OV2640_ImageWin_Set((<span class="number">1600</span>-lcddev.width)/<span class="number">2</span>,(<span class="number">1200</span>-lcddev.height)/<span class="number">2</span>,lcddev.width,lcddev.height);<span class="comment">//1:1真实尺寸</span></span><br><span class="line">						OV2640_OutSize_Set(lcddev.width,lcddev.height); </span><br><span class="line">						<span class="built_in">sprintf</span>((<span class="keyword">char</span>*)msgbuf,<span class="string">&quot;Full Size 1:1&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						OV2640_ImageWin_Set(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1600</span>,<span class="number">1200</span>);				<span class="comment">//全尺寸缩放</span></span><br><span class="line">						OV2640_OutSize_Set(lcddev.width,lcddev.height); </span><br><span class="line">						<span class="built_in">sprintf</span>((<span class="keyword">char</span>*)msgbuf,<span class="string">&quot;Scale&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			LCD_ShowString(<span class="number">30</span>,<span class="number">50</span>,<span class="number">210</span>,<span class="number">16</span>,<span class="number">16</span>,msgbuf);<span class="comment">//显示提示内容</span></span><br><span class="line">			delay_ms(<span class="number">800</span>);</span><br><span class="line">			DCMI_Start();<span class="comment">//重新开始传输</span></span><br><span class="line">		&#125; </span><br><span class="line">		delay_ms(<span class="number">10</span>);		</span><br><span class="line">	&#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	u8 key;</span><br><span class="line">	u8 t;</span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//设置系统中断优先级分组2</span></span><br><span class="line">	delay_init(<span class="number">168</span>);<span class="comment">//初始化延时函数</span></span><br><span class="line">	uart_init(<span class="number">115200</span>);<span class="comment">//初始化串口波特率为115200</span></span><br><span class="line">	usart2_init(<span class="number">42</span>,<span class="number">115200</span>);<span class="comment">//初始化串口2波特率为115200</span></span><br><span class="line">	LED_Init();<span class="comment">//初始化LED </span></span><br><span class="line"> 	LCD_Init();<span class="comment">//LCD初始化  </span></span><br><span class="line"> 	KEY_Init();<span class="comment">//按键初始化 </span></span><br><span class="line">	TIM3_Int_Init(<span class="number">10000</span><span class="number">-1</span>,<span class="number">8400</span><span class="number">-1</span>);<span class="comment">//10Khz计数,1秒钟中断一次</span></span><br><span class="line">	</span><br><span class="line"> 	usmart_dev.init(<span class="number">84</span>);<span class="comment">//初始化USMART</span></span><br><span class="line"> 	POINT_COLOR=RED;<span class="comment">//设置字体为红色 </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(OV2640_Init())<span class="comment">//初始化OV2640</span></span><br><span class="line">	&#123;</span><br><span class="line">		LCD_ShowString(<span class="number">30</span>,<span class="number">130</span>,<span class="number">240</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;OV2640 ERR&quot;</span>);</span><br><span class="line">		delay_ms(<span class="number">200</span>);</span><br><span class="line">	    LCD_Fill(<span class="number">30</span>,<span class="number">130</span>,<span class="number">239</span>,<span class="number">170</span>,WHITE);</span><br><span class="line">		delay_ms(<span class="number">200</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	LCD_ShowString(<span class="number">30</span>,<span class="number">130</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;OV2640 OK&quot;</span>);</span><br><span class="line">    </span><br><span class="line"> 	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;	</span><br><span class="line">		key=KEY_Scan(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(key==KEY0_PRES)<span class="comment">//RGB565模式</span></span><br><span class="line">		&#123;</span><br><span class="line">			ov2640_mode=<span class="number">0</span>;   </span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key==WKUP_PRES)<span class="comment">//JPEG模式</span></span><br><span class="line">		&#123;</span><br><span class="line">			ov2640_mode=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		t++; 									  </span><br><span class="line">		<span class="keyword">if</span>(t==<span class="number">100</span>)</span><br><span class="line">            LCD_ShowString(<span class="number">30</span>,<span class="number">150</span>,<span class="number">230</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;KEY0:RGB565  KEY_UP:JPEG&quot;</span>);<span class="comment">//闪烁显示提示信息</span></span><br><span class="line"> 		<span class="keyword">if</span>(t==<span class="number">200</span>)</span><br><span class="line">		&#123;	</span><br><span class="line">			LCD_Fill(<span class="number">30</span>,<span class="number">150</span>,<span class="number">230</span>,<span class="number">150</span>+<span class="number">16</span>,WHITE);</span><br><span class="line">			t=<span class="number">0</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		delay_ms(<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ov2640_mode)</span><br><span class="line">        jpeg_test();</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">        rgb565_test(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">stm32</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2021/11/19/STM32%E5%A4%96%E8%AE%BE%E9%85%8D%E7%BD%AE%E9%80%9F%E6%9F%A5%E3%80%90%E6%91%84%E5%83%8F%E5%A4%B4%E3%80%91/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-STM32深入学习【RCC】" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90RCC%E3%80%91/">STM32深入学习【RCC】</a>
    </h1>
  

        
<!-- 显示阅读次数-->
<!--  -->
<!--显示阅读次数完毕 -->

        
        <a href="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90RCC%E3%80%91/" class="archive-article-date">
  	<time datetime="2021-11-19T08:03:19.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2021-11-19</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="复位"><a href="#复位" class="headerlink" title="复位"></a>复位</h1><h2 id="系统复位"><a href="#系统复位" class="headerlink" title="系统复位"></a>系统复位</h2><p>系统复位将所有寄存器复位，<strong>除了时钟控制寄存器CSR中的复位标志和备份域寄存器</strong></p>
<p>复位条件：</p>
<ol>
<li><p><strong>外部复位：NRST引脚电平拉低</strong></p>
</li>
<li><p>WWDG复位：窗口看门狗计数结束</p>
</li>
<li><p>IWDG复位：独立看门狗计数结束</p>
</li>
<li><p><strong>软件复位(内核软复位)：将Cortex-M4内核的应用中断和复位控制寄存器(SCB_AIRCR)中的SYSRESEREQ(sys_reset_eq)位 置1</strong></p>
<p> 在以下三种情况下会产生<strong>内核复位</strong>：</p>
<ol>
<li>上电复位：MCU通电时内核自动将所有组成部件复位</li>
<li>系统复位：只复位处理器和外设，不会复位内核debug部分（常用来进行debug）</li>
<li>处理器复位：仅复位处理器</li>
</ol>
<p> 上电复位和系统复位持续时间取决于MCU设计，在一些情况下，复位会持续数毫秒来等待晶振时钟稳定。在复位后、处理器运行程序之前，Cortex-M处理器将从内存中读取前两个字，即 位于中断向量表之前的<strong>主栈顶指针(MSP Main Stack Pointer)<strong>和</strong>复位向量</strong>初始值，其中复位向量就是复位句柄的起始地址。在这两个字被处理器读取以后，处理器会以这两个值建立主堆栈指针MSP和程序计数器PC</p>
<p> 提前建立MSP的原因：上电后可能会出现系统错误以至于处理器调用NMI或硬件错误相关服务函数，就需要栈内存和MSP把一些处理器状态信息压栈来处理系统错误相关的中断</p>
<p> 注意：Cortex-M4的SP初始化和传统ARM核的初始化不相同，它必须被在软件中初始化，而中断向量表存储的是中断向量的地址，因为M4的栈是自顶向下生长的，初始化的SP值应该被设置到栈顶以下的第一个内存，如下图所示：<strong>中断向量表之前的SP初始值是一个指向栈顶的指针</strong></p>
<p> <img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90RCC%E3%80%91/image-20210111171431355.png" alt="image-20210111171431355"></p>
<p> 下面是arm提供的core_cm4.h文件中有关系统复位的程序,以C内嵌汇编代码写成</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__STATIC_INLINE <span class="keyword">void</span> <span class="title">NVIC_SystemReset</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __DSB();<span class="comment">/* Ensure all outstanding memory accesses included</span></span><br><span class="line"><span class="comment">  			buffered write are completed before reset */</span></span><br><span class="line">  SCB-&gt;AIRCR  = (<span class="keyword">uint32_t</span>)((<span class="number">0x5FA</span>UL &lt;&lt; SCB_AIRCR_VECTKEY_Pos)    |</span><br><span class="line">                           (SCB-&gt;AIRCR &amp; SCB_AIRCR_PRIGROUP_Msk) |</span><br><span class="line">                            SCB_AIRCR_SYSRESETREQ_Msk    );<span class="comment">/* Keep priority group unchanged */</span></span><br><span class="line">  __DSB();<span class="comment">/* Ensure completion of memory access */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;)<span class="comment">/* wait until reset */</span></span><br><span class="line">  &#123;</span><br><span class="line">    __NOP();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>低功耗管理复位</p>
<p> 引发低功耗复位的方式：</p>
<ol>
<li>进入待机时复位：清零用户选项字节中的nRST_STDBY位。使能后，只要成功执行进入待机模式序列，MCU就不会进入待机，而是进行复位</li>
<li>进入停止模式时产生复位：清零用户选项字节中的nRST_STOP位。使能后，只要成功执行进入停止模式序列，MCU就不会进入停止模式，而是进行复位</li>
</ol>
</li>
</ol>
<h2 id="电源复位"><a href="#电源复位" class="headerlink" title="电源复位"></a>电源复位</h2><p>将<strong>除备份域内的寄存器外</strong>，其他所有寄存器复位</p>
<p>MCU内部的复位信号会在NRST引脚上输出，脉冲发生器会确保每个内部复位源的<strong>复位脉冲都至少持续20us</strong></p>
<p>条件：</p>
<ol>
<li>上电/掉电/欠压复位</li>
<li>退出待机模式复位</li>
</ol>
<p>复位电路如下：</p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90RCC%E3%80%91/image-20210111181028844.png" alt="image-20210111181028844"></p>
<h2 id="备份域复位"><a href="#备份域复位" class="headerlink" title="备份域复位"></a>备份域复位</h2><p>备份域复位会将<strong>所有RTC寄存器和RCC_BDCR寄存器复位</strong>，但<strong>BKPSRAM不受影响</strong></p>
<p>BKPSRAM的<strong>唯一</strong>复位方式是通过FLASH接口将FLASH保护等级从1切换到0</p>
<p>复位条件：</p>
<ol>
<li>软件复位：将RCC备份域控制寄存器(RCC_BDCR)中的BDRST位 置1</li>
<li>在$V_{DD}$和$V_{BAT}$都掉电后，其中任意一个又再上电</li>
</ol>
<p>即 备份域靠$V_{BAT}$来维持断电情况下的运行，但如果$V_{BAT}$掉电则备份域无法保存数据</p>
<h1 id="时钟控制-RCC"><a href="#时钟控制-RCC" class="headerlink" title="时钟控制(RCC)"></a>时钟控制(RCC)</h1><p>ARM核的SoC底层都采用了同步时序电路和时钟门控技术。外设控制寄存器使用D触发器构成，在时钟信号的变沿触发，这就导致了想配置外设寄存器就必须供给其时钟，而时钟又是片上资源消耗较多的一个功能实现，所以stm32采用了时钟门控技术，可以独立开启/关闭某个外设的时钟，在不需要时可以关闭一个外设的时钟来实现低功耗</p>
<h2 id="时钟源"><a href="#时钟源" class="headerlink" title="时钟源"></a>时钟源</h2><p>系统时钟由<strong>HSI时钟、HSE时钟、主PLL时钟</strong>三者之一来驱动</p>
<p>同时，MCU可接入**32kHz低速内部RC(LSI RC)<strong>驱动IWDG，也可用于RTC在停机/待机模式下的自动唤醒；还可接入</strong>32.768kHz低速外部晶振(LSE晶振)**来驱动RTC时钟</p>
<p>每个时钟源都可以独立打开或关闭，同时开启的时钟源越少，功耗越低</p>
<h2 id="时钟树"><a href="#时钟树" class="headerlink" title="时钟树"></a>时钟树</h2><p>stm32f4的内部时钟相当复杂，呈多输入-多输出的树形结构，可分为以下几个主要组成部分</p>
<h3 id="总线时钟"><a href="#总线时钟" class="headerlink" title="总线时钟"></a>总线时钟</h3><p>所有内部总线都可以通过多个预分频器进行时钟配置</p>
<p>AHB最大频率168MHz</p>
<p>高速APB2最大频率84MHz</p>
<p>低速APB1最大频率42MHz</p>
<h3 id="特殊外设时钟"><a href="#特殊外设时钟" class="headerlink" title="特殊外设时钟"></a>特殊外设时钟</h3><table>
<thead>
<tr>
<th>外设</th>
<th>频率</th>
<th>时钟源</th>
<th>时钟源频率</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>USB OTG FS</td>
<td>=48MHz</td>
<td>特定PLL输出</td>
<td>48MHz</td>
<td>PLL48CLK</td>
</tr>
<tr>
<td>RNG</td>
<td>&lt;=48MHz</td>
<td>特定PLL输出</td>
<td>48MHz</td>
<td>PLL48CLK</td>
</tr>
<tr>
<td>SDIO</td>
<td>&lt;=48MHz</td>
<td>特定PLL输出</td>
<td>48MHz</td>
<td>PLL48CLK</td>
</tr>
<tr>
<td>I2S时钟</td>
<td>数据包位宽*2*音频采样频率</td>
<td>特定PLL输出 或 I2S_CKIN引脚的外部时钟</td>
<td></td>
<td>PLL I2S</td>
</tr>
<tr>
<td>USB OTG HS</td>
<td>=60MHz</td>
<td>外部USB2.0 PHY</td>
<td>24-60MHz</td>
<td>USB HS ULPI</td>
</tr>
<tr>
<td>以太网</td>
<td>&gt;=25MHz</td>
<td>外部PHY提供的以太网MAC时钟</td>
<td>25-50MHz</td>
<td>MACRXCLK等</td>
</tr>
<tr>
<td>以太网</td>
<td></td>
<td>(包括TX、RX、RMII)</td>
<td></td>
<td>（见下图）</td>
</tr>
</tbody></table>
<p>下图为特殊外设时钟树</p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90RCC%E3%80%91/image-20210111183533164.png" alt="image-20210111183533164"></p>
<h3 id="系统定时器-SysTick-时钟"><a href="#系统定时器-SysTick-时钟" class="headerlink" title="系统定时器(SysTick)时钟"></a>系统定时器(SysTick)时钟</h3><p>使用<strong>8分频的AHB时钟(HCLK)<strong>或直接使用</strong>AHB时钟(HCLK)</strong></p>
<p>可在SysTick控制和状态寄存器中配置</p>
<h3 id="硬件定时器时钟"><a href="#硬件定时器时钟" class="headerlink" title="硬件定时器时钟"></a>硬件定时器时钟</h3><p>stm32f42xxx和43xxx的定时器时钟频率由<strong>硬件自动设置</strong></p>
<p>根据RCC_CFGR寄存器中TIIMPRE位的取值分为两种情况</p>
<ol>
<li><p>TIMPRE=0</p>
<p> APB预分频器分频系数为1，则设定定时器时钟TIMxCLK=PCLKx；否则，TIMxCLK=2*PCLKx</p>
</li>
<li><p>TIMPRE=1</p>
<p> APB预分频器分频系数为1、2或4，则设定定时器时钟TIMxCLK=HCLK；否则，TIMxCLK=4*PCLKx</p>
</li>
</ol>
<h3 id="内核自由运行时钟"><a href="#内核自由运行时钟" class="headerlink" title="内核自由运行时钟"></a>内核自由运行时钟</h3><p>由<strong>FCLK</strong>充当</p>
<h3 id="其他外设时钟"><a href="#其他外设时钟" class="headerlink" title="其他外设时钟"></a>其他外设时钟</h3><p>其他所有外设时钟均由系统时钟SYSCLK提供</p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90RCC%E3%80%91/image-20210111184430333.png" alt="image-20210111184430333"></p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90RCC%E3%80%91/image-20210111184357362.png" alt="image-20210111184357362"></p>
<h2 id="内部时钟信号"><a href="#内部时钟信号" class="headerlink" title="内部时钟信号"></a>内部时钟信号</h2><h3 id="高速外部时钟HSE-High-speed-Signal-Extern"><a href="#高速外部时钟HSE-High-speed-Signal-Extern" class="headerlink" title="高速外部时钟HSE(High-speed Signal Extern)"></a>高速外部时钟HSE(High-speed Signal Extern)</h3><p>==时钟源：HSE外部晶振 或 HSE外部用户时钟==</p>
<ol>
<li>外部源（HSE旁路）模式</li>
</ol>
<p>必须提供占空比约为50%的外部时钟信号来驱动OSC_IN引脚</p>
<p>信号可以是方波、正弦波或三角波之一</p>
<p>OSC_OUT引脚应保持高阻态</p>
<p><strong>将RCC_CR-&gt;HSEBYP=1和RCC_CR-&gt;HSEON=1可使用此模式</strong></p>
<ol start="2">
<li>外部晶振（HSE晶振）模式</li>
</ol>
<p>硬件要求：谐振器和负载电容必须尽可能靠近振荡器引脚来减少输出失真和起振稳定时间</p>
<p>RCC_CR-&gt;HSERDY标志位指示高速外部振荡器是否稳定，该标志位为1时才能使用该时钟</p>
<p>将RCC_CR-&gt;HSEON=1才能使用HSE晶振，即<strong>RCC_CR-&gt;HSEON=1和RCC_CR-&gt;HSERDY=1可使用此模式</strong></p>
<p>特别地，可以在RCC时钟中断寄存器RCC_CIR中使能中断来开启此模式下的中断</p>
<h3 id="高速内部时钟信号HSI-High-speed-Signal-Inner"><a href="#高速内部时钟信号HSI-High-speed-Signal-Inner" class="headerlink" title="高速内部时钟信号HSI(High-speed Signal Inner)"></a>高速内部时钟信号HSI(High-speed Signal Inner)</h3><p>==时钟源：内部16MHz频率RC振荡器==</p>
<p>可以直接用做系统时钟或用作PLL的输入</p>
<p>优点：成本低、起振速度较快    缺点：精度不如HSE</p>
<p>ST会对器件进行出厂较准，可达到$T_A=25+273K$下1%的精度；复位后，工厂校准值将加载到RCC_CR-&gt;HSICAL[7:0]位中，用户可通过RCC_CR-&gt;HSITRIM[4:0]位进行HSI频率微调以适应各种电压或温度</p>
<p>RCC_CR-&gt;HSIRDY标志位为1表示HSI RC稳定运行，只有此情况下，HSI才能使用</p>
<p>将RCC_CR-&gt;HSION=1可打开HSI RC</p>
<p><strong>RCC_CR-&gt;HSION=1和RCC_CR-&gt;HSIRDY=1可使用此模式</strong></p>
<p>特殊情况下，HSII信号可以作为备份时钟源使用，以防HSE晶振故障</p>
<h3 id="锁相环电路PLL-Phase-Lock-Loop"><a href="#锁相环电路PLL-Phase-Lock-Loop" class="headerlink" title="锁相环电路PLL(Phase Lock Loop)"></a>锁相环电路PLL(Phase Lock Loop)</h3><p>stm32f4xx具有2个PLL</p>
<ol>
<li><p>主PLL(PLL)</p>
<p> 由HSE或HSI提供时钟信号，具有两个不同的输出时钟</p>
<ol>
<li>高速系统时钟输出：最高可达168MHz</li>
<li>PLL48CLK输出：最高可达48MHz，用于提供USB OTG FS、RNG、SDIO时钟</li>
</ol>
<p> 通过RCC_PLLCFGR寄存器进行配置，有M、N、P、Q共4个分频系数位</p>
<p> <img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90RCC%E3%80%91/image-20210111191542166.png" alt="image-20210111191542166"></p>
</li>
<li><p>专用PLL(PLLI2S)</p>
<p> 由HSE或HSI提供时钟信号</p>
<p> 用于生成精确时钟来在I2S接口实现高品质音频性能</p>
<p> 通过RCC_CFGR寄存器进行配置，有使能/禁止位N和分频系数位R</p>
<p> <img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90RCC%E3%80%91/image-20210111191557599.png" alt="image-20210111191557599"></p>
</li>
</ol>
<p>==注意：使能PLL后，PLL配置参数不可再更改，应先对PLL进行配置，然后再使能==</p>
<p>进入停机或待机模式后，两个PLL将被硬件禁止；如将HSE或由HSE提供信号的PLL用作系统时钟时，HSE发生故障，则两个PLL也将由硬件禁止</p>
<h3 id="低速外部时钟信号LSE-Low-speed-Signal-Extern"><a href="#低速外部时钟信号LSE-Low-speed-Signal-Extern" class="headerlink" title="低速外部时钟信号LSE(Low-speed Signal Extern)"></a>低速外部时钟信号LSE(Low-speed Signal Extern)</h3><p>==时钟源：LSE外部晶振 或 LSE外部用户时钟==</p>
<ol>
<li>外部源（LSE旁路）模式</li>
</ol>
<p>必须提供占空比约为50%，最高频率不超过1MHz的外部时钟信号来驱动OSC32_IN引脚</p>
<p>信号可以是方波、正弦波或三角波之一</p>
<p>OSC32_OUT引脚应保持高阻态</p>
<p><strong>将RCC_CR-&gt;LSEBYP=1和RCC_CR-&gt;LSEON=1可使用此模式</strong></p>
<ol start="2">
<li>外部晶振（LSE晶振）模式</li>
</ol>
<p>硬件要求：使用32.768kHz晶体振荡器，精度较高、功耗较低，谐振器和负载电容必须尽可能靠近振荡器引脚来减少输出失真和起振稳定时间</p>
<p>RCC_BDCR-&gt;LSERDY标志位指示低速外部振荡器是否稳定，该标志位为1时才能使用该时钟</p>
<p>将RCC_CR-&gt;LSEON=1才能使用LSE晶振，即<strong>RCC_CR-&gt;LSEON=1和RCC_CR-&gt;LSERDY=1可使用此模式</strong></p>
<p>特别地，可以在RCC时钟中断寄存器RCC_CIR中使能中断来开启此模式下的中断</p>
<h3 id="低速内部时钟信号LSI-Low-speed-Signal-Inner"><a href="#低速内部时钟信号LSI-Low-speed-Signal-Inner" class="headerlink" title="低速内部时钟信号LSI(Low-speed Signal Inner)"></a>低速内部时钟信号LSI(Low-speed Signal Inner)</h3><p><strong>可用作低功耗时钟源再停机和待机模式下保持运行</strong></p>
<p>可供独立看门狗IWDG和自动唤醒单元AWU使用</p>
<p>时钟频率在32kHz左右</p>
<p>RCC_CSR-&gt;LSIRDY标志位指示低速内部振荡器是否稳定，该标志位为1时才能使用该时钟</p>
<p>将RCC_CR-&gt;LSION=1才能使用LSE RC，即<strong>RCC_CR-&gt;LSION=1和RCC_CR-&gt;LSIRDY=1可使用此模式</strong></p>
<p>可以在RCC时钟中断寄存器RCC_CIR中使能中断来开启此模式下的中断</p>
<h2 id="系统时钟-SYSCLK"><a href="#系统时钟-SYSCLK" class="headerlink" title="系统时钟(SYSCLK)"></a>系统时钟(SYSCLK)</h2><p>系统时钟：MCU内部的主时钟，为内核处理器提供运行时钟</p>
<p>系统复位后，默认系统时钟为HSI，且在直接使用HSI或通过PLL使用HSI时钟源来作为系统时钟时，该时钟源无法停止</p>
<p>只有目标时钟源已经就绪（时钟在启动延迟或PLL锁相后稳定时），才能从一个时钟源切换到另一个；如果选择了尚未就绪的时钟源，则切换在该时钟源就绪时才进行，就绪状态由RCC_CR寄存器中的状态标志位指示</p>
<h2 id="时钟安全系统-CSS"><a href="#时钟安全系统-CSS" class="headerlink" title="时钟安全系统(CSS)"></a>时钟安全系统(CSS)</h2><p>时钟检测器可以通过软件打开，激活后将在HSE振荡器启动延迟后使能，在此振荡器停止时被关闭</p>
<p><strong>负责监控HSE时钟信号</strong></p>
<p>HSE故障时，此振荡器将自动禁止，CSS会发送一个时钟故障时间到TIM1和TIM8的短路输入，并生成一个时钟安全系统中断CSSI来向软件通知该故障，CSSI直接和M4内核的NMI（不可屏蔽中断）异常向量链接</p>
<p>注意：如果HSE偶发故障，则CSS会生成一个中断，NMI将无限期执行，需要在NMI ISR中将CSS中断清零，即<strong>将RCC_CIR-&gt;CSSC=1</strong>才能避免这种情况</p>
<h2 id="RTC-AWU时钟"><a href="#RTC-AWU时钟" class="headerlink" title="RTC/AWU时钟"></a>RTC/AWU时钟</h2><p>一旦选定RTCCLK时钟源后只能通过复位电源域来修改</p>
<p>配置RCC_BDCR-&gt;RTCSEL[1:0]和RCC_CFGR-&gt;RTCPRE[4:0]进行选择时钟源</p>
<p>可用于RTC的时钟源：</p>
<ol>
<li>HSE 1MHz：系统电源掉电或内部调压器关闭后无法保证RTC状态</li>
<li>LSE：只要$V_{BAT}$工作即可让RTC工作</li>
<li>LSI：系统电源丢失后无法保证AWU状态</li>
</ol>
<h2 id="看门狗时钟"><a href="#看门狗时钟" class="headerlink" title="看门狗时钟"></a>看门狗时钟</h2><p>独立看门狗强制要求LSI RC开启且不可禁止，LSI稳定后将被用于IWDG</p>
<h2 id="时钟输出功能"><a href="#时钟输出功能" class="headerlink" title="时钟输出功能"></a>时钟输出功能</h2><ol>
<li>MCO1</li>
</ol>
<p>可以通过预分频器向MCO1(PA8)输出HSI、LSE、HSE、PLL时钟之一</p>
<p>通过RCC_CFGR-&gt;MCO1PRE[2:0]和MCO1[1:0]进行选择</p>
<ol start="2">
<li>MCO2</li>
</ol>
<p>可以通过预分频器向MCO2(PC9)输出HSE、PLL、SYSCLK、PLLI2S时钟之一</p>
<p>通过RCC_CFGR-&gt;MCO2PRE[2:0]和MCO2[1:0]进行选择</p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90RCC%E3%80%91/image-20210111194823355.png" alt="image-20210111194823355"></p>
<p><strong>注意：MCO输出时钟不得超过最大IO速度(一般为100MHz)</strong></p>
<p><strong>必须将对应引脚设置为复用模式才可使用时钟输出功能</strong></p>
<h2 id="时钟测量"><a href="#时钟测量" class="headerlink" title="时钟测量"></a>时钟测量</h2><p>所有时钟源的频率都可以通过TIM5channel4和TIM11channel1的输入捕获进行<strong>间接测量</strong></p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90RCC%E3%80%91/image-20210111195057781.png" alt="image-20210111195057781"></p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90RCC%E3%80%91/image-20210111195828703.png" alt="image-20210111195828703"></p>
<h3 id="TIM5channel4的测量"><a href="#TIM5channel4的测量" class="headerlink" title="TIM5channel4的测量"></a>TIM5channel4的测量</h3><p>TIM5具有一个输入捕获复用器，可选择输入捕获是由IO触发还是由内部时钟触发</p>
<p>通过设置TIM5_OR-&gt;TI4_RMP[1:0]位进行选择</p>
<p>借助待测信号连续边沿之间的比较信号计数数量即可对内部时钟周期进行测量</p>
<p>$待测信号周期=\frac{比较信号周期}{比较信号数量}$</p>
<p>比较信号和待测信号频率（周期）之比越大，得到的结果越精确</p>
<h3 id="TIM11channel1的测量"><a href="#TIM11channel1的测量" class="headerlink" title="TIM11channel1的测量"></a>TIM11channel1的测量</h3><p>TIM11自带一个输入复用器，可选择输入捕获是由IO触发还是由内部时钟触发</p>
<p>另外，HSE_RTC时钟(由一个可编程预分频器分频的HSE)连接到channel1输入捕获，可用来粗略指示外部晶振频率</p>
<h1 id="常用RCC库函数"><a href="#常用RCC库函数" class="headerlink" title="常用RCC库函数"></a>常用RCC库函数</h1><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>RCC_AHBPeriphClockCmd()</td>
<td>使能/失能AHB外设时钟</td>
</tr>
<tr>
<td>RCC_APB2PeriphClockCmd()</td>
<td>使能/失能APB2外设时钟</td>
</tr>
<tr>
<td>RCC_APB1PeriphClockCmd()</td>
<td>使能/失能APB1外设时钟</td>
</tr>
<tr>
<td>RCC_HSICmd()</td>
<td>使能/失能HSI晶振</td>
</tr>
<tr>
<td>RCC_PLLConfig()</td>
<td>设置PLL时钟源及倍频系数</td>
</tr>
<tr>
<td>RCC_PLLCmd()</td>
<td>使能/失能PLL输出</td>
</tr>
<tr>
<td>RCC_SYSCLKConfig()</td>
<td>设置系统时钟SYSCLK</td>
</tr>
<tr>
<td>RCC_HCLKConfig()</td>
<td>设置AHB总线时钟HCLK</td>
</tr>
<tr>
<td>RCC_PCLK1Config()</td>
<td>设置低速APB时钟PCLK1</td>
</tr>
<tr>
<td>RCC_PCLK2Config()</td>
<td>设置高速APB时钟PCLK2</td>
</tr>
<tr>
<td>RCC_USBCLKConfig()</td>
<td>设置USB时钟</td>
</tr>
<tr>
<td>RCC_ADCCLKConfig()</td>
<td>设置ADC时钟</td>
</tr>
<tr>
<td>RCC_LSEConfig()</td>
<td>设置LSE晶振</td>
</tr>
<tr>
<td>RCC_LSICmd()</td>
<td>使能/失能LSE晶振</td>
</tr>
<tr>
<td>RCC_RTCCLKConfig()</td>
<td>设置RTC时钟</td>
</tr>
<tr>
<td>RCC_RTCCLKCmd()</td>
<td>使能/失能RTC时钟</td>
</tr>
<tr>
<td>RCC_GetClocksFreq()</td>
<td>返回不同片上时钟的频率</td>
</tr>
<tr>
<td>RCC_BackupResetCmd()</td>
<td>强制/释放后备域复位</td>
</tr>
<tr>
<td>RCC_HSEConfig()</td>
<td>设置HSE晶振</td>
</tr>
<tr>
<td>RCC_GetSYSCLKSource()</td>
<td>返回用作系统时钟SYSCLK的时钟源</td>
</tr>
<tr>
<td>RCC_ITConfig()</td>
<td>使能/失能指定的RCC中断</td>
</tr>
<tr>
<td>RCC_GetITStatus()</td>
<td>检查指定的RCC中断是否发生</td>
</tr>
<tr>
<td>RCC_ClearITPendingBit()</td>
<td>清除RCC的中断待处理位</td>
</tr>
<tr>
<td>RCC_GetFlagStatus()</td>
<td>检查指定的RCC标志位是否设置</td>
</tr>
</tbody></table>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">stm32</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90RCC%E3%80%91/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-STM32深入学习【中断控制】" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E3%80%91/">STM32深入学习【中断控制】</a>
    </h1>
  

        
<!-- 显示阅读次数-->
<!--  -->
<!--显示阅读次数完毕 -->

        
        <a href="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E3%80%91/" class="archive-article-date">
  	<time datetime="2021-11-19T08:02:43.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2021-11-19</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="嵌套向量中断控制器NVIC"><a href="#嵌套向量中断控制器NVIC" class="headerlink" title="嵌套向量中断控制器NVIC"></a>嵌套向量中断控制器NVIC</h1><p>ARM内核标准规定了使用<strong>嵌套向量中断控制器NVIC</strong>控制异常和中断。对于STM32F407的Cortex-M4内核，NVIC具有16个可编程优先级、86个可屏蔽中断通道（ARM标准规定NVIC最多支持240个中断请求、1个不可屏蔽中断NMI、1个systick中断和多个系统异常，STM32只用到了一部分）</p>
<p>为了继续执行被中断的程序，异常流程需要利用一些手段来保存被中断程序的状态（保护现场），并在异常处理完成后自动恢复（恢复现场），这个过程一般有硬件实现，但是也可以由硬件、软件共同操作。<strong>对于M4内核，当异常被接受后，有些寄存器会被自动保存到栈中，并在返回流程中自动回复，因此可以将异常处理写作普通的C函数，这并不会带来额外的软件开销</strong></p>
<p>这段C函数就被称为<strong>中断服务程序</strong>（中断服务函数）</p>
<p>在STM32中实现了NVIC并设置了专门用于控制外部中断/事件的EXTI外设</p>
<h3 id="NVIC设备与EXTI设备的概念梳理"><a href="#NVIC设备与EXTI设备的概念梳理" class="headerlink" title="NVIC设备与EXTI设备的概念梳理"></a>NVIC设备与EXTI设备的概念梳理</h3><p>NVIC是位于M4核内部的设备，负责处理<strong>来自内核外界的所有中断信号</strong>和<strong>来自内核的异常信号</strong></p>
<p>这里的异常实际上是狭义的异常概念——广义上异常包括了中断：内部的异常信号称为狭义的异常，外部的异常信号称为中断</p>
<p>根据内核IP厂商的划分，通常会用很多不同的方式称呼这个东西，但是本质上都差不多</p>
<p>EXTI设备则是位于STM32的SoC中，并不在内核上，作为一个专门的外设用来处理来自片外和SoC中的异常、中断、事件信号</p>
<p>这里的三个概念都是狭义的：</p>
<p>异常指来自SoC内部的异常信号，中断指来自SoC外部（一般是GPIO）的异常信号，而事件则是指来自SoC内部或外部的特殊异常，一般是某个外设完成某个任务或某个FIFO已满时发出的中断信号</p>
<p>信号的流向是：外部异常-&gt;EXTI-&gt;NVIC-&gt;内核</p>
<p>内核在接收到NVIC发来的中断请求后自动执行中断处理的硬件程序，而在此之前的操作都归属于NVIC完成</p>
<p>详细的内核中断流程需要参考Cortex-M4内核相关参考手册或教程，这里不再赘述</p>
<h2 id="外部中断-事件控制器EXTI"><a href="#外部中断-事件控制器EXTI" class="headerlink" title="外部中断/事件控制器EXTI"></a>外部中断/事件控制器EXTI</h2><p>外部中断/事件控制器是NVIC内部专用于控制外部中断的设备，包含23个可用于产生事件/中断请求的边沿检测其，每根输入线都能单独配置、单独屏蔽</p>
<p>EXTI控制器具有以下特性</p>
<ul>
<li>每个中断/事件线上都具有独立的触发和屏蔽</li>
<li>每个中断线都具有专用的状态位</li>
<li>支持多达 23 个软件事件/中断请求</li>
<li>检测脉冲宽度低于 APB2 时钟宽度的外部信号</li>
</ul>
<p>EXTI控制器结构框图如下</p>
<p> <img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E3%80%91/image-20210513091957958.png" alt="image-20210513091957958"></p>
<p><strong>中断信号的捕获</strong>：输入线可以配置到其他外设（如GPIO），输入信号会先通过边沿检测电路，如果配置了跳变沿触发的外部中断，对应的跳变沿信号会将跳变沿触发选择寄存器置位，此时CPU就可以通过AMBA总线（一般是APB总线）访问EXTI外设中的对应寄存器，进而检测到中断信号</p>
<p><strong>中断事件屏蔽</strong>：当对中断屏蔽寄存器、软件中断事件寄存器置位时，信号会经过后续逻辑电路的处理：<em>跳变沿<strong>或</strong>软件中断事件出现</em>，或门就会输出1到后续的两个与门，<em>如果事件屏蔽寄存器对应位置1</em>，就会触发事件到脉冲发生器；<em>如果中断屏蔽寄存器对应位置1</em>，就会触发中断挂起请求，挂起请求寄存器置1，这个寄存器会直接被NVIC访问，实现直接对NVIC的中断控制，<em>CPU可访问该寄存器并清除对应位来恢复中断</em></p>
<h3 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h3><p>中断配置方法：</p>
<ol>
<li><p>配置并使能中断线</p>
<p> 根据需要的边缘检测设置2个触发寄存器，边沿检测电路就会按照配置进行外部输入信号的检测</p>
</li>
<li><p>在中断屏蔽寄存器要开启的控制位写1来使能中断请求</p>
</li>
</ol>
<p>事件的配置方法和上面一样，只不过需要把中断线改成对应事件线</p>
<p>中断/事件触发后，EXTI会产生中断请求，对应地挂起位会置1</p>
<p>在挂起寄存器的对应位写1会清除对应中断请求，<strong>在中断处理程序的开头一定要记得清除中断请求</strong>，否则中断会一直进行</p>
<h3 id="硬件中断-事件选择配置"><a href="#硬件中断-事件选择配置" class="headerlink" title="硬件中断/事件选择配置"></a>硬件中断/事件选择配置</h3><ol>
<li>配置中断线/事件线（各23根）的屏蔽位（EXTI_IMR和EXTI_EMR寄存器）</li>
<li>配置中断/事件线的触发选择位（EXTI_RTSR和EXTI_FTSR寄存器）</li>
<li>如果是配置外部中断，还需要配置到对应外部中断控制器EXTI的NVIC中断通道使能和屏蔽位，使得23个中断线中的请求可以被M4内核正确响应</li>
</ol>
<p>当然除了硬件中断外也可以单独配置软件中断/事件模式，大体流程和硬件的差不多，STM也提供了库函数（STP库和LL库有，HAL库就没有，当然用HAL库也不在意这些东西）</p>
<h3 id="外部中断-事件线映射"><a href="#外部中断-事件线映射" class="headerlink" title="外部中断/事件线映射"></a>外部中断/事件线映射</h3><p>详细的映射表可以查阅STM32F4xx参考手册，这里不列出</p>
<p>只需要注意一点：<strong>所有EXTI的映射都是固定的</strong>，千万不要弄错EXTI线与GPIO的端口对应，否则会导致中断用不了！</p>
<p>作者在刚学习STM32的时候曾经犯过这个错误，把RTC的EXTI直接接到了GPIO，然后发现中断没有任何效果，查了好久才明白EXTI线和GPIO的对应关系</p>
<h2 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h2><p>中断向量表是位于MCU的bootloader代码部分中用于声明中断跳转位置的一段代码</p>
<p>使用中断向量表保证MCU中断跳转不会跑飞</p>
<p>相关内容请参考bootloader相关材料或教程</p>
<h2 id="EXTI系统事件"><a href="#EXTI系统事件" class="headerlink" title="EXTI系统事件"></a>EXTI系统事件</h2><h3 id="唤醒事件"><a href="#唤醒事件" class="headerlink" title="唤醒事件"></a>唤醒事件</h3><p>STM32可以处理外部或内部事件对内核进行唤醒（WFE）</p>
<p>唤醒的途径有以下两种</p>
<ul>
<li><p>在外设控制寄存器处使能一个中断，但不在NVIC中使能；同时使能M4内核控制寄存器中的SEVONPEND位</p>
<p>  <strong>在MCU从WFE恢复时，一定要清除对应外设和外设NVIC的中断/中断通道挂起位</strong></p>
</li>
<li><p>配置一个外部或内部EXTI线为事件模式，当CPU从WFE恢复时，因为对应事件线的挂起位没有被置位，所以不必清除相应外设的中断挂起位或NVIC中断通道挂起位</p>
</li>
</ul>
<h3 id="RTC事件"><a href="#RTC事件" class="headerlink" title="RTC事件"></a>RTC事件</h3><p>STM32F4支持来自SoC内部的RTC中断唤醒，通过配置SoC唤醒中断就可以开启这个事件</p>
<p>RTC事件的中断线固定为22号</p>
<h2 id="NVIC与EXTI外设的库函数"><a href="#NVIC与EXTI外设的库函数" class="headerlink" title="NVIC与EXTI外设的库函数"></a>NVIC与EXTI外设的库函数</h2><p>库函数.c文件的前半部分简要说明了外部中断线的映射</p>
<blockquote>
<p>[..] External interrupt/event lines are mapped as following:<br>(#) All available GPIO pins are connected to the 16 external<br>    interrupt/event lines from EXTI0 to EXTI15.<br>(#) EXTI line 16 is connected to the PVD Output<br>(#) EXTI line 17 is connected to the RTC Alarm event<br>(#) EXTI line 18 is connected to the USB OTG FS Wakeup from suspend event<br>(#) EXTI line 19 is connected to the Ethernet Wakeup event<br>(#) EXTI line 20 is connected to the USB OTG HS (configured in FS) Wakeup event<br>(#) EXTI line 21 is connected to the RTC Tamper and Time Stamp events<br>(#) EXTI line 22 is connected to the RTC Wakeup event</p>
<p>外部中断线如下映射：</p>
<ul>
<li>所有GPIO引脚连接到从EXTI0到EXTI15的外部中断/事件线</li>
<li>EXTI16连接到PVD输出</li>
<li>EXTI17连接到RTC闹钟事件</li>
<li>EXTI18连接到USB OTG FS唤醒事件</li>
<li>EXTI19连接到以太网唤醒事件</li>
<li>EXTI20连接到USB OTG HS唤醒事件</li>
<li>EXTI21连接到RTC检测和时间戳事件</li>
<li>EXTI22连接到RTC唤醒事件</li>
</ul>
</blockquote>
<p>配置步骤如下：</p>
<ol>
<li>使用<code>RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE)</code>开启EXTI外设时钟</li>
<li>使用<code>GPIO_Init()</code>函数配置GPIO为输入模式</li>
<li>使用<code>SYSCFG_EXTILineConfig()</code>配置输入源连接到对应的EXTI线</li>
<li>使用EXTI外设配置结构体设置模式、触发选项，并使用<code>EXTI_Init()</code>应用设置</li>
<li>使用<code>NVIC_Init()</code>函数开启EXTI连接到NVIC中断通道</li>
</ol>
<h3 id="EXTI库函数参考"><a href="#EXTI库函数参考" class="headerlink" title="EXTI库函数参考"></a>EXTI库函数参考</h3><ol>
<li>将EXTI配置寄存器置0</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI_DeInit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  EXTI-&gt;IMR = <span class="number">0x00000000</span>;</span><br><span class="line">  EXTI-&gt;EMR = <span class="number">0x00000000</span>;</span><br><span class="line">  EXTI-&gt;RTSR = <span class="number">0x00000000</span>;</span><br><span class="line">  EXTI-&gt;FTSR = <span class="number">0x00000000</span>;</span><br><span class="line">  EXTI-&gt;PR = <span class="number">0x007FFFFF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>初始化EXTI初始化结构体和配置寄存器</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI_StructInit</span><span class="params">(EXTI_InitTypeDef* EXTI_InitStruct)</span> <span class="comment">//初始化EXTI配置结构体</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  EXTI_InitStruct-&gt;EXTI_Line = EXTI_LINENONE;</span><br><span class="line">  EXTI_InitStruct-&gt;EXTI_Mode = EXTI_Mode_Interrupt;</span><br><span class="line">  EXTI_InitStruct-&gt;EXTI_Trigger = EXTI_Trigger_Falling;</span><br><span class="line">  EXTI_InitStruct-&gt;EXTI_LineCmd = DISABLE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI_Init</span><span class="params">(EXTI_InitTypeDef* EXTI_InitStruct)</span> <span class="comment">//初始化EXTI配置寄存器（应用设置）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> tmp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_EXTI_MODE(EXTI_InitStruct-&gt;EXTI_Mode));</span><br><span class="line">  assert_param(IS_EXTI_TRIGGER(EXTI_InitStruct-&gt;EXTI_Trigger));</span><br><span class="line">  assert_param(IS_EXTI_LINE(EXTI_InitStruct-&gt;EXTI_Line));  </span><br><span class="line">  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct-&gt;EXTI_LineCmd));</span><br><span class="line"></span><br><span class="line">  tmp = (<span class="keyword">uint32_t</span>)EXTI_BASE;</span><br><span class="line">     </span><br><span class="line">  <span class="keyword">if</span> (EXTI_InitStruct-&gt;EXTI_LineCmd != DISABLE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Clear EXTI line configuration */</span></span><br><span class="line">    EXTI-&gt;IMR &amp;= ~EXTI_InitStruct-&gt;EXTI_Line;</span><br><span class="line">    EXTI-&gt;EMR &amp;= ~EXTI_InitStruct-&gt;EXTI_Line;</span><br><span class="line">    </span><br><span class="line">    tmp += EXTI_InitStruct-&gt;EXTI_Mode;</span><br><span class="line"></span><br><span class="line">    *(__IO <span class="keyword">uint32_t</span> *) tmp |= EXTI_InitStruct-&gt;EXTI_Line;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Clear Rising Falling edge configuration */</span></span><br><span class="line">    EXTI-&gt;RTSR &amp;= ~EXTI_InitStruct-&gt;EXTI_Line;</span><br><span class="line">    EXTI-&gt;FTSR &amp;= ~EXTI_InitStruct-&gt;EXTI_Line;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Select the trigger for the selected external interrupts */</span></span><br><span class="line">    <span class="keyword">if</span> (EXTI_InitStruct-&gt;EXTI_Trigger == EXTI_Trigger_Rising_Falling)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Rising Falling edge */</span></span><br><span class="line">      EXTI-&gt;RTSR |= EXTI_InitStruct-&gt;EXTI_Line;</span><br><span class="line">      EXTI-&gt;FTSR |= EXTI_InitStruct-&gt;EXTI_Line;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      tmp = (<span class="keyword">uint32_t</span>)EXTI_BASE;</span><br><span class="line">      tmp += EXTI_InitStruct-&gt;EXTI_Trigger;</span><br><span class="line"></span><br><span class="line">      *(__IO <span class="keyword">uint32_t</span> *) tmp |= EXTI_InitStruct-&gt;EXTI_Line;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    tmp += EXTI_InitStruct-&gt;EXTI_Mode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Disable the selected external lines */</span></span><br><span class="line">    *(__IO <span class="keyword">uint32_t</span> *) tmp &amp;= ~EXTI_InitStruct-&gt;EXTI_Line;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在选定的中断线上生成软件中断</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI_GenerateSWInterrupt</span><span class="params">(<span class="keyword">uint32_t</span> EXTI_Line)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_EXTI_LINE(EXTI_Line));</span><br><span class="line">  </span><br><span class="line">  EXTI-&gt;SWIER |= EXTI_Line;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>获取当前中断状态、清除中断标志位</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FlagStatus <span class="title">EXTI_GetFlagStatus</span><span class="params">(<span class="keyword">uint32_t</span> EXTI_Line)</span> <span class="comment">//获取当前中断标志位状态</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FlagStatus bitstatus = RESET;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_GET_EXTI_LINE(EXTI_Line));</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ((EXTI-&gt;PR &amp; EXTI_Line) != (<span class="keyword">uint32_t</span>)RESET)</span><br><span class="line">  &#123;</span><br><span class="line">    bitstatus = SET;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    bitstatus = RESET;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bitstatus;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ITStatus <span class="title">EXTI_GetITStatus</span><span class="params">(<span class="keyword">uint32_t</span> EXTI_Line)</span> <span class="comment">//获取当前中断状态</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FlagStatus bitstatus = RESET;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_GET_EXTI_LINE(EXTI_Line));</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ((EXTI-&gt;PR &amp; EXTI_Line) != (<span class="keyword">uint32_t</span>)RESET)</span><br><span class="line">  &#123;</span><br><span class="line">    bitstatus = SET;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    bitstatus = RESET;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bitstatus;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI_ClearFlag</span><span class="params">(<span class="keyword">uint32_t</span> EXTI_Line)</span> <span class="comment">//清除中断标志位</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_EXTI_LINE(EXTI_Line));</span><br><span class="line">  </span><br><span class="line">  EXTI-&gt;PR = EXTI_Line;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI_ClearITPendingBit</span><span class="params">(<span class="keyword">uint32_t</span> EXTI_Line)</span> <span class="comment">//清除中断挂起标志</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_EXTI_LINE(EXTI_Line));</span><br><span class="line">  </span><br><span class="line">  EXTI-&gt;PR = EXTI_Line;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是一些定义在STP库头文件中结构体和宏函数的简述</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择事件触发还是中断触发</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  EXTI_Mode_Interrupt = <span class="number">0x00</span>,</span><br><span class="line">  EXTI_Mode_Event = <span class="number">0x04</span></span><br><span class="line">&#125;EXTIMode_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_EXTI_MODE(MODE) (((MODE) == EXTI_Mode_Interrupt) || ((MODE) == EXTI_Mode_Event))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//EXTI触发状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  EXTI_Trigger_Rising = <span class="number">0x08</span>,</span><br><span class="line">  EXTI_Trigger_Falling = <span class="number">0x0C</span>,  </span><br><span class="line">  EXTI_Trigger_Rising_Falling = <span class="number">0x10</span></span><br><span class="line">&#125;EXTITrigger_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_EXTI_TRIGGER(TRIGGER) (((TRIGGER) == EXTI_Trigger_Rising) || \</span></span><br><span class="line"><span class="meta">                                  ((TRIGGER) == EXTI_Trigger_Falling) || \</span></span><br><span class="line"><span class="meta">                                  ((TRIGGER) == EXTI_Trigger_Rising_Falling))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//EXTI配置结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> EXTI_Line; <span class="comment">//中断线号</span></span><br><span class="line">  EXTIMode_TypeDef EXTI_Mode; <span class="comment">//EXTI模式选择</span></span><br><span class="line">  EXTITrigger_TypeDef EXTI_Trigger; <span class="comment">//EXTI触发状态</span></span><br><span class="line">  FunctionalState EXTI_LineCmd; <span class="comment">//中断线使能</span></span><br><span class="line">&#125;EXTI_InitTypeDef;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是中断线的宏定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line0       ((uint32_t)0x00001)     <span class="comment">/*!&lt; External interrupt line 0 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line1       ((uint32_t)0x00002)     <span class="comment">/*!&lt; External interrupt line 1 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line2       ((uint32_t)0x00004)     <span class="comment">/*!&lt; External interrupt line 2 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line3       ((uint32_t)0x00008)     <span class="comment">/*!&lt; External interrupt line 3 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line4       ((uint32_t)0x00010)     <span class="comment">/*!&lt; External interrupt line 4 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line5       ((uint32_t)0x00020)     <span class="comment">/*!&lt; External interrupt line 5 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line6       ((uint32_t)0x00040)     <span class="comment">/*!&lt; External interrupt line 6 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line7       ((uint32_t)0x00080)     <span class="comment">/*!&lt; External interrupt line 7 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line8       ((uint32_t)0x00100)     <span class="comment">/*!&lt; External interrupt line 8 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line9       ((uint32_t)0x00200)     <span class="comment">/*!&lt; External interrupt line 9 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line10      ((uint32_t)0x00400)     <span class="comment">/*!&lt; External interrupt line 10 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line11      ((uint32_t)0x00800)     <span class="comment">/*!&lt; External interrupt line 11 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line12      ((uint32_t)0x01000)     <span class="comment">/*!&lt; External interrupt line 12 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line13      ((uint32_t)0x02000)     <span class="comment">/*!&lt; External interrupt line 13 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line14      ((uint32_t)0x04000)     <span class="comment">/*!&lt; External interrupt line 14 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line15      ((uint32_t)0x08000)     <span class="comment">/*!&lt; External interrupt line 15 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line16      ((uint32_t)0x10000)     <span class="comment">/*!&lt; External interrupt line 16 Connected to the PVD Output */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line17      ((uint32_t)0x20000)     <span class="comment">/*!&lt; External interrupt line 17 Connected to the RTC Alarm event */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line18      ((uint32_t)0x40000)     <span class="comment">/*!&lt; External interrupt line 18 Connected to the USB OTG FS Wakeup from suspend event */</span>                                    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line19      ((uint32_t)0x80000)     <span class="comment">/*!&lt; External interrupt line 19 Connected to the Ethernet Wakeup event */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line20      ((uint32_t)0x00100000)  <span class="comment">/*!&lt; External interrupt line 20 Connected to the USB OTG HS (configured in FS) Wakeup event  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line21      ((uint32_t)0x00200000)  <span class="comment">/*!&lt; External interrupt line 21 Connected to the RTC Tamper and Time Stamp events */</span>                                               </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line22      ((uint32_t)0x00400000)  <span class="comment">/*!&lt; External interrupt line 22 Connected to the RTC Wakeup event */</span>                                               </span></span><br><span class="line">                                          </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_EXTI_LINE(LINE) ((((LINE) &amp; (uint32_t)0xFF800000) == 0x00) &amp;&amp; ((LINE) != (uint16_t)0x00))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_GET_EXTI_LINE(LINE) (((LINE) == EXTI_Line0) || ((LINE) == EXTI_Line1) || \</span></span><br><span class="line"><span class="meta">                                ((LINE) == EXTI_Line2) || ((LINE) == EXTI_Line3) || \</span></span><br><span class="line"><span class="meta">                                ((LINE) == EXTI_Line4) || ((LINE) == EXTI_Line5) || \</span></span><br><span class="line"><span class="meta">                                ((LINE) == EXTI_Line6) || ((LINE) == EXTI_Line7) || \</span></span><br><span class="line"><span class="meta">                                ((LINE) == EXTI_Line8) || ((LINE) == EXTI_Line9) || \</span></span><br><span class="line"><span class="meta">                                ((LINE) == EXTI_Line10) || ((LINE) == EXTI_Line11) || \</span></span><br><span class="line"><span class="meta">                                ((LINE) == EXTI_Line12) || ((LINE) == EXTI_Line13) || \</span></span><br><span class="line"><span class="meta">                                ((LINE) == EXTI_Line14) || ((LINE) == EXTI_Line15) || \</span></span><br><span class="line"><span class="meta">                                ((LINE) == EXTI_Line16) || ((LINE) == EXTI_Line17) || \</span></span><br><span class="line"><span class="meta">                                ((LINE) == EXTI_Line18) || ((LINE) == EXTI_Line19) || \</span></span><br><span class="line"><span class="meta">                                ((LINE) == EXTI_Line20) || ((LINE) == EXTI_Line21) ||\</span></span><br><span class="line"><span class="meta">                                ((LINE) == EXTI_Line22))</span></span><br></pre></td></tr></table></figure>

<h3 id="使用库函数配置NVIC"><a href="#使用库函数配置NVIC" class="headerlink" title="使用库函数配置NVIC"></a>使用库函数配置NVIC</h3><p>在配置完EXTI后，还需要开启NVIC才能使用外部中断/事件；即使不使用外部中断，systick等SoC内部乃至内核异常都需要使能NVIC配置才行，ARM（这回不是ST了）提供了配置NVIC的库函数，保存在misc.c文件中</p>
<p>整套库函数都被包括在CMSIS标准中，这套标准可以在所有使用了ARM内核处理器的设备中通用，上到A53下到Cortex-M0都可以使用</p>
<p>因为这里主要讲述STM32F4相关的中断控制，对移植的操作不再赘述</p>
<p>软件配置NVIC主要是对中断优先级进行配置</p>
<p><strong>中断优先级分为抢占优先级和子优先级，抢占优先级高的中断可以对抢占优先级低的中断形成中断嵌套；如果抢占优先级相等，则子优先级更高的先执行；若两个中断优先级完全一致，则哪个先发生哪个先执行；数字越小，优先级越高</strong></p>
<p>使用库函数<code>NVIC_Init()</code>来配置中断优先级</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NVIC_Init</span><span class="params">(NVIC_InitTypeDef* NVIC_InitStruct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span> tmppriority = <span class="number">0x00</span>, tmppre = <span class="number">0x00</span>, tmpsub = <span class="number">0x0F</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct-&gt;NVIC_IRQChannelCmd));</span><br><span class="line">  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct-&gt;NVIC_IRQChannelPreemptionPriority));  </span><br><span class="line">  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct-&gt;NVIC_IRQChannelSubPriority));</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (NVIC_InitStruct-&gt;NVIC_IRQChannelCmd != DISABLE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Compute the Corresponding IRQ Priority --------------------------------*/</span>    </span><br><span class="line">    tmppriority = (<span class="number">0x700</span> - ((SCB-&gt;AIRCR) &amp; (<span class="keyword">uint32_t</span>)<span class="number">0x700</span>))&gt;&gt; <span class="number">0x08</span>;</span><br><span class="line">    tmppre = (<span class="number">0x4</span> - tmppriority);</span><br><span class="line">    tmpsub = tmpsub &gt;&gt; tmppriority;</span><br><span class="line"></span><br><span class="line">    tmppriority = NVIC_InitStruct-&gt;NVIC_IRQChannelPreemptionPriority &lt;&lt; tmppre;</span><br><span class="line">    tmppriority |=  (<span class="keyword">uint8_t</span>)(NVIC_InitStruct-&gt;NVIC_IRQChannelSubPriority &amp; tmpsub);</span><br><span class="line">        </span><br><span class="line">    tmppriority = tmppriority &lt;&lt; <span class="number">0x04</span>;</span><br><span class="line">        </span><br><span class="line">    NVIC-&gt;IP[NVIC_InitStruct-&gt;NVIC_IRQChannel] = tmppriority;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Enable the Selected IRQ Channels --------------------------------------*/</span></span><br><span class="line">    NVIC-&gt;ISER[NVIC_InitStruct-&gt;NVIC_IRQChannel &gt;&gt; <span class="number">0x05</span>] =</span><br><span class="line">      (<span class="keyword">uint32_t</span>)<span class="number">0x01</span> &lt;&lt; (NVIC_InitStruct-&gt;NVIC_IRQChannel &amp; (<span class="keyword">uint8_t</span>)<span class="number">0x1F</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Disable the Selected IRQ Channels -------------------------------------*/</span></span><br><span class="line">    NVIC-&gt;ICER[NVIC_InitStruct-&gt;NVIC_IRQChannel &gt;&gt; <span class="number">0x05</span>] =</span><br><span class="line">      (<span class="keyword">uint32_t</span>)<span class="number">0x01</span> &lt;&lt; (NVIC_InitStruct-&gt;NVIC_IRQChannel &amp; (<span class="keyword">uint8_t</span>)<span class="number">0x1F</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要特别注意的是：中断需要配置中断向量表才能使用——中断发生时处理器会根据中断向量表进行跳转</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NVIC_SetVectorTable</span><span class="params">(<span class="keyword">uint32_t</span> NVIC_VectTab, <span class="keyword">uint32_t</span> Offset)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));</span><br><span class="line">  assert_param(IS_NVIC_OFFSET(Offset));  </span><br><span class="line">   </span><br><span class="line">  SCB-&gt;VTOR = NVIC_VectTab | (Offset &amp; (<span class="keyword">uint32_t</span>)<span class="number">0x1FFFFF80</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置中断向量表的库函数一般不常用，中断向量表都会直接以汇编代码的形式写在bootloader中</p>
<p>ARM内核还具有中断分组机制，将所有中断分为0到4共5组</p>
<p>misc.c的描述如下：</p>
<table>
<thead>
<tr>
<th>NVIC分组</th>
<th>抢占优先级数目</th>
<th>子优先级数目</th>
<th>抢占优先级位数</th>
<th>子优先级位数</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0-15</td>
<td>0</td>
<td>4</td>
</tr>
<tr>
<td>1</td>
<td>0-1</td>
<td>0-7</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>0-3</td>
<td>0-3</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>0-7</td>
<td>0-1</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>0-15</td>
<td>0</td>
<td>4</td>
<td>0</td>
</tr>
</tbody></table>
<p>设置分组的原因是用户需求不同，但NVIC优先级控制寄存器位数有限，需要使用类似网络子网掩码的方式形成抢占优先级和子优先级分割，用户可以根据自己的需要选择合适的NVIC分组</p>
<p>使用库函数<code>NVIC_PriorityGroupConfig()</code>来配置中断分组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NVIC_PriorityGroupConfig</span><span class="params">(<span class="keyword">uint32_t</span> NVIC_PriorityGroup)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */</span></span><br><span class="line">  SCB-&gt;AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NVIC还支持低功耗唤醒的配置，使用下面的库函数配置低功耗唤醒源</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NVIC_SystemLPConfig</span><span class="params">(<span class="keyword">uint8_t</span> LowPowerMode, FunctionalState NewState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_NVIC_LP(LowPowerMode));</span><br><span class="line">  assert_param(IS_FUNCTIONAL_STATE(NewState));  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (NewState != DISABLE)</span><br><span class="line">  &#123;</span><br><span class="line">    SCB-&gt;SCR |= LowPowerMode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    SCB-&gt;SCR &amp;= (<span class="keyword">uint32_t</span>)(~(<span class="keyword">uint32_t</span>)LowPowerMode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NVIC配置结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint8_t</span> NVIC_IRQChannel; <span class="comment">//NVIC通道</span></span><br><span class="line">  <span class="keyword">uint8_t</span> NVIC_IRQChannelPreemptionPriority; <span class="comment">//抢占优先级</span></span><br><span class="line">  <span class="keyword">uint8_t</span> NVIC_IRQChannelSubPriority; <span class="comment">//子优先级</span></span><br><span class="line">  FunctionalState NVIC_IRQChannelCmd; <span class="comment">//NVIC中断使能状态</span></span><br><span class="line">&#125; NVIC_InitTypeDef;</span><br></pre></td></tr></table></figure>

<p>下面是一些关于中断的宏定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中断向量表基地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NVIC_VectTab_RAM             ((uint32_t)0x20000000)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NVIC_VectTab_FLASH           ((uint32_t)0x08000000)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_NVIC_VECTTAB(VECTTAB) (((VECTTAB) == NVIC_VectTab_RAM) || \</span></span><br><span class="line"><span class="meta">                                  ((VECTTAB) == NVIC_VectTab_FLASH))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//抢占优先级分组</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NVIC_PriorityGroup_0         ((uint32_t)0x700) <span class="comment">/*!&lt; 0 bits for pre-emption priority</span></span></span><br><span class="line"><span class="comment"><span class="meta">                                                            4 bits for subpriority */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NVIC_PriorityGroup_1         ((uint32_t)0x600) <span class="comment">/*!&lt; 1 bits for pre-emption priority</span></span></span><br><span class="line"><span class="comment"><span class="meta">                                                            3 bits for subpriority */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NVIC_PriorityGroup_2         ((uint32_t)0x500) <span class="comment">/*!&lt; 2 bits for pre-emption priority</span></span></span><br><span class="line"><span class="comment"><span class="meta">                                                            2 bits for subpriority */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NVIC_PriorityGroup_3         ((uint32_t)0x400) <span class="comment">/*!&lt; 3 bits for pre-emption priority</span></span></span><br><span class="line"><span class="comment"><span class="meta">                                                            1 bits for subpriority */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NVIC_PriorityGroup_4         ((uint32_t)0x300) <span class="comment">/*!&lt; 4 bits for pre-emption priority</span></span></span><br><span class="line"><span class="comment"><span class="meta">                                                            0 bits for subpriority */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PriorityGroup_0) || \</span></span><br><span class="line"><span class="meta">                                       ((GROUP) == NVIC_PriorityGroup_1) || \</span></span><br><span class="line"><span class="meta">                                       ((GROUP) == NVIC_PriorityGroup_2) || \</span></span><br><span class="line"><span class="meta">                                       ((GROUP) == NVIC_PriorityGroup_3) || \</span></span><br><span class="line"><span class="meta">                                       ((GROUP) == NVIC_PriorityGroup_4))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_NVIC_PREEMPTION_PRIORITY(PRIORITY)  ((PRIORITY) &lt; 0x10)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_NVIC_SUB_PRIORITY(PRIORITY)  ((PRIORITY) &lt; 0x10)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_NVIC_OFFSET(OFFSET)  ((OFFSET) &lt; 0x000FFFFF)</span></span><br></pre></td></tr></table></figure>

<p>misc中还有一些其他关于内核低功耗、systick时钟的库函数，这一部分不属于本文讨论范围，不再说明</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">stm32</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E3%80%91/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-STM32深入学习【定时器】" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/">STM32深入学习【定时器】</a>
    </h1>
  

        
<!-- 显示阅读次数-->
<!--  -->
<!--显示阅读次数完毕 -->

        
        <a href="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/" class="archive-article-date">
  	<time datetime="2021-11-19T08:01:44.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2021-11-19</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="定时器时钟"><a href="#定时器时钟" class="headerlink" title="定时器时钟"></a>定时器时钟</h1><blockquote>
<p>单片机就是定时器！定时器就是单片机！——某个不愿透露姓名的学长</p>
</blockquote>
<p>定时器是单片机的灵魂，学一个单片机，最先掌握的是GPIO，最容易掉坑的是中断控制器，最复杂的是那些总线协议，而最难掌握的就是定时器</p>
<p>这里笔者通过阅读STM32F4xx官方参考手册，配合英文版和中文版整理了与STM32标准外设库有关的定时器知识点（其实大部分是摘抄/翻译原文），经过自己浅薄的经验（半年多的STM32学习经历）梳理得到以下内容，权当抛砖引玉</p>
<p>将外设库源码摘抄附录在结尾，顺序与正文基本一致，可供参考</p>
<h2 id="内核定时器SYSTICK"><a href="#内核定时器SYSTICK" class="headerlink" title="内核定时器SYSTICK"></a>内核定时器SYSTICK</h2><blockquote>
<p>我心永恒——SysTick</p>
</blockquote>
<p>参考《Cortex M3与M4权威指南》内核定时器部分以获取更多信息</p>
<p>内核定时器SysTick是由ARM规定的包括在Cortex-M内核中的一个定时器，只能像基本定时器一样进行一般的定时功能，偶尔可以配合NVIC实现定时器中断</p>
<p>这个定时器主要用于作为操作系统（RTOS）系统时钟，使用CMSIS规定的库函数或寄存器就可以进行操作，大大增强操作系统的可移植性。下直自己码的简陋RTOS，上到嵌入式Linux都可以使用这个定时器</p>
<h2 id="通用定时器组1"><a href="#通用定时器组1" class="headerlink" title="通用定时器组1"></a>通用定时器组1</h2><blockquote>
<p>通用的就是最好的</p>
</blockquote>
<p>通用定时器由TIM2、TIM3、TIM4、TIM5组成，其中TIM2、5拥有32位自动重载计数器，精度更高；TIM3、4拥有16位自动重载计数器，该计数器由可编程预分频器驱动，<strong>预分频器为16位，分频系数在1到65536之间</strong></p>
<p>支持以下功能</p>
<ul>
<li>通过输入捕获测量输入信号脉冲宽度</li>
<li>可使用外部信号控制定时器</li>
<li>可实现多个定时器互连的同步电路</li>
<li>四个独立的输入捕获、输出比较和PWM输出、单脉冲输出通道</li>
<li>产生DMA请求（触发源包括定时器溢出、初始化、输入捕获、输出比较、触发事件等）</li>
<li>支持驱动编码器和霍尔传感器</li>
<li>外部时钟触发输入或逐周期电流管理</li>
</ul>
<p>所有这些定时器互相完全独立，不共享任何资源，可以让任意两个通用定时器同步工作</p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/image-20210516170041918.png" alt="image-20210516170041918"></p>
<h3 id="时基单元"><a href="#时基单元" class="headerlink" title="时基单元"></a>时基单元</h3><p><strong>定时器的时基单元实际上就是一套用于稳定输出时钟的计数器</strong>，定时器的其他高级功能都是在计数器的基础上实现的</p>
<p>这就是为什么定时器中断、输出PWM、检测输入信号等操作都需要预先设定时基单元</p>
<p>时基单元本身的时钟来自于RCC的TIMxCLK，由APB总线提供；不过也可以设定成由片外电路独立输入，也就是所谓的TIMxETR；甚至也可以用其他定时器触发，这就是“从模式-定时器级联”</p>
<p>时基单元包括：</p>
<ul>
<li><strong>计数器</strong>寄存器 (TIMx_CNT)</li>
<li><strong>预分频器</strong>寄存器 (TIMx_PSC)</li>
<li><strong>自动重载</strong>寄存器 (TIMx_ARR)</li>
</ul>
<p>计数器、自动重载寄存器和预分频器寄存器可通过软件进行读写。即使在计数器运行时也可执行读写操作。</p>
<h4 id="关于计数器重载"><a href="#关于计数器重载" class="headerlink" title="关于计数器重载"></a>关于计数器重载</h4><blockquote>
<p><strong>自动重载寄存器是预装载的</strong>。对自动重载寄存器执行写入或读取操作时会访问<strong>预装载寄存器</strong>。预装载寄存器的内容既可以<strong>直接传送</strong>到<strong>影子寄存器</strong>，也可以在每次<strong>发生更新事件</strong> (UEV) 时传送到影子寄存器——这取决于 TIMx_CR1 寄存器中的自动重载预装载使能位 (ARPE)。当 计数器达到上溢值（或者在递减计数时达到下溢值）并且 TIMx_CR1 寄存器中的 UDIS 位为 0 时，将发送更新事件。<strong>该更新事件也可由软件产生</strong>（称为软件更新事件）</p>
</blockquote>
<p>以上段落就是指时基单元中的计数器值会通过自动重载寄存器对应的影子寄存器进行更新，CPU能操作的是顶层的自动重载寄存器：写入值后，根据自动重载预装载使能位（ARPE）的选项，在发生更新事件后或下一个时钟信号到来时，表层寄存器的值会被复制到影子寄存器，同时计数器寄存器会自动根据影子寄存器的值更新</p>
<h4 id="关于计数器配置"><a href="#关于计数器配置" class="headerlink" title="关于计数器配置"></a>关于计数器配置</h4><blockquote>
<p>计数器由预分频器输出 CK_CNT 提供时钟，仅当 TIMx_CR1 寄存器中的计数器启动位 (CEN) 置 1 时，才会启动计数器<br><strong>真正的计数器使能信号 CNT_EN 在 CEN 置 1 的一个时钟周期后被置 1</strong></p>
</blockquote>
<h4 id="关于预分频器"><a href="#关于预分频器" class="headerlink" title="关于预分频器"></a>关于预分频器</h4><blockquote>
<p>预分频器可对计数器时钟频率进行分频，分频系数介于 1 到 65536 之间（该预分频器基于 16 位/32 位TIMx_PSC寄存器所控制的 16 位计数器），由于该控制寄存器具有缓冲功能，因此<strong>预分频器可实现实时更改</strong>，新的预分频比将在下一更新事件发生时被采用</p>
</blockquote>
<p>所以不仅可以在定时器工作时动态更改计数器值，也可以动态更改分频值</p>
<p>示例时序图如下：</p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/image-20210516170857412.png" alt="image-20210516170857412"></p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/image-20210516170948206.png" alt="image-20210516170948206"></p>
<h3 id="定时器计数模式"><a href="#定时器计数模式" class="headerlink" title="定时器计数模式"></a>定时器计数模式</h3><p>下面的内容都是摘自官方文档</p>
<h4 id="递增模式"><a href="#递增模式" class="headerlink" title="递增模式"></a>递增模式</h4><blockquote>
<p><strong>计数器从0计数（自动+1）到自动重载值，然后重新从0开始计数并生成计数器上溢事件</strong><br><strong>每次发生计数器上溢时会生成更新事件</strong>，将 TIMx_EGR 寄存器中的 UG 位置 1（通过软件或使用从模式控制器）也可以生成更新事件<br>通过软件将 TIMx_CR1 寄存器中的 UDIS 位置 1 可禁止 UEV 事件。这可避免向预装载寄存器写入新值时更新影子寄存器。在 UDIS 位写入 0 之前不会产生任何更新事件，不过计数器和预分频器计数器都会重新从 0 开始计数（而预分频比保持不变）。此外如果 TIMx_CR1 寄存器中的 URS 位（更新请求选择）已置 1，则将 UG 位置 1 会生成更新事件 UEV，但不会将 UIF 标志置 1（因此，不会发送任何中断或 DMA 请求）。这样如果在发生捕获事件时将计数器清零，将不会同时产生更新中断和捕获中断。<br>发生更新事件时，将更新所有寄存器且将更新标志（TIMx_SR 寄存器中的 UIF 位）置 1（取 决于 URS 位）：</p>
<p>● 预分频器的缓冲区中将重新装载预装载值（TIMx_PSC 寄存器的内容）</p>
<p>● 自动重载影子寄存器将以预装载值进行更新</p>
</blockquote>
<h4 id="递减模式"><a href="#递减模式" class="headerlink" title="递减模式"></a>递减模式</h4><blockquote>
<p><strong>计数器从自动重载值开始递减计数到0， 然后重新从自动重载值开始计数并生成计数器下溢事件</strong><br><strong>每次发生计数器下溢时会生成更新事件</strong>，或将 TIMx_EGR 寄存器中的 UG 位置 1（通过软件或使用从模式控制器）也可以生成更新事件<br>通过软件将 TIMx_CR1 寄存器中的 UDIS 位置 1 可禁止 UEV 更新事件。这可避免向预装载寄存器写入新值时更新影子寄存器。在 UDIS 位写入 0 之前不会产生任何更新事件。不过，计数器会重新从当前自动重载值开始计数，而预分频器计数器则重新从 0 开始计数（但预分频比保持不变）。<br>此外如果 TIMx_CR1 寄存器中的 URS 位（更新请求选择）已置 1，则将 UG 位置 1 会生 成更新事件 UEV，但不会将 UIF 标志置 1（因此，不会发送任何中断或 DMA 请求）。这样如果在发生捕获事件时将计数器清零，将不会同时产生更新中断和捕获中断。<br>发生更新事件时，将更新所有寄存器且将更新标志（TIMx_SR 寄存器中的 UIF 位）置 1（取决于 URS 位）：</p>
<p>● 预分频器的缓冲区中将重新装载预装载值（TIMx_PSC 寄存器的内容）。</p>
<p>● 自动重载活动寄存器将以预装载值（TIMx_ARR 寄存器的内容）进行更新。</p>
<p><strong>自动重载寄存器会在计数器重载之前得到更新，因此下一个计数周期就是我们所希望的新的周期长度</strong></p>
</blockquote>
<h4 id="中心对齐"><a href="#中心对齐" class="headerlink" title="中心对齐"></a>中心对齐</h4><blockquote>
<p><strong>在中心对齐模式下，计数器从 0 开始计数到自动重载值-1， 生成计数器上溢事件；然后从自动重载值开始向下计数到 1 并生成计数器下溢事件。之后从 0 开始重新计数</strong>——一个计数周期生成两个上溢事件<br>当 TIMx_CR1 寄存器中的 CMS 位不为“00”时，中心对齐模式有效。将通道配置为输出模式时，其输出比较中断标志将在以下模式下置 1，即：计数器递减计数（中心对齐模式 1， CMS =“01”）、计数器递增计数（中心对齐模式 2，CMS =“10”）以及计数器递增/递 减计数（中心对齐模式 3，CMS =“11”）<br>此模式下无法写入方向位（TIMx_CR1 寄存器中的 DIR 位）；而是<strong>由硬件更新</strong>并指示当前计数器方向。<br>每次发生计数器上溢和下溢时都会生成更新事件，或将 TIMx_EGR 寄存器中的 UG 位置 1 （通过软件或使用从模式控制器）也可以生成更新事件。这种情况下，计数器以及预分频器计数器将重新从 0 开始计数<br>通过软件将 TIMx_CR1 寄存器中的 UDIS 位置 1 可禁止 UEV 更新事件。这可避免向预装载 寄存器写入新值时更新影子寄存器。在 UDIS 位写入 0 之前不会产生任何更新事件。计数器仍会根据当前自动重载值进行递增和递减计数</p>
<p>如果 TIMx_CR1 寄存器中的 URS 位（更新请求选择）已置 1，则将 UG 位置 1 会生 成更新事件 UEV，但不会将 UIF 标志置 1（因此，不会发送任何中断或 DMA 请求）。如果在发生捕获事件时将计数器清零，将不会同时产生更新中断和捕获中断。<br>发生更新事件时，将更新所有寄存器且将更新标志（TIMx_SR 寄存器中的 UIF 位）置 1（取 决于 URS 位）：</p>
<p>● 预分频器的缓冲区中将重新装载预装载值（TIMx_PSC 寄存器的内容）。</p>
<p>● 自动重载活动寄存器将以预装载值 （TIMx_ARR 寄存器的内容）进行更新。注意，如</p>
<p>果更新操作是由计数器上溢触发的，则自动重载寄存器在重载计数器之前更新，下一个计数周期就是我们所希望的新的周期长度（计数器被重载新的值）</p>
</blockquote>
<h3 id="时钟选择"><a href="#时钟选择" class="headerlink" title="时钟选择"></a>时钟选择</h3><p>计数器时钟可以由内部/外部时钟源提供</p>
<h4 id="内部时钟CK-INT"><a href="#内部时钟CK-INT" class="headerlink" title="内部时钟CK_INT"></a>内部时钟CK_INT</h4><p>如果禁止从模式控制器，则CEN、DIR、UG三个寄存器位就充当实际控制位，能且仅能通过软件更改，其中UG位还会自动清零；当CEN=1时，预分频器时钟由内部时钟CK_INT提供</p>
<h4 id="外部时钟模式1"><a href="#外部时钟模式1" class="headerlink" title="外部时钟模式1"></a>外部时钟模式1</h4><p>使用外部输入引脚TIx</p>
<p>当TIMx_SMCR寄存器中的SMS=111时，可选择此模式，计数器可在选定的输入信号出现上升沿或下降沿时计数</p>
<p>如下图所示</p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/image-20210518132306079.png" alt="image-20210518132306079"></p>
<p>使用方法：</p>
<ol>
<li>开启外部时钟输入通道TIx</li>
<li>可选择在TIMx_CCMR1寄存器的ICF[3:0]位写入滤波时间配置，或令ICF=0x0000来禁止滤波</li>
<li>边沿检测器和捕获预分频器不需要进行设置</li>
<li>选择上升沿/下降沿极性有效</li>
<li>配置定时器在外部时钟模式1下工作</li>
<li>选择已经开启的外部时钟输入通道TIx作为输入源</li>
<li>使能计数器</li>
</ol>
<p>配置完毕后，计数器就会在外部输入呈现对应上升沿/下降沿时计数一次并将TIF标志置1</p>
<h4 id="外部时钟模式2"><a href="#外部时钟模式2" class="headerlink" title="外部时钟模式2"></a>外部时钟模式2</h4><p><strong>仅对TIM2、3、4适用</strong></p>
<p>使用外部触发输入ETR</p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/image-20210518132925999.png" alt="image-20210518132925999"></p>
<p>与外部时钟模式1的最大区别就是可以自行配置预分频器来实现“每当ETR出现n个上升沿/下降沿时，计数器计数一次”的效果</p>
<p>同时可能会由于ETRP信号经过重新同步电路而引起ETR上升沿与实际计数器时钟之间的延迟</p>
<p>配置方法：</p>
<ol>
<li>设置滤波器滤波时间</li>
<li>设置ETR预分频器分频系数</li>
<li>选择上升沿/下降沿检测</li>
<li>使能外部时钟模式2</li>
<li>使能计数器</li>
</ol>
<h3 id="外部触发输入——外部触发同步"><a href="#外部触发输入——外部触发同步" class="headerlink" title="外部触发输入——外部触发同步"></a>外部触发输入——外部触发同步</h3><p>定时器可以以复位、门控和触发三种模式与外部触发实现同步</p>
<ol>
<li><p><strong>复位模式（从模式）</strong></p>
<p>当触发输入信号发生变化时，计数器及其预分频器可重新初始化</p>
<p>如果 TIMx_CR1 寄存器中的 URS 位处于低电平，则会生成更新事件 UEV，所有预装载寄存器 （TIMx_ARR 和 TIMx_CCRx）都将更新</p>
</li>
<li><p><strong>门控模式（从模式）</strong></p>
<p>输入信号的电平可用来使能计数器</p>
<p>门控模式作用于电平而非边沿，可设置为高/低电平触发使能定时器计数器</p>
</li>
<li><p><strong>触发模式（从模式）</strong></p>
<p>所选输入上发生某一事件时可以启动计数器，该事件使用软件程序决定，可以通过外设配置寄存器设置</p>
</li>
<li><p><strong>外部时钟模式2+触发模式（从模式）</strong></p>
<p>外部时钟模式 2 可与另一种从模式（外部时钟模式1和编码器模式除外）结合使用</p>
<p>ETR 信号用作外部时钟输入，在复位模式、门控模式或触发模式下工作时，可选择另一个输入作为触发输入，但不建议通过 TIMx_SMCR 寄存器中的 TS 位来选择 ETR 作为 TRGI</p>
</li>
</ol>
<h4 id="内部触发输入——定时器级联与同步"><a href="#内部触发输入——定时器级联与同步" class="headerlink" title="内部触发输入——定时器级联与同步"></a>内部触发输入——定时器级联与同步</h4><p>使用一个定时器作为另一个定时器的预分频器</p>
<p>定时器可以从内部连接在一起以实现定时器同步或级联。当某个定时器配置为主模式时， 可对另一个配置为从模式的定时器的计数器执行复位、启动、停止操作或为其提供时钟</p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/image-20210521225925100.png" alt="image-20210521225925100"></p>
<p>使用时需要注意：</p>
<ol>
<li>一定要设置好主模式定时器与从模式定时器</li>
<li>主模式定时器的输出连接到从模式定时器的输入，不能反接</li>
<li>将主模式和从模式定时器都配置为触发模式</li>
</ol>
<p>这个功能实现比较复杂，可以查阅参考手册中给出的示例程序</p>
<h3 id="捕获-比较通道"><a href="#捕获-比较通道" class="headerlink" title="捕获/比较通道"></a>捕获/比较通道</h3><p>一个定时器时基单元具有四个/三个/两个独立的捕获/比较通道，可以完成更高级的任务</p>
<p>每个捕获/比较通道均附带一个捕获/比较寄存器（包括一个影子寄存器）、一套输入阶段设备（数字滤波器、多路复用器和预分频器）和一套输出阶段设备（比较器和输出控制器）</p>
<p>下图为输入阶段设备结构框图</p>
<p>TIx作为输入进行采样，滤波器生成一个滤波后的信号 TIxF 输出到带有极性选择功能的边沿检测器。边沿检测器会根据配置生成一个上升沿/下降沿信号 (TIxFPx)，该信号可<strong>直接用作从模式控制器的触发输入</strong>（通过一套组合逻辑），也可先进行预分频 (ICxPS)，再进入捕获寄存器</p>
<p>信号可以来自TI1、2、3、4（只要有输入线、滤波器、边沿检测器就可以输入到多路复用器），进而输入到统一的预分频器</p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/image-20210518135027490.png" alt="image-20210518135027490"></p>
<p>下图是捕获/比较通道的主电路结构框图</p>
<p>捕获/比较模块由一个<strong>预装载寄存器</strong>和一个<strong>影子寄存器</strong>组成。始终可通过读写操作访问预装载寄存器。</p>
<p><em>在捕获模式下，<strong>捕获实际发生在影子寄存器中</strong>，然后<strong>将影子寄存器的内容复制到预装载寄存器中</strong></em></p>
<p><em>在比较模式下，<strong>预装载寄存器的内容将复制到影子寄存器中</strong>，然后将影子寄存器的内容<strong>与计数器</strong>进行<strong>比较</strong></em></p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/image-20210518135041953.png" alt="image-20210518135041953"></p>
<p>下图是捕获/比较通道的输出阶段设备</p>
<p>输出阶段的输出模式控制器会根据软件配置和来自主电路的信号生成一个中间基准波形：OCxRef（高电平有效）。这个信号可以经过一个三态门（输出使能电路）到输出捕获，也可以直接输送到主模式控制器</p>
<p>末端的输出使能电路决定最终输出信号的极性。</p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/image-20210518135052372.png" alt="image-20210518135052372"></p>
<h3 id="输入捕获与PWM输入"><a href="#输入捕获与PWM输入" class="headerlink" title="输入捕获与PWM输入"></a>输入捕获与PWM输入</h3><blockquote>
<p>输入捕获模式下，当相应的 ICx 信号被检测到跳变沿后，将使用<strong>捕获/比较寄存器</strong>(TIMx_CCRx)来锁存计数器的值，并触发捕获事件；发生捕获事件时，会将相应的CCXIF标志（TIMx_SR 寄存器）置1， 并可配置发送中断或 DMA 请求</p>
<p>如果发生捕获事件时 CCxIF 标志已处于高位，则会将重复捕获标志 CCxOF（TIMx_SR 寄存器）置1——可通过软件向 CCxIF 写入 0 来给 CCxIF 清零或读取存储在 TIMx_CCRx 寄存器中的已捕获数据——向 CCxOF 写入0后会将其清零</p>
</blockquote>
<p>输入捕获配置步骤如下：</p>
<ol>
<li><p>选择有效输入</p>
<p>TIMx_CCR1 必须连接到 TI1 输入，因此向 TIMx_CCMR1 寄存器中的CC1S 位写入 01——只要 CC1S 不等于 00，就会将通道配置为输入模式，并且 TIMx_CCR1 寄存器将处于只读状态</p>
</li>
<li><p>根据连接到定时器的信号，对所需的输入滤波时间进行编程</p>
<p>如果输入为 TIx 输入之一，则对 TIMx_CCMRx 寄存器中的 ICxF 位进行编程</p>
<p>注意：<strong>滤波时间必须大于输入信号发生抖动的内部时钟周期数</strong></p>
</li>
<li><p>选择输入通道的有效边沿</p>
</li>
<li><p>配置输入信号预分频器</p>
<p>预分频系数决定了累计多少个有效信号边沿后触发一次有效事件</p>
</li>
<li><p>将TIMx_CCER寄存器中的CC1E位置1，让计数器的捕获寄存器被使能</p>
</li>
<li><p>在需要的情况下可以使能中断、DMA请求</p>
<p>使能可以在任何时候通过软件操作外设控制寄存器进行</p>
</li>
</ol>
<p>使用输入捕获时，推荐<strong>在读出捕获溢出标志之前读取数据</strong>，这样可避免丢失在读取捕获溢出标志之后与读取数据之前可能出现的重复捕获信息</p>
<p>PWM输入模式是输入捕获模式的一个特例，用于对输入的PWM信号进行针对性捕获、分析</p>
<p>其实现步骤与输入捕获模式基本相同，仅存在以下不同之处：</p>
<ol>
<li>两个 ICx 信号被映射至同一个 TIx 输入</li>
<li>这两个 ICx 信号在边沿处有效，但极性相反</li>
<li>需要选择两个 TIxFP 信号之一作为触发输入，并将从模式控制器配置为复位模式</li>
</ol>
<h3 id="输出比较与PWM输出"><a href="#输出比较与PWM输出" class="headerlink" title="输出比较与PWM输出"></a>输出比较与PWM输出</h3><p>官方文档的输出比较模式总结如下：</p>
<blockquote>
<p>输出比较用于控制输出波形，或指示已经过某一时间段</p>
<p>当输出捕获/比较寄存器与计数器之间相匹配时，输出比较将进行以下操作：</p>
<ol>
<li>为相应的输出引脚分配一个有可编程输出比较模式和输出极性的输出值。匹配时，输出引脚既可保持其电平 (OCXM=000)，也可设置为有效电平 (OCXM=001)、无效电平(OCXM=010) 或进行翻转 (OCxM=011)</li>
<li>将中断状态寄存器中的标志置1</li>
<li>如果相应中断或DMA使能位置1，将生成中断或发送DMA请求</li>
</ol>
<p>此外，可以将TIMx_CCRx 寄存器配置为带或不带预装载寄存器；输出比较模式下，更新事件 UEV 对 OCxREF 和 OCx 输出毫无影响，同步的精度可以达到计数器的一个计数周期，输出比较模式也可用于输出单脉冲（在单脉冲模式下）</p>
<p>下面是基本使用步骤：</p>
<ol>
<li>选择计数器时钟（内部、外部、预分频器）</li>
<li>如果要生成中断和/或 DMA 请求，将 CCxIE 位和/或 CCxDE 位置 1</li>
<li>选择输出模式。例如，当 CNT 与 CCRx 匹配、未使用预装载 CCRx 并且 OCx 使能且为 高电平有效时，必须写入 OCxM=011、OCxPE=0、CCxP=0 和 CCxE=1 来翻转 OCx 输出引脚。</li>
<li>通过将 TIMx_CR1 寄存器中的 CEN 位置 1 来使能计数器。</li>
</ol>
<p>可随时通过软件更新 TIMx_CCRx 寄存器以控制输出波形，前提是未使能预装载寄存器 （OCxPE=0，否则仅当发生下一个更新事件 UEV 时，才会更新 TIMx_CCRx 影子寄存器）</p>
</blockquote>
<p>PWM模式实际上是基于输出比较模式实现的</p>
<p>利用输出比较模式可以生成PWM信号，<em>信号频率由 TIMx_ARR 寄存器值决定，其占空比则 由 TIMx_CCRx 寄存器值决定</em></p>
<blockquote>
<p>通用定时器具有独立的4个通道用于PWM模式输出，必须通过将 TIMx_CCMRx 寄存器中的 OCxPE 位置 1 使能相应预装载寄存器，再通过将 TIMx_CR1 寄存器中的 ARPE 位置 1 使能自动重载预装载寄存器。由于只有在发生更新事件时预装载寄存器才会传送到影子寄存器，因此启动计数器之前，必须通过将 TIMx_EGR 寄存器中的 UG 位置 1 来初始化所有寄存器。OCx 极性可使用 TIMx_CCER 寄存器的 CCxP 位来编程。既可以设为高电平有效，也可以设为低电平有效。OCx 输出通过将 TIMx_CCER 寄存器中的 CCxE 位置 1 来使能</p>
<p>在PWM模式下，MCU会将TIMx_CNT与TIMx_CCRx进行比较，之后根据计数器计数方向输出特定值。当比较结果发生改变或从“冻结”配置转换回任意PWM模式时，OCREF信号变为有效状态</p>
<p>定时器运行期间，可以通过软件强制 PWM 输出。根据 TIMx_CR1 寄存器中的 CMS 位状态，定时器也能够产生边沿对齐模式或中心对齐模式的 PWM 信号。</p>
</blockquote>
<p>PWM计数模式可配置为递增、递减、中心对齐三种，其中使用中心对齐模式时要注意以下几点：</p>
<ul>
<li>启动中心对齐模式时<strong>将使用当前的递增/递减计数配置</strong>，计数器将根据写入TIMx_CR1 寄存器中 DIR 位的值进行递增或递减计数</li>
<li><strong>不得同时</strong>通过软件<strong>修改</strong>DIR 和 CMS 位</li>
<li>不建议在运行中心对齐模式时对计数器执行<strong>写操作</strong>，否则将发生意想不到的结果</li>
<li>使用中心对齐模式最为保险的方法是：在启动计数器前通过软件生成更新（将 TIMx_EGR寄存器中的 UG 位置 1），并且不要在计数器运行过程中对其执行写操作</li>
</ul>
<h3 id="强制输出模式"><a href="#强制输出模式" class="headerlink" title="强制输出模式"></a>强制输出模式</h3><p>可以通过强制写入输出比较控制寄存器来强制定时器输出特定的电平</p>
<p>不太常用，官方文档介绍如下：</p>
<blockquote>
<p>在输出模式（TIMx_CCMRx 寄存器中的 CCxS 位 = 00）下，可直接由软件将每个输出比较信号（OCxREF 和 OCx）强制设置为有效电平或无效电平，而无需考虑输出比较寄存器和计数器之间的任何比较结果<br>要将输出比较信号 (OCXREF/OCx) 强制设置为有效电平，只需向相应 TIMx_CCMRx 寄存器 中的 OCxM 位写入 101。ocxref 进而强制设置为高电平（OCxREF 始终为高电平有效）， 同时 OCx 获取 CCxP 极性位的相反值<br>例如：CCxP=0（OCx 高电平有效）=&gt; OCx 强制设置为高电平<br>通过向 TIMx_CCMRx 寄存器中的 OCxM 位写入 100，可将 ocxref 信号强制设置为低电平<br>无论如何，TIMx_CCRx 影子寄存器与计数器之间的比较仍会执行，而且允许将标志置 1。 因此可发送相应的中断和 DMA 请求</p>
</blockquote>
<h3 id="单脉冲模式"><a href="#单脉冲模式" class="headerlink" title="单脉冲模式"></a>单脉冲模式</h3><p><strong>单脉冲模式</strong>OPM是基本定时器模式的一个特例</p>
<p>在这种模式下，计数器可以<strong>在一个激励信号的触发下启动</strong>，并可<strong>在一段可编程的延时后产生一个脉宽可编程的脉冲</strong></p>
<p><em>这个模式比较像单稳态触发器逻辑</em></p>
<p>可以通过从模式控制器启动计数器。可以在输出比较模式或 PWM 模式下生成波形。</p>
<p>开启方式：将 TIMx_CR1 寄存器中的 OPM 位置 1，即可选择单脉冲模式。发生下一更新事件 UEV 时，计数器将自动停止。只有当比较值与计数器初始值不同时，才能正确产生一个脉冲。</p>
<p>基本使用方法如下：</p>
<ol>
<li>将 TIxFPx 映射到 TIx，连接输入端口与单脉冲控制器</li>
<li>设置有效边沿极性</li>
<li>配置TIxFPx为从模式控制器的触发（TRGI）</li>
<li>配置触发模式，设置使用TIxFPx来启动计数器</li>
<li>正常配置时基单元</li>
<li>将脉冲发生之前的延迟时间T<del>delay</del>写入TIMx_CCR1寄存器</li>
<li>脉冲长度由自动重载值与比较值之差TIMx_ARR - TIMx_CCR1来定义</li>
</ol>
<p><strong>特例情况——OCx快速使能</strong></p>
<p>单脉冲模式下，TIx 输入的边沿检测会将 CEN 位置 1，表示使能计数器。然后在计数器值与比较值之间发生比较时，将切换输出。</p>
<p>但是完成这些操作需要多个时钟周期，这会限制可能的最小延迟（tDELAY 最小值）。</p>
<p>如果要输出延迟时间最短的波形，可以将 TIMx_CCMRx 寄存器中的 OCxFE 位置 1。这样会强制 OCxRef（和 OCx）对激励信号做出响应，而不再考虑比较的结果。其新电平与发生比较匹配时相同。仅当通道配置为 PWM1 或 PWM2 模式时，OCxFE 才会起作用。</p>
<h3 id="编码器接口模式"><a href="#编码器接口模式" class="headerlink" title="编码器接口模式"></a>编码器接口模式</h3><p>STM32提供了针对编码器控制的计数器优化</p>
<p>TI1 和 TI2 两个输入用于连接增量编码器，如下图所示</p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/image-20210521224858860.png" alt="image-20210521224858860"></p>
<p>使能计数器后，计数器的时钟由TI1FP1或YI2FP2上的<strong>每次有效信号转换</strong>提供。TI1FP1和TI2FP2是进行输入滤波器和极性选择后TI1和TI2的信号，如果不进行滤波和反相，则有TI1FP1=TI1，TI2FP2=TI2，根据两个输入的信号转换序列，定时器产生计数脉冲和方向信号，根据该信号转换序列，计数器相应递增或递减计数，同时硬件对TIMx_CR1寄存器的DIR位进行相应修改。任何输入（TI1 或 TI2）发生信号转换时，都会计算DIR位，无论计数器是仅在TI1或TI2边沿处计数还是同时在TI1和TI2处计数。可通过编程 TIMx_CCER 寄存器的 CC1P 和 CC2P 位选择 TI1 和 TI2 极性</p>
<p><strong>编码器接口模式就相当于带有方向选择的外部时钟</strong>，计数器仅根据方向设定在 0 到 TIMx_ARR 寄存器中的自动重载值之间进行连续计数，在启动前必须先配置 TIMx_ARR。此外捕获、比较、预分频器、触发输出功能继续正常工作。在此模式下，计数器会根据增量编码器的速度和方向自动进行修改，<strong>其内容始终表示编码器的位置</strong></p>
<p>使用该模式，外部增量编码器可直接与 MCU 相连，无需外部接口逻辑；通常使用比较器将编码器的差分输出转换为数字信号来提高抗噪声性能，用于指示机械零位的第三个编码器输出可与外部中断输入相连，用以触发计数器复位</p>
<p>定时器配置为<strong>编码器接口模式</strong>时，会提供传感器当前位置的相关信息。使用<em>另一个</em>配置为<strong>捕获模式</strong>的定时器<strong>测量两个编码器事件之间的周期</strong>，可获得动态信息（速度、加速度和减速度），指示机械零位的编码器输出即可用于此目的。根据两个事件之间的时间间隔，还可定期读取计数器——可以将计数器值锁存到第三个输入捕获寄存器来实现此目的（捕获信号必须为周期性信号，可以由另一个定时器产生）；还可以通过由RTC或其他定时器生成的DMA请求读取计数器值。</p>
<h3 id="特殊配置——发生外部事件时清除OCxREF信号"><a href="#特殊配置——发生外部事件时清除OCxREF信号" class="headerlink" title="特殊配置——发生外部事件时清除OCxREF信号"></a>特殊配置——发生外部事件时清除OCxREF信号</h3><p>对于给定通道，在 ETRF 输入施加高电平（相应 TIMx_CCMRx 寄存器中的 OCxCE 使能位置“1”），可使 OCxREF 信号变为低电平，此后OCxREF 信号将保持低电平直到发生下一更新事件 (UEV)<br>此功能仅能用于输出比较模式和 PWM 模式，不适用于强制输出模式</p>
<h3 id="特殊配置——定时器输入异或"><a href="#特殊配置——定时器输入异或" class="headerlink" title="特殊配置——定时器输入异或"></a>特殊配置——定时器输入异或</h3><p>借助TIMx_CR2寄存器中的TI1S位，可将通道1的输入滤波器连接到<strong>异或门</strong>的输出，从而将TIMx_CH1到TIMx_CH3这三个输入引脚组合在一起。<strong>异或输出可与触发或输入捕获等所有定时器输入功能配合使用</strong></p>
<h2 id="通用定时器组2"><a href="#通用定时器组2" class="headerlink" title="通用定时器组2"></a>通用定时器组2</h2><blockquote>
<p>备份！一定要备份！</p>
</blockquote>
<p>通用定时器由TIM9到TIM14组成，包含一个16位自动重载计数器，该计数器由可编程预分频器驱动</p>
<p>支持的功能和通用定时器组1完全一致，但是少了两个定时器附属多功能通道</p>
<p>结构框图如下所示：</p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/image-20210521231253113.png" alt="image-20210521231253113"></p>
<p>同时这些定时器也难以实现定时器组1能够实现的一些复杂功能，因为它们的控制寄存器、多路选择器被削减了一部分</p>
<p>TIM9和TIM12比较特殊，可以实现其他定时器无法完成的PWM输入、外部触发同步和定时器同步/级联，可以用作定时器组1的补充</p>
<h2 id="高级定时器"><a href="#高级定时器" class="headerlink" title="高级定时器"></a>高级定时器</h2><blockquote>
<p>大外设，体积大，多来几个装不下</p>
</blockquote>
<p>高级定时器由TIM1和TIM8组成，两个定时器共用一个16位自动重载计数器，该计数器由可编程预分频器驱动</p>
<p>支持以下功能</p>
<ul>
<li>通过输入捕获测量输入信号脉冲宽度</li>
<li>生成输出比较和PWM波</li>
<li>生成带死区插入的互补PWM</li>
</ul>
<p>高级定时器和通用定时器彼此完全独立，但两个高级定时器会共享资源</p>
<p>高级定时器和通用定时器可以实现同步功能</p>
<p>高级定时器拥有基本定时器、通用定时器的所有基础功能，并且内置了非常强大（但是在通用控制方面很少用到）的舵机、推进器、飞控、磁编码器等控制功能，可以说<em>一个更比六个强</em>！</p>
<p>下图是高级定时器的结构框图，足以看出其强大性能</p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/image-20210521231849841.png" alt="image-20210521231849841"></p>
<p>下面着重说明TIM1和TIM8与通用定时器不同的地方</p>
<h3 id="重复计数器"><a href="#重复计数器" class="headerlink" title="重复计数器"></a>重复计数器</h3><p>高级定时器配备了一个<strong>重复计数器</strong>，只有当重复计数器达到零时，才会生成更新事件</p>
<p>每当发生N+1个计数器上溢或下溢（其中N是TIMx_RCR重复计数器寄存器中的值），数据就将从预装载寄存器转移到影子寄存器（TIMx_ARR自动重载寄存器、 TIMx_PSC预分频器寄存器以及比较模式下的TIMx_CCRx捕获/比较寄存器）中</p>
<p>重复计数器是自动重载类型，其重复率为TIMx_RCR寄存器所定义的值，它允许的定时器计数器重载最大重复次数不超过128个，每个PWM周期内可实现更新占空比两次。当在中心对齐模式下，每个PWM周期仅刷新一次比较寄存器时，由于模式的对称性，最大分辨率为2xTck</p>
<p>重复计数器在下列情况下递减：</p>
<ol>
<li>递增计数模式下的每个计数器上溢</li>
<li>递减计数模式下的每个计数器下溢</li>
<li>中心对齐模式下每个计数器上溢和计数器下溢</li>
</ol>
<p>特别地，更新时间可以由软件或硬件人为生成，重复计数器会根据更新事件重新装载</p>
<p>中心对齐模式下如果RCR值为奇数，更新事件将在上溢或下溢时发生，这取决于何时写入RCR寄存器以及何时启动计数器：如果在启动计数器前写入RCR，则UEV在上溢时发生；如果在启动计数器后写入RCR，则UEV在下溢时发生</p>
<h3 id="特化的PWM输出模式"><a href="#特化的PWM输出模式" class="headerlink" title="特化的PWM输出模式"></a>特化的PWM输出模式</h3><p>根据TIMx_CR1寄存器中的CMS位状态，高级定时器能够产生<strong>边沿对齐模式</strong>或<strong>中心对齐模式</strong>的PWM信号</p>
<p>详情见参考手册，基本就是字面意思</p>
<h3 id="互补输出与死区插入"><a href="#互补输出与死区插入" class="headerlink" title="互补输出与死区插入"></a>互补输出与死区插入</h3><p>TIM1和TIM8可以输出两路互补信号，并管理输出的关断与接通瞬间（死区时间），用户可以根据与输出相连接的器件及其特性（电平转换器的固有延迟、开关器件产生的延迟等等）来调整死区时间做到精准控制。每路输出可以独立选择输出极性（主输出OCx或互补输出OCxN），通过对TIMx_CCER寄存器中的CCxP和CCxNP位执行写操作来完成极性选择。</p>
<p>互补信号 OCx 和 OCxN 通过</p>
<ol>
<li>TIMx_CCER 寄存器中的 CCxE 和 CCxNE 位</li>
<li>TIMx_BDTR 和 TIMx_CR2 寄存器中的 MOE、OISx、OISxN、OSSI 和 OSSR 位</li>
</ol>
<p>以上控制位的组合进行激活。需要注意：切换至IDLE（MOE下降到0）的时刻，死区仍然有效</p>
<p>CCxE 和 CCxNE 位同时置 1 并且 MOE 位置 1（如果存在断路）时，使能死区插入。TIMx_BDTR 寄存器中的 DTG[7:0] 位用于控制所有通道的死区生成。高级定时器将基于参考波形 OCxREF 生成 2 个输出 OCx 和 OCxN。</p>
<p>示例：OCx 和 OCxN 为高电平有效时，</p>
<ul>
<li>输出信号 OCx 与参考信号相同，只是其上升沿相对参考上升沿存在延迟。</li>
<li>输出信号 OCxN 与参考信号相反，并且其上升沿相对参考下降沿存在延迟。</li>
<li>如果延迟时间大于有效输出（OCx 或 OCxN）的宽度，则不会产生相应的脉冲</li>
</ul>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/image-20210522103114232.png" alt="image-20210522103114232"></p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/image-20210522103127846.png" alt="image-20210522103127846"><br>在输出模式（包括强制输出模式、输出比较模式和PWM模式）下，通过配置 TIMx_CCER 寄存 器中的 CCxE 和 CCxNE 位，可将 OCxREF 重定向到 OCx 输出或 OCxN 输出。通过此功能，可以在一个输出上发送特定波形（如PWM或静态有效电平)，而同时使互补输出保持无效电平；或者使两个输出同时保持无效电平；或者两个输出同时处于有效电平，两者互补并且带死区。</p>
<p>注意：如果仅使能 OCxN (CCxE=0, CCxNE=1)，两者不互补，一旦 OCxREF 为高电平，OCxN 即变为有效</p>
<p>示例：如果 CCxNP=0，则 OCxN=OCxRef。另一方面，如果同时使能 OCx 和 OCxN (CCxE=CCxNE=1)，OCx 在 OCxREF 为高电平时变为有效，而 OCxN 则与之互补， 在 OCxREF 为低电平时变为有效。</p>
<h3 id="断路功能"><a href="#断路功能" class="headerlink" title="断路功能"></a>断路功能</h3><blockquote>
<p>使用断路功能时，根据其它控制位（TIMx_BDTR 寄存器中的 MOE、OSSI 和 OSSR 位以及 TIMx_CR2 寄存器中的 OISx 和 OISxN 位）修改输出使能信号和无效电平。断路源可以是断路输入引脚，也可以是时钟故障事件，后者由复位时钟控制器中的时钟安全系统 (CSS) 生成</p>
<p>注意：任何情况下， OCx 和 OCxN 输出都不能同时置为有效电平<br>退出复位状态后，断路功能处于禁止状态，MOE 位处于低电平。将 TIMx_BDTR 寄存器 中的 BKE 位置 1，可使能断路功能。断路输入的极性可通过该寄存器中的 BKP 位来选择。BKE 和 BKP 位可同时修改。对 BKE 和 BKP 位执行写操作时，写操作会在 1 个 APB 时钟周期的延迟后生效。因此，执行写操作后，需要等待 1 个 APB 时钟周期，才能准确回读该位。</p>
<p>由于 MOE 下降沿可能是异步信号，因此在实际信号（作用于输出）与同步控制位（位于 TIMx_BDTR 寄存器中）之间插入了再同步电路，从而在异步信号与同步信号之间产生延迟。例如：如果在 MOE 处于低电平时向其写入 1，则必须首先插入延迟（空指令）， 才能准确进行读取——因为写入的是异步信号，而读取的却是同步信号。<br>发生断路（断路输入上出现所选电平）时需要执行以下操作：</p>
<ul>
<li><p>MOE 位异步清零，使输出处于无效状态、空闲状态或复位状态</p>
<p>即使 MCU 振荡器关闭，该功能仍然有效</p>
</li>
<li><p>MOE=0 时，将以 TIMx_CR2 寄存器 OISx 位中编程的电平驱动每个输出通道；如果OSSI=0，则定时器将释放使能输出，否则使能输出始终保持高电平</p>
</li>
</ul>
<p>除断路输入和输出管理外，断路电路内部还实施了写保护，用以保护应用的安全，用户可冻结多个参数配置</p>
<p>使用互补输出时电路会自动遵守以下原则：</p>
<ol>
<li>输出首先置于复位状态或无效状态</li>
<li>如果定时器时钟仍存在，则将重新激活死区发生器，在死区后以OISx和OISxN位中编程的电平驱动输出。即使在这种情况下，也不能同时将OCx和OCxN驱动至其有效电平。MOE会进行再同步，因此死区的持续时间会比通常情况长一些</li>
<li>如果 OSSI=0，则定时器会释放使能输出，否则只要 CCxE 位或 CCxNE 位处于高电平，使能输出就会保持或变为高电平、</li>
<li>可以通过配置寄存器使用定时器中断或DMA请求</li>
<li>如果TIMx_BDTR寄存器中的AOE位置1，则MOE位会在发生下一更新事件(UEV)时自动再次置1</li>
</ol>
<p>断路输入为电平有效。因此当断路输入有效电平时，不能将 MOE 位置 1（自动或通过软件都不行），也不能将状态标志 BIF 清零。断路可由 BRK 输入生成，该输入具有可编程极性，其使能位 BKE 位于 TIMx_BDTR 寄存器中</p>
<p>断路有两种生成方案：</p>
<ol>
<li>使用BRK输入生成，该输入具有可编程极性，其使能位 BKE 位于 TIMx_BDTR 寄存器中</li>
<li>由软件通过 TIMx_EGR 寄存器中的 BG 位生成</li>
</ol>
</blockquote>
<h3 id="生成六路互补PWM"><a href="#生成六路互补PWM" class="headerlink" title="生成六路互补PWM"></a>生成六路互补PWM</h3><p>可用于驱动三相交流异步电动机</p>
<p>当通道使用互补输出时，在OCxM、CCxE 和 CCxNE 位上提供预装载位。发生COM换向事件时，这些预装载位将传输到影子位。用户可以预先编程下一步骤的配置，并同时更改所有通道的配置。COM可由软件通过将 TIMx_EGR 寄存器中的 COM 位置 1 而生成，也可以由硬件在 TRGI 上升沿生成<br>发生 COM 事件时，TIMx_SR 寄存器中的 COMIF 位将会置 1。可以使用中断或DMA请求</p>
<h3 id="霍尔传感器驱动"><a href="#霍尔传感器驱动" class="headerlink" title="霍尔传感器驱动"></a>霍尔传感器驱动</h3><p>高级定时器最重要的功能之一就是直接驱动霍尔传感器</p>
<p>需要通过用于<strong>生成电机驱动 PWM 信号的高级控制定时器</strong>（TIM1、TIM8）以及中称为 “<strong>接口定时器</strong>”的<strong>另一个通用定时器</strong> TIMx（TIM2、TIM3、TIM4 或 TIM5），实现与霍尔传感器的连接。</p>
<p>连接要点如下所示：</p>
<ul>
<li><p>3个高级定时器的输入引脚TIMx_CH1、TIMx_CH2 和 TIMx_CH3通过<strong>异或门</strong>连接到TI1输入通道（通过将TIMx_CR2寄存器中的TI1S位置1来选择），由“接口定时器” 进行捕获</p>
</li>
<li><p>从模式控制器配置为复位模式，从输入设置为 TI1F_ED</p>
<p>每当3个输入中有一个输入发生切换时，计数器会从0开始重新计数。这样将产生由霍尔输入的任何变化而触发的时基</p>
</li>
<li><p>在“接口定时器”上，捕获/比较通道1配置为捕获模式，捕获信号为TRC。<strong>捕获值对应于输入上两次变化的间隔时间</strong>，可提供与电机转速相关的信息</p>
</li>
<li><p>“接口定时器”可用于在输出模式下产生脉冲，以通过触发 COM 事件更改高级控制定时器 （TIM1 或 TIM8）各个通道的配置</p>
</li>
<li><p>TIM1 定时器用于生成电机驱动 PWM 信号</p>
</li>
<li><p>必须对接口定时器通道进行编程，以便在编程的延迟过后产生正脉冲，该脉冲通过TRGO输出发送到高级控制定时器（TIM1 或 TIM8）</p>
</li>
</ul>
<p>在高级控制定时器TIM1中，必须选择正确的 ITR 输入作为触发输入，定时器编程为可产生 PWM 信号，捕获/比较控制信号进行预装载（TIMx_CR2 寄存器的 CCPC=1），并且 COM 事件由触发输入控制（TIMx_CR2 寄存器中 CCUS=1）。发生 COM 事件后，在 PWM 控制 位（CCxE、OCxM）中写入下一步的配置，此操作可在由 OC2REF 上升沿产生的中断子程序中完成。</p>
<p>示例程序的时序图如下：</p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/image-20210522104705636.png" alt="image-20210522104705636"></p>
<h2 id="基本定时器"><a href="#基本定时器" class="headerlink" title="基本定时器"></a>基本定时器</h2><blockquote>
<p>别鞭尸了，有种比比销量——8051</p>
</blockquote>
<p>基本定时器由TIM6和TIM7组成，包含一个16位自动重载计数器，该计数器由可编程预分频器驱动</p>
<p>可以用作通用定时器生成时基，也可以专用于驱动DAC——这两个定时器内部直连DAC并能够通过它触发输出驱动DAC，也就是说<strong>TIM6和TIM7可以用作“模拟输出”</strong></p>
<p>两个定时器彼此完全独立，不共享资源</p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/image-20210521231037664.png" alt="image-20210521231037664"></p>
<p>基本定时器的结构非常简单，形如其名——只有定时器的基本功能</p>
<p><strong>基本定时器适合于单纯需要定时的场合，因此常被用来当作备用的“SysTick”</strong></p>
<p>如果定时器资源不够用，不妨将简单的定时任务交给TIM6、7完成</p>
<h1 id="STM32的STP定时器库函数"><a href="#STM32的STP定时器库函数" class="headerlink" title="STM32的STP定时器库函数"></a>STM32的STP定时器库函数</h1><blockquote>
<p>从STP换到HAL，没想到愣是没有一丝改变</p>
</blockquote>
<p>STM32的定时器库函数<strong>非常多</strong></p>
<p>这里作以下基本梳理（大多是从.c文件开头的注释翻译整理）</p>
<h2 id="库函数的基本使用方法"><a href="#库函数的基本使用方法" class="headerlink" title="库函数的基本使用方法"></a>库函数的基本使用方法</h2><p>库函数被分成了9组功能，如下所示</p>
<h3 id="TIM时基管理"><a href="#TIM时基管理" class="headerlink" title="TIM时基管理"></a>TIM时基管理</h3><p>ST提供了一些库函数用来管理定时器的基础设置</p>
<p>时基管理的使用方法很简单，如下所示</p>
<blockquote>
<ol>
<li>使用RCC_APBxPeriphClockCmd(RCC_APBxPeriph_TIMx, ENABLE)函数开启定时器时钟</li>
<li>使用设定好的参数设置定时器初始化结构体</li>
<li>使用TIM_TimeBaseInit()函数来应用定时器时基设置</li>
<li>如果需要产生TIM更新中断，还需要使能NVIC并进行相关配置</li>
<li>使用TIM_ITConfig(TIMx, TIM_IT_Update)函数配置中断服务函数</li>
<li>使用TIM_Cmd(ENABLE)函数使能TIM计数器</li>
</ol>
</blockquote>
<ul>
<li>设置/获取分频系数Prescaler</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置分频系数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_PrescalerConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> Prescaler, <span class="keyword">uint16_t</span> TIM_PSCReloadMode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_ALL_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));</span><br><span class="line">  <span class="comment">/* Set the Prescaler value */</span></span><br><span class="line">  TIMx-&gt;PSC = Prescaler;</span><br><span class="line">  <span class="comment">/* Set or reset the UG Bit */</span></span><br><span class="line">  TIMx-&gt;EGR = TIM_PSCReloadMode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置/获取自动重装值Autoreload</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置定时器自动重装载值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SetAutoreload</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint32_t</span> Autoreload)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_ALL_PERIPH(TIMx));</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Set the Autoreload Register value */</span></span><br><span class="line">  TIMx-&gt;ARR = Autoreload;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取定时器自动重装载值</span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">TIM_GetPrescaler</span><span class="params">(TIM_TypeDef* TIMx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_ALL_PERIPH(TIMx));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get the Prescaler Register value */</span></span><br><span class="line">  <span class="keyword">return</span> TIMx-&gt;PSC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置定时器计数器寄存器值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SetCounter</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint32_t</span> Counter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">   assert_param(IS_TIM_ALL_PERIPH(TIMx));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the Counter Register value */</span></span><br><span class="line">  TIMx-&gt;CNT = Counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取定时器计数器寄存器值</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">TIM_GetCounter</span><span class="params">(TIM_TypeDef* TIMx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_ALL_PERIPH(TIMx));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get the Counter Register value */</span></span><br><span class="line">  <span class="keyword">return</span> TIMx-&gt;CNT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>计时模式配置</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置定时器计数器模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_CounterModeConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_CounterMode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmpcr1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST3_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));</span><br><span class="line"></span><br><span class="line">  tmpcr1 = TIMx-&gt;CR1;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset the CMS and DIR Bits */</span></span><br><span class="line">  tmpcr1 &amp;= (<span class="keyword">uint16_t</span>)~(TIM_CR1_DIR | TIM_CR1_CMS);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the Counter Mode */</span></span><br><span class="line">  tmpcr1 |= TIM_CounterMode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write to TIMx CR1 register */</span></span><br><span class="line">  TIMx-&gt;CR1 = tmpcr1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置时钟分频</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SetClockDivision</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_CKD)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST1_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_CKD_DIV(TIM_CKD));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset the CKD Bits */</span></span><br><span class="line">  TIMx-&gt;CR1 &amp;= (<span class="keyword">uint16_t</span>)(~TIM_CR1_CKD);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the CKD value */</span></span><br><span class="line">  TIMx-&gt;CR1 |= TIM_CKD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>选择单脉冲模式</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SelectOnePulseMode</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_OPMode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_ALL_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_OPM_MODE(TIM_OPMode));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset the OPM Bit */</span></span><br><span class="line">  TIMx-&gt;CR1 &amp;= (<span class="keyword">uint16_t</span>)~TIM_CR1_OPM;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Configure the OPM Mode */</span></span><br><span class="line">  TIMx-&gt;CR1 |= TIM_OPMode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>更新请求配置</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定时器更新中断请求配置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_UpdateRequestConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_UpdateSource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_ALL_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (TIM_UpdateSource != TIM_UpdateSource_Global)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Set the URS Bit */</span></span><br><span class="line">    TIMx-&gt;CR1 |= TIM_CR1_URS;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Reset the URS Bit */</span></span><br><span class="line">    TIMx-&gt;CR1 &amp;= (<span class="keyword">uint16_t</span>)~TIM_CR1_URS;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>更新失能配置</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定时器更新中断失能控制</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_UpdateDisableConfig</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_ALL_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_FUNCTIONAL_STATE(NewState));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (NewState != DISABLE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Set the Update Disable Bit */</span></span><br><span class="line">    TIMx-&gt;CR1 |= TIM_CR1_UDIS;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Reset the Update Disable Bit */</span></span><br><span class="line">    TIMx-&gt;CR1 &amp;= (<span class="keyword">uint16_t</span>)~TIM_CR1_UDIS;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>自动重装载配置</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ARR预装载寄存器配置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ARRPreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_ALL_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_FUNCTIONAL_STATE(NewState));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (NewState != DISABLE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Set the ARR Preload Bit */</span></span><br><span class="line">    TIMx-&gt;CR1 |= TIM_CR1_ARPE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Reset the ARR Preload Bit */</span></span><br><span class="line">    TIMx-&gt;CR1 &amp;= (<span class="keyword">uint16_t</span>)~TIM_CR1_ARPE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使能/关闭计数器</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_Cmd</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_ALL_PERIPH(TIMx)); </span><br><span class="line">  assert_param(IS_FUNCTIONAL_STATE(NewState));</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (NewState != DISABLE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Enable the TIM Counter */</span></span><br><span class="line">    TIMx-&gt;CR1 |= TIM_CR1_CEN;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Disable the TIM Counter */</span></span><br><span class="line">    TIMx-&gt;CR1 &amp;= (<span class="keyword">uint16_t</span>)~TIM_CR1_CEN;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关函数如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取消定时器初始化并关闭时钟</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_DeInit</span><span class="params">(TIM_TypeDef* TIMx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_ALL_PERIPH(TIMx)); </span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (TIMx == TIM1)</span><br><span class="line">  &#123;</span><br><span class="line">    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);</span><br><span class="line">    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (TIMx == TIM2) </span><br><span class="line">  &#123;     </span><br><span class="line">    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);</span><br><span class="line">    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (TIMx == TIM3)</span><br><span class="line">  &#123; </span><br><span class="line">    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);</span><br><span class="line">    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (TIMx == TIM4)</span><br><span class="line">  &#123; </span><br><span class="line">    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);</span><br><span class="line">    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (TIMx == TIM5)</span><br><span class="line">  &#123;      </span><br><span class="line">    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);</span><br><span class="line">    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (TIMx == TIM6)  </span><br><span class="line">  &#123;    </span><br><span class="line">    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);</span><br><span class="line">    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (TIMx == TIM7)</span><br><span class="line">  &#123;      </span><br><span class="line">    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);</span><br><span class="line">    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (TIMx == TIM8)</span><br><span class="line">  &#123;      </span><br><span class="line">    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);</span><br><span class="line">    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (TIMx == TIM9)</span><br><span class="line">  &#123;      </span><br><span class="line">    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);</span><br><span class="line">    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  </span><br><span class="line">   &#125;  </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (TIMx == TIM10)</span><br><span class="line">  &#123;      </span><br><span class="line">    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);</span><br><span class="line">    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (TIMx == TIM11) </span><br><span class="line">  &#123;     </span><br><span class="line">    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);</span><br><span class="line">    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (TIMx == TIM12)</span><br><span class="line">  &#123;      </span><br><span class="line">    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);</span><br><span class="line">    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (TIMx == TIM13) </span><br><span class="line">  &#123;       </span><br><span class="line">    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);</span><br><span class="line">    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123; </span><br><span class="line">    <span class="keyword">if</span> (TIMx == TIM14) </span><br><span class="line">    &#123;     </span><br><span class="line">      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);</span><br><span class="line">      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); </span><br><span class="line">    &#125;   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据已有设置配置定时器初始化结构体</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_TimeBaseStructInit</span><span class="params">(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Set the default configuration */</span></span><br><span class="line">  TIM_TimeBaseInitStruct-&gt;TIM_Period = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">  TIM_TimeBaseInitStruct-&gt;TIM_Prescaler = <span class="number">0x0000</span>;</span><br><span class="line">  TIM_TimeBaseInitStruct-&gt;TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">  TIM_TimeBaseInitStruct-&gt;TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">  TIM_TimeBaseInitStruct-&gt;TIM_RepetitionCounter = <span class="number">0x0000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据初始化结构体配置定时器设置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_TimeBaseInit</span><span class="params">(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmpcr1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_ALL_PERIPH(TIMx)); </span><br><span class="line">  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct-&gt;TIM_CounterMode));</span><br><span class="line">  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct-&gt;TIM_ClockDivision));</span><br><span class="line"></span><br><span class="line">  tmpcr1 = TIMx-&gt;CR1;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((TIMx == TIM1) || (TIMx == TIM8)||</span><br><span class="line">     (TIMx == TIM2) || (TIMx == TIM3)||</span><br><span class="line">     (TIMx == TIM4) || (TIMx == TIM5)) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Select the Counter Mode */</span></span><br><span class="line">    tmpcr1 &amp;= (<span class="keyword">uint16_t</span>)(~(TIM_CR1_DIR | TIM_CR1_CMS));</span><br><span class="line">    tmpcr1 |= (<span class="keyword">uint32_t</span>)TIM_TimeBaseInitStruct-&gt;TIM_CounterMode;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span>((TIMx != TIM6) &amp;&amp; (TIMx != TIM7))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Set the clock division */</span></span><br><span class="line">    tmpcr1 &amp;=  (<span class="keyword">uint16_t</span>)(~TIM_CR1_CKD);</span><br><span class="line">    tmpcr1 |= (<span class="keyword">uint32_t</span>)TIM_TimeBaseInitStruct-&gt;TIM_ClockDivision;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  TIMx-&gt;CR1 = tmpcr1;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the Autoreload value */</span></span><br><span class="line">  TIMx-&gt;ARR = TIM_TimeBaseInitStruct-&gt;TIM_Period ;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Set the Prescaler value */</span></span><br><span class="line">  TIMx-&gt;PSC = TIM_TimeBaseInitStruct-&gt;TIM_Prescaler;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> ((TIMx == TIM1) || (TIMx == TIM8))  </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Set the Repetition Counter value */</span></span><br><span class="line">    TIMx-&gt;RCR = TIM_TimeBaseInitStruct-&gt;TIM_RepetitionCounter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Generate an update event to reload the Prescaler </span></span><br><span class="line"><span class="comment">     and the repetition counter(only for TIM1 and TIM8) value immediatly */</span></span><br><span class="line">  TIMx-&gt;EGR = TIM_PSCReloadMode_Immediate;          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TIM输出比较管理"><a href="#TIM输出比较管理" class="headerlink" title="TIM输出比较管理"></a>TIM输出比较管理</h3><p>ST提供了有关输出捕获与输出比较的库函数</p>
<p>输出捕获实际上就是对定时器的输出信号进行监测，从而实现PWM等操作</p>
<p>使用方法如下：</p>
<blockquote>
<ol>
<li>使用RCC_APBxPeriphClockCmd(RCC_APBxPeriph_TIMx, ENABLE)函数开启定时器时钟</li>
<li>配置GPIO为复用模式并配置定时器到GPIO的复用选项</li>
<li>使用下面的参数配置定时器时基单元初始化结构体设置<ul>
<li>自动重装载值 = 0xFFFF</li>
<li>分频系数 = 0x0000</li>
<li>计数模式：向上计数</li>
<li>时钟分频：TIM_CKD_DIV1</li>
</ul>
</li>
<li>使用下面的参数配置定时器输出捕获初始化结构体设置<ul>
<li>输出比较模式：TIM_OCMode</li>
<li>输出状态：TIM_OutputState</li>
<li>定时器脉冲值：TIM_Pulse</li>
<li>定时器输出比较极性：根据输出比较所需电平有效性选择</li>
</ul>
</li>
<li>使用TIM_OCxInit(TIMx, &amp;TIM_OCInitStruct)函数使用合适的配置来设置所需的通道</li>
<li>使用TIM_Cmd(ENABLE)使能定时器计数器</li>
<li>如果要使用PWM输出，需要额外使能输出捕获预装载寄存器，使用函数TIM_OCxPreloadConfig(TIMx, TIM_OCPreload_ENABLE)</li>
<li>可以在输出捕获的基础上使用定时器中断或DMA，只要使用对应库函数TIM_ITConfig(TIMx, TIM_IT_CCx)或TIM_DMA_Cmd(TIMx, TIM_DMA_CCx)提前进行配置即可</li>
</ol>
</blockquote>
<p>输出捕获的最简单用法就是PWM，但是除了这个功能，他还能实现更多更复杂的功能，相关库函数如下：</p>
<ul>
<li>将每个通道独立配置为输出比较</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化通道1输入捕获</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OC1Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmpccmrx = <span class="number">0</span>, tmpccer = <span class="number">0</span>, tmpcr2 = <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST1_PERIPH(TIMx)); </span><br><span class="line">  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct-&gt;TIM_OCMode));</span><br><span class="line">  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct-&gt;TIM_OutputState));</span><br><span class="line">  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct-&gt;TIM_OCPolarity));   </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Disable the Channel 1: Reset the CC1E Bit */</span></span><br><span class="line">  TIMx-&gt;CCER &amp;= (<span class="keyword">uint16_t</span>)~TIM_CCER_CC1E;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Get the TIMx CCER register value */</span></span><br><span class="line">  tmpccer = TIMx-&gt;CCER;</span><br><span class="line">  <span class="comment">/* Get the TIMx CR2 register value */</span></span><br><span class="line">  tmpcr2 =  TIMx-&gt;CR2;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Get the TIMx CCMR1 register value */</span></span><br><span class="line">  tmpccmrx = TIMx-&gt;CCMR1;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* Reset the Output Compare Mode Bits */</span></span><br><span class="line">  tmpccmrx &amp;= (<span class="keyword">uint16_t</span>)~TIM_CCMR1_OC1M;</span><br><span class="line">  tmpccmrx &amp;= (<span class="keyword">uint16_t</span>)~TIM_CCMR1_CC1S;</span><br><span class="line">  <span class="comment">/* Select the Output Compare Mode */</span></span><br><span class="line">  tmpccmrx |= TIM_OCInitStruct-&gt;TIM_OCMode;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Reset the Output Polarity level */</span></span><br><span class="line">  tmpccer &amp;= (<span class="keyword">uint16_t</span>)~TIM_CCER_CC1P;</span><br><span class="line">  <span class="comment">/* Set the Output Compare Polarity */</span></span><br><span class="line">  tmpccer |= TIM_OCInitStruct-&gt;TIM_OCPolarity;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Set the Output State */</span></span><br><span class="line">  tmpccer |= TIM_OCInitStruct-&gt;TIM_OutputState;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span>((TIMx == TIM1) || (TIMx == TIM8))</span><br><span class="line">  &#123;</span><br><span class="line">    assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct-&gt;TIM_OutputNState));</span><br><span class="line">    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct-&gt;TIM_OCNPolarity));</span><br><span class="line">    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct-&gt;TIM_OCNIdleState));</span><br><span class="line">    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct-&gt;TIM_OCIdleState));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Reset the Output N Polarity level */</span></span><br><span class="line">    tmpccer &amp;= (<span class="keyword">uint16_t</span>)~TIM_CCER_CC1NP;</span><br><span class="line">    <span class="comment">/* Set the Output N Polarity */</span></span><br><span class="line">    tmpccer |= TIM_OCInitStruct-&gt;TIM_OCNPolarity;</span><br><span class="line">    <span class="comment">/* Reset the Output N State */</span></span><br><span class="line">    tmpccer &amp;= (<span class="keyword">uint16_t</span>)~TIM_CCER_CC1NE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Set the Output N State */</span></span><br><span class="line">    tmpccer |= TIM_OCInitStruct-&gt;TIM_OutputNState;</span><br><span class="line">    <span class="comment">/* Reset the Output Compare and Output Compare N IDLE State */</span></span><br><span class="line">    tmpcr2 &amp;= (<span class="keyword">uint16_t</span>)~TIM_CR2_OIS1;</span><br><span class="line">    tmpcr2 &amp;= (<span class="keyword">uint16_t</span>)~TIM_CR2_OIS1N;</span><br><span class="line">    <span class="comment">/* Set the Output Idle state */</span></span><br><span class="line">    tmpcr2 |= TIM_OCInitStruct-&gt;TIM_OCIdleState;</span><br><span class="line">    <span class="comment">/* Set the Output N Idle state */</span></span><br><span class="line">    tmpcr2 |= TIM_OCInitStruct-&gt;TIM_OCNIdleState;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Write to TIMx CR2 */</span></span><br><span class="line">  TIMx-&gt;CR2 = tmpcr2;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Write to TIMx CCMR1 */</span></span><br><span class="line">  TIMx-&gt;CCMR1 = tmpccmrx;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Set the Capture Compare Register value */</span></span><br><span class="line">  TIMx-&gt;CCR1 = TIM_OCInitStruct-&gt;TIM_Pulse;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Write to TIMx CCER */</span></span><br><span class="line">  TIMx-&gt;CCER = tmpccer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化通道2、通道3、通道4的库函数与初始化通道1库函数不能说一模一样，只能说别无二致，所以在此不列出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用默认设置初始化输入捕获初始化结构体</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OCStructInit</span><span class="params">(TIM_OCInitTypeDef* TIM_OCInitStruct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Set the default configuration */</span></span><br><span class="line">  TIM_OCInitStruct-&gt;TIM_OCMode = TIM_OCMode_Timing;</span><br><span class="line">  TIM_OCInitStruct-&gt;TIM_OutputState = TIM_OutputState_Disable;</span><br><span class="line">  TIM_OCInitStruct-&gt;TIM_OutputNState = TIM_OutputNState_Disable;</span><br><span class="line">  TIM_OCInitStruct-&gt;TIM_Pulse = <span class="number">0x00000000</span>;</span><br><span class="line">  TIM_OCInitStruct-&gt;TIM_OCPolarity = TIM_OCPolarity_High;</span><br><span class="line">  TIM_OCInitStruct-&gt;TIM_OCNPolarity = TIM_OCPolarity_High;</span><br><span class="line">  TIM_OCInitStruct-&gt;TIM_OCIdleState = TIM_OCIdleState_Reset;</span><br><span class="line">  TIM_OCInitStruct-&gt;TIM_OCNIdleState = TIM_OCNIdleState_Reset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>选择输出比较模式</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择输出比较的通道、使用定时器x、输出比较的模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SelectOCxM</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_Channel, <span class="keyword">uint16_t</span> TIM_OCMode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> tmp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmp1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST1_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_CHANNEL(TIM_Channel));</span><br><span class="line">  assert_param(IS_TIM_OCM(TIM_OCMode));</span><br><span class="line"></span><br><span class="line">  tmp = (<span class="keyword">uint32_t</span>) TIMx;</span><br><span class="line">  tmp += CCMR_OFFSET;</span><br><span class="line"></span><br><span class="line">  tmp1 = CCER_CCE_SET &lt;&lt; (<span class="keyword">uint16_t</span>)TIM_Channel;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Disable the Channel: Reset the CCxE Bit */</span></span><br><span class="line">  TIMx-&gt;CCER &amp;= (<span class="keyword">uint16_t</span>) ~tmp1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))</span><br><span class="line">  &#123;</span><br><span class="line">    tmp += (TIM_Channel&gt;&gt;<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reset the OCxM bits in the CCMRx register */</span></span><br><span class="line">    *(__IO <span class="keyword">uint32_t</span> *) tmp &amp;= CCMR_OC13M_MASK;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/* Configure the OCxM bits in the CCMRx register */</span></span><br><span class="line">    *(__IO <span class="keyword">uint32_t</span> *) tmp |= TIM_OCMode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    tmp += (<span class="keyword">uint16_t</span>)(TIM_Channel - (<span class="keyword">uint16_t</span>)<span class="number">4</span>)&gt;&gt; (<span class="keyword">uint16_t</span>)<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reset the OCxM bits in the CCMRx register */</span></span><br><span class="line">    *(__IO <span class="keyword">uint32_t</span> *) tmp &amp;= CCMR_OC24M_MASK;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Configure the OCxM bits in the CCMRx register */</span></span><br><span class="line">    *(__IO <span class="keyword">uint32_t</span> *) tmp |= (<span class="keyword">uint16_t</span>)(TIM_OCMode &lt;&lt; <span class="number">8</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">可以使用如下模式：</span></span><br><span class="line"><span class="comment">定时 TIM_OCMode_Timing</span></span><br><span class="line"><span class="comment">启动 TIM_OCMode_Active</span></span><br><span class="line"><span class="comment">翻转 TIM_OCMode_Toggle</span></span><br><span class="line"><span class="comment">PWM模式1 TIM_OCMode_PWM1</span></span><br><span class="line"><span class="comment">PWM模式2 TIM_OCMode_PWM2</span></span><br><span class="line"><span class="comment">强制启动 TIM_ForcedAction_Active</span></span><br><span class="line"><span class="comment">强制停止 TIM_ForcedAction_InActive</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>选择每个通道的极性</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置正极性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OC1PolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_OCPolarity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmpccer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST1_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));</span><br><span class="line"></span><br><span class="line">  tmpccer = TIMx-&gt;CCER;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set or Reset the CC1P Bit */</span></span><br><span class="line">  tmpccer &amp;= (<span class="keyword">uint16_t</span>)(~TIM_CCER_CC1P);</span><br><span class="line">  tmpccer |= TIM_OCPolarity;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write to TIMx CCER register */</span></span><br><span class="line">  TIMx-&gt;CCER = tmpccer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置负极性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OC1NPolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_OCNPolarity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmpccer = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST4_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));</span><br><span class="line">   </span><br><span class="line">  tmpccer = TIMx-&gt;CCER;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set or Reset the CC1NP Bit */</span></span><br><span class="line">  tmpccer &amp;= (<span class="keyword">uint16_t</span>)~TIM_CCER_CC1NP;</span><br><span class="line">  tmpccer |= TIM_OCNPolarity;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write to TIMx CCER register */</span></span><br><span class="line">  TIMx-&gt;CCER = tmpccer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个库函数都有4个不同通道的设置，在此仅列出通道1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>设置/获取输出捕获/比较寄存器的值</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置输出比较寄存器1、2、3、4的值</span></span><br><span class="line"><span class="comment">//每个输出比较寄存器对应一个通道</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SetCompare1</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint32_t</span> Compare1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST1_PERIPH(TIMx));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the Capture Compare1 Register value */</span></span><br><span class="line">  TIMx-&gt;CCR1 = Compare1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SetCompare2</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint32_t</span> Compare2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST2_PERIPH(TIMx));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the Capture Compare2 Register value */</span></span><br><span class="line">  TIMx-&gt;CCR2 = Compare2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、4的库函数和1、2大同小异，在此不列出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置输出捕获寄存器1、2、3、4的值，2、3、4的设置库函数不列出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ForcedOC1Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_ForcedAction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmpccmr1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST1_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));</span><br><span class="line">  tmpccmr1 = TIMx-&gt;CCMR1;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset the OC1M Bits */</span></span><br><span class="line">  tmpccmr1 &amp;= (<span class="keyword">uint16_t</span>)~TIM_CCMR1_OC1M;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Configure The Forced output Mode */</span></span><br><span class="line">  tmpccmr1 |= TIM_ForcedAction;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write to TIMx CCMR1 register */</span></span><br><span class="line">  TIMx-&gt;CCMR1 = tmpccmr1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置定时器输出捕获预装载寄存器的值（同样是4个通道）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OC1PreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_OCPreload)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmpccmr1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST1_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));</span><br><span class="line"></span><br><span class="line">  tmpccmr1 = TIMx-&gt;CCMR1;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset the OC1PE Bit */</span></span><br><span class="line">  tmpccmr1 &amp;= (<span class="keyword">uint16_t</span>)(~TIM_CCMR1_OC1PE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Enable or Disable the Output Compare Preload feature */</span></span><br><span class="line">  tmpccmr1 |= TIM_OCPreload;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write to TIMx CCMR1 register */</span></span><br><span class="line">  TIMx-&gt;CCMR1 = tmpccmr1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>选择输出比较快速模式（Output Compare Fast mode）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出比较快速模式设置（4个通道）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OC1FastConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_OCFast)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmpccmr1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST1_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get the TIMx CCMR1 register value */</span></span><br><span class="line">  tmpccmr1 = TIMx-&gt;CCMR1;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset the OC1FE Bit */</span></span><br><span class="line">  tmpccmr1 &amp;= (<span class="keyword">uint16_t</span>)~TIM_CCMR1_OC1FE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Enable or Disable the Output Compare Fast Bit */</span></span><br><span class="line">  tmpccmr1 |= TIM_OCFast;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write to TIMx CCMR1 */</span></span><br><span class="line">  TIMx-&gt;CCMR1 = tmpccmr1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>选择输出比较强制模式（Output Compare Forced mode）</li>
<li>输出比较-预装载模式</li>
<li>清空输出比较参考值</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清空输出比较参考值（4通道）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ClearOC1Ref</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_OCClear)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmpccmr1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST1_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));</span><br><span class="line"></span><br><span class="line">  tmpccmr1 = TIMx-&gt;CCMR1;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset the OC1CE Bit */</span></span><br><span class="line">  tmpccmr1 &amp;= (<span class="keyword">uint16_t</span>)~TIM_CCMR1_OC1CE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Enable or Disable the Output Compare Clear Bit */</span></span><br><span class="line">  tmpccmr1 |= TIM_OCClear;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write to TIMx CCMR1 register */</span></span><br><span class="line">  TIMx-&gt;CCMR1 = tmpccmr1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>选择OCREF清空信号</li>
<li>使能/失能捕获/比较通道</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//控制捕获通道开启/关闭</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_CCxCmd</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_Channel, <span class="keyword">uint16_t</span> TIM_CCx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST1_PERIPH(TIMx)); </span><br><span class="line">  assert_param(IS_TIM_CHANNEL(TIM_Channel));</span><br><span class="line">  assert_param(IS_TIM_CCX(TIM_CCx));</span><br><span class="line"></span><br><span class="line">  tmp = CCER_CCE_SET &lt;&lt; TIM_Channel;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset the CCxE Bit */</span></span><br><span class="line">  TIMx-&gt;CCER &amp;= (<span class="keyword">uint16_t</span>)~ tmp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set or reset the CCxE Bit */</span> </span><br><span class="line">  TIMx-&gt;CCER |=  (<span class="keyword">uint16_t</span>)(TIM_CCx &lt;&lt; TIM_Channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制捕获比较通道开启/关闭</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_CCxNCmd</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_Channel, <span class="keyword">uint16_t</span> TIM_CCxN)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST4_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));</span><br><span class="line">  assert_param(IS_TIM_CCXN(TIM_CCxN));</span><br><span class="line"></span><br><span class="line">  tmp = CCER_CCNE_SET &lt;&lt; TIM_Channel;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset the CCxNE Bit */</span></span><br><span class="line">  TIMx-&gt;CCER &amp;= (<span class="keyword">uint16_t</span>) ~tmp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set or reset the CCxNE Bit */</span> </span><br><span class="line">  TIMx-&gt;CCER |=  (<span class="keyword">uint16_t</span>)(TIM_CCxN &lt;&lt; TIM_Channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TIM输入捕获管理"><a href="#TIM输入捕获管理" class="headerlink" title="TIM输入捕获管理"></a>TIM输入捕获管理</h3><p>ST也提供了定时器输入捕获的库函数</p>
<p>基本使用方法如下：</p>
<blockquote>
<ol>
<li>使用RCC_APBxPeriphClockCmd(RCC_APBxPeriph_TIMx, ENABLE) 函数开启定时器时钟</li>
<li>将GPIO配置为合适的输入引脚，设置位复用模式并连接到定时器输入捕获</li>
<li>如果需要可以自行配置定时器时基设定，但推荐默认状态为：<ul>
<li>自动重装载值：0xFFFF</li>
<li>分频值：0x0000</li>
<li>计数模式：向上计数</li>
<li>时钟分频：TIM_CKD_DIV1一分频</li>
</ul>
</li>
<li>使用以下参数配置定时器输入捕获初始化结构体<ul>
<li>定时器通道：选择合适的通道</li>
<li>定时器输入捕获选项：根据输入捕获选择</li>
<li>定时器输入捕获分频：随机应变</li>
<li>定时器输入捕获屏蔽器值：根据要过滤的捕获信号设置</li>
</ul>
</li>
<li>使用TIM_ICInit(TIMx, &amp;TIM_ICInitStruct)函数根据上面的设置配置所需通道，就可以让定时器输入捕获测量输入信号的频率、占空比，或使用TIM_PWMIConfig(TIMx, &amp;TIM_ICInitStruct)函数配置通道来测量输入PWM波的频率和占空比</li>
<li>可使用中断或DMA方式读取测量信号，TIM_ITConfig(TIMx, TIM_IT_CCx)和TIM_DMA_Cmd(TIMx, TIM_DMA_CCx)函数都可选</li>
<li>使用TIM_Cmd(ENABLE)来开启定时器计数器</li>
<li>使用TIM_GetCapturex(TIMx)来读取捕获到的值</li>
</ol>
</blockquote>
<ul>
<li>单独配置每个通道位输入捕获模式</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据输入捕获初始化结构体配置某个通道为输入捕获模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ICInit</span><span class="params">(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST1_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct-&gt;TIM_ICPolarity));</span><br><span class="line">  assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct-&gt;TIM_ICSelection));</span><br><span class="line">  assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct-&gt;TIM_ICPrescaler));</span><br><span class="line">  assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct-&gt;TIM_ICFilter));</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (TIM_ICInitStruct-&gt;TIM_Channel == TIM_Channel_1)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* TI1 Configuration */</span></span><br><span class="line">    TI1_Config(TIMx, TIM_ICInitStruct-&gt;TIM_ICPolarity,</span><br><span class="line">               TIM_ICInitStruct-&gt;TIM_ICSelection,</span><br><span class="line">               TIM_ICInitStruct-&gt;TIM_ICFilter);</span><br><span class="line">    <span class="comment">/* Set the Input Capture Prescaler value */</span></span><br><span class="line">    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (TIM_ICInitStruct-&gt;TIM_Channel == TIM_Channel_2)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* TI2 Configuration */</span></span><br><span class="line">    assert_param(IS_TIM_LIST2_PERIPH(TIMx));</span><br><span class="line">    TI2_Config(TIMx, TIM_ICInitStruct-&gt;TIM_ICPolarity,</span><br><span class="line">               TIM_ICInitStruct-&gt;TIM_ICSelection,</span><br><span class="line">               TIM_ICInitStruct-&gt;TIM_ICFilter);</span><br><span class="line">    <span class="comment">/* Set the Input Capture Prescaler value */</span></span><br><span class="line">    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (TIM_ICInitStruct-&gt;TIM_Channel == TIM_Channel_3)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* TI3 Configuration */</span></span><br><span class="line">    assert_param(IS_TIM_LIST3_PERIPH(TIMx));</span><br><span class="line">    TI3_Config(TIMx,  TIM_ICInitStruct-&gt;TIM_ICPolarity,</span><br><span class="line">               TIM_ICInitStruct-&gt;TIM_ICSelection,</span><br><span class="line">               TIM_ICInitStruct-&gt;TIM_ICFilter);</span><br><span class="line">    <span class="comment">/* Set the Input Capture Prescaler value */</span></span><br><span class="line">    TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* TI4 Configuration */</span></span><br><span class="line">    assert_param(IS_TIM_LIST3_PERIPH(TIMx));</span><br><span class="line">    TI4_Config(TIMx, TIM_ICInitStruct-&gt;TIM_ICPolarity,</span><br><span class="line">               TIM_ICInitStruct-&gt;TIM_ICSelection,</span><br><span class="line">               TIM_ICInitStruct-&gt;TIM_ICFilter);</span><br><span class="line">    <span class="comment">/* Set the Input Capture Prescaler value */</span></span><br><span class="line">    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用默认设置配置输入捕获初始化结构体</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ICStructInit</span><span class="params">(TIM_ICInitTypeDef* TIM_ICInitStruct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Set the default configuration */</span></span><br><span class="line">  TIM_ICInitStruct-&gt;TIM_Channel = TIM_Channel_1;</span><br><span class="line">  TIM_ICInitStruct-&gt;TIM_ICPolarity = TIM_ICPolarity_Rising;</span><br><span class="line">  TIM_ICInitStruct-&gt;TIM_ICSelection = TIM_ICSelection_DirectTI;</span><br><span class="line">  TIM_ICInitStruct-&gt;TIM_ICPrescaler = TIM_ICPSC_DIV1;</span><br><span class="line">  TIM_ICInitStruct-&gt;TIM_ICFilter = <span class="number">0x00</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可配置通道1/2处于PWM输入模式，用于获取外部脉冲/测量外部信号频率（如编码器输入、遥控信号输入等）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置通道为PWM输入模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_PWMIConfig</span><span class="params">(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> icoppositepolarity = TIM_ICPolarity_Rising;</span><br><span class="line">  <span class="keyword">uint16_t</span> icoppositeselection = TIM_ICSelection_DirectTI;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST2_PERIPH(TIMx));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Select the Opposite Input Polarity */</span></span><br><span class="line">  <span class="keyword">if</span> (TIM_ICInitStruct-&gt;TIM_ICPolarity == TIM_ICPolarity_Rising)</span><br><span class="line">  &#123;</span><br><span class="line">    icoppositepolarity = TIM_ICPolarity_Falling;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    icoppositepolarity = TIM_ICPolarity_Rising;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Select the Opposite Input */</span></span><br><span class="line">  <span class="keyword">if</span> (TIM_ICInitStruct-&gt;TIM_ICSelection == TIM_ICSelection_DirectTI)</span><br><span class="line">  &#123;</span><br><span class="line">    icoppositeselection = TIM_ICSelection_IndirectTI;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    icoppositeselection = TIM_ICSelection_DirectTI;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (TIM_ICInitStruct-&gt;TIM_Channel == TIM_Channel_1)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* TI1 Configuration */</span></span><br><span class="line">    TI1_Config(TIMx, TIM_ICInitStruct-&gt;TIM_ICPolarity, TIM_ICInitStruct-&gt;TIM_ICSelection,</span><br><span class="line">               TIM_ICInitStruct-&gt;TIM_ICFilter);</span><br><span class="line">    <span class="comment">/* Set the Input Capture Prescaler value */</span></span><br><span class="line">    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);</span><br><span class="line">    <span class="comment">/* TI2 Configuration */</span></span><br><span class="line">    TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct-&gt;TIM_ICFilter);</span><br><span class="line">    <span class="comment">/* Set the Input Capture Prescaler value */</span></span><br><span class="line">    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123; </span><br><span class="line">    <span class="comment">/* TI2 Configuration */</span></span><br><span class="line">    TI2_Config(TIMx, TIM_ICInitStruct-&gt;TIM_ICPolarity, TIM_ICInitStruct-&gt;TIM_ICSelection,</span><br><span class="line">               TIM_ICInitStruct-&gt;TIM_ICFilter);</span><br><span class="line">    <span class="comment">/* Set the Input Capture Prescaler value */</span></span><br><span class="line">    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);</span><br><span class="line">    <span class="comment">/* TI1 Configuration */</span></span><br><span class="line">    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct-&gt;TIM_ICFilter);</span><br><span class="line">    <span class="comment">/* Set the Input Capture Prescaler value */</span></span><br><span class="line">    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置输入捕获预分频器</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置输入捕获1、2、3、4通道预分频器的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SetIC1Prescaler</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_ICPSC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST1_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset the IC1PSC Bits */</span></span><br><span class="line">  TIMx-&gt;CCMR1 &amp;= (<span class="keyword">uint16_t</span>)~TIM_CCMR1_IC1PSC;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the IC1PSC value */</span></span><br><span class="line">  TIMx-&gt;CCMR1 |= TIM_ICPSC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取捕获/比较值</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取输入捕获1、2、3、4的值</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">TIM_GetCapture1</span><span class="params">(TIM_TypeDef* TIMx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST1_PERIPH(TIMx));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get the Capture 1 Register value */</span></span><br><span class="line">  <span class="keyword">return</span> TIMx-&gt;CCR1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">TIM_GetCapture2</span><span class="params">(TIM_TypeDef* TIMx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST2_PERIPH(TIMx));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get the Capture 2 Register value */</span></span><br><span class="line">  <span class="keyword">return</span> TIMx-&gt;CCR2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">TIM_GetCapture3</span><span class="params">(TIM_TypeDef* TIMx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST3_PERIPH(TIMx)); </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get the Capture 3 Register value */</span></span><br><span class="line">  <span class="keyword">return</span> TIMx-&gt;CCR3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">TIM_GetCapture4</span><span class="params">(TIM_TypeDef* TIMx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST3_PERIPH(TIMx));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get the Capture 4 Register value */</span></span><br><span class="line">  <span class="keyword">return</span> TIMx-&gt;CCR4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高级定时器（TIM1、TIM8）的特殊控制库函数"><a href="#高级定时器（TIM1、TIM8）的特殊控制库函数" class="headerlink" title="高级定时器（TIM1、TIM8）的特殊控制库函数"></a>高级定时器（TIM1、TIM8）的特殊控制库函数</h3><p>STM32F4中具有两个高级定时器，ST也为它们提供了库函数</p>
<p>下面是基本使用方法</p>
<blockquote>
<ol>
<li>使用输出比较模式配置定时器通道</li>
<li>使用TIM_BDTRInitStruct结构体设置时钟断点极性、死区时间、锁定等级、OSSI/OSSR状态和AOE（自动输出使能）模式</li>
<li>使用TIM_BDTRConfig(TIMx, &amp;TIM_BDTRInitStruct)配置定时器的高级功能</li>
<li>使用TIM_CtrlPWMOutputs(TIM1, ENABLE)函数使能主输出</li>
<li>一旦断点发生，定时器的输出信号就会被置于重置或某个经过TIM_BDTRConfig()设定的状态</li>
</ol>
</blockquote>
<ul>
<li>配置断点输入（Break input）、死区时间、锁定等级、OSSI、OSSR状态、AOE（自动输入使能）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_BDTRConfig</span><span class="params">(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST4_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct-&gt;TIM_OSSRState));</span><br><span class="line">  assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct-&gt;TIM_OSSIState));</span><br><span class="line">  assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct-&gt;TIM_LOCKLevel));</span><br><span class="line">  assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct-&gt;TIM_Break));</span><br><span class="line">  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct-&gt;TIM_BreakPolarity));</span><br><span class="line">  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct-&gt;TIM_AutomaticOutput));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,</span></span><br><span class="line"><span class="comment">     the OSSI State, the dead time value and the Automatic Output Enable Bit */</span></span><br><span class="line">  TIMx-&gt;BDTR = (<span class="keyword">uint32_t</span>)TIM_BDTRInitStruct-&gt;TIM_OSSRState | TIM_BDTRInitStruct-&gt;TIM_OSSIState |</span><br><span class="line">             TIM_BDTRInitStruct-&gt;TIM_LOCKLevel | TIM_BDTRInitStruct-&gt;TIM_DeadTime |</span><br><span class="line">             TIM_BDTRInitStruct-&gt;TIM_Break | TIM_BDTRInitStruct-&gt;TIM_BreakPolarity |</span><br><span class="line">             TIM_BDTRInitStruct-&gt;TIM_AutomaticOutput;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用初始化结构体默认设置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_BDTRStructInit</span><span class="params">(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Set the default configuration */</span></span><br><span class="line">  TIM_BDTRInitStruct-&gt;TIM_OSSRState = TIM_OSSRState_Disable;</span><br><span class="line">  TIM_BDTRInitStruct-&gt;TIM_OSSIState = TIM_OSSIState_Disable;</span><br><span class="line">  TIM_BDTRInitStruct-&gt;TIM_LOCKLevel = TIM_LOCKLevel_OFF;</span><br><span class="line">  TIM_BDTRInitStruct-&gt;TIM_DeadTime = <span class="number">0x00</span>;</span><br><span class="line">  TIM_BDTRInitStruct-&gt;TIM_Break = TIM_Break_Disable;</span><br><span class="line">  TIM_BDTRInitStruct-&gt;TIM_BreakPolarity = TIM_BreakPolarity_Low;</span><br><span class="line">  TIM_BDTRInitStruct-&gt;TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使能/失能定时器外设主输出</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_CtrlPWMOutputs</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST4_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_FUNCTIONAL_STATE(NewState));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (NewState != DISABLE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Enable the TIM Main Output */</span></span><br><span class="line">    TIMx-&gt;BDTR |= TIM_BDTR_MOE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Disable the TIM Main Output */</span></span><br><span class="line">    TIMx-&gt;BDTR &amp;= (<span class="keyword">uint16_t</span>)~TIM_BDTR_MOE;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>选择通讯事件</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择通信事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SelectCOM</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST4_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_FUNCTIONAL_STATE(NewState));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (NewState != DISABLE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Set the COM Bit */</span></span><br><span class="line">    TIMx-&gt;CR2 |= TIM_CR2_CCUS;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Reset the COM Bit */</span></span><br><span class="line">    TIMx-&gt;CR2 &amp;= (<span class="keyword">uint16_t</span>)~TIM_CR2_CCUS;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置/重置捕获比较预装载控制位</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置捕获比较预装载控制位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_CCPreloadControl</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST4_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_FUNCTIONAL_STATE(NewState));</span><br><span class="line">  <span class="keyword">if</span> (NewState != DISABLE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Set the CCPC Bit */</span></span><br><span class="line">    TIMx-&gt;CR2 |= TIM_CR2_CCPC;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Reset the CCPC Bit */</span></span><br><span class="line">    TIMx-&gt;CR2 &amp;= (<span class="keyword">uint16_t</span>)~TIM_CR2_CCPC;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定时器中断、DMA与标志位管理"><a href="#定时器中断、DMA与标志位管理" class="headerlink" title="定时器中断、DMA与标志位管理"></a>定时器中断、DMA与标志位管理</h3><p>STM32中的一些定时器是可以触发定时器中断、DMA的，ST也提供了管理库函数</p>
<ul>
<li>使能/失能中断源</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使能或关闭定时器中断</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ITConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_IT, FunctionalState NewState)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_ALL_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_IT(TIM_IT));</span><br><span class="line">  assert_param(IS_FUNCTIONAL_STATE(NewState));</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (NewState != DISABLE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Enable the Interrupt sources */</span></span><br><span class="line">    TIMx-&gt;DIER |= TIM_IT;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Disable the Interrupt sources */</span></span><br><span class="line">    TIMx-&gt;DIER &amp;= (<span class="keyword">uint16_t</span>)~TIM_IT;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">TIM_IT参数可设置为以下值</span></span><br><span class="line"><span class="comment">TIM_IT_Update:定时器更新中断</span></span><br><span class="line"><span class="comment">TIM_IT_CC1:定时器比较中断4</span></span><br><span class="line"><span class="comment">TIM_IT_CC2:定时器比较中断4</span></span><br><span class="line"><span class="comment">TIM_IT_CC3:定时器比较中断4</span></span><br><span class="line"><span class="comment">TIM_IT_CC4:定时器比较中断4</span></span><br><span class="line"><span class="comment">TIM_IT_COM:定时器通讯中断</span></span><br><span class="line"><span class="comment">TIM_IT_Trigger:定时器触发中断</span></span><br><span class="line"><span class="comment">TIM_IT_Break:定时器暂停中断</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">TIM6和TIM7只能使用TIM_IT_Update，TIM9和TIM12只能使用TIM_IT_Update，TIM_IT_CC1, TIM_IT_CC2或TIM_IT_Trigger</span></span><br><span class="line"><span class="comment">TIM10、11、13、14只能使用TIM_IT_Update或TIM_IT_CC1</span></span><br><span class="line"><span class="comment">TIM1和TIM8两个高级定时器才被允许使用TIM_IT_COM和TIM_IT_Break</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置定时器软件事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_GenerateEvent</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_EventSource)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_ALL_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Set the event sources */</span></span><br><span class="line">  TIMx-&gt;EGR = TIM_EventSource;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">TIM_EventSource_Update:定时器更新事件（下面内容和上面中断的内冲差不多，懒得翻译了）</span></span><br><span class="line"><span class="comment">TIM_EventSource_CC1: Timer Capture Compare 1 Event source</span></span><br><span class="line"><span class="comment">TIM_EventSource_CC2: Timer Capture Compare 2 Event source</span></span><br><span class="line"><span class="comment">TIM_EventSource_CC3: Timer Capture Compare 3 Event source</span></span><br><span class="line"><span class="comment">TIM_EventSource_CC4: Timer Capture Compare 4 Event source</span></span><br><span class="line"><span class="comment">TIM_EventSource_COM: Timer COM event source  </span></span><br><span class="line"><span class="comment">TIM_EventSource_Trigger: Timer Trigger Event source</span></span><br><span class="line"><span class="comment">TIM_EventSource_Break: Timer Break event source</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">其中TIM6、7只能使用定时器更新事件；只有高级定时器TIM1、8才能使用后三个高级事件功能</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取标志状态</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前中断标志位状态</span></span><br><span class="line"><span class="function">FlagStatus <span class="title">TIM_GetFlagStatus</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_FLAG)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  ITStatus bitstatus = RESET;  </span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_ALL_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_GET_FLAG(TIM_FLAG));</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ((TIMx-&gt;SR &amp; TIM_FLAG) != (<span class="keyword">uint16_t</span>)RESET)</span><br><span class="line">  &#123;</span><br><span class="line">    bitstatus = SET;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    bitstatus = RESET;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bitstatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取中断状态</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前中断发生状态</span></span><br><span class="line"><span class="function">ITStatus <span class="title">TIM_GetITStatus</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_IT)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ITStatus bitstatus = RESET;  </span><br><span class="line">  <span class="keyword">uint16_t</span> itstatus = <span class="number">0x0</span>, itenable = <span class="number">0x0</span>;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_ALL_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_GET_IT(TIM_IT));</span><br><span class="line">   </span><br><span class="line">  itstatus = TIMx-&gt;SR &amp; TIM_IT;</span><br><span class="line">  </span><br><span class="line">  itenable = TIMx-&gt;DIER &amp; TIM_IT;</span><br><span class="line">  <span class="keyword">if</span> ((itstatus != (<span class="keyword">uint16_t</span>)RESET) &amp;&amp; (itenable != (<span class="keyword">uint16_t</span>)RESET))</span><br><span class="line">  &#123;</span><br><span class="line">    bitstatus = SET;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    bitstatus = RESET;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bitstatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>清空标志位/挂起标志位</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清空中断标志位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ClearFlag</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_FLAG)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_ALL_PERIPH(TIMx));</span><br><span class="line">   </span><br><span class="line">  <span class="comment">/* Clear the flags */</span></span><br><span class="line">  TIMx-&gt;SR = (<span class="keyword">uint16_t</span>)~TIM_FLAG;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空中断挂起标志位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ClearITPendingBit</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_IT)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_ALL_PERIPH(TIMx));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Clear the IT pending Bit */</span></span><br><span class="line">  TIMx-&gt;SR = (<span class="keyword">uint16_t</span>)~TIM_IT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使能/失能DMA请求</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使能定时器DMA</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_DMACmd</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_DMASource, FunctionalState NewState)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST5_PERIPH(TIMx)); </span><br><span class="line">  assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));</span><br><span class="line">  assert_param(IS_FUNCTIONAL_STATE(NewState));</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (NewState != DISABLE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Enable the DMA sources */</span></span><br><span class="line">    TIMx-&gt;DIER |= TIM_DMASource; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Disable the DMA sources */</span></span><br><span class="line">    TIMx-&gt;DIER &amp;= (<span class="keyword">uint16_t</span>)~TIM_DMASource;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>配置DMA突发传输模式（burst mode）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置定时器DMA突发传输模式与相关设置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_DMAConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_DMABase, <span class="keyword">uint16_t</span> TIM_DMABurstLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST3_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_DMA_BASE(TIM_DMABase)); </span><br><span class="line">  assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the DMA Base and the DMA Burst Length */</span></span><br><span class="line">  TIMx-&gt;DCR = TIM_DMABase | TIM_DMABurstLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>选择捕获比较DMA请求</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择捕获比较DMA请求使能</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SelectCCDMA</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST3_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_FUNCTIONAL_STATE(NewState));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (NewState != DISABLE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Set the CCDS Bit */</span></span><br><span class="line">    TIMx-&gt;CR2 |= TIM_CR2_CCDS;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Reset the CCDS Bit */</span></span><br><span class="line">    TIMx-&gt;CR2 &amp;= (<span class="keyword">uint16_t</span>)~TIM_CR2_CCDS;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定时器时钟管理"><a href="#定时器时钟管理" class="headerlink" title="定时器时钟管理"></a>定时器时钟管理</h3><p>这里是关于定时器时钟源的管理库函数</p>
<ul>
<li>选择内部/外部时钟输入</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置定时器内部时钟</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_InternalClockConfig</span><span class="params">(TIM_TypeDef* TIMx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST2_PERIPH(TIMx));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Disable slave mode to clock the prescaler directly with the internal clock */</span></span><br><span class="line">  TIMx-&gt;SMCR &amp;=  (<span class="keyword">uint16_t</span>)~TIM_SMCR_SMS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置定时器内部触发作为外部时钟</span></span><br><span class="line"><span class="comment">//可选择TIM_TS_ITR0到3作为内部触发源</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ITRxExternalClockConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_InputTriggerSource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST2_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Select the Internal Trigger */</span></span><br><span class="line">  TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Select the External clock mode1 */</span></span><br><span class="line">  TIMx-&gt;SMCR |= TIM_SlaveMode_External1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置定时器触发器作为外部时钟源</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_TIxExternalClockConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_TIxExternalCLKSource,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">uint16_t</span> TIM_ICPolarity, <span class="keyword">uint16_t</span> ICFilter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST1_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));</span><br><span class="line">  assert_param(IS_TIM_IC_FILTER(ICFilter));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Configure the Timer Input Clock Source */</span></span><br><span class="line">  <span class="keyword">if</span> (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)</span><br><span class="line">  &#123;</span><br><span class="line">    TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Select the Trigger source */</span></span><br><span class="line">  TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);</span><br><span class="line">  <span class="comment">/* Select the External clock mode1 */</span></span><br><span class="line">  TIMx-&gt;SMCR |= TIM_SlaveMode_External1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>选择外部时钟模式为ETR（模式1/模式2）、TIx或ITRx</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置定时器ETR模式1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ETRClockMode1Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_ExtTRGPrescaler,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">uint16_t</span> TIM_ExtTRGPolarity, <span class="keyword">uint16_t</span> ExtTRGFilter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmpsmcr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST3_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));</span><br><span class="line">  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));</span><br><span class="line">  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));</span><br><span class="line">  <span class="comment">/* Configure the ETR Clock source */</span></span><br><span class="line">  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Get the TIMx SMCR register value */</span></span><br><span class="line">  tmpsmcr = TIMx-&gt;SMCR;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset the SMS Bits */</span></span><br><span class="line">  tmpsmcr &amp;= (<span class="keyword">uint16_t</span>)~TIM_SMCR_SMS;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Select the External clock mode1 */</span></span><br><span class="line">  tmpsmcr |= TIM_SlaveMode_External1;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Select the Trigger selection : ETRF */</span></span><br><span class="line">  tmpsmcr &amp;= (<span class="keyword">uint16_t</span>)~TIM_SMCR_TS;</span><br><span class="line">  tmpsmcr |= TIM_TS_ETRF;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write to TIMx SMCR */</span></span><br><span class="line">  TIMx-&gt;SMCR = tmpsmcr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置ETR模式2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ETRClockMode2Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_ExtTRGPrescaler, </span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">uint16_t</span> TIM_ExtTRGPolarity, <span class="keyword">uint16_t</span> ExtTRGFilter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST3_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));</span><br><span class="line">  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));</span><br><span class="line">  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Configure the ETR Clock source */</span></span><br><span class="line">  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Enable the External clock mode2 */</span></span><br><span class="line">  TIMx-&gt;SMCR |= TIM_SMCR_ECE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定时器同步管理"><a href="#定时器同步管理" class="headerlink" title="定时器同步管理"></a>定时器同步管理</h3><p>STM32中部分定时器可以实现同步功能，这里是相关的同步管理库函数</p>
<p>基本配置方法如下所示：</p>
<blockquote>
<p>两个/多个定时器可进行串连、同步、交错等多种配置，需要以下步骤：</p>
<ol>
<li>使用下面的两个函数配置主定时器：<ul>
<li>TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)选择输出触发源</li>
<li>TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)选择当前定时器模式为主从模式</li>
</ul>
</li>
<li>使用下面的函数配置从定时器：<ul>
<li>TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)选择触发源输入</li>
<li>TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)选择当前定时器模式为从模式</li>
</ul>
</li>
<li>这样从定时器就会被连接到主定时器的触发器，接收主定时器控制</li>
<li>使用TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)函数配置定时器的外部触发源，可实现由外部信号控制定时器</li>
<li>配合TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)与TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)函数，可以让定时器接收外部信号并作为从模式工作</li>
</ol>
</blockquote>
<ul>
<li>选择输入触发信号</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SelectInputTrigger</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_InputTriggerSource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmpsmcr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST1_PERIPH(TIMx)); </span><br><span class="line">  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get the TIMx SMCR register value */</span></span><br><span class="line">  tmpsmcr = TIMx-&gt;SMCR;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset the TS Bits */</span></span><br><span class="line">  tmpsmcr &amp;= (<span class="keyword">uint16_t</span>)~TIM_SMCR_TS;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the Input Trigger source */</span></span><br><span class="line">  tmpsmcr |= TIM_InputTriggerSource;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write to TIMx SMCR */</span></span><br><span class="line">  TIMx-&gt;SMCR = tmpsmcr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>选择输出触发信号</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SelectOutputTrigger</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_TRGOSource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST5_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset the MMS Bits */</span></span><br><span class="line">  TIMx-&gt;CR2 &amp;= (<span class="keyword">uint16_t</span>)~TIM_CR2_MMS;</span><br><span class="line">  <span class="comment">/* Select the TRGO source */</span></span><br><span class="line">  TIMx-&gt;CR2 |=  TIM_TRGOSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>选择主从模式</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置定时器为从模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SelectSlaveMode</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_SlaveMode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST2_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset the SMS Bits */</span></span><br><span class="line">  TIMx-&gt;SMCR &amp;= (<span class="keyword">uint16_t</span>)~TIM_SMCR_SMS;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Select the Slave Mode */</span></span><br><span class="line">  TIMx-&gt;SMCR |= TIM_SlaveMode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置定时器为主/从模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SelectMasterSlaveMode</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_MasterSlaveMode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST2_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset the MSM Bit */</span></span><br><span class="line">  TIMx-&gt;SMCR &amp;= (<span class="keyword">uint16_t</span>)~TIM_SMCR_MSM;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Set or Reset the MSM Bit */</span></span><br><span class="line">  TIMx-&gt;SMCR |= TIM_MasterSlaveMode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当作为外部触发使用时进行ETR配置</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置定时器外部触发模式（ETR）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ETRConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_ExtTRGPrescaler,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">uint16_t</span> TIM_ExtTRGPolarity, <span class="keyword">uint16_t</span> ExtTRGFilter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmpsmcr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST3_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));</span><br><span class="line">  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));</span><br><span class="line">  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));</span><br><span class="line"></span><br><span class="line">  tmpsmcr = TIMx-&gt;SMCR;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset the ETR Bits */</span></span><br><span class="line">  tmpsmcr &amp;= SMCR_ETR_MASK;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the Prescaler, the Filter value and the Polarity */</span></span><br><span class="line">  tmpsmcr |= (<span class="keyword">uint16_t</span>)(TIM_ExtTRGPrescaler | (<span class="keyword">uint16_t</span>)(TIM_ExtTRGPolarity | (<span class="keyword">uint16_t</span>)(ExtTRGFilter &lt;&lt; (<span class="keyword">uint16_t</span>)<span class="number">8</span>)));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write to TIMx SMCR */</span></span><br><span class="line">  TIMx-&gt;SMCR = tmpsmcr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定时器特殊结构管理"><a href="#定时器特殊结构管理" class="headerlink" title="定时器特殊结构管理"></a>定时器特殊结构管理</h3><p>定时器也可以作为特殊设备的接口使用，ST也提供了这样用法的库函数</p>
<ul>
<li>解码器接口配置</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_EncoderInterfaceConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_EncoderMode,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">uint16_t</span> TIM_IC1Polarity, <span class="keyword">uint16_t</span> TIM_IC2Polarity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmpsmcr = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmpccmr1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmpccer = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST2_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));</span><br><span class="line">  assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));</span><br><span class="line">  assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get the TIMx SMCR register value */</span></span><br><span class="line">  tmpsmcr = TIMx-&gt;SMCR;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get the TIMx CCMR1 register value */</span></span><br><span class="line">  tmpccmr1 = TIMx-&gt;CCMR1;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get the TIMx CCER register value */</span></span><br><span class="line">  tmpccer = TIMx-&gt;CCER;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the encoder Mode */</span></span><br><span class="line">  tmpsmcr &amp;= (<span class="keyword">uint16_t</span>)~TIM_SMCR_SMS;</span><br><span class="line">  tmpsmcr |= TIM_EncoderMode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Select the Capture Compare 1 and the Capture Compare 2 as input */</span></span><br><span class="line">  tmpccmr1 &amp;= ((<span class="keyword">uint16_t</span>)~TIM_CCMR1_CC1S) &amp; ((<span class="keyword">uint16_t</span>)~TIM_CCMR1_CC2S);</span><br><span class="line">  tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the TI1 and the TI2 Polarities */</span></span><br><span class="line">  tmpccer &amp;= ((<span class="keyword">uint16_t</span>)~TIM_CCER_CC1P) &amp; ((<span class="keyword">uint16_t</span>)~TIM_CCER_CC2P);</span><br><span class="line">  tmpccer |= (<span class="keyword">uint16_t</span>)(TIM_IC1Polarity | (<span class="keyword">uint16_t</span>)(TIM_IC2Polarity &lt;&lt; (<span class="keyword">uint16_t</span>)<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write to TIMx SMCR */</span></span><br><span class="line">  TIMx-&gt;SMCR = tmpsmcr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write to TIMx CCMR1 */</span></span><br><span class="line">  TIMx-&gt;CCMR1 = tmpccmr1;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write to TIMx CCER */</span></span><br><span class="line">  TIMx-&gt;CCER = tmpccer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>选择Hall Sensor</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SelectHallSensor</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST2_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_FUNCTIONAL_STATE(NewState));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (NewState != DISABLE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Set the TI1S Bit */</span></span><br><span class="line">    TIMx-&gt;CR2 |= TIM_CR2_TI1S;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Reset the TI1S Bit */</span></span><br><span class="line">    TIMx-&gt;CR2 &amp;= (<span class="keyword">uint16_t</span>)~TIM_CR2_TI1S;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定时器特殊重映射配置"><a href="#定时器特殊重映射配置" class="headerlink" title="定时器特殊重映射配置"></a>定时器特殊重映射配置</h3><p>一些定时器能够被重映射为特殊的配置端口，这里是该功能的管理库函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置定时器重映射端口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_RemapConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_Remap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST6_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_REMAP(TIM_Remap));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the Timer remapping configuration */</span></span><br><span class="line">  TIMx-&gt;OR =  TIM_Remap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置TI1、2、3、4作为输入，这里仅列出TI1的库函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TI1_Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_ICPolarity, <span class="keyword">uint16_t</span> TIM_ICSelection,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">uint16_t</span> TIM_ICFilter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmpccmr1 = <span class="number">0</span>, tmpccer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Disable the Channel 1: Reset the CC1E Bit */</span></span><br><span class="line">  TIMx-&gt;CCER &amp;= (<span class="keyword">uint16_t</span>)~TIM_CCER_CC1E;</span><br><span class="line">  tmpccmr1 = TIMx-&gt;CCMR1;</span><br><span class="line">  tmpccer = TIMx-&gt;CCER;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Select the Input and set the filter */</span></span><br><span class="line">  tmpccmr1 &amp;= ((<span class="keyword">uint16_t</span>)~TIM_CCMR1_CC1S) &amp; ((<span class="keyword">uint16_t</span>)~TIM_CCMR1_IC1F);</span><br><span class="line">  tmpccmr1 |= (<span class="keyword">uint16_t</span>)(TIM_ICSelection | (<span class="keyword">uint16_t</span>)(TIM_ICFilter &lt;&lt; (<span class="keyword">uint16_t</span>)<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Select the Polarity and set the CC1E Bit */</span></span><br><span class="line">  tmpccer &amp;= (<span class="keyword">uint16_t</span>)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);</span><br><span class="line">  tmpccer |= (<span class="keyword">uint16_t</span>)(TIM_ICPolarity | (<span class="keyword">uint16_t</span>)TIM_CCER_CC1E);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write to TIMx CCMR1 and CCER registers */</span></span><br><span class="line">  TIMx-&gt;CCMR1 = tmpccmr1;</span><br><span class="line">  TIMx-&gt;CCER = tmpccer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">stm32</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-vim操作简介" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/19/vim%E6%93%8D%E4%BD%9C%E7%AE%80%E4%BB%8B/">vim操作简介</a>
    </h1>
  

        
<!-- 显示阅读次数-->
<!--  -->
<!--显示阅读次数完毕 -->

        
        <a href="/2021/11/19/vim%E6%93%8D%E4%BD%9C%E7%AE%80%E4%BB%8B/" class="archive-article-date">
  	<time datetime="2021-11-19T08:00:32.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2021-11-19</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="vim输入模式介绍"><a href="#vim输入模式介绍" class="headerlink" title="vim输入模式介绍"></a>vim输入模式介绍</h1><p><strong>普通模式</strong>(esc)<br> 普通模式中，用户可执行一般的编辑器命令，如移动光标，删除文本等。这也是Vim启动后的默认模式。<br>普通模式命令往往需要一个操作符结尾。例如普通模式命令”dd”删除当前行，但是第一个”d”的后面可以跟另外的移动命令来代替第二个”d”，比如用移动到下一行的”j”键就可以删除当前行和下一行。另外还可以指定命令重复次数，“2dd”（重复”dd”两次），和”dj”的效果是一样的。<br> 在普通模式中，有很多方法可以进入插入模式。比较普通的方式是按<a>（append／追加）键或者<i>（insert／插入）键。</i></a></p>
<p>一般用i进入插入模式</p>
<p><strong>插入模式</strong>(i)<br> 在这个模式中，大多数按键都会向文本<strong>缓冲</strong>(buffer)中插入文本。<br> 在插入模式中，可以按<ESC>键回到普通模式。</ESC></p>
<p><strong>可视模式</strong>(v)<br>与普通模式相似。但移动命令会扩大高亮的文本区域。高亮区域可以是字符、行或者是一块文本。当执行一个非移动命令时，命令会被执行到这块高亮的区域上。</p>
<p>Vim的”文本对象”也能和移动命令一样用在这个模式中。</p>
<p>在普通模式中按<v>键进入可视模式<br>按<ctrl>+<V>进入可视块模式<br>按<shift>+<V>进入可视行模式</V></shift></V></ctrl></v></p>
<p><strong>选择模式</strong><br> 这个模式和无模式编辑器的行为比较相似（Windows标准文本控件的方式）。这个模式中，可以用鼠标或者光标键高亮选择文本，不过输入任何字符的话，Vim会用这个字符替换选择的高亮文本块，并且自动进入插入模式。</p>
<p>不常用</p>
<p><strong>命令行模式</strong><br>在普通模式使用&lt;:&gt;+[命令]进入命令行模式<br>命令行模式中可以输入会被解释成命令并执行的文本。</p>
<p>在命令执行之后，Vim返回到命令行模式之前的模式，通常是普通模式。</p>
<p><strong>Ex模式</strong><br> 这和命令行模式比较相似，在使用”:visual”命令离开Ex模式前，可以一次执行多条命令。</p>
<h3 id="【一般模式】"><a href="#【一般模式】" class="headerlink" title="【一般模式】"></a>【<strong>一般模式</strong>】</h3><h3 id="光标移动、复制粘贴、搜索替换"><a href="#光标移动、复制粘贴、搜索替换" class="headerlink" title="光标移动、复制粘贴、搜索替换"></a>光标移动、复制粘贴、搜索替换</h3><table>
<thead>
<tr>
<th>移动光标</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>h 或 向左箭头键(←)</td>
<td>光标向左移动一个字符</td>
</tr>
<tr>
<td>j 或 向下箭头键(↓)</td>
<td>光标向下移动一个字符</td>
</tr>
<tr>
<td>k 或 向上箭头键(↑)</td>
<td>光标向上移动一个字符</td>
</tr>
<tr>
<td>l 或 向右箭头键(→)</td>
<td>光标向右移动一个字符</td>
</tr>
<tr>
<td>如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。     如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键，     亦即加上想要进行的次数(数字)后，按下动作即可！</td>
<td></td>
</tr>
<tr>
<td>[Ctrl] + [f]</td>
<td>屏幕『向下』移动一页，相当于 [Page Down]按键     (常用)</td>
</tr>
<tr>
<td>[Ctrl] + [b]</td>
<td>屏幕『向上』移动一页，相当于 [Page Up] 按键     (常用)</td>
</tr>
<tr>
<td>[Ctrl] + [d]</td>
<td>屏幕『向下』移动半页</td>
</tr>
<tr>
<td>[Ctrl] + [u]</td>
<td>屏幕『向上』移动半页</td>
</tr>
<tr>
<td>+</td>
<td>光标移动到非空格符的下一行</td>
</tr>
<tr>
<td>-</td>
<td>光标移动到非空格符的上一行</td>
</tr>
<tr>
<td>n<space></space></td>
<td>那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n     个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</space></td>
</tr>
<tr>
<td>0 或功能键[Home]</td>
<td>这是数字『 0 』：移动到这一行的最前面字符处     (常用)</td>
</tr>
<tr>
<td>$ 或功能键[End]</td>
<td>移动到这一行的最后面字符处(常用)</td>
</tr>
<tr>
<td>H</td>
<td>光标移动到这个屏幕的最上方那一行的第一个字符</td>
</tr>
<tr>
<td>M</td>
<td>光标移动到这个屏幕的中央那一行的第一个字符</td>
</tr>
<tr>
<td>L</td>
<td>光标移动到这个屏幕的最下方那一行的第一个字符</td>
</tr>
<tr>
<td>G</td>
<td>移动到这个档案的最后一行(常用)</td>
</tr>
<tr>
<td>nG</td>
<td>n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20      行(可配合 :set nu)</td>
</tr>
<tr>
<td>gg</td>
<td>移动到这个档案的第一行，相当于 1G 啊！     (常用)</td>
</tr>
<tr>
<td>n<Enter></Enter></td>
<td>n 为数字。光标向下移动 n 行(常用)</td>
</tr>
<tr>
<td><strong>搜索替换</strong></td>
<td></td>
</tr>
<tr>
<td>/word</td>
<td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird      这个字符串，就输入 /vbird 即可！     (常用)</td>
</tr>
<tr>
<td>?word</td>
<td>向光标之上寻找一个字符串名称为 word 的字符串。</td>
</tr>
<tr>
<td>n</td>
<td>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说，     如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird      的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td>
</tr>
<tr>
<td>N</td>
<td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。     例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td>
</tr>
<tr>
<td>使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！</td>
<td></td>
</tr>
<tr>
<td>:n1,n2s/word1/word2/g</td>
<td>n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为     word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则：      『:100,200s/vbird/VBIRD/g』。(<em>常用</em>)</td>
</tr>
<tr>
<td>:1,$s/word1/word2/g 或 :%s/word1/word2/g</td>
<td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为     word2 ！(<em>常用</em>)</td>
</tr>
<tr>
<td>:1,$s/word1/word2/gc 或 :%s/word1/word2/gc</td>
<td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为     word2 ！且在取代前显示提示字符给用户确认 (confirm)     是否需要取代！(<em>常用</em>)</td>
</tr>
<tr>
<td><strong>删除、复制与贴上</strong></td>
<td></td>
</tr>
<tr>
<td>x, X</td>
<td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)，      X 为向前删除一个字符(相当于 [backspace] 亦即是退格键)     (常用)</td>
</tr>
<tr>
<td>nx</td>
<td>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符，     『10x』。</td>
</tr>
<tr>
<td>dd</td>
<td>删除游标所在的那一整行(<em>常用</em>)</td>
</tr>
<tr>
<td>ndd</td>
<td>n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行     (<em>常用</em>)</td>
</tr>
<tr>
<td>d1G</td>
<td>删除光标所在到第一行的所有数据</td>
</tr>
<tr>
<td>dG</td>
<td>删除光标所在到最后一行的所有数据</td>
</tr>
<tr>
<td>d$</td>
<td>删除游标所在处，到该行的最后一个字符</td>
</tr>
<tr>
<td>d0</td>
<td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td>
</tr>
<tr>
<td>yy</td>
<td>复制游标所在的那一行(常用)</td>
</tr>
<tr>
<td>nyy</td>
<td>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20     行(常用)</td>
</tr>
<tr>
<td>y1G</td>
<td>复制游标所在行到第一行的所有数据</td>
</tr>
<tr>
<td>yG</td>
<td>复制游标所在行到最后一行的所有数据</td>
</tr>
<tr>
<td>y0</td>
<td>复制光标所在的那个字符到该行行首的所有数据</td>
</tr>
<tr>
<td>y$</td>
<td>复制光标所在的那个字符到该行行尾的所有数据</td>
</tr>
<tr>
<td>p, P</td>
<td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！     举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后，     那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？     那么原本的第 20 行会被推到变成 30 行。     (常用)</td>
</tr>
<tr>
<td>J</td>
<td>将光标所在行与下一行的数据结合成同一行</td>
</tr>
<tr>
<td>c</td>
<td>重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td>
</tr>
<tr>
<td>u</td>
<td>复原前一个动作。(<em>常用</em>)</td>
</tr>
<tr>
<td>[Ctrl]+r</td>
<td>重做上一个动作。(<em>常用</em>)</td>
</tr>
<tr>
<td>.</td>
<td>重复前一个动作    (<em>常用</em>)</td>
</tr>
</tbody></table>
<h3 id="【编辑模式】"><a href="#【编辑模式】" class="headerlink" title="【编辑模式】"></a>【<strong>编辑模式</strong>】</h3><table>
<thead>
<tr>
<th>进入输入或取代的编辑模式</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>i, I</td>
<td>进入输入模式(Insert mode)：      i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。     (常用)</td>
</tr>
<tr>
<td>a, A</td>
<td>进入输入模式(Insert mode)：      a 为『从目前光标所在的下一个字符处开始输入』， A     为『从光标所在行的最后一个字符处开始输入』。(常用)</td>
</tr>
<tr>
<td>o, O</td>
<td>进入输入模式(Insert mode)：      这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』；     O 为在目前光标所在处的上一行输入新的一行！(常用)</td>
</tr>
<tr>
<td>r, R</td>
<td>进入取代模式(Replace mode)：      r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下     ESC 为止；(常用)</td>
</tr>
<tr>
<td>上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。想要在档案里面输入字符时一定要在左下角处看到 INSERT 或 REPLACE 才能输入！</td>
<td></td>
</tr>
<tr>
<td>[Esc]</td>
<td>退出编辑模式，回到一般模式中(常用)</td>
</tr>
</tbody></table>
<h3 id="【指令行模式】"><a href="#【指令行模式】" class="headerlink" title="【指令行模式】"></a>【<strong>指令行模式</strong>】</h3><table>
<thead>
<tr>
<th>指令行的储存、离开等指令</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>:w</td>
<td>将编辑的数据写入硬盘档案中(常用)</td>
</tr>
<tr>
<td>:w!</td>
<td>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入，     还是跟你对该档案的档案权限有关啊！</td>
</tr>
<tr>
<td>:q</td>
<td>离开 vi (常用)</td>
</tr>
<tr>
<td>:q!</td>
<td>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td>
</tr>
<tr>
<td>惊叹号 (!) 在 vim当中，常常具有『强制』的意思</td>
<td></td>
</tr>
<tr>
<td>:wq</td>
<td>储存后离开，若为 :wq! 则为强制储存后离开     (常用)</td>
</tr>
<tr>
<td>ZZ</td>
<td>这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于(保存并退出)</td>
</tr>
<tr>
<td>ZQ</td>
<td>不保存，强制退出。效果等同于 :q!。</td>
</tr>
<tr>
<td>:w [filename]</td>
<td>将编辑的数据储存成另一个档案（类似另存新档）</td>
</tr>
<tr>
<td>:r [filename]</td>
<td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』     这个档案内容加到游标所在行后面</td>
</tr>
<tr>
<td>:n1,n2 w [filename]</td>
<td>将 n1 到 n2 的内容储存成 filename 这个档案。</td>
</tr>
<tr>
<td>:! command</td>
<td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如      『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！</td>
</tr>
<tr>
<td><strong>vim 环境的变更</strong></td>
<td></td>
</tr>
<tr>
<td>:set nu</td>
<td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td>
</tr>
<tr>
<td>:set nonu</td>
<td>与 set nu 相反，为取消行号！</td>
</tr>
</tbody></table>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">嵌入式Linux</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2021/11/19/vim%E6%93%8D%E4%BD%9C%E7%AE%80%E4%BB%8B/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
    </nav>
  


          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2021 RedlightASl
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true,
		toc_hide_index: true,
		root: "/",
		innerArchive: true,
		showTags: false
	}
</script>

<script>!function(t){function n(e){if(r[e])return r[e].exports;var i=r[e]={exports:{},id:e,loaded:!1};return t[e].call(i.exports,i,i.exports,n),i.loaded=!0,i.exports}var r={};n.m=t,n.c=r,n.p="./",n(0)}([function(t,n,r){r(195),t.exports=r(191)},function(t,n,r){var e=r(3),i=r(52),o=r(27),u=r(28),c=r(53),f="prototype",a=function(t,n,r){var s,l,h,v,p=t&a.F,d=t&a.G,y=t&a.S,g=t&a.P,b=t&a.B,m=d?e:y?e[n]||(e[n]={}):(e[n]||{})[f],x=d?i:i[n]||(i[n]={}),w=x[f]||(x[f]={});d&&(r=n);for(s in r)l=!p&&m&&void 0!==m[s],h=(l?m:r)[s],v=b&&l?c(h,e):g&&"function"==typeof h?c(Function.call,h):h,m&&u(m,s,h,t&a.U),x[s]!=h&&o(x,s,v),g&&w[s]!=h&&(w[s]=h)};e.core=i,a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,a.U=64,a.R=128,t.exports=a},function(t,n,r){var e=r(6);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n,r){var e=r(126)("wks"),i=r(76),o=r(3).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n,r){var e=r(94),i=r(33);t.exports=function(t){return e(i(t))}},function(t,n,r){t.exports=!r(4)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(2),i=r(167),o=r(50),u=Object.defineProperty;n.f=r(10)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){t.exports=!r(18)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(14),i=r(22);t.exports=r(12)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(20),i=r(58),o=r(42),u=Object.defineProperty;n.f=r(12)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){var e=r(40)("wks"),i=r(23),o=r(5).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n,r){var e=r(67),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){var e=r(46);t.exports=function(t){return Object(e(t))}},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n,r){var e=r(63),i=r(34);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(21);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n,r){var e=r(11),i=r(66);t.exports=r(10)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(3),i=r(27),o=r(24),u=r(76)("src"),c="toString",f=Function[c],a=(""+f).split(c);r(52).inspectSource=function(t){return f.call(t)},(t.exports=function(t,n,r,c){var f="function"==typeof r;f&&(o(r,"name")||i(r,"name",n)),t[n]!==r&&(f&&(o(r,u)||i(r,u,t[n]?""+t[n]:a.join(String(n)))),t===e?t[n]=r:c?t[n]?t[n]=r:i(t,n,r):(delete t[n],i(t,n,r)))})(Function.prototype,c,function(){return"function"==typeof this&&this[u]||f.call(this)})},function(t,n,r){var e=r(1),i=r(4),o=r(46),u=function(t,n,r,e){var i=String(o(t)),u="<"+n;return""!==r&&(u+=" "+r+'="'+String(e).replace(/"/g,"&quot;")+'"'),u+">"+i+"</"+n+">"};t.exports=function(t,n){var r={};r[t]=n(u),e(e.P+e.F*i(function(){var n=""[t]('"');return n!==n.toLowerCase()||n.split('"').length>3}),"String",r)}},function(t,n,r){var e=r(115),i=r(46);t.exports=function(t){return e(i(t))}},function(t,n,r){var e=r(116),i=r(66),o=r(30),u=r(50),c=r(24),f=r(167),a=Object.getOwnPropertyDescriptor;n.f=r(10)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(24),i=r(17),o=r(145)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n){t.exports={}},function(t,n){t.exports=!0},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(14).f,i=r(8),o=r(15)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(40)("keys"),i=r(23);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(5),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n,r){var e=r(21);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(36),u=r(44),c=r(14).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){n.f=r(15)},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n,r){var e=r(4);t.exports=function(t,n){return!!t&&e(function(){n?t.call(null,function(){},1):t.call(null)})}},function(t,n,r){var e=r(53),i=r(115),o=r(17),u=r(16),c=r(203);t.exports=function(t,n){var r=1==t,f=2==t,a=3==t,s=4==t,l=6==t,h=5==t||l,v=n||c;return function(n,c,p){for(var d,y,g=o(n),b=i(g),m=e(c,p,3),x=u(b.length),w=0,S=r?v(n,x):f?v(n,0):void 0;x>w;w++)if((h||w in b)&&(d=b[w],y=m(d,w,g),t))if(r)S[w]=y;else if(y)switch(t){case 3:return!0;case 5:return d;case 6:return w;case 2:S.push(d)}else if(s)return!1;return l?-1:a||s?s:S}}},function(t,n,r){var e=r(1),i=r(52),o=r(4);t.exports=function(t,n){var r=(i.Object||{})[t]||Object[t],u={};u[t]=n(r),e(e.S+e.F*o(function(){r(1)}),"Object",u)}},function(t,n,r){var e=r(6);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(91),u=r(13),c="prototype",f=function(t,n,r){var a,s,l,h=t&f.F,v=t&f.G,p=t&f.S,d=t&f.P,y=t&f.B,g=t&f.W,b=v?i:i[n]||(i[n]={}),m=b[c],x=v?e:p?e[n]:(e[n]||{})[c];v&&(r=n);for(a in r)(s=!h&&x&&void 0!==x[a])&&a in b||(l=s?x[a]:r[a],b[a]=v&&"function"!=typeof x[a]?r[a]:y&&s?o(l,e):g&&x[a]==l?function(t){var n=function(n,r,e){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(n);case 2:return new t(n,r)}return new t(n,r,e)}return t.apply(this,arguments)};return n[c]=t[c],n}(l):d&&"function"==typeof l?o(Function.call,l):l,d&&((b.virtual||(b.virtual={}))[a]=l,t&f.R&&m&&!m[a]&&u(m,a,l)))};f.F=1,f.G=2,f.S=4,f.P=8,f.B=16,f.W=32,f.U=64,f.R=128,t.exports=f},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n,r){var e=r(26);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(183),i=r(1),o=r(126)("metadata"),u=o.store||(o.store=new(r(186))),c=function(t,n,r){var i=u.get(t);if(!i){if(!r)return;u.set(t,i=new e)}var o=i.get(n);if(!o){if(!r)return;i.set(n,o=new e)}return o},f=function(t,n,r){var e=c(n,r,!1);return void 0!==e&&e.has(t)},a=function(t,n,r){var e=c(n,r,!1);return void 0===e?void 0:e.get(t)},s=function(t,n,r,e){c(r,e,!0).set(t,n)},l=function(t,n){var r=c(t,n,!1),e=[];return r&&r.forEach(function(t,n){e.push(n)}),e},h=function(t){return void 0===t||"symbol"==typeof t?t:String(t)},v=function(t){i(i.S,"Reflect",t)};t.exports={store:u,map:c,has:f,get:a,set:s,keys:l,key:h,exp:v}},function(t,n,r){"use strict";if(r(10)){var e=r(69),i=r(3),o=r(4),u=r(1),c=r(127),f=r(152),a=r(53),s=r(68),l=r(66),h=r(27),v=r(73),p=r(67),d=r(16),y=r(75),g=r(50),b=r(24),m=r(180),x=r(114),w=r(6),S=r(17),_=r(137),O=r(70),E=r(32),P=r(71).f,j=r(154),F=r(76),M=r(7),A=r(48),N=r(117),T=r(146),I=r(155),k=r(80),L=r(123),R=r(74),C=r(130),D=r(160),U=r(11),W=r(31),G=U.f,B=W.f,V=i.RangeError,z=i.TypeError,q=i.Uint8Array,K="ArrayBuffer",J="Shared"+K,Y="BYTES_PER_ELEMENT",H="prototype",$=Array[H],X=f.ArrayBuffer,Q=f.DataView,Z=A(0),tt=A(2),nt=A(3),rt=A(4),et=A(5),it=A(6),ot=N(!0),ut=N(!1),ct=I.values,ft=I.keys,at=I.entries,st=$.lastIndexOf,lt=$.reduce,ht=$.reduceRight,vt=$.join,pt=$.sort,dt=$.slice,yt=$.toString,gt=$.toLocaleString,bt=M("iterator"),mt=M("toStringTag"),xt=F("typed_constructor"),wt=F("def_constructor"),St=c.CONSTR,_t=c.TYPED,Ot=c.VIEW,Et="Wrong length!",Pt=A(1,function(t,n){return Tt(T(t,t[wt]),n)}),jt=o(function(){return 1===new q(new Uint16Array([1]).buffer)[0]}),Ft=!!q&&!!q[H].set&&o(function(){new q(1).set({})}),Mt=function(t,n){if(void 0===t)throw z(Et);var r=+t,e=d(t);if(n&&!m(r,e))throw V(Et);return e},At=function(t,n){var r=p(t);if(r<0||r%n)throw V("Wrong offset!");return r},Nt=function(t){if(w(t)&&_t in t)return t;throw z(t+" is not a typed array!")},Tt=function(t,n){if(!(w(t)&&xt in t))throw z("It is not a typed array constructor!");return new t(n)},It=function(t,n){return kt(T(t,t[wt]),n)},kt=function(t,n){for(var r=0,e=n.length,i=Tt(t,e);e>r;)i[r]=n[r++];return i},Lt=function(t,n,r){G(t,n,{get:function(){return this._d[r]}})},Rt=function(t){var n,r,e,i,o,u,c=S(t),f=arguments.length,s=f>1?arguments[1]:void 0,l=void 0!==s,h=j(c);if(void 0!=h&&!_(h)){for(u=h.call(c),e=[],n=0;!(o=u.next()).done;n++)e.push(o.value);c=e}for(l&&f>2&&(s=a(s,arguments[2],2)),n=0,r=d(c.length),i=Tt(this,r);r>n;n++)i[n]=l?s(c[n],n):c[n];return i},Ct=function(){for(var t=0,n=arguments.length,r=Tt(this,n);n>t;)r[t]=arguments[t++];return r},Dt=!!q&&o(function(){gt.call(new q(1))}),Ut=function(){return gt.apply(Dt?dt.call(Nt(this)):Nt(this),arguments)},Wt={copyWithin:function(t,n){return D.call(Nt(this),t,n,arguments.length>2?arguments[2]:void 0)},every:function(t){return rt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},fill:function(t){return C.apply(Nt(this),arguments)},filter:function(t){return It(this,tt(Nt(this),t,arguments.length>1?arguments[1]:void 0))},find:function(t){return et(Nt(this),t,arguments.length>1?arguments[1]:void 0)},findIndex:function(t){return it(Nt(this),t,arguments.length>1?arguments[1]:void 0)},forEach:function(t){Z(Nt(this),t,arguments.length>1?arguments[1]:void 0)},indexOf:function(t){return ut(Nt(this),t,arguments.length>1?arguments[1]:void 0)},includes:function(t){return ot(Nt(this),t,arguments.length>1?arguments[1]:void 0)},join:function(t){return vt.apply(Nt(this),arguments)},lastIndexOf:function(t){return st.apply(Nt(this),arguments)},map:function(t){return Pt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},reduce:function(t){return lt.apply(Nt(this),arguments)},reduceRight:function(t){return ht.apply(Nt(this),arguments)},reverse:function(){for(var t,n=this,r=Nt(n).length,e=Math.floor(r/2),i=0;i<e;)t=n[i],n[i++]=n[--r],n[r]=t;return n},some:function(t){return nt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},sort:function(t){return pt.call(Nt(this),t)},subarray:function(t,n){var r=Nt(this),e=r.length,i=y(t,e);return new(T(r,r[wt]))(r.buffer,r.byteOffset+i*r.BYTES_PER_ELEMENT,d((void 0===n?e:y(n,e))-i))}},Gt=function(t,n){return It(this,dt.call(Nt(this),t,n))},Bt=function(t){Nt(this);var n=At(arguments[1],1),r=this.length,e=S(t),i=d(e.length),o=0;if(i+n>r)throw V(Et);for(;o<i;)this[n+o]=e[o++]},Vt={entries:function(){return at.call(Nt(this))},keys:function(){return ft.call(Nt(this))},values:function(){return ct.call(Nt(this))}},zt=function(t,n){return w(t)&&t[_t]&&"symbol"!=typeof n&&n in t&&String(+n)==String(n)},qt=function(t,n){return zt(t,n=g(n,!0))?l(2,t[n]):B(t,n)},Kt=function(t,n,r){return!(zt(t,n=g(n,!0))&&w(r)&&b(r,"value"))||b(r,"get")||b(r,"set")||r.configurable||b(r,"writable")&&!r.writable||b(r,"enumerable")&&!r.enumerable?G(t,n,r):(t[n]=r.value,t)};St||(W.f=qt,U.f=Kt),u(u.S+u.F*!St,"Object",{getOwnPropertyDescriptor:qt,defineProperty:Kt}),o(function(){yt.call({})})&&(yt=gt=function(){return vt.call(this)});var Jt=v({},Wt);v(Jt,Vt),h(Jt,bt,Vt.values),v(Jt,{slice:Gt,set:Bt,constructor:function(){},toString:yt,toLocaleString:Ut}),Lt(Jt,"buffer","b"),Lt(Jt,"byteOffset","o"),Lt(Jt,"byteLength","l"),Lt(Jt,"length","e"),G(Jt,mt,{get:function(){return this[_t]}}),t.exports=function(t,n,r,f){f=!!f;var a=t+(f?"Clamped":"")+"Array",l="Uint8Array"!=a,v="get"+t,p="set"+t,y=i[a],g=y||{},b=y&&E(y),m=!y||!c.ABV,S={},_=y&&y[H],j=function(t,r){var e=t._d;return e.v[v](r*n+e.o,jt)},F=function(t,r,e){var i=t._d;f&&(e=(e=Math.round(e))<0?0:e>255?255:255&e),i.v[p](r*n+i.o,e,jt)},M=function(t,n){G(t,n,{get:function(){return j(this,n)},set:function(t){return F(this,n,t)},enumerable:!0})};m?(y=r(function(t,r,e,i){s(t,y,a,"_d");var o,u,c,f,l=0,v=0;if(w(r)){if(!(r instanceof X||(f=x(r))==K||f==J))return _t in r?kt(y,r):Rt.call(y,r);o=r,v=At(e,n);var p=r.byteLength;if(void 0===i){if(p%n)throw V(Et);if((u=p-v)<0)throw V(Et)}else if((u=d(i)*n)+v>p)throw V(Et);c=u/n}else c=Mt(r,!0),u=c*n,o=new X(u);for(h(t,"_d",{b:o,o:v,l:u,e:c,v:new Q(o)});l<c;)M(t,l++)}),_=y[H]=O(Jt),h(_,"constructor",y)):L(function(t){new y(null),new y(t)},!0)||(y=r(function(t,r,e,i){s(t,y,a);var o;return w(r)?r instanceof X||(o=x(r))==K||o==J?void 0!==i?new g(r,At(e,n),i):void 0!==e?new g(r,At(e,n)):new g(r):_t in r?kt(y,r):Rt.call(y,r):new g(Mt(r,l))}),Z(b!==Function.prototype?P(g).concat(P(b)):P(g),function(t){t in y||h(y,t,g[t])}),y[H]=_,e||(_.constructor=y));var A=_[bt],N=!!A&&("values"==A.name||void 0==A.name),T=Vt.values;h(y,xt,!0),h(_,_t,a),h(_,Ot,!0),h(_,wt,y),(f?new y(1)[mt]==a:mt in _)||G(_,mt,{get:function(){return a}}),S[a]=y,u(u.G+u.W+u.F*(y!=g),S),u(u.S,a,{BYTES_PER_ELEMENT:n,from:Rt,of:Ct}),Y in _||h(_,Y,n),u(u.P,a,Wt),R(a),u(u.P+u.F*Ft,a,{set:Bt}),u(u.P+u.F*!N,a,Vt),u(u.P+u.F*(_.toString!=yt),a,{toString:yt}),u(u.P+u.F*o(function(){new y(1).slice()}),a,{slice:Gt}),u(u.P+u.F*(o(function(){return[1,2].toLocaleString()!=new y([1,2]).toLocaleString()})||!o(function(){_.toLocaleString.call([1,2])})),a,{toLocaleString:Ut}),k[a]=N?A:T,e||N||h(_,bt,T)}}else t.exports=function(){}},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n,r){var e=r(21),i=r(5).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n,r){t.exports=!r(12)&&!r(18)(function(){return 7!=Object.defineProperty(r(57)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){"use strict";var e=r(36),i=r(51),o=r(64),u=r(13),c=r(8),f=r(35),a=r(96),s=r(38),l=r(103),h=r(15)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n,r){var e=r(20),i=r(100),o=r(34),u=r(39)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(57)("iframe"),e=o.length;for(n.style.display="none",r(93).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(63),i=r(34).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(8),i=r(9),o=r(90)(!1),u=r(39)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){t.exports=r(13)},function(t,n,r){var e=r(76)("meta"),i=r(6),o=r(24),u=r(11).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(4)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n){t.exports=function(t,n,r,e){if(!(t instanceof n)||void 0!==e&&e in t)throw TypeError(r+": incorrect invocation!");return t}},function(t,n){t.exports=!1},function(t,n,r){var e=r(2),i=r(173),o=r(133),u=r(145)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(132)("iframe"),e=o.length;for(n.style.display="none",r(135).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(175),i=r(133).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n,r){var e=r(175),i=r(133);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(28);t.exports=function(t,n,r){for(var i in n)e(t,i,n[i],r);return t}},function(t,n,r){"use strict";var e=r(3),i=r(11),o=r(10),u=r(7)("species");t.exports=function(t){var n=e[t];o&&n&&!n[u]&&i.f(n,u,{configurable:!0,get:function(){return this}})}},function(t,n,r){var e=r(67),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n,r){var e=r(33);t.exports=function(t){return Object(e(t))}},function(t,n,r){var e=r(7)("unscopables"),i=Array.prototype;void 0==i[e]&&r(27)(i,e,{}),t.exports=function(t){i[e][t]=!0}},function(t,n,r){var e=r(53),i=r(169),o=r(137),u=r(2),c=r(16),f=r(154),a={},s={},n=t.exports=function(t,n,r,l,h){var v,p,d,y,g=h?function(){return t}:f(t),b=e(r,l,n?2:1),m=0;if("function"!=typeof g)throw TypeError(t+" is not iterable!");if(o(g)){for(v=c(t.length);v>m;m++)if((y=n?b(u(p=t[m])[0],p[1]):b(t[m]))===a||y===s)return y}else for(d=g.call(t);!(p=d.next()).done;)if((y=i(d,b,p.value,n))===a||y===s)return y};n.BREAK=a,n.RETURN=s},function(t,n){t.exports={}},function(t,n,r){var e=r(11).f,i=r(24),o=r(7)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(1),i=r(46),o=r(4),u=r(150),c="["+u+"]",f="​",a=RegExp("^"+c+c+"*"),s=RegExp(c+c+"*$"),l=function(t,n,r){var i={},c=o(function(){return!!u[t]()||f[t]()!=f}),a=i[t]=c?n(h):u[t];r&&(i[r]=a),e(e.P+e.F*c,"String",i)},h=l.trim=function(t,n){return t=String(i(t)),1&n&&(t=t.replace(a,"")),2&n&&(t=t.replace(s,"")),t};t.exports=l},function(t,n,r){t.exports={default:r(86),__esModule:!0}},function(t,n,r){t.exports={default:r(87),__esModule:!0}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}n.__esModule=!0;var i=r(84),o=e(i),u=r(83),c=e(u),f="function"==typeof c.default&&"symbol"==typeof o.default?function(t){return typeof t}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":typeof t};n.default="function"==typeof c.default&&"symbol"===f(o.default)?function(t){return void 0===t?"undefined":f(t)}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":void 0===t?"undefined":f(t)}},function(t,n,r){r(110),r(108),r(111),r(112),t.exports=r(25).Symbol},function(t,n,r){r(109),r(113),t.exports=r(44).f("iterator")},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n){t.exports=function(){}},function(t,n,r){var e=r(9),i=r(106),o=r(105);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){var e=r(88);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(19),i=r(62),o=r(37);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){t.exports=r(5).document&&document.documentElement},function(t,n,r){var e=r(56);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n,r){var e=r(56);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(60),i=r(22),o=r(38),u={};r(13)(u,r(15)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,r){var e=r(19),i=r(9);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){var e=r(23)("meta"),i=r(21),o=r(8),u=r(14).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(18)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n,r){var e=r(14),i=r(20),o=r(19);t.exports=r(12)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(37),i=r(22),o=r(9),u=r(42),c=r(8),f=r(58),a=Object.getOwnPropertyDescriptor;n.f=r(12)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(9),i=r(61).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(8),i=r(77),o=r(39)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,r){var e=r(41),i=r(33);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(41),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n,r){var e=r(41),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){"use strict";var e=r(89),i=r(97),o=r(35),u=r(9);t.exports=r(59)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){},function(t,n,r){"use strict";var e=r(104)(!0);r(59)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";var e=r(5),i=r(8),o=r(12),u=r(51),c=r(64),f=r(99).KEY,a=r(18),s=r(40),l=r(38),h=r(23),v=r(15),p=r(44),d=r(43),y=r(98),g=r(92),b=r(95),m=r(20),x=r(9),w=r(42),S=r(22),_=r(60),O=r(102),E=r(101),P=r(14),j=r(19),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(61).f=O.f=Z,r(37).f=X,r(62).f=tt,o&&!r(36)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(13)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){r(43)("asyncIterator")},function(t,n,r){r(43)("observable")},function(t,n,r){r(107);for(var e=r(5),i=r(13),o=r(35),u=r(15)("toStringTag"),c=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],f=0;f<5;f++){var a=c[f],s=e[a],l=s&&s.prototype;l&&!l[u]&&i(l,u,a),o[a]=o.Array}},function(t,n,r){var e=r(45),i=r(7)("toStringTag"),o="Arguments"==e(function(){return arguments}()),u=function(t,n){try{return t[n]}catch(t){}};t.exports=function(t){var n,r,c;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=u(n=Object(t),i))?r:o?e(n):"Object"==(c=e(n))&&"function"==typeof n.callee?"Arguments":c}},function(t,n,r){var e=r(45);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(30),i=r(16),o=r(75);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){"use strict";var e=r(3),i=r(1),o=r(28),u=r(73),c=r(65),f=r(79),a=r(68),s=r(6),l=r(4),h=r(123),v=r(81),p=r(136);t.exports=function(t,n,r,d,y,g){var b=e[t],m=b,x=y?"set":"add",w=m&&m.prototype,S={},_=function(t){var n=w[t];o(w,t,"delete"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"has"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"get"==t?function(t){return g&&!s(t)?void 0:n.call(this,0===t?0:t)}:"add"==t?function(t){return n.call(this,0===t?0:t),this}:function(t,r){return n.call(this,0===t?0:t,r),this})};if("function"==typeof m&&(g||w.forEach&&!l(function(){(new m).entries().next()}))){var O=new m,E=O[x](g?{}:-0,1)!=O,P=l(function(){O.has(1)}),j=h(function(t){new m(t)}),F=!g&&l(function(){for(var t=new m,n=5;n--;)t[x](n,n);return!t.has(-0)});j||(m=n(function(n,r){a(n,m,t);var e=p(new b,n,m);return void 0!=r&&f(r,y,e[x],e),e}),m.prototype=w,w.constructor=m),(P||F)&&(_("delete"),_("has"),y&&_("get")),(F||E)&&_(x),g&&w.clear&&delete w.clear}else m=d.getConstructor(n,t,y,x),u(m.prototype,r),c.NEED=!0;return v(m,t),S[t]=m,i(i.G+i.W+i.F*(m!=b),S),g||d.setStrong(m,t,y),m}},function(t,n,r){"use strict";var e=r(27),i=r(28),o=r(4),u=r(46),c=r(7);t.exports=function(t,n,r){var f=c(t),a=r(u,f,""[t]),s=a[0],l=a[1];o(function(){var n={};return n[f]=function(){return 7},7!=""[t](n)})&&(i(String.prototype,t,s),e(RegExp.prototype,f,2==n?function(t,n){return l.call(t,this,n)}:function(t){return l.call(t,this)}))}
},function(t,n,r){"use strict";var e=r(2);t.exports=function(){var t=e(this),n="";return t.global&&(n+="g"),t.ignoreCase&&(n+="i"),t.multiline&&(n+="m"),t.unicode&&(n+="u"),t.sticky&&(n+="y"),n}},function(t,n){t.exports=function(t,n,r){var e=void 0===r;switch(n.length){case 0:return e?t():t.call(r);case 1:return e?t(n[0]):t.call(r,n[0]);case 2:return e?t(n[0],n[1]):t.call(r,n[0],n[1]);case 3:return e?t(n[0],n[1],n[2]):t.call(r,n[0],n[1],n[2]);case 4:return e?t(n[0],n[1],n[2],n[3]):t.call(r,n[0],n[1],n[2],n[3])}return t.apply(r,n)}},function(t,n,r){var e=r(6),i=r(45),o=r(7)("match");t.exports=function(t){var n;return e(t)&&(void 0!==(n=t[o])?!!n:"RegExp"==i(t))}},function(t,n,r){var e=r(7)("iterator"),i=!1;try{var o=[7][e]();o.return=function(){i=!0},Array.from(o,function(){throw 2})}catch(t){}t.exports=function(t,n){if(!n&&!i)return!1;var r=!1;try{var o=[7],u=o[e]();u.next=function(){return{done:r=!0}},o[e]=function(){return u},t(o)}catch(t){}return r}},function(t,n,r){t.exports=r(69)||!r(4)(function(){var t=Math.random();__defineSetter__.call(null,t,function(){}),delete r(3)[t]})},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(3),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n,r){for(var e,i=r(3),o=r(27),u=r(76),c=u("typed_array"),f=u("view"),a=!(!i.ArrayBuffer||!i.DataView),s=a,l=0,h="Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(",");l<9;)(e=i[h[l++]])?(o(e.prototype,c,!0),o(e.prototype,f,!0)):s=!1;t.exports={ABV:a,CONSTR:s,TYPED:c,VIEW:f}},function(t,n){"use strict";var r={versions:function(){var t=window.navigator.userAgent;return{trident:t.indexOf("Trident")>-1,presto:t.indexOf("Presto")>-1,webKit:t.indexOf("AppleWebKit")>-1,gecko:t.indexOf("Gecko")>-1&&-1==t.indexOf("KHTML"),mobile:!!t.match(/AppleWebKit.*Mobile.*/),ios:!!t.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:t.indexOf("Android")>-1||t.indexOf("Linux")>-1,iPhone:t.indexOf("iPhone")>-1||t.indexOf("Mac")>-1,iPad:t.indexOf("iPad")>-1,webApp:-1==t.indexOf("Safari"),weixin:-1==t.indexOf("MicroMessenger")}}()};t.exports=r},function(t,n,r){"use strict";var e=r(85),i=function(t){return t&&t.__esModule?t:{default:t}}(e),o=function(){function t(t,n,e){return n||e?String.fromCharCode(n||e):r[t]||t}function n(t){return e[t]}var r={"&quot;":'"',"&lt;":"<","&gt;":">","&amp;":"&","&nbsp;":" "},e={};for(var u in r)e[r[u]]=u;return r["&apos;"]="'",e["'"]="&#39;",{encode:function(t){return t?(""+t).replace(/['<> "&]/g,n).replace(/\r?\n/g,"<br/>").replace(/\s/g,"&nbsp;"):""},decode:function(n){return n?(""+n).replace(/<br\s*\/?>/gi,"\n").replace(/&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,t).replace(/\u00a0/g," "):""},encodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},encodeBase16forJSON:function(t){if(!t)return t;t=t.replace(/[\u4E00-\u9FBF]/gi,function(t){return escape(t).replace("%u","\\u")});for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},decodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r+=2)n.push(String.fromCharCode("0x"+t.slice(r,r+2)));return n.join("")},encodeObject:function(t){if(t instanceof Array)for(var n=0,r=t.length;r>n;n++)t[n]=o.encodeObject(t[n]);else if("object"==(void 0===t?"undefined":(0,i.default)(t)))for(var e in t)t[e]=o.encodeObject(t[e]);else if("string"==typeof t)return o.encode(t);return t},loadScript:function(t){var n=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(n),n.setAttribute("src",t)},addLoadEvent:function(t){var n=window.onload;"function"!=typeof window.onload?window.onload=t:window.onload=function(){n(),t()}}}}();t.exports=o},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=function(t){for(var n=e(this),r=o(n.length),u=arguments.length,c=i(u>1?arguments[1]:void 0,r),f=u>2?arguments[2]:void 0,a=void 0===f?r:i(f,r);a>c;)n[c++]=t;return n}},function(t,n,r){"use strict";var e=r(11),i=r(66);t.exports=function(t,n,r){n in t?e.f(t,n,i(0,r)):t[n]=r}},function(t,n,r){var e=r(6),i=r(3).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n,r){var e=r(7)("match");t.exports=function(t){var n=/./;try{"/./"[t](n)}catch(r){try{return n[e]=!1,!"/./"[t](n)}catch(t){}}return!0}},function(t,n,r){t.exports=r(3).document&&document.documentElement},function(t,n,r){var e=r(6),i=r(144).set;t.exports=function(t,n,r){var o,u=n.constructor;return u!==r&&"function"==typeof u&&(o=u.prototype)!==r.prototype&&e(o)&&i&&i(t,o),t}},function(t,n,r){var e=r(80),i=r(7)("iterator"),o=Array.prototype;t.exports=function(t){return void 0!==t&&(e.Array===t||o[i]===t)}},function(t,n,r){var e=r(45);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(70),i=r(66),o=r(81),u={};r(27)(u,r(7)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n,r){"use strict";var e=r(69),i=r(1),o=r(28),u=r(27),c=r(24),f=r(80),a=r(139),s=r(81),l=r(32),h=r(7)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n){var r=Math.expm1;t.exports=!r||r(10)>22025.465794806718||r(10)<22025.465794806718||-2e-17!=r(-2e-17)?function(t){return 0==(t=+t)?t:t>-1e-6&&t<1e-6?t+t*t/2:Math.exp(t)-1}:r},function(t,n){t.exports=Math.sign||function(t){return 0==(t=+t)||t!=t?t:t<0?-1:1}},function(t,n,r){var e=r(3),i=r(151).set,o=e.MutationObserver||e.WebKitMutationObserver,u=e.process,c=e.Promise,f="process"==r(45)(u);t.exports=function(){var t,n,r,a=function(){var e,i;for(f&&(e=u.domain)&&e.exit();t;){i=t.fn,t=t.next;try{i()}catch(e){throw t?r():n=void 0,e}}n=void 0,e&&e.enter()};if(f)r=function(){u.nextTick(a)};else if(o){var s=!0,l=document.createTextNode("");new o(a).observe(l,{characterData:!0}),r=function(){l.data=s=!s}}else if(c&&c.resolve){var h=c.resolve();r=function(){h.then(a)}}else r=function(){i.call(e,a)};return function(e){var i={fn:e,next:void 0};n&&(n.next=i),t||(t=i,r()),n=i}}},function(t,n,r){var e=r(6),i=r(2),o=function(t,n){if(i(t),!e(n)&&null!==n)throw TypeError(n+": can't set as prototype!")};t.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(t,n,e){try{e=r(53)(Function.call,r(31).f(Object.prototype,"__proto__").set,2),e(t,[]),n=!(t instanceof Array)}catch(t){n=!0}return function(t,r){return o(t,r),n?t.__proto__=r:e(t,r),t}}({},!1):void 0),check:o}},function(t,n,r){var e=r(126)("keys"),i=r(76);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(2),i=r(26),o=r(7)("species");t.exports=function(t,n){var r,u=e(t).constructor;return void 0===u||void 0==(r=e(u)[o])?n:i(r)}},function(t,n,r){var e=r(67),i=r(46);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(122),i=r(46);t.exports=function(t,n,r){if(e(n))throw TypeError("String#"+r+" doesn't accept regex!");return String(i(t))}},function(t,n,r){"use strict";var e=r(67),i=r(46);t.exports=function(t){var n=String(i(this)),r="",o=e(t);if(o<0||o==1/0)throw RangeError("Count can't be negative");for(;o>0;(o>>>=1)&&(n+=n))1&o&&(r+=n);return r}},function(t,n){t.exports="\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"},function(t,n,r){var e,i,o,u=r(53),c=r(121),f=r(135),a=r(132),s=r(3),l=s.process,h=s.setImmediate,v=s.clearImmediate,p=s.MessageChannel,d=0,y={},g="onreadystatechange",b=function(){var t=+this;if(y.hasOwnProperty(t)){var n=y[t];delete y[t],n()}},m=function(t){b.call(t.data)};h&&v||(h=function(t){for(var n=[],r=1;arguments.length>r;)n.push(arguments[r++]);return y[++d]=function(){c("function"==typeof t?t:Function(t),n)},e(d),d},v=function(t){delete y[t]},"process"==r(45)(l)?e=function(t){l.nextTick(u(b,t,1))}:p?(i=new p,o=i.port2,i.port1.onmessage=m,e=u(o.postMessage,o,1)):s.addEventListener&&"function"==typeof postMessage&&!s.importScripts?(e=function(t){s.postMessage(t+"","*")},s.addEventListener("message",m,!1)):e=g in a("script")?function(t){f.appendChild(a("script"))[g]=function(){f.removeChild(this),b.call(t)}}:function(t){setTimeout(u(b,t,1),0)}),t.exports={set:h,clear:v}},function(t,n,r){"use strict";var e=r(3),i=r(10),o=r(69),u=r(127),c=r(27),f=r(73),a=r(4),s=r(68),l=r(67),h=r(16),v=r(71).f,p=r(11).f,d=r(130),y=r(81),g="ArrayBuffer",b="DataView",m="prototype",x="Wrong length!",w="Wrong index!",S=e[g],_=e[b],O=e.Math,E=e.RangeError,P=e.Infinity,j=S,F=O.abs,M=O.pow,A=O.floor,N=O.log,T=O.LN2,I="buffer",k="byteLength",L="byteOffset",R=i?"_b":I,C=i?"_l":k,D=i?"_o":L,U=function(t,n,r){var e,i,o,u=Array(r),c=8*r-n-1,f=(1<<c)-1,a=f>>1,s=23===n?M(2,-24)-M(2,-77):0,l=0,h=t<0||0===t&&1/t<0?1:0;for(t=F(t),t!=t||t===P?(i=t!=t?1:0,e=f):(e=A(N(t)/T),t*(o=M(2,-e))<1&&(e--,o*=2),t+=e+a>=1?s/o:s*M(2,1-a),t*o>=2&&(e++,o/=2),e+a>=f?(i=0,e=f):e+a>=1?(i=(t*o-1)*M(2,n),e+=a):(i=t*M(2,a-1)*M(2,n),e=0));n>=8;u[l++]=255&i,i/=256,n-=8);for(e=e<<n|i,c+=n;c>0;u[l++]=255&e,e/=256,c-=8);return u[--l]|=128*h,u},W=function(t,n,r){var e,i=8*r-n-1,o=(1<<i)-1,u=o>>1,c=i-7,f=r-1,a=t[f--],s=127&a;for(a>>=7;c>0;s=256*s+t[f],f--,c-=8);for(e=s&(1<<-c)-1,s>>=-c,c+=n;c>0;e=256*e+t[f],f--,c-=8);if(0===s)s=1-u;else{if(s===o)return e?NaN:a?-P:P;e+=M(2,n),s-=u}return(a?-1:1)*e*M(2,s-n)},G=function(t){return t[3]<<24|t[2]<<16|t[1]<<8|t[0]},B=function(t){return[255&t]},V=function(t){return[255&t,t>>8&255]},z=function(t){return[255&t,t>>8&255,t>>16&255,t>>24&255]},q=function(t){return U(t,52,8)},K=function(t){return U(t,23,4)},J=function(t,n,r){p(t[m],n,{get:function(){return this[r]}})},Y=function(t,n,r,e){var i=+r,o=l(i);if(i!=o||o<0||o+n>t[C])throw E(w);var u=t[R]._b,c=o+t[D],f=u.slice(c,c+n);return e?f:f.reverse()},H=function(t,n,r,e,i,o){var u=+r,c=l(u);if(u!=c||c<0||c+n>t[C])throw E(w);for(var f=t[R]._b,a=c+t[D],s=e(+i),h=0;h<n;h++)f[a+h]=s[o?h:n-h-1]},$=function(t,n){s(t,S,g);var r=+n,e=h(r);if(r!=e)throw E(x);return e};if(u.ABV){if(!a(function(){new S})||!a(function(){new S(.5)})){S=function(t){return new j($(this,t))};for(var X,Q=S[m]=j[m],Z=v(j),tt=0;Z.length>tt;)(X=Z[tt++])in S||c(S,X,j[X]);o||(Q.constructor=S)}var nt=new _(new S(2)),rt=_[m].setInt8;nt.setInt8(0,2147483648),nt.setInt8(1,2147483649),!nt.getInt8(0)&&nt.getInt8(1)||f(_[m],{setInt8:function(t,n){rt.call(this,t,n<<24>>24)},setUint8:function(t,n){rt.call(this,t,n<<24>>24)}},!0)}else S=function(t){var n=$(this,t);this._b=d.call(Array(n),0),this[C]=n},_=function(t,n,r){s(this,_,b),s(t,S,b);var e=t[C],i=l(n);if(i<0||i>e)throw E("Wrong offset!");if(r=void 0===r?e-i:h(r),i+r>e)throw E(x);this[R]=t,this[D]=i,this[C]=r},i&&(J(S,k,"_l"),J(_,I,"_b"),J(_,k,"_l"),J(_,L,"_o")),f(_[m],{getInt8:function(t){return Y(this,1,t)[0]<<24>>24},getUint8:function(t){return Y(this,1,t)[0]},getInt16:function(t){var n=Y(this,2,t,arguments[1]);return(n[1]<<8|n[0])<<16>>16},getUint16:function(t){var n=Y(this,2,t,arguments[1]);return n[1]<<8|n[0]},getInt32:function(t){return G(Y(this,4,t,arguments[1]))},getUint32:function(t){return G(Y(this,4,t,arguments[1]))>>>0},getFloat32:function(t){return W(Y(this,4,t,arguments[1]),23,4)},getFloat64:function(t){return W(Y(this,8,t,arguments[1]),52,8)},setInt8:function(t,n){H(this,1,t,B,n)},setUint8:function(t,n){H(this,1,t,B,n)},setInt16:function(t,n){H(this,2,t,V,n,arguments[2])},setUint16:function(t,n){H(this,2,t,V,n,arguments[2])},setInt32:function(t,n){H(this,4,t,z,n,arguments[2])},setUint32:function(t,n){H(this,4,t,z,n,arguments[2])},setFloat32:function(t,n){H(this,4,t,K,n,arguments[2])},setFloat64:function(t,n){H(this,8,t,q,n,arguments[2])}});y(S,g),y(_,b),c(_[m],u.VIEW,!0),n[g]=S,n[b]=_},function(t,n,r){var e=r(3),i=r(52),o=r(69),u=r(182),c=r(11).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){var e=r(114),i=r(7)("iterator"),o=r(80);t.exports=r(52).getIteratorMethod=function(t){if(void 0!=t)return t[i]||t["@@iterator"]||o[e(t)]}},function(t,n,r){"use strict";var e=r(78),i=r(170),o=r(80),u=r(30);t.exports=r(140)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){function r(t,n){t.classList?t.classList.add(n):t.className+=" "+n}t.exports=r},function(t,n){function r(t,n){if(t.classList)t.classList.remove(n);else{var r=new RegExp("(^|\\b)"+n.split(" ").join("|")+"(\\b|$)","gi");t.className=t.className.replace(r," ")}}t.exports=r},function(t,n){function r(){throw new Error("setTimeout has not been defined")}function e(){throw new Error("clearTimeout has not been defined")}function i(t){if(s===setTimeout)return setTimeout(t,0);if((s===r||!s)&&setTimeout)return s=setTimeout,setTimeout(t,0);try{return s(t,0)}catch(n){try{return s.call(null,t,0)}catch(n){return s.call(this,t,0)}}}function o(t){if(l===clearTimeout)return clearTimeout(t);if((l===e||!l)&&clearTimeout)return l=clearTimeout,clearTimeout(t);try{return l(t)}catch(n){try{return l.call(null,t)}catch(n){return l.call(this,t)}}}function u(){d&&v&&(d=!1,v.length?p=v.concat(p):y=-1,p.length&&c())}function c(){if(!d){var t=i(u);d=!0;for(var n=p.length;n;){for(v=p,p=[];++y<n;)v&&v[y].run();y=-1,n=p.length}v=null,d=!1,o(t)}}function f(t,n){this.fun=t,this.array=n}function a(){}var s,l,h=t.exports={};!function(){try{s="function"==typeof setTimeout?setTimeout:r}catch(t){s=r}try{l="function"==typeof clearTimeout?clearTimeout:e}catch(t){l=e}}();var v,p=[],d=!1,y=-1;h.nextTick=function(t){var n=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)n[r-1]=arguments[r];p.push(new f(t,n)),1!==p.length||d||i(c)},f.prototype.run=function(){this.fun.apply(null,this.array)},h.title="browser",h.browser=!0,h.env={},h.argv=[],h.version="",h.versions={},h.on=a,h.addListener=a,h.once=a,h.off=a,h.removeListener=a,h.removeAllListeners=a,h.emit=a,h.prependListener=a,h.prependOnceListener=a,h.listeners=function(t){return[]},h.binding=function(t){throw new Error("process.binding is not supported")},h.cwd=function(){return"/"},h.chdir=function(t){throw new Error("process.chdir is not supported")},h.umask=function(){return 0}},function(t,n,r){var e=r(45);t.exports=function(t,n){if("number"!=typeof t&&"Number"!=e(t))throw TypeError(n);return+t}},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=[].copyWithin||function(t,n){var r=e(this),u=o(r.length),c=i(t,u),f=i(n,u),a=arguments.length>2?arguments[2]:void 0,s=Math.min((void 0===a?u:i(a,u))-f,u-c),l=1;for(f<c&&c<f+s&&(l=-1,f+=s-1,c+=s-1);s-- >0;)f in r?r[c]=r[f]:delete r[c],c+=l,f+=l;return r}},function(t,n,r){var e=r(79);t.exports=function(t,n){var r=[];return e(t,!1,r.push,r,n),r}},function(t,n,r){var e=r(26),i=r(17),o=r(115),u=r(16);t.exports=function(t,n,r,c,f){e(n);var a=i(t),s=o(a),l=u(a.length),h=f?l-1:0,v=f?-1:1;if(r<2)for(;;){if(h in s){c=s[h],h+=v;break}if(h+=v,f?h<0:l<=h)throw TypeError("Reduce of empty array with no initial value")}for(;f?h>=0:l>h;h+=v)h in s&&(c=n(c,s[h],h,a));return c}},function(t,n,r){"use strict";var e=r(26),i=r(6),o=r(121),u=[].slice,c={},f=function(t,n,r){if(!(n in c)){for(var e=[],i=0;i<n;i++)e[i]="a["+i+"]";c[n]=Function("F,a","return new F("+e.join(",")+")")}return c[n](t,r)};t.exports=Function.bind||function(t){var n=e(this),r=u.call(arguments,1),c=function(){var e=r.concat(u.call(arguments));return this instanceof c?f(n,e.length,e):o(n,e,t)};return i(n.prototype)&&(c.prototype=n.prototype),c}},function(t,n,r){"use strict";var e=r(11).f,i=r(70),o=r(73),u=r(53),c=r(68),f=r(46),a=r(79),s=r(140),l=r(170),h=r(74),v=r(10),p=r(65).fastKey,d=v?"_s":"size",y=function(t,n){var r,e=p(n);if("F"!==e)return t._i[e];for(r=t._f;r;r=r.n)if(r.k==n)return r};t.exports={getConstructor:function(t,n,r,s){var l=t(function(t,e){c(t,l,n,"_i"),t._i=i(null),t._f=void 0,t._l=void 0,t[d]=0,void 0!=e&&a(e,r,t[s],t)});return o(l.prototype,{clear:function(){for(var t=this,n=t._i,r=t._f;r;r=r.n)r.r=!0,r.p&&(r.p=r.p.n=void 0),delete n[r.i];t._f=t._l=void 0,t[d]=0},delete:function(t){var n=this,r=y(n,t);if(r){var e=r.n,i=r.p;delete n._i[r.i],r.r=!0,i&&(i.n=e),e&&(e.p=i),n._f==r&&(n._f=e),n._l==r&&(n._l=i),n[d]--}return!!r},forEach:function(t){c(this,l,"forEach");for(var n,r=u(t,arguments.length>1?arguments[1]:void 0,3);n=n?n.n:this._f;)for(r(n.v,n.k,this);n&&n.r;)n=n.p},has:function(t){return!!y(this,t)}}),v&&e(l.prototype,"size",{get:function(){return f(this[d])}}),l},def:function(t,n,r){var e,i,o=y(t,n);return o?o.v=r:(t._l=o={i:i=p(n,!0),k:n,v:r,p:e=t._l,n:void 0,r:!1},t._f||(t._f=o),e&&(e.n=o),t[d]++,"F"!==i&&(t._i[i]=o)),t},getEntry:y,setStrong:function(t,n,r){s(t,n,function(t,n){this._t=t,this._k=n,this._l=void 0},function(){for(var t=this,n=t._k,r=t._l;r&&r.r;)r=r.p;return t._t&&(t._l=r=r?r.n:t._t._f)?"keys"==n?l(0,r.k):"values"==n?l(0,r.v):l(0,[r.k,r.v]):(t._t=void 0,l(1))},r?"entries":"values",!r,!0),h(n)}}},function(t,n,r){var e=r(114),i=r(161);t.exports=function(t){return function(){if(e(this)!=t)throw TypeError(t+"#toJSON isn't generic");return i(this)}}},function(t,n,r){"use strict";var e=r(73),i=r(65).getWeak,o=r(2),u=r(6),c=r(68),f=r(79),a=r(48),s=r(24),l=a(5),h=a(6),v=0,p=function(t){return t._l||(t._l=new d)},d=function(){this.a=[]},y=function(t,n){return l(t.a,function(t){return t[0]===n})};d.prototype={get:function(t){var n=y(this,t);if(n)return n[1]},has:function(t){return!!y(this,t)},set:function(t,n){var r=y(this,t);r?r[1]=n:this.a.push([t,n])},delete:function(t){var n=h(this.a,function(n){return n[0]===t});return~n&&this.a.splice(n,1),!!~n}},t.exports={getConstructor:function(t,n,r,o){var a=t(function(t,e){c(t,a,n,"_i"),t._i=v++,t._l=void 0,void 0!=e&&f(e,r,t[o],t)});return e(a.prototype,{delete:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).delete(t):n&&s(n,this._i)&&delete n[this._i]},has:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).has(t):n&&s(n,this._i)}}),a},def:function(t,n,r){var e=i(o(n),!0);return!0===e?p(t).set(n,r):e[t._i]=r,t},ufstore:p}},function(t,n,r){t.exports=!r(10)&&!r(4)(function(){return 7!=Object.defineProperty(r(132)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(6),i=Math.floor;t.exports=function(t){return!e(t)&&isFinite(t)&&i(t)===t}},function(t,n,r){var e=r(2);t.exports=function(t,n,r,i){try{return i?n(e(r)[0],r[1]):n(r)}catch(n){var o=t.return;throw void 0!==o&&e(o.call(t)),n}}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n){t.exports=Math.log1p||function(t){return(t=+t)>-1e-8&&t<1e-8?t-t*t/2:Math.log(1+t)}},function(t,n,r){"use strict";var e=r(72),i=r(125),o=r(116),u=r(17),c=r(115),f=Object.assign;t.exports=!f||r(4)(function(){var t={},n={},r=Symbol(),e="abcdefghijklmnopqrst";return t[r]=7,e.split("").forEach(function(t){n[t]=t}),7!=f({},t)[r]||Object.keys(f({},n)).join("")!=e})?function(t,n){for(var r=u(t),f=arguments.length,a=1,s=i.f,l=o.f;f>a;)for(var h,v=c(arguments[a++]),p=s?e(v).concat(s(v)):e(v),d=p.length,y=0;d>y;)l.call(v,h=p[y++])&&(r[h]=v[h]);return r}:f},function(t,n,r){var e=r(11),i=r(2),o=r(72);t.exports=r(10)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(30),i=r(71).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(24),i=r(30),o=r(117)(!1),u=r(145)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){var e=r(72),i=r(30),o=r(116).f;t.exports=function(t){return function(n){for(var r,u=i(n),c=e(u),f=c.length,a=0,s=[];f>a;)o.call(u,r=c[a++])&&s.push(t?[r,u[r]]:u[r]);return s}}},function(t,n,r){var e=r(71),i=r(125),o=r(2),u=r(3).Reflect;t.exports=u&&u.ownKeys||function(t){var n=e.f(o(t)),r=i.f;return r?n.concat(r(t)):n}},function(t,n,r){var e=r(3).parseFloat,i=r(82).trim;t.exports=1/e(r(150)+"-0")!=-1/0?function(t){var n=i(String(t),3),r=e(n);return 0===r&&"-"==n.charAt(0)?-0:r}:e},function(t,n,r){var e=r(3).parseInt,i=r(82).trim,o=r(150),u=/^[\-+]?0[xX]/;t.exports=8!==e(o+"08")||22!==e(o+"0x16")?function(t,n){var r=i(String(t),3);return e(r,n>>>0||(u.test(r)?16:10))}:e},function(t,n){t.exports=Object.is||function(t,n){return t===n?0!==t||1/t==1/n:t!=t&&n!=n}},function(t,n,r){var e=r(16),i=r(149),o=r(46);t.exports=function(t,n,r,u){var c=String(o(t)),f=c.length,a=void 0===r?" ":String(r),s=e(n);if(s<=f||""==a)return c;var l=s-f,h=i.call(a,Math.ceil(l/a.length));return h.length>l&&(h=h.slice(0,l)),u?h+c:c+h}},function(t,n,r){n.f=r(7)},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Map",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{get:function(t){var n=e.getEntry(this,t);return n&&n.v},set:function(t,n){return e.def(this,0===t?0:t,n)}},e,!0)},function(t,n,r){r(10)&&"g"!=/./g.flags&&r(11).f(RegExp.prototype,"flags",{configurable:!0,get:r(120)})},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Set",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t=0===t?0:t,t)}},e)},function(t,n,r){"use strict";var e,i=r(48)(0),o=r(28),u=r(65),c=r(172),f=r(166),a=r(6),s=u.getWeak,l=Object.isExtensible,h=f.ufstore,v={},p=function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},d={get:function(t){if(a(t)){var n=s(t);return!0===n?h(this).get(t):n?n[this._i]:void 0}},set:function(t,n){return f.def(this,t,n)}},y=t.exports=r(118)("WeakMap",p,d,f,!0,!0);7!=(new y).set((Object.freeze||Object)(v),7).get(v)&&(e=f.getConstructor(p),c(e.prototype,d),u.NEED=!0,i(["delete","has","get","set"],function(t){var n=y.prototype,r=n[t];o(n,t,function(n,i){if(a(n)&&!l(n)){this._f||(this._f=new e);var o=this._f[t](n,i);return"set"==t?this:o}return r.call(this,n,i)})}))},,,,function(t,n){"use strict";function r(){var t=document.querySelector("#page-nav");if(t&&!document.querySelector("#page-nav .extend.prev")&&(t.innerHTML='<a class="extend prev disabled" rel="prev">&laquo; Prev</a>'+t.innerHTML),t&&!document.querySelector("#page-nav .extend.next")&&(t.innerHTML=t.innerHTML+'<a class="extend next disabled" rel="next">Next &raquo;</a>'),yiliaConfig&&yiliaConfig.open_in_new){document.querySelectorAll(".article-entry a:not(.article-more-a)").forEach(function(t){var n=t.getAttribute("target");n&&""!==n||t.setAttribute("target","_blank")})}if(yiliaConfig&&yiliaConfig.toc_hide_index){document.querySelectorAll(".toc-number").forEach(function(t){t.style.display="none"})}var n=document.querySelector("#js-aboutme");n&&0!==n.length&&(n.innerHTML=n.innerText)}t.exports={init:r}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}function i(t,n){var r=/\/|index.html/g;return t.replace(r,"")===n.replace(r,"")}function o(){for(var t=document.querySelectorAll(".js-header-menu li a"),n=window.location.pathname,r=0,e=t.length;r<e;r++){var o=t[r];i(n,o.getAttribute("href"))&&(0,h.default)(o,"active")}}function u(t){for(var n=t.offsetLeft,r=t.offsetParent;null!==r;)n+=r.offsetLeft,r=r.offsetParent;return n}function c(t){for(var n=t.offsetTop,r=t.offsetParent;null!==r;)n+=r.offsetTop,r=r.offsetParent;return n}function f(t,n,r,e,i){var o=u(t),f=c(t)-n;if(f-r<=i){var a=t.$newDom;a||(a=t.cloneNode(!0),(0,d.default)(t,a),t.$newDom=a,a.style.position="fixed",a.style.top=(r||f)+"px",a.style.left=o+"px",a.style.zIndex=e||2,a.style.width="100%",a.style.color="#fff"),a.style.visibility="visible",t.style.visibility="hidden"}else{t.style.visibility="visible";var s=t.$newDom;s&&(s.style.visibility="hidden")}}function a(){var t=document.querySelector(".js-overlay"),n=document.querySelector(".js-header-menu");f(t,document.body.scrollTop,-63,2,0),f(n,document.body.scrollTop,1,3,0)}function s(){document.querySelector("#container").addEventListener("scroll",function(t){a()}),window.addEventListener("scroll",function(t){a()}),a()}var l=r(156),h=e(l),v=r(157),p=(e(v),r(382)),d=e(p),y=r(128),g=e(y),b=r(190),m=e(b),x=r(129);(function(){g.default.versions.mobile&&window.screen.width<800&&(o(),s())})(),(0,x.addLoadEvent)(function(){m.default.init()}),t.exports={}},,,,function(t,n,r){(function(t){"use strict";function n(t,n,r){t[n]||Object[e](t,n,{writable:!0,configurable:!0,value:r})}if(r(381),r(391),r(198),t._babelPolyfill)throw new Error("only one instance of babel-polyfill is allowed");t._babelPolyfill=!0;var e="defineProperty";n(String.prototype,"padLeft","".padStart),n(String.prototype,"padRight","".padEnd),"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function(t){[][t]&&n(Array,t,Function.call.bind([][t]))})}).call(n,function(){return this}())},,,function(t,n,r){r(210),t.exports=r(52).RegExp.escape},,,,function(t,n,r){var e=r(6),i=r(138),o=r(7)("species");t.exports=function(t){var n;return i(t)&&(n=t.constructor,"function"!=typeof n||n!==Array&&!i(n.prototype)||(n=void 0),e(n)&&null===(n=n[o])&&(n=void 0)),void 0===n?Array:n}},function(t,n,r){var e=r(202);t.exports=function(t,n){return new(e(t))(n)}},function(t,n,r){"use strict";var e=r(2),i=r(50),o="number";t.exports=function(t){if("string"!==t&&t!==o&&"default"!==t)throw TypeError("Incorrect hint");return i(e(this),t!=o)}},function(t,n,r){var e=r(72),i=r(125),o=r(116);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){var e=r(72),i=r(30);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){"use strict";var e=r(208),i=r(121),o=r(26);t.exports=function(){for(var t=o(this),n=arguments.length,r=Array(n),u=0,c=e._,f=!1;n>u;)(r[u]=arguments[u++])===c&&(f=!0);return function(){var e,o=this,u=arguments.length,a=0,s=0;if(!f&&!u)return i(t,r,o);if(e=r.slice(),f)for(;n>a;a++)e[a]===c&&(e[a]=arguments[s++]);for(;u>s;)e.push(arguments[s++]);return i(t,e,o)}}},function(t,n,r){t.exports=r(3)},function(t,n){t.exports=function(t,n){var r=n===Object(n)?function(t){return n[t]}:n;return function(n){return String(n).replace(t,r)}}},function(t,n,r){var e=r(1),i=r(209)(/[\\^$*+?.()|[\]{}]/g,"\\$&");e(e.S,"RegExp",{escape:function(t){return i(t)}})},function(t,n,r){var e=r(1);e(e.P,"Array",{copyWithin:r(160)}),r(78)("copyWithin")},function(t,n,r){"use strict";var e=r(1),i=r(48)(4);e(e.P+e.F*!r(47)([].every,!0),"Array",{every:function(t){return i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.P,"Array",{fill:r(130)}),r(78)("fill")},function(t,n,r){"use strict";var e=r(1),i=r(48)(2);e(e.P+e.F*!r(47)([].filter,!0),"Array",{filter:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(6),o="findIndex",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{findIndex:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(5),o="find",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{find:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(0),o=r(47)([].forEach,!0);e(e.P+e.F*!o,"Array",{forEach:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(53),i=r(1),o=r(17),u=r(169),c=r(137),f=r(16),a=r(131),s=r(154);i(i.S+i.F*!r(123)(function(t){Array.from(t)}),"Array",{from:function(t){var n,r,i,l,h=o(t),v="function"==typeof this?this:Array,p=arguments.length,d=p>1?arguments[1]:void 0,y=void 0!==d,g=0,b=s(h);if(y&&(d=e(d,p>2?arguments[2]:void 0,2)),void 0==b||v==Array&&c(b))for(n=f(h.length),r=new v(n);n>g;g++)a(r,g,y?d(h[g],g):h[g]);else for(l=b.call(h),r=new v;!(i=l.next()).done;g++)a(r,g,y?u(l,d,[i.value,g],!0):i.value);return r.length=g,r}})},function(t,n,r){"use strict";var e=r(1),i=r(117)(!1),o=[].indexOf,u=!!o&&1/[1].indexOf(1,-0)<0;e(e.P+e.F*(u||!r(47)(o)),"Array",{indexOf:function(t){return u?o.apply(this,arguments)||0:i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.S,"Array",{isArray:r(138)})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=[].join;e(e.P+e.F*(r(115)!=Object||!r(47)(o)),"Array",{join:function(t){return o.call(i(this),void 0===t?",":t)}})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=r(67),u=r(16),c=[].lastIndexOf,f=!!c&&1/[1].lastIndexOf(1,-0)<0;e(e.P+e.F*(f||!r(47)(c)),"Array",{lastIndexOf:function(t){if(f)return c.apply(this,arguments)||0;var n=i(this),r=u(n.length),e=r-1;for(arguments.length>1&&(e=Math.min(e,o(arguments[1]))),e<0&&(e=r+e);e>=0;e--)if(e in n&&n[e]===t)return e||0;return-1}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(1);e(e.P+e.F*!r(47)([].map,!0),"Array",{map:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(131);e(e.S+e.F*r(4)(function(){function t(){}return!(Array.of.call(t)instanceof t)}),"Array",{of:function(){for(var t=0,n=arguments.length,r=new("function"==typeof this?this:Array)(n);n>t;)i(r,t,arguments[t++]);return r.length=n,r}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduceRight,!0),"Array",{reduceRight:function(t){return i(this,t,arguments.length,arguments[1],!0)}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduce,!0),"Array",{reduce:function(t){return i(this,t,arguments.length,arguments[1],!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(135),o=r(45),u=r(75),c=r(16),f=[].slice;e(e.P+e.F*r(4)(function(){i&&f.call(i)}),"Array",{slice:function(t,n){var r=c(this.length),e=o(this);if(n=void 0===n?r:n,"Array"==e)return f.call(this,t,n);for(var i=u(t,r),a=u(n,r),s=c(a-i),l=Array(s),h=0;h<s;h++)l[h]="String"==e?this.charAt(i+h):this[i+h];return l}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(3);e(e.P+e.F*!r(47)([].some,!0),"Array",{some:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(26),o=r(17),u=r(4),c=[].sort,f=[1,2,3];e(e.P+e.F*(u(function(){f.sort(void 0)})||!u(function(){f.sort(null)})||!r(47)(c)),"Array",{sort:function(t){return void 0===t?c.call(o(this)):c.call(o(this),i(t))}})},function(t,n,r){r(74)("Array")},function(t,n,r){var e=r(1);e(e.S,"Date",{now:function(){return(new Date).getTime()}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=Date.prototype.getTime,u=function(t){return t>9?t:"0"+t};e(e.P+e.F*(i(function(){return"0385-07-25T07:06:39.999Z"!=new Date(-5e13-1).toISOString()})||!i(function(){new Date(NaN).toISOString()})),"Date",{toISOString:function(){
if(!isFinite(o.call(this)))throw RangeError("Invalid time value");var t=this,n=t.getUTCFullYear(),r=t.getUTCMilliseconds(),e=n<0?"-":n>9999?"+":"";return e+("00000"+Math.abs(n)).slice(e?-6:-4)+"-"+u(t.getUTCMonth()+1)+"-"+u(t.getUTCDate())+"T"+u(t.getUTCHours())+":"+u(t.getUTCMinutes())+":"+u(t.getUTCSeconds())+"."+(r>99?r:"0"+u(r))+"Z"}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50);e(e.P+e.F*r(4)(function(){return null!==new Date(NaN).toJSON()||1!==Date.prototype.toJSON.call({toISOString:function(){return 1}})}),"Date",{toJSON:function(t){var n=i(this),r=o(n);return"number"!=typeof r||isFinite(r)?n.toISOString():null}})},function(t,n,r){var e=r(7)("toPrimitive"),i=Date.prototype;e in i||r(27)(i,e,r(204))},function(t,n,r){var e=Date.prototype,i="Invalid Date",o="toString",u=e[o],c=e.getTime;new Date(NaN)+""!=i&&r(28)(e,o,function(){var t=c.call(this);return t===t?u.call(this):i})},function(t,n,r){var e=r(1);e(e.P,"Function",{bind:r(163)})},function(t,n,r){"use strict";var e=r(6),i=r(32),o=r(7)("hasInstance"),u=Function.prototype;o in u||r(11).f(u,o,{value:function(t){if("function"!=typeof this||!e(t))return!1;if(!e(this.prototype))return t instanceof this;for(;t=i(t);)if(this.prototype===t)return!0;return!1}})},function(t,n,r){var e=r(11).f,i=r(66),o=r(24),u=Function.prototype,c="name",f=Object.isExtensible||function(){return!0};c in u||r(10)&&e(u,c,{configurable:!0,get:function(){try{var t=this,n=(""+t).match(/^\s*function ([^ (]*)/)[1];return o(t,c)||!f(t)||e(t,c,i(5,n)),n}catch(t){return""}}})},function(t,n,r){var e=r(1),i=r(171),o=Math.sqrt,u=Math.acosh;e(e.S+e.F*!(u&&710==Math.floor(u(Number.MAX_VALUE))&&u(1/0)==1/0),"Math",{acosh:function(t){return(t=+t)<1?NaN:t>94906265.62425156?Math.log(t)+Math.LN2:i(t-1+o(t-1)*o(t+1))}})},function(t,n,r){function e(t){return isFinite(t=+t)&&0!=t?t<0?-e(-t):Math.log(t+Math.sqrt(t*t+1)):t}var i=r(1),o=Math.asinh;i(i.S+i.F*!(o&&1/o(0)>0),"Math",{asinh:e})},function(t,n,r){var e=r(1),i=Math.atanh;e(e.S+e.F*!(i&&1/i(-0)<0),"Math",{atanh:function(t){return 0==(t=+t)?t:Math.log((1+t)/(1-t))/2}})},function(t,n,r){var e=r(1),i=r(142);e(e.S,"Math",{cbrt:function(t){return i(t=+t)*Math.pow(Math.abs(t),1/3)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{clz32:function(t){return(t>>>=0)?31-Math.floor(Math.log(t+.5)*Math.LOG2E):32}})},function(t,n,r){var e=r(1),i=Math.exp;e(e.S,"Math",{cosh:function(t){return(i(t=+t)+i(-t))/2}})},function(t,n,r){var e=r(1),i=r(141);e(e.S+e.F*(i!=Math.expm1),"Math",{expm1:i})},function(t,n,r){var e=r(1),i=r(142),o=Math.pow,u=o(2,-52),c=o(2,-23),f=o(2,127)*(2-c),a=o(2,-126),s=function(t){return t+1/u-1/u};e(e.S,"Math",{fround:function(t){var n,r,e=Math.abs(t),o=i(t);return e<a?o*s(e/a/c)*a*c:(n=(1+c/u)*e,r=n-(n-e),r>f||r!=r?o*(1/0):o*r)}})},function(t,n,r){var e=r(1),i=Math.abs;e(e.S,"Math",{hypot:function(t,n){for(var r,e,o=0,u=0,c=arguments.length,f=0;u<c;)r=i(arguments[u++]),f<r?(e=f/r,o=o*e*e+1,f=r):r>0?(e=r/f,o+=e*e):o+=r;return f===1/0?1/0:f*Math.sqrt(o)}})},function(t,n,r){var e=r(1),i=Math.imul;e(e.S+e.F*r(4)(function(){return-5!=i(4294967295,5)||2!=i.length}),"Math",{imul:function(t,n){var r=65535,e=+t,i=+n,o=r&e,u=r&i;return 0|o*u+((r&e>>>16)*u+o*(r&i>>>16)<<16>>>0)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log10:function(t){return Math.log(t)/Math.LN10}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log1p:r(171)})},function(t,n,r){var e=r(1);e(e.S,"Math",{log2:function(t){return Math.log(t)/Math.LN2}})},function(t,n,r){var e=r(1);e(e.S,"Math",{sign:r(142)})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S+e.F*r(4)(function(){return-2e-17!=!Math.sinh(-2e-17)}),"Math",{sinh:function(t){return Math.abs(t=+t)<1?(i(t)-i(-t))/2:(o(t-1)-o(-t-1))*(Math.E/2)}})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S,"Math",{tanh:function(t){var n=i(t=+t),r=i(-t);return n==1/0?1:r==1/0?-1:(n-r)/(o(t)+o(-t))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{trunc:function(t){return(t>0?Math.floor:Math.ceil)(t)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(45),u=r(136),c=r(50),f=r(4),a=r(71).f,s=r(31).f,l=r(11).f,h=r(82).trim,v="Number",p=e[v],d=p,y=p.prototype,g=o(r(70)(y))==v,b="trim"in String.prototype,m=function(t){var n=c(t,!1);if("string"==typeof n&&n.length>2){n=b?n.trim():h(n,3);var r,e,i,o=n.charCodeAt(0);if(43===o||45===o){if(88===(r=n.charCodeAt(2))||120===r)return NaN}else if(48===o){switch(n.charCodeAt(1)){case 66:case 98:e=2,i=49;break;case 79:case 111:e=8,i=55;break;default:return+n}for(var u,f=n.slice(2),a=0,s=f.length;a<s;a++)if((u=f.charCodeAt(a))<48||u>i)return NaN;return parseInt(f,e)}}return+n};if(!p(" 0o1")||!p("0b1")||p("+0x1")){p=function(t){var n=arguments.length<1?0:t,r=this;return r instanceof p&&(g?f(function(){y.valueOf.call(r)}):o(r)!=v)?u(new d(m(n)),r,p):m(n)};for(var x,w=r(10)?a(d):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","),S=0;w.length>S;S++)i(d,x=w[S])&&!i(p,x)&&l(p,x,s(d,x));p.prototype=y,y.constructor=p,r(28)(e,v,p)}},function(t,n,r){var e=r(1);e(e.S,"Number",{EPSILON:Math.pow(2,-52)})},function(t,n,r){var e=r(1),i=r(3).isFinite;e(e.S,"Number",{isFinite:function(t){return"number"==typeof t&&i(t)}})},function(t,n,r){var e=r(1);e(e.S,"Number",{isInteger:r(168)})},function(t,n,r){var e=r(1);e(e.S,"Number",{isNaN:function(t){return t!=t}})},function(t,n,r){var e=r(1),i=r(168),o=Math.abs;e(e.S,"Number",{isSafeInteger:function(t){return i(t)&&o(t)<=9007199254740991}})},function(t,n,r){var e=r(1);e(e.S,"Number",{MAX_SAFE_INTEGER:9007199254740991})},function(t,n,r){var e=r(1);e(e.S,"Number",{MIN_SAFE_INTEGER:-9007199254740991})},function(t,n,r){var e=r(1),i=r(178);e(e.S+e.F*(Number.parseFloat!=i),"Number",{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.S+e.F*(Number.parseInt!=i),"Number",{parseInt:i})},function(t,n,r){"use strict";var e=r(1),i=r(67),o=r(159),u=r(149),c=1..toFixed,f=Math.floor,a=[0,0,0,0,0,0],s="Number.toFixed: incorrect invocation!",l="0",h=function(t,n){for(var r=-1,e=n;++r<6;)e+=t*a[r],a[r]=e%1e7,e=f(e/1e7)},v=function(t){for(var n=6,r=0;--n>=0;)r+=a[n],a[n]=f(r/t),r=r%t*1e7},p=function(){for(var t=6,n="";--t>=0;)if(""!==n||0===t||0!==a[t]){var r=String(a[t]);n=""===n?r:n+u.call(l,7-r.length)+r}return n},d=function(t,n,r){return 0===n?r:n%2==1?d(t,n-1,r*t):d(t*t,n/2,r)},y=function(t){for(var n=0,r=t;r>=4096;)n+=12,r/=4096;for(;r>=2;)n+=1,r/=2;return n};e(e.P+e.F*(!!c&&("0.000"!==8e-5.toFixed(3)||"1"!==.9.toFixed(0)||"1.25"!==1.255.toFixed(2)||"1000000000000000128"!==(0xde0b6b3a7640080).toFixed(0))||!r(4)(function(){c.call({})})),"Number",{toFixed:function(t){var n,r,e,c,f=o(this,s),a=i(t),g="",b=l;if(a<0||a>20)throw RangeError(s);if(f!=f)return"NaN";if(f<=-1e21||f>=1e21)return String(f);if(f<0&&(g="-",f=-f),f>1e-21)if(n=y(f*d(2,69,1))-69,r=n<0?f*d(2,-n,1):f/d(2,n,1),r*=4503599627370496,(n=52-n)>0){for(h(0,r),e=a;e>=7;)h(1e7,0),e-=7;for(h(d(10,e,1),0),e=n-1;e>=23;)v(1<<23),e-=23;v(1<<e),h(1,1),v(2),b=p()}else h(0,r),h(1<<-n,0),b=p()+u.call(l,a);return a>0?(c=b.length,b=g+(c<=a?"0."+u.call(l,a-c)+b:b.slice(0,c-a)+"."+b.slice(c-a))):b=g+b,b}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=r(159),u=1..toPrecision;e(e.P+e.F*(i(function(){return"1"!==u.call(1,void 0)})||!i(function(){u.call({})})),"Number",{toPrecision:function(t){var n=o(this,"Number#toPrecision: incorrect invocation!");return void 0===t?u.call(n):u.call(n,t)}})},function(t,n,r){var e=r(1);e(e.S+e.F,"Object",{assign:r(172)})},function(t,n,r){var e=r(1);e(e.S,"Object",{create:r(70)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperties:r(173)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperty:r(11).f})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("freeze",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(30),i=r(31).f;r(49)("getOwnPropertyDescriptor",function(){return function(t,n){return i(e(t),n)}})},function(t,n,r){r(49)("getOwnPropertyNames",function(){return r(174).f})},function(t,n,r){var e=r(17),i=r(32);r(49)("getPrototypeOf",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6);r(49)("isExtensible",function(t){return function(n){return!!e(n)&&(!t||t(n))}})},function(t,n,r){var e=r(6);r(49)("isFrozen",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(6);r(49)("isSealed",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(1);e(e.S,"Object",{is:r(180)})},function(t,n,r){var e=r(17),i=r(72);r(49)("keys",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("preventExtensions",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("seal",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(1);e(e.S,"Object",{setPrototypeOf:r(144).set})},function(t,n,r){"use strict";var e=r(114),i={};i[r(7)("toStringTag")]="z",i+""!="[object z]"&&r(28)(Object.prototype,"toString",function(){return"[object "+e(this)+"]"},!0)},function(t,n,r){var e=r(1),i=r(178);e(e.G+e.F*(parseFloat!=i),{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.G+e.F*(parseInt!=i),{parseInt:i})},function(t,n,r){"use strict";var e,i,o,u=r(69),c=r(3),f=r(53),a=r(114),s=r(1),l=r(6),h=r(26),v=r(68),p=r(79),d=r(146),y=r(151).set,g=r(143)(),b="Promise",m=c.TypeError,x=c.process,w=c[b],x=c.process,S="process"==a(x),_=function(){},O=!!function(){try{var t=w.resolve(1),n=(t.constructor={})[r(7)("species")]=function(t){t(_,_)};return(S||"function"==typeof PromiseRejectionEvent)&&t.then(_)instanceof n}catch(t){}}(),E=function(t,n){return t===n||t===w&&n===o},P=function(t){var n;return!(!l(t)||"function"!=typeof(n=t.then))&&n},j=function(t){return E(w,t)?new F(t):new i(t)},F=i=function(t){var n,r;this.promise=new t(function(t,e){if(void 0!==n||void 0!==r)throw m("Bad Promise constructor");n=t,r=e}),this.resolve=h(n),this.reject=h(r)},M=function(t){try{t()}catch(t){return{error:t}}},A=function(t,n){if(!t._n){t._n=!0;var r=t._c;g(function(){for(var e=t._v,i=1==t._s,o=0;r.length>o;)!function(n){var r,o,u=i?n.ok:n.fail,c=n.resolve,f=n.reject,a=n.domain;try{u?(i||(2==t._h&&I(t),t._h=1),!0===u?r=e:(a&&a.enter(),r=u(e),a&&a.exit()),r===n.promise?f(m("Promise-chain cycle")):(o=P(r))?o.call(r,c,f):c(r)):f(e)}catch(t){f(t)}}(r[o++]);t._c=[],t._n=!1,n&&!t._h&&N(t)})}},N=function(t){y.call(c,function(){var n,r,e,i=t._v;if(T(t)&&(n=M(function(){S?x.emit("unhandledRejection",i,t):(r=c.onunhandledrejection)?r({promise:t,reason:i}):(e=c.console)&&e.error&&e.error("Unhandled promise rejection",i)}),t._h=S||T(t)?2:1),t._a=void 0,n)throw n.error})},T=function(t){if(1==t._h)return!1;for(var n,r=t._a||t._c,e=0;r.length>e;)if(n=r[e++],n.fail||!T(n.promise))return!1;return!0},I=function(t){y.call(c,function(){var n;S?x.emit("rejectionHandled",t):(n=c.onrejectionhandled)&&n({promise:t,reason:t._v})})},k=function(t){var n=this;n._d||(n._d=!0,n=n._w||n,n._v=t,n._s=2,n._a||(n._a=n._c.slice()),A(n,!0))},L=function(t){var n,r=this;if(!r._d){r._d=!0,r=r._w||r;try{if(r===t)throw m("Promise can't be resolved itself");(n=P(t))?g(function(){var e={_w:r,_d:!1};try{n.call(t,f(L,e,1),f(k,e,1))}catch(t){k.call(e,t)}}):(r._v=t,r._s=1,A(r,!1))}catch(t){k.call({_w:r,_d:!1},t)}}};O||(w=function(t){v(this,w,b,"_h"),h(t),e.call(this);try{t(f(L,this,1),f(k,this,1))}catch(t){k.call(this,t)}},e=function(t){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1},e.prototype=r(73)(w.prototype,{then:function(t,n){var r=j(d(this,w));return r.ok="function"!=typeof t||t,r.fail="function"==typeof n&&n,r.domain=S?x.domain:void 0,this._c.push(r),this._a&&this._a.push(r),this._s&&A(this,!1),r.promise},catch:function(t){return this.then(void 0,t)}}),F=function(){var t=new e;this.promise=t,this.resolve=f(L,t,1),this.reject=f(k,t,1)}),s(s.G+s.W+s.F*!O,{Promise:w}),r(81)(w,b),r(74)(b),o=r(52)[b],s(s.S+s.F*!O,b,{reject:function(t){var n=j(this);return(0,n.reject)(t),n.promise}}),s(s.S+s.F*(u||!O),b,{resolve:function(t){if(t instanceof w&&E(t.constructor,this))return t;var n=j(this);return(0,n.resolve)(t),n.promise}}),s(s.S+s.F*!(O&&r(123)(function(t){w.all(t).catch(_)})),b,{all:function(t){var n=this,r=j(n),e=r.resolve,i=r.reject,o=M(function(){var r=[],o=0,u=1;p(t,!1,function(t){var c=o++,f=!1;r.push(void 0),u++,n.resolve(t).then(function(t){f||(f=!0,r[c]=t,--u||e(r))},i)}),--u||e(r)});return o&&i(o.error),r.promise},race:function(t){var n=this,r=j(n),e=r.reject,i=M(function(){p(t,!1,function(t){n.resolve(t).then(r.resolve,e)})});return i&&e(i.error),r.promise}})},function(t,n,r){var e=r(1),i=r(26),o=r(2),u=(r(3).Reflect||{}).apply,c=Function.apply;e(e.S+e.F*!r(4)(function(){u(function(){})}),"Reflect",{apply:function(t,n,r){var e=i(t),f=o(r);return u?u(e,n,f):c.call(e,n,f)}})},function(t,n,r){var e=r(1),i=r(70),o=r(26),u=r(2),c=r(6),f=r(4),a=r(163),s=(r(3).Reflect||{}).construct,l=f(function(){function t(){}return!(s(function(){},[],t)instanceof t)}),h=!f(function(){s(function(){})});e(e.S+e.F*(l||h),"Reflect",{construct:function(t,n){o(t),u(n);var r=arguments.length<3?t:o(arguments[2]);if(h&&!l)return s(t,n,r);if(t==r){switch(n.length){case 0:return new t;case 1:return new t(n[0]);case 2:return new t(n[0],n[1]);case 3:return new t(n[0],n[1],n[2]);case 4:return new t(n[0],n[1],n[2],n[3])}var e=[null];return e.push.apply(e,n),new(a.apply(t,e))}var f=r.prototype,v=i(c(f)?f:Object.prototype),p=Function.apply.call(t,v,n);return c(p)?p:v}})},function(t,n,r){var e=r(11),i=r(1),o=r(2),u=r(50);i(i.S+i.F*r(4)(function(){Reflect.defineProperty(e.f({},1,{value:1}),1,{value:2})}),"Reflect",{defineProperty:function(t,n,r){o(t),n=u(n,!0),o(r);try{return e.f(t,n,r),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(31).f,o=r(2);e(e.S,"Reflect",{deleteProperty:function(t,n){var r=i(o(t),n);return!(r&&!r.configurable)&&delete t[n]}})},function(t,n,r){"use strict";var e=r(1),i=r(2),o=function(t){this._t=i(t),this._i=0;var n,r=this._k=[];for(n in t)r.push(n)};r(139)(o,"Object",function(){var t,n=this,r=n._k;do{if(n._i>=r.length)return{value:void 0,done:!0}}while(!((t=r[n._i++])in n._t));return{value:t,done:!1}}),e(e.S,"Reflect",{enumerate:function(t){return new o(t)}})},function(t,n,r){var e=r(31),i=r(1),o=r(2);i(i.S,"Reflect",{getOwnPropertyDescriptor:function(t,n){return e.f(o(t),n)}})},function(t,n,r){var e=r(1),i=r(32),o=r(2);e(e.S,"Reflect",{getPrototypeOf:function(t){return i(o(t))}})},function(t,n,r){function e(t,n){var r,c,s=arguments.length<3?t:arguments[2];return a(t)===s?t[n]:(r=i.f(t,n))?u(r,"value")?r.value:void 0!==r.get?r.get.call(s):void 0:f(c=o(t))?e(c,n,s):void 0}var i=r(31),o=r(32),u=r(24),c=r(1),f=r(6),a=r(2);c(c.S,"Reflect",{get:e})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{has:function(t,n){return n in t}})},function(t,n,r){var e=r(1),i=r(2),o=Object.isExtensible;e(e.S,"Reflect",{isExtensible:function(t){return i(t),!o||o(t)}})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{ownKeys:r(177)})},function(t,n,r){var e=r(1),i=r(2),o=Object.preventExtensions;e(e.S,"Reflect",{preventExtensions:function(t){i(t);try{return o&&o(t),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(144);i&&e(e.S,"Reflect",{setPrototypeOf:function(t,n){i.check(t,n);try{return i.set(t,n),!0}catch(t){return!1}}})},function(t,n,r){function e(t,n,r){var f,h,v=arguments.length<4?t:arguments[3],p=o.f(s(t),n);if(!p){if(l(h=u(t)))return e(h,n,r,v);p=a(0)}return c(p,"value")?!(!1===p.writable||!l(v)||(f=o.f(v,n)||a(0),f.value=r,i.f(v,n,f),0)):void 0!==p.set&&(p.set.call(v,r),!0)}var i=r(11),o=r(31),u=r(32),c=r(24),f=r(1),a=r(66),s=r(2),l=r(6);f(f.S,"Reflect",{set:e})},function(t,n,r){var e=r(3),i=r(136),o=r(11).f,u=r(71).f,c=r(122),f=r(120),a=e.RegExp,s=a,l=a.prototype,h=/a/g,v=/a/g,p=new a(h)!==h;if(r(10)&&(!p||r(4)(function(){return v[r(7)("match")]=!1,a(h)!=h||a(v)==v||"/a/i"!=a(h,"i")}))){a=function(t,n){var r=this instanceof a,e=c(t),o=void 0===n;return!r&&e&&t.constructor===a&&o?t:i(p?new s(e&&!o?t.source:t,n):s((e=t instanceof a)?t.source:t,e&&o?f.call(t):n),r?this:l,a)};for(var d=u(s),y=0;d.length>y;)!function(t){t in a||o(a,t,{configurable:!0,get:function(){return s[t]},set:function(n){s[t]=n}})}(d[y++]);l.constructor=a,a.prototype=l,r(28)(e,"RegExp",a)}r(74)("RegExp")},function(t,n,r){r(119)("match",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("replace",2,function(t,n,r){return[function(e,i){"use strict";var o=t(this),u=void 0==e?void 0:e[n];return void 0!==u?u.call(e,o,i):r.call(String(o),e,i)},r]})},function(t,n,r){r(119)("search",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("split",2,function(t,n,e){"use strict";var i=r(122),o=e,u=[].push,c="split",f="length",a="lastIndex";if("c"=="abbc"[c](/(b)*/)[1]||4!="test"[c](/(?:)/,-1)[f]||2!="ab"[c](/(?:ab)*/)[f]||4!="."[c](/(.?)(.?)/)[f]||"."[c](/()()/)[f]>1||""[c](/.?/)[f]){var s=void 0===/()??/.exec("")[1];e=function(t,n){var r=String(this);if(void 0===t&&0===n)return[];if(!i(t))return o.call(r,t,n);var e,c,l,h,v,p=[],d=(t.ignoreCase?"i":"")+(t.multiline?"m":"")+(t.unicode?"u":"")+(t.sticky?"y":""),y=0,g=void 0===n?4294967295:n>>>0,b=new RegExp(t.source,d+"g");for(s||(e=new RegExp("^"+b.source+"$(?!\\s)",d));(c=b.exec(r))&&!((l=c.index+c[0][f])>y&&(p.push(r.slice(y,c.index)),!s&&c[f]>1&&c[0].replace(e,function(){for(v=1;v<arguments[f]-2;v++)void 0===arguments[v]&&(c[v]=void 0)}),c[f]>1&&c.index<r[f]&&u.apply(p,c.slice(1)),h=c[0][f],y=l,p[f]>=g));)b[a]===c.index&&b[a]++;return y===r[f]?!h&&b.test("")||p.push(""):p.push(r.slice(y)),p[f]>g?p.slice(0,g):p}}else"0"[c](void 0,0)[f]&&(e=function(t,n){return void 0===t&&0===n?[]:o.call(this,t,n)});return[function(r,i){var o=t(this),u=void 0==r?void 0:r[n];return void 0!==u?u.call(r,o,i):e.call(String(o),r,i)},e]})},function(t,n,r){"use strict";r(184);var e=r(2),i=r(120),o=r(10),u="toString",c=/./[u],f=function(t){r(28)(RegExp.prototype,u,t,!0)};r(4)(function(){return"/a/b"!=c.call({source:"a",flags:"b"})})?f(function(){var t=e(this);return"/".concat(t.source,"/","flags"in t?t.flags:!o&&t instanceof RegExp?i.call(t):void 0)}):c.name!=u&&f(function(){return c.call(this)})},function(t,n,r){"use strict";r(29)("anchor",function(t){return function(n){return t(this,"a","name",n)}})},function(t,n,r){"use strict";r(29)("big",function(t){return function(){return t(this,"big","","")}})},function(t,n,r){"use strict";r(29)("blink",function(t){return function(){return t(this,"blink","","")}})},function(t,n,r){"use strict";r(29)("bold",function(t){return function(){return t(this,"b","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!1);e(e.P,"String",{codePointAt:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="endsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{endsWith:function(t){var n=o(this,t,u),r=arguments.length>1?arguments[1]:void 0,e=i(n.length),f=void 0===r?e:Math.min(i(r),e),a=String(t);return c?c.call(n,a,f):n.slice(f-a.length,f)===a}})},function(t,n,r){"use strict";r(29)("fixed",function(t){return function(){return t(this,"tt","","")}})},function(t,n,r){"use strict";r(29)("fontcolor",function(t){return function(n){return t(this,"font","color",n)}})},function(t,n,r){"use strict";r(29)("fontsize",function(t){return function(n){return t(this,"font","size",n)}})},function(t,n,r){var e=r(1),i=r(75),o=String.fromCharCode,u=String.fromCodePoint;e(e.S+e.F*(!!u&&1!=u.length),"String",{fromCodePoint:function(t){for(var n,r=[],e=arguments.length,u=0;e>u;){if(n=+arguments[u++],i(n,1114111)!==n)throw RangeError(n+" is not a valid code point");r.push(n<65536?o(n):o(55296+((n-=65536)>>10),n%1024+56320))}return r.join("")}})},function(t,n,r){"use strict";var e=r(1),i=r(148),o="includes";e(e.P+e.F*r(134)(o),"String",{includes:function(t){return!!~i(this,t,o).indexOf(t,arguments.length>1?arguments[1]:void 0)}})},function(t,n,r){"use strict";r(29)("italics",function(t){return function(){return t(this,"i","","")}})},function(t,n,r){"use strict";var e=r(147)(!0);r(140)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";r(29)("link",function(t){return function(n){return t(this,"a","href",n)}})},function(t,n,r){var e=r(1),i=r(30),o=r(16);e(e.S,"String",{raw:function(t){for(var n=i(t.raw),r=o(n.length),e=arguments.length,u=[],c=0;r>c;)u.push(String(n[c++])),c<e&&u.push(String(arguments[c]));return u.join("")}})},function(t,n,r){var e=r(1);e(e.P,"String",{repeat:r(149)})},function(t,n,r){"use strict";r(29)("small",function(t){return function(){return t(this,"small","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="startsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{startsWith:function(t){var n=o(this,t,u),r=i(Math.min(arguments.length>1?arguments[1]:void 0,n.length)),e=String(t);return c?c.call(n,e,r):n.slice(r,r+e.length)===e}})},function(t,n,r){"use strict";r(29)("strike",function(t){return function(){return t(this,"strike","","")}})},function(t,n,r){"use strict";r(29)("sub",function(t){return function(){return t(this,"sub","","")}})},function(t,n,r){"use strict";r(29)("sup",function(t){return function(){return t(this,"sup","","")}})},function(t,n,r){"use strict";r(82)("trim",function(t){return function(){return t(this,3)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(10),u=r(1),c=r(28),f=r(65).KEY,a=r(4),s=r(126),l=r(81),h=r(76),v=r(7),p=r(182),d=r(153),y=r(206),g=r(205),b=r(138),m=r(2),x=r(30),w=r(50),S=r(66),_=r(70),O=r(174),E=r(31),P=r(11),j=r(72),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(71).f=O.f=Z,r(116).f=X,r(125).f=tt,o&&!r(69)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(27)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){"use strict";var e=r(1),i=r(127),o=r(152),u=r(2),c=r(75),f=r(16),a=r(6),s=r(3).ArrayBuffer,l=r(146),h=o.ArrayBuffer,v=o.DataView,p=i.ABV&&s.isView,d=h.prototype.slice,y=i.VIEW,g="ArrayBuffer";e(e.G+e.W+e.F*(s!==h),{ArrayBuffer:h}),e(e.S+e.F*!i.CONSTR,g,{isView:function(t){return p&&p(t)||a(t)&&y in t}}),e(e.P+e.U+e.F*r(4)(function(){return!new h(2).slice(1,void 0).byteLength}),g,{slice:function(t,n){if(void 0!==d&&void 0===n)return d.call(u(this),t);for(var r=u(this).byteLength,e=c(t,r),i=c(void 0===n?r:n,r),o=new(l(this,h))(f(i-e)),a=new v(this),s=new v(o),p=0;e<i;)s.setUint8(p++,a.getUint8(e++));return o}}),r(74)(g)},function(t,n,r){var e=r(1);e(e.G+e.W+e.F*!r(127).ABV,{DataView:r(152).DataView})},function(t,n,r){r(55)("Float32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Float64",8,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}},!0)},function(t,n,r){"use strict";var e=r(166);r(118)("WeakSet",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t,!0)}},e,!1,!0)},function(t,n,r){"use strict";var e=r(1),i=r(117)(!0);e(e.P,"Array",{includes:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)("includes")},function(t,n,r){var e=r(1),i=r(143)(),o=r(3).process,u="process"==r(45)(o);e(e.G,{asap:function(t){var n=u&&o.domain;i(n?n.bind(t):t)}})},function(t,n,r){var e=r(1),i=r(45);e(e.S,"Error",{isError:function(t){return"Error"===i(t)}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Map",{toJSON:r(165)("Map")})},function(t,n,r){var e=r(1);e(e.S,"Math",{iaddh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o+(e>>>0)+((i&u|(i|u)&~(i+u>>>0))>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{imulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>16,f=i>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>16)+((o*f>>>0)+(a&r)>>16)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{isubh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o-(e>>>0)-((~i&u|~(i^u)&i-u>>>0)>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{umulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>>16,f=i>>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>>16)+((o*f>>>0)+(a&r)>>>16)}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineGetter__:function(t,n){u.f(i(this),t,{get:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineSetter__:function(t,n){u.f(i(this),t,{set:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){var e=r(1),i=r(176)(!0);e(e.S,"Object",{entries:function(t){return i(t)}})},function(t,n,r){var e=r(1),i=r(177),o=r(30),u=r(31),c=r(131);e(e.S,"Object",{getOwnPropertyDescriptors:function(t){for(var n,r=o(t),e=u.f,f=i(r),a={},s=0;f.length>s;)c(a,n=f[s++],e(r,n));return a}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupGetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.get}while(r=u(r))}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupSetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.set}while(r=u(r))}})},function(t,n,r){var e=r(1),i=r(176)(!1);e(e.S,"Object",{values:function(t){return i(t)}})},function(t,n,r){"use strict";var e=r(1),i=r(3),o=r(52),u=r(143)(),c=r(7)("observable"),f=r(26),a=r(2),s=r(68),l=r(73),h=r(27),v=r(79),p=v.RETURN,d=function(t){return null==t?void 0:f(t)},y=function(t){var n=t._c;n&&(t._c=void 0,n())},g=function(t){return void 0===t._o},b=function(t){g(t)||(t._o=void 0,y(t))},m=function(t,n){a(t),this._c=void 0,this._o=t,t=new x(this);try{var r=n(t),e=r;null!=r&&("function"==typeof r.unsubscribe?r=function(){e.unsubscribe()}:f(r),this._c=r)}catch(n){return void t.error(n)}g(this)&&y(this)};m.prototype=l({},{unsubscribe:function(){b(this)}});var x=function(t){this._s=t};x.prototype=l({},{next:function(t){var n=this._s;if(!g(n)){var r=n._o;try{var e=d(r.next);if(e)return e.call(r,t)}catch(t){try{b(n)}finally{throw t}}}},error:function(t){var n=this._s;if(g(n))throw t;var r=n._o;n._o=void 0;try{var e=d(r.error);if(!e)throw t;t=e.call(r,t)}catch(t){try{y(n)}finally{throw t}}return y(n),t},complete:function(t){var n=this._s;if(!g(n)){var r=n._o;n._o=void 0;try{var e=d(r.complete);t=e?e.call(r,t):void 0}catch(t){try{y(n)}finally{throw t}}return y(n),t}}});var w=function(t){s(this,w,"Observable","_f")._f=f(t)};l(w.prototype,{subscribe:function(t){return new m(t,this._f)},forEach:function(t){var n=this;return new(o.Promise||i.Promise)(function(r,e){f(t);var i=n.subscribe({next:function(n){try{return t(n)}catch(t){e(t),i.unsubscribe()}},error:e,complete:r})})}}),l(w,{from:function(t){var n="function"==typeof this?this:w,r=d(a(t)[c]);if(r){var e=a(r.call(t));return e.constructor===n?e:new n(function(t){return e.subscribe(t)})}return new n(function(n){var r=!1;return u(function(){if(!r){try{if(v(t,!1,function(t){if(n.next(t),r)return p})===p)return}catch(t){if(r)throw t;return void n.error(t)}n.complete()}}),function(){r=!0}})},of:function(){for(var t=0,n=arguments.length,r=Array(n);t<n;)r[t]=arguments[t++];return new("function"==typeof this?this:w)(function(t){var n=!1;return u(function(){if(!n){for(var e=0;e<r.length;++e)if(t.next(r[e]),n)return;t.complete()}}),function(){n=!0}})}}),h(w.prototype,c,function(){return this}),e(e.G,{Observable:w}),r(74)("Observable")},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.set;e.exp({defineMetadata:function(t,n,r,e){u(t,n,i(r),o(e))}})},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.map,c=e.store;e.exp({deleteMetadata:function(t,n){var r=arguments.length<3?void 0:o(arguments[2]),e=u(i(n),r,!1);if(void 0===e||!e.delete(t))return!1;if(e.size)return!0;var f=c.get(n);return f.delete(r),!!f.size||c.delete(n)}})},function(t,n,r){var e=r(185),i=r(161),o=r(54),u=r(2),c=r(32),f=o.keys,a=o.key,s=function(t,n){var r=f(t,n),o=c(t);if(null===o)return r;var u=s(o,n);return u.length?r.length?i(new e(r.concat(u))):u:r};o.exp({getMetadataKeys:function(t){return s(u(t),arguments.length<2?void 0:a(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.get,f=e.key,a=function(t,n,r){if(u(t,n,r))return c(t,n,r);var e=o(n);return null!==e?a(t,e,r):void 0};e.exp({getMetadata:function(t,n){return a(t,i(n),arguments.length<3?void 0:f(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.keys,u=e.key;e.exp({getOwnMetadataKeys:function(t){
return o(i(t),arguments.length<2?void 0:u(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.get,u=e.key;e.exp({getOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.key,f=function(t,n,r){if(u(t,n,r))return!0;var e=o(n);return null!==e&&f(t,e,r)};e.exp({hasMetadata:function(t,n){return f(t,i(n),arguments.length<3?void 0:c(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.has,u=e.key;e.exp({hasOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(26),u=e.key,c=e.set;e.exp({metadata:function(t,n){return function(r,e){c(t,n,(void 0!==e?i:o)(r),u(e))}}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Set",{toJSON:r(165)("Set")})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!0);e(e.P,"String",{at:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(46),o=r(16),u=r(122),c=r(120),f=RegExp.prototype,a=function(t,n){this._r=t,this._s=n};r(139)(a,"RegExp String",function(){var t=this._r.exec(this._s);return{value:t,done:null===t}}),e(e.P,"String",{matchAll:function(t){if(i(this),!u(t))throw TypeError(t+" is not a regexp!");var n=String(this),r="flags"in f?String(t.flags):c.call(t),e=new RegExp(t.source,~r.indexOf("g")?r:"g"+r);return e.lastIndex=o(t.lastIndex),new a(e,n)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padEnd:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padStart:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!0)}})},function(t,n,r){"use strict";r(82)("trimLeft",function(t){return function(){return t(this,1)}},"trimStart")},function(t,n,r){"use strict";r(82)("trimRight",function(t){return function(){return t(this,2)}},"trimEnd")},function(t,n,r){r(153)("asyncIterator")},function(t,n,r){r(153)("observable")},function(t,n,r){var e=r(1);e(e.S,"System",{global:r(3)})},function(t,n,r){for(var e=r(155),i=r(28),o=r(3),u=r(27),c=r(80),f=r(7),a=f("iterator"),s=f("toStringTag"),l=c.Array,h=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],v=0;v<5;v++){var p,d=h[v],y=o[d],g=y&&y.prototype;if(g){g[a]||u(g,a,l),g[s]||u(g,s,d),c[d]=l;for(p in e)g[p]||i(g,p,e[p],!0)}}},function(t,n,r){var e=r(1),i=r(151);e(e.G+e.B,{setImmediate:i.set,clearImmediate:i.clear})},function(t,n,r){var e=r(3),i=r(1),o=r(121),u=r(207),c=e.navigator,f=!!c&&/MSIE .\./.test(c.userAgent),a=function(t){return f?function(n,r){return t(o(u,[].slice.call(arguments,2),"function"==typeof n?n:Function(n)),r)}:t};i(i.G+i.B+i.F*f,{setTimeout:a(e.setTimeout),setInterval:a(e.setInterval)})},function(t,n,r){r(330),r(269),r(271),r(270),r(273),r(275),r(280),r(274),r(272),r(282),r(281),r(277),r(278),r(276),r(268),r(279),r(283),r(284),r(236),r(238),r(237),r(286),r(285),r(256),r(266),r(267),r(257),r(258),r(259),r(260),r(261),r(262),r(263),r(264),r(265),r(239),r(240),r(241),r(242),r(243),r(244),r(245),r(246),r(247),r(248),r(249),r(250),r(251),r(252),r(253),r(254),r(255),r(317),r(322),r(329),r(320),r(312),r(313),r(318),r(323),r(325),r(308),r(309),r(310),r(311),r(314),r(315),r(316),r(319),r(321),r(324),r(326),r(327),r(328),r(231),r(233),r(232),r(235),r(234),r(220),r(218),r(224),r(221),r(227),r(229),r(217),r(223),r(214),r(228),r(212),r(226),r(225),r(219),r(222),r(211),r(213),r(216),r(215),r(230),r(155),r(302),r(307),r(184),r(303),r(304),r(305),r(306),r(287),r(183),r(185),r(186),r(342),r(331),r(332),r(337),r(340),r(341),r(335),r(338),r(336),r(339),r(333),r(334),r(288),r(289),r(290),r(291),r(292),r(295),r(293),r(294),r(296),r(297),r(298),r(299),r(301),r(300),r(343),r(369),r(372),r(371),r(373),r(374),r(370),r(375),r(376),r(354),r(357),r(353),r(351),r(352),r(355),r(356),r(346),r(368),r(377),r(345),r(347),r(349),r(348),r(350),r(359),r(360),r(362),r(361),r(364),r(363),r(365),r(366),r(367),r(344),r(358),r(380),r(379),r(378),t.exports=r(52)},function(t,n){function r(t,n){if("string"==typeof n)return t.insertAdjacentHTML("afterend",n);var r=t.nextSibling;return r?t.parentNode.insertBefore(n,r):t.parentNode.appendChild(n)}t.exports=r},,,,,,,,,function(t,n,r){(function(n,r){!function(n){"use strict";function e(t,n,r,e){var i=n&&n.prototype instanceof o?n:o,u=Object.create(i.prototype),c=new p(e||[]);return u._invoke=s(t,r,c),u}function i(t,n,r){try{return{type:"normal",arg:t.call(n,r)}}catch(t){return{type:"throw",arg:t}}}function o(){}function u(){}function c(){}function f(t){["next","throw","return"].forEach(function(n){t[n]=function(t){return this._invoke(n,t)}})}function a(t){function n(r,e,o,u){var c=i(t[r],t,e);if("throw"!==c.type){var f=c.arg,a=f.value;return a&&"object"==typeof a&&m.call(a,"__await")?Promise.resolve(a.__await).then(function(t){n("next",t,o,u)},function(t){n("throw",t,o,u)}):Promise.resolve(a).then(function(t){f.value=t,o(f)},u)}u(c.arg)}function e(t,r){function e(){return new Promise(function(e,i){n(t,r,e,i)})}return o=o?o.then(e,e):e()}"object"==typeof r&&r.domain&&(n=r.domain.bind(n));var o;this._invoke=e}function s(t,n,r){var e=P;return function(o,u){if(e===F)throw new Error("Generator is already running");if(e===M){if("throw"===o)throw u;return y()}for(r.method=o,r.arg=u;;){var c=r.delegate;if(c){var f=l(c,r);if(f){if(f===A)continue;return f}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(e===P)throw e=M,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);e=F;var a=i(t,n,r);if("normal"===a.type){if(e=r.done?M:j,a.arg===A)continue;return{value:a.arg,done:r.done}}"throw"===a.type&&(e=M,r.method="throw",r.arg=a.arg)}}}function l(t,n){var r=t.iterator[n.method];if(r===g){if(n.delegate=null,"throw"===n.method){if(t.iterator.return&&(n.method="return",n.arg=g,l(t,n),"throw"===n.method))return A;n.method="throw",n.arg=new TypeError("The iterator does not provide a 'throw' method")}return A}var e=i(r,t.iterator,n.arg);if("throw"===e.type)return n.method="throw",n.arg=e.arg,n.delegate=null,A;var o=e.arg;return o?o.done?(n[t.resultName]=o.value,n.next=t.nextLoc,"return"!==n.method&&(n.method="next",n.arg=g),n.delegate=null,A):o:(n.method="throw",n.arg=new TypeError("iterator result is not an object"),n.delegate=null,A)}function h(t){var n={tryLoc:t[0]};1 in t&&(n.catchLoc=t[1]),2 in t&&(n.finallyLoc=t[2],n.afterLoc=t[3]),this.tryEntries.push(n)}function v(t){var n=t.completion||{};n.type="normal",delete n.arg,t.completion=n}function p(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(h,this),this.reset(!0)}function d(t){if(t){var n=t[w];if(n)return n.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var r=-1,e=function n(){for(;++r<t.length;)if(m.call(t,r))return n.value=t[r],n.done=!1,n;return n.value=g,n.done=!0,n};return e.next=e}}return{next:y}}function y(){return{value:g,done:!0}}var g,b=Object.prototype,m=b.hasOwnProperty,x="function"==typeof Symbol?Symbol:{},w=x.iterator||"@@iterator",S=x.asyncIterator||"@@asyncIterator",_=x.toStringTag||"@@toStringTag",O="object"==typeof t,E=n.regeneratorRuntime;if(E)return void(O&&(t.exports=E));E=n.regeneratorRuntime=O?t.exports:{},E.wrap=e;var P="suspendedStart",j="suspendedYield",F="executing",M="completed",A={},N={};N[w]=function(){return this};var T=Object.getPrototypeOf,I=T&&T(T(d([])));I&&I!==b&&m.call(I,w)&&(N=I);var k=c.prototype=o.prototype=Object.create(N);u.prototype=k.constructor=c,c.constructor=u,c[_]=u.displayName="GeneratorFunction",E.isGeneratorFunction=function(t){var n="function"==typeof t&&t.constructor;return!!n&&(n===u||"GeneratorFunction"===(n.displayName||n.name))},E.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,c):(t.__proto__=c,_ in t||(t[_]="GeneratorFunction")),t.prototype=Object.create(k),t},E.awrap=function(t){return{__await:t}},f(a.prototype),a.prototype[S]=function(){return this},E.AsyncIterator=a,E.async=function(t,n,r,i){var o=new a(e(t,n,r,i));return E.isGeneratorFunction(n)?o:o.next().then(function(t){return t.done?t.value:o.next()})},f(k),k[_]="Generator",k.toString=function(){return"[object Generator]"},E.keys=function(t){var n=[];for(var r in t)n.push(r);return n.reverse(),function r(){for(;n.length;){var e=n.pop();if(e in t)return r.value=e,r.done=!1,r}return r.done=!0,r}},E.values=d,p.prototype={constructor:p,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=g,this.done=!1,this.delegate=null,this.method="next",this.arg=g,this.tryEntries.forEach(v),!t)for(var n in this)"t"===n.charAt(0)&&m.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=g)},stop:function(){this.done=!0;var t=this.tryEntries[0],n=t.completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(t){function n(n,e){return o.type="throw",o.arg=t,r.next=n,e&&(r.method="next",r.arg=g),!!e}if(this.done)throw t;for(var r=this,e=this.tryEntries.length-1;e>=0;--e){var i=this.tryEntries[e],o=i.completion;if("root"===i.tryLoc)return n("end");if(i.tryLoc<=this.prev){var u=m.call(i,"catchLoc"),c=m.call(i,"finallyLoc");if(u&&c){if(this.prev<i.catchLoc)return n(i.catchLoc,!0);if(this.prev<i.finallyLoc)return n(i.finallyLoc)}else if(u){if(this.prev<i.catchLoc)return n(i.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return n(i.finallyLoc)}}}},abrupt:function(t,n){for(var r=this.tryEntries.length-1;r>=0;--r){var e=this.tryEntries[r];if(e.tryLoc<=this.prev&&m.call(e,"finallyLoc")&&this.prev<e.finallyLoc){var i=e;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=n&&n<=i.finallyLoc&&(i=null);var o=i?i.completion:{};return o.type=t,o.arg=n,i?(this.method="next",this.next=i.finallyLoc,A):this.complete(o)},complete:function(t,n){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&n&&(this.next=n),A},finish:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),v(r),A}},catch:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.tryLoc===t){var e=r.completion;if("throw"===e.type){var i=e.arg;v(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,n,r){return this.delegate={iterator:d(t),resultName:n,nextLoc:r},"next"===this.method&&(this.arg=g),A}}}("object"==typeof n?n:"object"==typeof window?window:"object"==typeof self?self:this)}).call(n,function(){return this}(),r(158))}])</script><script src="/./main.0cf68a.js"></script><script>!function(){!function(e){var t=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(t),t.setAttribute("src",e)}("/slider.e37972.js")}()</script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
      
      
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">所有文章</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'friends')"><a href="javascript:void(0)" q-class="active:friends">友链</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">关于我</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">杂项</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">机器学习与机器视觉</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">电路设计</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">测试</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">电赛笔记</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">随笔</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">stm32</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">C语言进阶</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">ESP32</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">IoT</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">嵌入式Linux</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">FPGA</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、请确保node版本大于6.2<br/>2、在博客根目录（注意不是yilia根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            3、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: false
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    
    	<section class="tools-section tools-section-friends" q-show="friends">
  		
        <ul class="search-ul">
          
            <li class="search-li">
              <a href="https://dawncraft.cc/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>软院全栈dalao</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>广告位招租</a>
            </li>
          
        </ul>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">这个天天摸鱼的微电人，&lt;br/&gt;  二刺螈（迫真），&lt;br/&gt;  因为学不懂编程改行硬件的菜b，&lt;br/&gt;  是谁呢？&lt;br/&gt;  没错就是我(即答)</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>