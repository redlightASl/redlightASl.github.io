<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="https://redlightasl.github.io">
  <title>红光今天吃什么</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="想搞FPGA的微电人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="红光今天吃什么">
<meta property="og:url" content="https://redlightasl.github.io/page/2/">
<meta property="og:site_name" content="红光今天吃什么">
<meta property="og:description" content="想搞FPGA的微电人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="RedlightASl">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="红光今天吃什么" type="application/atom+xml">
  
  
    <link rel="icon" href="/assets/favicon.png">
  
  <link rel="stylesheet" type="text/css" href="/./main.0cf68a.css">
  <style type="text/css">
  
    #container.show {
      background: linear-gradient(200deg,#f3c4ef,#a0cfe4);
    }
  </style>
  

  

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      
<div class="overlay" style="background: #9400d3"></div>
<!-- 左侧边栏（上半部分）不设置背景颜色 -->
<!-- <div class="overlay" > -->
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="/assets/Patchouli.jpg" class="js-avatar">
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/"></a></h1>
		</hgroup>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/tags/%E9%9A%8F%E7%AC%94/">随笔</a></li>
	        
			</ul>
		</nav>
		<!-- <nav> -->
			<!-- 总文章数 37 -->
		<!-- </nav>		 -->
		<nav class="header-smart-menu">
    		
    			
    			<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'friends')" href="javascript:void(0)">友链</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">关于我</a>
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/redlightASl" title="github"><i class="icon-github"></i></a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/redlightasl" title="zhihu"><i class="icon-zhihu"></i></a>
		        
					<a class="bilibili" target="_blank" href="https://space.bilibili.com/12073240" title="bilibili"><i class="icon-bilibili"></i></a>
		        
					<a class="mail" target="_blank" href="mailto:dddbbbdd@foxmail.com" title="mail"><i class="icon-mail"></i></a>
		        
					<a class="twitter" target="_blank" href="https://twitter.com/Redligh34025775" title="twitter"><i class="icon-twitter"></i></a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #9400d3"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="/assets/Patchouli.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author"></h1>
			</hgroup>
			
			
			
				
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/redlightASl" title="github"><i class="icon-github"></i></a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/redlightasl" title="zhihu"><i class="icon-zhihu"></i></a>
			        
						<a class="bilibili" target="_blank" href="https://space.bilibili.com/12073240" title="bilibili"><i class="icon-bilibili"></i></a>
			        
						<a class="mail" target="_blank" href="mailto:dddbbbdd@foxmail.com" title="mail"><i class="icon-mail"></i></a>
			        
						<a class="twitter" target="_blank" href="https://twitter.com/Redligh34025775" title="twitter"><i class="icon-twitter"></i></a>
			        
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 50%">
				
				
					<li style="width: 50%"><a href="/">主页</a></li>
		        
					<li style="width: 50%"><a href="/tags/%E9%9A%8F%E7%AC%94/">随笔</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1" class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            
  
    <article id="post-OpenWrt简单软件配置" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/19/OpenWrt%E7%AE%80%E5%8D%95%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/">OpenWrt简单软件配置</a>
    </h1>
  

        
<!-- 显示阅读次数-->
<!--  -->
<!--显示阅读次数完毕 -->

        
        <a href="/2021/11/19/OpenWrt%E7%AE%80%E5%8D%95%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/" class="archive-article-date">
  	<time datetime="2021-11-19T07:59:33.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2021-11-19</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="OpenWrt软件配置"><a href="#OpenWrt软件配置" class="headerlink" title="OpenWrt软件配置"></a>OpenWrt软件配置</h1><p>上一篇讲述过如何在硬件设备中部署OpenWrt并进行基础的网络使用，这里重点介绍OpenWrt的软件配置</p>
<h2 id="配置路由器"><a href="#配置路由器" class="headerlink" title="配置路由器"></a>配置路由器</h2><p>在笔者的项目中，需要实现以下功能：</p>
<ul>
<li>可以通过WAN口连接外网</li>
<li>可以通过连接互联网下载软件包</li>
<li>通过LAN口连接的设备直接可以直接在静态地址基础上建立tcp连接</li>
<li>内网设备可以通过路由器连接互联网</li>
</ul>
<p>因此选择了对内（LAN口之间）配置为交换机模式，对外（WAN口）配置为路由器模式</p>
<p>通过luci界面就可以很方便地进行配置，这就是折腾OpenWrt的优势——有点折腾但不是太折腾。</p>
<p>基本步骤如下：</p>
<ol>
<li><p>重置所有端口为默认状态</p>
</li>
<li><p>设置当前连接LAN口的IP地址、子网掩码等参数（192.168.0.1、255.255.255.0，老生常谈的东西）</p>
</li>
<li><p>重启OpenWrt设备并确保以自己设置的LAN口ip能ping通</p>
</li>
<li><p>切到“交换机”界面，如下图所示和指导进行配置</p>
<p> 其中Port 1、2、3、4都是LAN口，Port5是WAN口</p>
<p> 将第一行Port1、2、3、4都设置为<strong>不关联</strong>；将第一行Port5设置为<strong>关</strong>；将第二行Port1、2、3、4都设置为<strong>关</strong>；将第二行Port5设置为<strong>不关联</strong>；将两行的CPU（eth0）都设置为<strong>关联</strong></p>
<p> 这是为了划分出两个VLAN，便于服务器联网</p>
<p> <img src="/2021/11/19/OpenWrt%E7%AE%80%E5%8D%95%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/image-20210929003040969.png" alt="image-20210929003040969"></p>
</li>
<li><p>切换到OpenWrt设置界面，调整防火墙策略，关闭所有LAN口的防火墙，只保留WAN口的防火墙；同时注意不要保留LAN口上的“桥接”</p>
</li>
<li><p>设置完毕，保存退出重启即可</p>
</li>
</ol>
<blockquote>
<p>这一套操作花了我将近三天时间，从中得出最好的经验就是有图形界面的情况下千万不要去动配置文件，否则会死得很惨——天知道你什么时候就把文件改炸了——而且一定要<strong>记得备份！记得备份！记得备份！</strong></p>
<p>同时需要注意：这个方法仅适用于连接到LAN口的设备使用静态ip并且<strong>静态ip一定要设置在同一个网段内</strong>，否则很容易ping不通，因为dhcp服务器会完全随机地在网段内分配ip，如果连接到的设备内部ip已经被占用，很可能会导致无法分配ip或查找不到对应ip</p>
</blockquote>
<h2 id="网络摄像头"><a href="#网络摄像头" class="headerlink" title="网络摄像头"></a>网络摄像头</h2><p>如果想要在OpenWrt上搭载网络摄像头，需要提前安装一下内核驱动和软件包：</p>
<ul>
<li>usbutils：用于lsusb命令支持，使用它可查看USB摄像头是否已经接入</li>
<li>kmod-i2c-core：IIC总线驱动，用于支持数字摄像头的SCCB总线</li>
<li>kmod-video-core、kmod-video-uvc、kmod-video-videobuf2、libv4l：免驱摄像头必须安装的驱动库</li>
<li>mjpg-streamer：使用该软件进行推流</li>
</ul>
<p>如果OpenWrt版本较新，可以考虑使用luci-app-mjpg-streamer，这是mjpg-streamer的luci界面支持软件，可以更方便的在luci界面中进行mjpg-streamer的配置</p>
<p>连接usb摄像头（最好是免驱摄像头），使用<code>lsusb</code>，查看设备是否连接成功</p>
<p>使用指令 <code>ls /dev/</code>查看里面是否存在video开头的设备</p>
<p>修改<code>/etc/config/mjpg-streamer</code>来配置软件参数</p>
<p>配置完成后，只需要使用<code>/etc/init.d/mjpg-streamer start</code>运行程序就可以进行推流</p>
<p>默认使用设备的8080端口，ip地址根据设备地址变化，例如打开<code>http://192.168.1.1:8080/?action=stream</code>访问摄像头图像</p>
<blockquote>
<p>项目中最后并没有采用这个方案</p>
<p>原因是设备硬件无法兼容Linux的摄像头内核驱动，或者说：19.04版本的驱动得不到兼容，但可以安装mjpg-streamer；14.08版本的驱动可以兼容，但是无法安装mjpg-streamer和负责串口转发的ser2net软件。为了保证设备的基本运行，不得不将摄像头转移到了另一个嵌入式linux平台，串口转发倒是挺正常的——虽然说也给我造成了很大麻烦</p>
</blockquote>
<h2 id="网口-串口转发"><a href="#网口-串口转发" class="headerlink" title="网口-串口转发"></a>网口-串口转发</h2><p><code>ser2net</code>是一个Linux下常用的TCP-串口透传应用程序，使用<code>sudo apt install ser2net</code>即可安装</p>
<p>通过修改<code>/etc/ser2net.conf</code>进行配置</p>
<p>基本参数如下：</p>
<ul>
<li><strong>最高支持115200波特率</strong></li>
<li>支持tcp报文（字节）、telnet协议通讯</li>
<li>根据硬件可支持硬件流控来驱动rs485总线</li>
</ul>
<p>在它的配置文件里头部会标注很多内容，其中参数说明就在头部注释的最后一段</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">            Sets  operational  parameters  <span class="keyword">for</span> the serial port.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            Options 300, 1200, 2400, 4800, 9600, 19200, 38400,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            57600, 115200 <span class="built_in">set</span> the various baud rates.  EVEN,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            ODD, NONE <span class="built_in">set</span> the parity.  1STOPBIT, 2STOPBITS <span class="built_in">set</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">            the number of stop bits.  7DATABITS, 8DATABITS <span class="built_in">set</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">            the number of data bits.  [-]XONXOFF turns on (-</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            off) XON/XOFF support.  [-]RTSCTS turns on (- off)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            hardware flow control, [-]LOCAL turns off (- on)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            monitoring of the modem lines, and</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            [-]HANGUP_WHEN_DONE turns on (- off) lowering the</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            modem control lines when the connextion is <span class="keyword">done</span>.</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">            NOBREAK disables automatic setting of the <span class="built_in">break</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">            setting of the serial port.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            The <span class="string">&quot;remctl&quot;</span> option allow remote control (ala RFC</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            2217) of serial-port configuration.  A banner name</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            may also be specified, that banner will be printed</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            <span class="keyword">for</span> the line.  If no banner is given, <span class="keyword">then</span> no</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            banner is printed.</span></span><br></pre></td></tr></table></figure>

<p>使用示例如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1234:raw:0:/dev/ttyS0:115200 8DATABITS NONE 1STOPBIT -RTSCTS -XONXOFF LOCAL</span><br></pre></td></tr></table></figure>

<p>使用1234端口以TCP报文的形式转发ttyS0收到的串口数据，串口配置为115200波特率、8数据位、无奇偶校验位、1停止位、关闭硬件流控</p>
<p>之后将其添加到<code>/etc/rc.local</code>中即可实现开机自启</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sbin/ser2net -c /etc/ser2net.conf &amp;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>笔者在初次使用该程序时，为了追求效率将串口波特率拉到了921600，发现上传数据一直出错，但是一直没有怀疑是串口软件的问题，排查了将近一周才发现这个软件<strong>不支持115200以上波特率</strong>串口的转发</p>
<p>这个问题也经常被大家忽视——很多低性能设备默认串口速率较低，不会提供更高速串口的支持。如果在需要高速转发的情况下，很可能就必须要换用其他协议或者选择性地放弃部分速度</p>
<p>在笔者的项目里，为了节省改动时间，就直接把串口速率降低到了115200</p>
</blockquote>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">IoT</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2021/11/19/OpenWrt%E7%AE%80%E5%8D%95%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-Socket简介" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/19/Socket%E7%AE%80%E4%BB%8B/">Socket简介</a>
    </h1>
  

        
<!-- 显示阅读次数-->
<!--  -->
<!--显示阅读次数完毕 -->

        
        <a href="/2021/11/19/Socket%E7%AE%80%E4%BB%8B/" class="archive-article-date">
  	<time datetime="2021-11-19T07:58:38.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2021-11-19</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><p>Socket即<strong>套接字</strong>，是由UNIX系统开发的网络通信接口，该接口API被纳入了POSIX标准，所有兼容POSIX的操作系统都可以使用该系列API，所以它成为了<strong>网络应用开发时最常用的API</strong></p>
<h2 id="Socket简介"><a href="#Socket简介" class="headerlink" title="Socket简介"></a>Socket简介</h2><p>Socket套接字是位于应用层和传输层之间的POSIX接口，应用程序可以直接通过Socket进行网络通信，然后由Socket将数据传递到传输层，Socket因此可以像文件一样以打开、读写、关闭的方式实现网络通信，这也是UNIX万物皆文件的思想体现。同时标准化的Socket接口使得应用程序具有良好的可移植性，目前不仅仅是Linux，一些RTOS像FreeRTOS、RT-Thread、uCOS和一些具有网络功能的SoC都实现了Socket API</p>
<p>需要注意：<strong>Socket和Websocket并不是一个东西</strong>，Socket是工作在传输控制层的应用程序接口，WebSocket则是一个应用层协议。Socket将协议簇下层的内容封装起来供上层应用程序调用；而WebSocket作为一个成熟的连接应用解决方案可以单独工作或与其他应用程序共同使用</p>
<h2 id="Socket-API简介"><a href="#Socket-API简介" class="headerlink" title="Socket API简介"></a>Socket API简介</h2><h3 id="创建socket描述符"><a href="#创建socket描述符" class="headerlink" title="创建socket描述符"></a>创建socket描述符</h3><p>根据属性设置创建Socket描述符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> protofamily, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数返回Socket描述符，这是一个int类型的数值，所有socket操作都基于描述符进行</p>
<p>其中protofamily表示协议簇，一般使用</p>
<ul>
<li>AF_INET：IPv4，使用32位IPv4地址与16位端口号组合</li>
<li>AF_INET6：IPv6，使用IPv6地址与端口号组合</li>
<li>AF_LOCAL（AF_UNIX）：UNIX域Socket，使用一个绝对路径作为地址</li>
<li>AF_ROUTE</li>
</ul>
<p>协议簇决定了Socket的地址类型，设置之后在通信中必须采用对应的地址</p>
<p>type则表示socket的类型，常用下面几种：</p>
<ul>
<li>SOCK_STREAM</li>
<li>SOCK_DGRAM</li>
<li>SOCK_RAW</li>
<li>SOCK_PACKET</li>
<li>SOCK_SEQPACKET</li>
</ul>
<p>protocol表示指定使用某传输协议，常用协议包括</p>
<ul>
<li>IPPROTO_TCP：TCP协议</li>
<li>IPPROTO_UDP：UDP协议</li>
<li>IPPROTO_SCTP：SCTP协议</li>
<li>IPPROTO_TIPC：TIPC协议</li>
</ul>
<p>注意：<strong>type和protocol不能随意组合</strong>，当protocol为0（NULL）时会自动选择type对应的默认协议</p>
<p>调用该函数创建一个Socket后，返回的套接字描述符描述它存在于某个对应协议簇空间中，并没有一个具体的地址，需要使用bind函数才能赋予描述符一个地址（即端口号），否则当调用connect()、listen()等函数时操作系统会自动随机分配一个端口给套接字</p>
<h3 id="绑定唯一端口号"><a href="#绑定唯一端口号" class="headerlink" title="绑定唯一端口号"></a>绑定唯一端口号</h3><p>每个应用程序想要使用网络功能，都要指定唯一的一个端口号，在Socket标准API中使用bind()函数为套接字绑定一个端口号，不过这个操作并不是必须的，在应用程序未使用bind指定端口号时，操作系统会自动分配一个随机的端口号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数返回int类型的指示符，如果为0则表示bind执行成功，返回<code>EADDRINUSE</code>表示端口号已被其他应用程序占用</p>
<p>参数中的sockfd就是通过socket()函数获得的socket描述符</p>
<p>addr则是指向要绑定给socket的协议地址的指针，这个地址结构体会根据地址创建socket时指定使用的地址协议簇的不同而不同：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IPv4</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>	 	sin_familt;		<span class="comment">/* AF_INET地址协议簇 */</span></span><br><span class="line">    <span class="keyword">in_port_t</span>	 	sin_port; 		<span class="comment">/* 在网络字节序中的端口 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> 	<span class="title">sin_addr</span>;</span> 		<span class="comment">/* 网络地址结构体 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其中网络地址结构体如下所示</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>	 	s_addr; 		<span class="comment">/* 网络地址字节序中的地址 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IPv6</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>	 	sin6_familt;	<span class="comment">/* AF_INET6地址协议簇 */</span></span><br><span class="line">    <span class="keyword">in_port_t</span>	 	sin6_port;		<span class="comment">/* 在网络字节序中的端口 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> 		sin6_flowinfo;  <span class="comment">/* IPv6流信息 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> 		sin6_scope_id;  <span class="comment">/* Scope ID */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>		<span class="comment">/* 网络地址结构体 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其中网络地址结构体如下所示</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>	s6_addr[<span class="number">16</span>];	<span class="comment">/* IPv6地址 */</span>    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//UNIX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNIX_PATH_MAX 108</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> 	sun_family;		<span class="comment">/* AF_UNIX地址协议簇 */</span></span><br><span class="line">    <span class="keyword">char</span> 			sun_path[UNIX_PATH_MAX];	<span class="comment">/* 路径名 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中addrlen代表地址长度，也根据地址协议簇决定</p>
<h3 id="启动连接"><a href="#启动连接" class="headerlink" title="启动连接"></a>启动连接</h3><p>客户端会使用connect()函数来启用一个Socket连接，在使用TCP时，客户端需要连接到TCP服务器，成功后才能继续通信</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数返回0表示connect成功，否则返回错误码，错误码有以下几种：</p>
<ul>
<li>ETIMEDOUT：TCP客户端没有收到SYN分节相应</li>
<li>ECONNREFUSED：服务器主机在客户端指定的端口上没有进程在等待与之连接，属于发生硬错误（hard error）</li>
<li>EHOSTUNREACH或ENETUNREACH：客户端发出的SYN在中间某个路由器上引发了一个“目标地不可达”（destination unreachable）的ICMP错误，属于发生软错误（soft error）</li>
</ul>
<p>参数中sockfd为Socket描述符，addr表示绑定给sockfd的协议地址指针，addrlen为地址长度</p>
<h3 id="监听Socket"><a href="#监听Socket" class="headerlink" title="监听Socket"></a>监听Socket</h3><p>如果是作为服务器，在调用socket()和bind()后，会<strong>调用listen()来监听当前Socket</strong>，调用成功后<strong>如果有客户端调用connect()发起连接请求，服务器就会接收到这个请求</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数返回0表示成功，返回-1表示出错</p>
<p>参数中sockfd依旧为Socket描述符</p>
<p>backlog表示未完成连接队列和已完成连接队列的总和的最大值</p>
<p>内核会给任何给定的监听Socket套接字维护两个队列（FIFO），一个是客户端已经发出连接请求，而服务器正在等待完成响应的TCP三次握手过程队列（TCP三次握手模型为了解决在不可靠信道上建立可靠连接，一个直观的例子就是——客户端请求建立传输，请确认！收到，服务器允许建立传输，请确认！收到，可以建立传输！——三次握手就是发送三次包的过程，可以有效防止错误地建立不必要的传输，不过因此会导致一定延迟，计算机为了进行三次握手要在FIFO中缓存当前握手信息，这就占用了未完成连接队列）；另一个是已经完成三次握手，连接成功的客户端队列</p>
<p>一般来说对于专用服务器，这个数值应该定义得较大，即使超过操作系统内核能支持的最大值也无妨，操作系统会自动将偏大值改成自身支持的最大值</p>
<h3 id="处理连接"><a href="#处理连接" class="headerlink" title="处理连接"></a>处理连接</h3><p>由服务器调用accept()函数来<strong>处理</strong>从已完成连接队列对头返回的<strong>下一个已完成连接</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果服务器与客户端正确建立连接，accept()函数会返回一个全新的Socket套接字，服务器通过这个新的套接字来和客户端进行通信</p>
<p>里面的参数都和之前的一样，这里不再赘述</p>
<h3 id="收发Socket网络数据"><a href="#收发Socket网络数据" class="headerlink" title="收发Socket网络数据"></a>收发Socket网络数据</h3><p>使用read和write函数族来从网络收发数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, </span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">int</span> flags, <span class="keyword">const</span> struct sockaddr * dest_addr, <span class="keyword">socklen_t</span> adrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, </span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">int</span> flags, struct sockaddr * src_addr, <span class="keyword">socklen_t</span> adrlen)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct msghdr *msg, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvmsg</span><span class="params">(<span class="keyword">int</span> sockfd, struct msghdr *msg, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p>read系列函数将套接字视为文件，从套接字描述符中读取内容到缓存buf，读成功时，read返回实际所读的字节数，如果返回值为0，则表示已经读到文件末尾，小于0则表示出现错误，如果错误为EINTR，说明读错误是由中断引起 ，如果是ECONNREST，表示网络连接出现问题</p>
<p>write系列函数将buf中的nbytes字节内容写入套接字描述符，成功时返回写的字节数；失败时返回-1，并设置errno变量。入股write返回值大于0，表示写了部分或全部数据；如果返回值小于0，则表示出现错误，如果是EINTR则表示由中断引起；如果是EPIPE，表示网络连接出现问题（对方已关闭连接）</p>
<h3 id="关闭Socket"><a href="#关闭Socket" class="headerlink" title="关闭Socket"></a>关闭Socket</h3><p>使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>

<p>关闭套接字并终止TCP连接</p>
<p>该函数实际上的作用是将某个socket标记为已关闭并立即返回到调用进程。被关闭的描述字不能再由调用进程使用，也就是不能再作为read或write的第一个参数</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">IoT</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2021/11/19/Socket%E7%AE%80%E4%BB%8B/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-OpenWrt与嵌入式Linux" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/19/OpenWrt%E4%B8%8E%E5%B5%8C%E5%85%A5%E5%BC%8FLinux/">OpenWrt与嵌入式Linux</a>
    </h1>
  

        
<!-- 显示阅读次数-->
<!--  -->
<!--显示阅读次数完毕 -->

        
        <a href="/2021/11/19/OpenWrt%E4%B8%8E%E5%B5%8C%E5%85%A5%E5%BC%8FLinux/" class="archive-article-date">
  	<time datetime="2021-11-19T07:56:34.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2021-11-19</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="OpenWrt与嵌入式Linux"><a href="#OpenWrt与嵌入式Linux" class="headerlink" title="OpenWrt与嵌入式Linux"></a>OpenWrt与嵌入式Linux</h1><p>由于要接手学长留下来的一个项目，“被迫”要学习OpenWrt的配置方法——虽然对于一个five电工来说这事挺莫名其妙的，但还是硬着头皮上吧（我本想拒绝，但他给的是在太多了）</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在<a target="_blank" rel="noopener" href="https://openwrt.org/">官网</a>中这样描述OpenWrt</p>
<blockquote>
<p>OpenWrt项目是一个针对嵌入式设备的Linux操作系统。OpenWrt不是一个单一且不可更改的固件，而是提供了具有软件包管理功能的完全可写的文件系统。这使您可以从供应商提供的应用范围和配置中解脱出来，并且让您通过使用适配任何应用的软件包来定制设备。对于开发人员来说，OpenWrt是一个无需围绕它构建完整固件就能开发应用程序的框架; 对于普通用户来说，这意味着拥有了完全定制的能力，能以意想不到的方式使用该设备。</p>
</blockquote>
<p>听上去很高大上，实际上OpenWrt就和Ubuntu、CentOS、Raspbian等<em>GNU/Linux发行版</em>一样，是一个基于Linux内核的操作系统。只不过它具有<strong>高度模块化可定制</strong>的特点，并且自带一系列<strong>网络组件</strong>，因此常常被用于路由器、工控、智能家居、小型交换机中。笔者接手的这个项目就是基于OpenWrt实现<strong>路由器</strong>-交换机的应用，并配置一个<strong>网络摄像头</strong>和一个<strong>网口数据转串口</strong></p>
<p>OpenWrt除了以上特点外，还有一个堪称嵌入式Linux杀手锏的特性：==超级大规模的开源社区==。可能是因为大家都很喜欢软路由，OpenWrt的软件包已经达到了好几千，这让它能秒掉一堆其他的嵌入式Linux发行版</p>
<h3 id="OpenWrt与桌面Linux操作系统"><a href="#OpenWrt与桌面Linux操作系统" class="headerlink" title="OpenWrt与桌面Linux操作系统"></a>OpenWrt与桌面Linux操作系统</h3><p>可能大家无法理解OpenWrt这种发行版的独特之处，请允许我在这里为大家重新介绍一下桌面Linux操作系统</p>
<p>一般的桌面操作系统都很难在低性能的嵌入式设备上运行，这是因为两点：</p>
<ol>
<li><p>它们需要占用大量的系统资源，尤其是内存用于支持各种deamon的运行</p>
<p> 一般的GNU/Linux发行版都采用Bash乃至更人性化也更占用资源的Zshell作为终端；而OpenWrt为了适应低性能的处理器，采用更简单的<strong>Ash</strong>作为默认shell。此外，OpenWrt使用的C库是<strong>uClibc</strong>而不是glibc，这是一个面向嵌入式系统的小型C标准库，也有很多RTOS比如FreeRTOS和RT-Thread都采用了这个C库</p>
</li>
<li><p>它们的体积都比较大，一个典型的桌面操作系统占用的存储空间至少在1GB以上</p>
<p> Ubuntu已经膨胀到了2GB，Debian也往往需要占据1GB的硬盘/SD卡/Flash空间；但OpenWrt具有很强的可裁减性，其内核、驱动、自带软件都可以方便地通过menuconfig进行配置，它的运行内存最小只要32M，存放代码数据的Flash空间最小只要8M，但支持使用完备的Linux内核，支持无线、有线网络应用</p>
</li>
</ol>
<p><strong>OpenWrt牺牲了兼容性</strong>，但是由于庞大的开源社区资源，他能够<strong>对大多数网络嵌入式设备提供支持</strong></p>
<p><strong>OpenWrt优化了效率和资源占用</strong>，然而因为难以支持更高性能开销的应用导致<strong>其工作范围局限在嵌入式领域</strong></p>
<h3 id="OpenWrt与一般的嵌入式Linux"><a href="#OpenWrt与一般的嵌入式Linux" class="headerlink" title="OpenWrt与一般的嵌入式Linux"></a>OpenWrt与一般的嵌入式Linux</h3><p>一般的嵌入式Linux都具有上面所说的特点，一些介于桌面Linux操作系统和嵌入式Linux操作系统之间并经过特殊优化的操作系统如Raspbian甚至能够提供更高的性能-资源占用比，但是OpenWrt相比一般的嵌入式Linux系统具有强大的多的网络应用：</p>
<ul>
<li><p>默认自带SSH</p>
</li>
<li><p>可选的图形化网络操作界面Luci（Lua Configuration Interface）</p>
<p>  这是一个使用Lua脚本语言编写的mvc架构的web框架，包含了openwrt的配置界面和一套扩展API。安装luci-core后只要在浏览器中输入OpenWrt设备的IP地址，即可出现其登录界面，可以通过安装luci扩展app实现对OpenWrt设备方方面面的管理</p>
<p>  这个操作界面是对OpenWrt没有图形界面的有效弥补，也是它不同于其他嵌入式Linux的特殊点，这也<strong>使OpenWrt相当好上手</strong></p>
</li>
<li><p>自带软路由模块和交换机模块，可配合硬件实现软/硬件路由功能</p>
</li>
<li><p>可选搭建VPN</p>
</li>
<li><p>可运行轻量级服务器软件</p>
</li>
<li><p>可运行轻量级流量整形与捕获分析软件</p>
<p>  OpenWrt常常被用于搭建软路由，很大程度上就是因为<strong>它支持各种控制网络流量和数据包的应用扩展</strong></p>
</li>
</ul>
<p>除了以上网络特性，OpenWrt还支持嵌入式Linux所具有的基本能力，包括对POSIX的兼容和VFS等</p>
<h3 id="OpenWrt与LEDE"><a href="#OpenWrt与LEDE" class="headerlink" title="OpenWrt与LEDE"></a>OpenWrt与LEDE</h3><p>LEDE是一个源于OpenWrt的分支嵌入式Linux系统，最初一批OpenWrt开发者觉得OpenWrt规则太老套，于是fork了OpenWrt的源码，然后创建了LEDE的分支，在里面添加了很多新开发流程和新功能，然后越来越多OpenWrt开发者转移到LEDE，最后二者又在2018年合并，形成了现在的OpenWrt</p>
<p>有的时候OpenWrt源里面会注明LEDE package，其实和OpenWrt一样，把它看成OpenWrt的某个版本即可</p>
<p>官网这样<a target="_blank" rel="noopener" href="https://openwrt.org/zh/about">解释</a>：</p>
<blockquote>
<p>OpenWrt/LEDE是一个为嵌入式设备（通常是无线路由器）开发的高扩展度的GNU/Linux发行版。与许多其他路由器的发行版不同，OpenWrt是一个完全为嵌入式设备构建的功能全面、易于修改的由现代Linux内核驱动的操作系统。在实践中，这意味着您可以得到您需要的所有功能，却仍能避免臃肿。</p>
<p>在2016年，LEDE项目作为OpenWrt项目的副产品而诞生，与OpenWrt共享很多相同的目标。该项目旨在成为一个嵌入式Linux版本，能让开发者、系统管理员或其他Linux爱好者轻松的为嵌入式设备特别是无线路由器构建或定制软件。<em>LEDE</em>这一名称代表<em>Linux Embedded Development Environment</em>。</p>
<p>项目成员与OpenWrt社区活跃成员高度重合，他们计划通过建立一个高度透明、注重协作和去中心化的社区为嵌入式Linux的开发带来新生。</p>
<p>LEDE已公布的目标包括:</p>
<ul>
<li>构造一个的伟大的嵌入式Linux发行版，运行稳定且功能实用</li>
<li>伴随社区设备测试反馈，形成定期、可预期的版本迭代</li>
<li>通过广泛的社区参与和公开会议，建立透明的决策机制</li>
</ul>
<p>LEDE项目的形成是为解决那些被OpenWrt项目或社区认为无法解决的长远问题</p>
<ol>
<li> 活跃核心开发者数量一直很低，而且无法吸引新面孔加入项目。</li>
<li> 不可依赖的基础设施，内部不同意和单点故障阻碍了错误修复。</li>
<li> 在OpenWrt项目中缺少沟通交流、透明度和协调, 无论是在核心团队内部还是在核心团队和其他团队之间。</li>
<li> 没有足够拥有权限的人处理补丁来流，很少关注测试和定期版本。</li>
<li> 不重视对稳定性和文档。</li>
</ol>
<p>为解决这些问题，LEDE项目采用了与OpenWrt不同的组织架构：</p>
<ol>
<li> 所有交流频道均是公开的，对非成员只读的频道控制在一个很好的信噪比。</li>
<li> 决策过程更公开，拥有投票权的开发者和重度用户数量接近50比50。</li>
<li> 大大简化基础设施，确保减少我们的维护工作量。</li>
<li> 更开明的合并政策，基于我们在处理Github上OpenWrt软件包反馈信息的经验。</li>
<li> 高度重视与简化发布流程合并的自动化测试。</li>
</ol>
<p>2018年1月，OpenWrt和以前的LEDE项目同意以OpenWrt这一名称进行合并。</p>
<p>新的、统一的OpenWrt项目将按照 <a target="_blank" rel="noopener" href="https://openwrt.org/zh/rules">由前LEDE项目建立的章程</a> 进行管理。以前的LEDE和OpenWrt项目的积极成员将继续在统一的OpenWrt上工作。</p>
</blockquote>
<h2 id="OpenWrt慢速上手"><a href="#OpenWrt慢速上手" class="headerlink" title="OpenWrt慢速上手"></a>OpenWrt慢速上手</h2><p>之所以这部分名叫《慢速上手》，是因为笔者要从底层开始到建立OpenWrt开发环境的全过程进行梳理，至于为什么——这就是我接手这个项目时遇到的窘境：学长跑路，给我留下了一堆残缺的资料，还有一个时灵时不灵的远程支援（虽然在前期的嵌入式开发debug部分确实给我帮了很大忙，但是怎么还在我滚挂系统的时候幸灾乐祸……这对青少年造成的坏影响，不可估量），于是只能从底层开始</p>
<p>所有我遇到的问题都会在</p>
<blockquote>
<p>引用栏</p>
</blockquote>
<p>中说明，避免后来者掉到坑里</p>
<h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><p>硬件设备使用的是海凌科的MT7621模块，基于联发科7621A SoC开发</p>
<ul>
<li>MIPS架构CPU 1004Kc，双核主频880MHz</li>
<li>256MB内存，32MB片上Flash，16位DDR2</li>
<li>自带片上、板载晶振</li>
<li>3.3V、500mA工作电压电流</li>
<li>JTAG调试接口</li>
<li>双WiFi接口</li>
<li>1个WAN口，4个LAN口，全千兆</li>
<li>2路SPI、1路IIC</li>
<li>I2S、PCM等组成的音频接口</li>
<li>2路USB2.0、3.0接口</li>
<li>3路UART接口</li>
<li>GPIO引出</li>
</ul>
<h4 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h4><p>手头的MT7621 SoC带有GPIO外设，可以通过控制<strong>GPIO_MODE寄存器</strong>来使能对应引脚，默认情况下会直接将GPIO复用到其他外设。GPIO是32位的，每个寄存器控制32个IO</p>
<p>常用寄存器如下所示：</p>
<ul>
<li>GPIO_CTRL_X 方向控制寄存器，用于控制GPIO状态为1输出，0输入，2高阻态</li>
<li>GPIO_POL_X 极性控制寄存器</li>
<li>GPIO_DATA_X 数据寄存器，通过读取这个寄存器来获取当前GPIO的值</li>
<li>GPIO_DSET_X 设置寄存器，置1进行使能GPIO</li>
<li>GPIO_DCLR_X 清除寄存器，置1进行失能GPIO</li>
</ul>
<p>使用方法如下：</p>
<ol>
<li><p>登录OpenWrt，使用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reg s 0</span><br><span class="line">reg w 60 0x48258</span><br></pre></td></tr></table></figure>

<p>读取GPIO_MODE寄存器值，<strong>将要配置为GPIO的引脚位设为1</strong></p>
<p>使用<code>reg r 60</code>查看是否配置成功</p>
</li>
<li><p>对应datasheet按照寄存器顺序使用指令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg w &lt;寄存器位&gt; &lt;要写入的寄存器值&gt;</span><br></pre></td></tr></table></figure>

<p>进行配置</p>
</li>
</ol>
<p>特别地，有些系统中提供了脚本控制的方法，这会使GPIO配置异常简单：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;13&quot; &gt; /sys/class/gpio/export #要设置的引脚</span><br><span class="line">echo &quot;out&quot; &gt; /sys/class/gpio/gpio13/direction #引脚模式</span><br><span class="line">echo &quot;1&quot; &gt; /sys/class/gpio/fpio13/value #设置GPIO输出值</span><br></pre></td></tr></table></figure>

<p>当然如果你要给OpenWrt写一套串口驱动，那就必须按照Linux驱动标准来了，这里不再赘述</p>
<h4 id="SPI与IIC"><a href="#SPI与IIC" class="headerlink" title="SPI与IIC"></a>SPI与IIC</h4><p>OpenWrt是支持SPI、IIC的，只要硬件支持就可以调用这俩东西</p>
<p>相对应的驱动随设备不同而不同，甚至需要在编译时单独加入</p>
<p>特别地，很多屏幕需要使用SPI驱动；很多摄像头需要使用IIC驱动（用来支持SCCB接口），因此最好在编译内核的时候将二者添加进去（占用空间并不是很大）</p>
<h4 id="LAN口"><a href="#LAN口" class="headerlink" title="LAN口"></a>LAN口</h4><p>路由器LAN口用来连接局域网，也就是内网，路由器可以<strong>为LAN口设备提供互联网接入</strong>或<strong>将所有LAN口设备连接到一个VLAN实现交换机目的</strong></p>
<p>相关的内容等到之后的配置OpenWrt再说</p>
<h4 id="WAN口"><a href="#WAN口" class="headerlink" title="WAN口"></a>WAN口</h4><p>路由器WAN口用于连接外网，通常会通过某个外部路由器接入互联网</p>
<p>WAN口是路由器的灵魂，没有WAN口的路由器就是个死交换机，有了WAN口，它才能从外网下载程序、实现路由功能等</p>
<p>一般路由器的配置都是单WAN口多LAN口</p>
<p>这里使用的路由模块配备了1WAN口4LAN口</p>
<blockquote>
<p>很可惜，在硬件组装初期，笔者的路由器WAN口完全连不上，不仅仅无法ping通，甚至ifconfig根本看不到有这个接口</p>
<p>在这种情况下如果想安装软件包就必须使用LAN口，在路由器端使用SCP协议拉取上位机提供的软件包，然后用opkg进行安装（opkg是OpenWrt里面类似dpkg的一个软件包管理器，可以很方便地安装、更新、删除软件包、切换软件源）</p>
<p>解决方法在后文给出</p>
</blockquote>
<h4 id="网络变压器与Bob-Smith电路"><a href="#网络变压器与Bob-Smith电路" class="headerlink" title="网络变压器与Bob-Smith电路"></a>网络变压器与Bob-Smith电路</h4><p>在网络硬件设计中经常接触到RJ-45网口，现在的RJ45网口很多都自带了网络变压器，因此只要正常接入并记得使用75欧或50欧电阻进行阻抗匹配就可以了；但是对于这里的路由模块，它使用杜邦线-排针代替RJ45网口（别问为什么，问就是特殊领域），因此需要仔细设计网络变压器部分的电路，它被称为<strong>Bob-Smith电路</strong></p>
<p><img src="/2021/11/19/OpenWrt%E4%B8%8E%E5%B5%8C%E5%85%A5%E5%BC%8FLinux/image-20210817004039321.png" alt="image-20210817004039321"></p>
<p>他有如下几个关键作用：</p>
<ol>
<li><p>信号传输</p>
<p> Bob-Smith电路分为<strong>电流型</strong>和<strong>电压型</strong>，根据驱动网络变压器的是电流为主还是电压为主区分</p>
<p> 电流型：<strong>网络变压器输入侧</strong>（接PHY芯片或SoC的那一侧）<strong>需要在每个变压器抽头处上拉到电源</strong>，如果EMC要求更加严格，还会使用一个高频（75MHz-200MHz）电感跨接在抽头和电源之间，上拉电源可以是1.8、2.5、3.3等，这是为了<strong>增强网络变压器的驱动能力</strong></p>
<p> 同时需要在输入侧变压器正负端跨接50-100欧姆（常用75欧姆）的分流电阻，用于调整信号驱动强度</p>
<p> 电压型：<strong>输入侧变压器抽头接到一起再通过100nF电容到地</strong>，这是为了提高网络变压器的EMC性能；正负端则分别接入50-100欧分压电阻到PHY芯片或SoC，用于调整信号驱动强度</p>
</li>
<li><p>阻抗匹配</p>
<p> <strong>阻抗匹配</strong>：当传输路径上阻抗不连续时，会有反射发生，阻抗匹配的作用就是通过端接元器件时，保证传输路线上的阻抗连续以去除传输链路上产生的反射。</p>
<p> 网络变压器的输出端要接共模双绞线，双绞线上传输的是差分信号，因此需要使用100-150欧的阻抗匹配</p>
<p> <strong>网络变压器输出端的抽头都需要接50欧或75欧</strong>（根据线缆长度不同决定，也可以改为100欧，但25欧因为阻值太低不常用）<strong>到线缆，同时需要一个100nF的电容用于旁路</strong>（滤波）</p>
<p> 这几个电阻就起到了阻抗匹配作用，计算公式如下<br> $$<br> Z=\sqrt{R-j\frac{1}{\omega C}}<br> $$</p>
</li>
<li><p>波形修复</p>
<p> 输出端的旁路电容可以有效对外传输线路上的噪声实现滤除</p>
</li>
<li><p>抑制杂波</p>
<p> 电压型BS电路通过下拉到地的100nF滤波电容实现了滤出高频噪声的作用，而两个串联在变压器上的分压电阻配合变压器寄生电感可以提高电路对差模信号的抑制能力，从而滤除高频杂波，保证网口通信正常</p>
<p> 电流型BS电路则直接使用较高电流驱动的方式削弱从控制端输出的高频杂波影响。但是因为电流型电路会导致整体功耗较大，所以正在被电压型取代（不过在大功率信号传输的领域还是有一定应用）</p>
</li>
<li><p>隔离高压</p>
<p> 这一条也可以称为<strong>共模-差模防护</strong>，电路可以通过一系列泻放路径抵抗从网络变压器输出端而来的浪涌电压电流。</p>
<p> 具体实现出于篇幅所限不在这里列出，大致思路就是<em>共模浪涌会被变压器和输出端电阻自行抵消，最多可能付出电容被击穿的代价，并不会伤害到控制端；而差模信号会被变压器引入到输入端，之后直接通过抽头的电容或上拉电阻被滤除，能够很大程度地减少对输入端和信号的影响</em></p>
</li>
</ol>
<blockquote>
<p>在配置过程中发现：WAN口无法使用</p>
<p>重新刷入三次系统，反复调试一周后发现还是这样，基本上排除了所有可能的软件问题。于是决定回到硬件检查是否网络变压器或引脚出问题。首先用万用表通断档依次检测电容两端对地是否导通，发现WAN口的输入电容两端都对地为0——短路了；之后换用电阻档断电测量输入输出电阻，原本电路中使用75欧电阻，但测量中发现有两个电阻阻值不对，一个是偏小到50欧，另一个则无穷大。换掉电容电阻，上电接网线，成功秒杀</p>
</blockquote>
<h3 id="自定制并编译内核"><a href="#自定制并编译内核" class="headerlink" title="自定制并编译内核"></a>自定制并编译内核</h3><p><a target="_blank" rel="noopener" href="https://github.com/openwrt/openwrt">openwrt</a>整个项目在github上可以找到</p>
<p>也可以通过<a target="_blank" rel="noopener" href="https://git.openwrt.org/openwrt/openwrt.git">官方OpenWrt源码</a>下载</p>
<p>于是直接用git下载或下载压缩包到linux系统就可以使用了</p>
<p>一般来说可以使用虚拟机搭建环境，但是如果你习惯了使用桌面端linux，可以直接在你的双系统/纯linux环境中搭建openwrt的开发环境</p>
<h4 id="配环境"><a href="#配环境" class="headerlink" title="配环境"></a>配环境</h4><p>根据openwrt项目中的README文档就可以简单地配好整个环境，这里摘录一下在ubuntu20中所需要安装的一些关键软件包</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc g++ make gettext libncurses5-dev patch binutils flex bison subversion build-essential autoconf bzip2 libz-dev zlib1g-dev gawk git ccache gettext asciidoc libssl-dev sphinxsearch xsltproc sphinx-common libtool libssl-dev unzip</span><br></pre></td></tr></table></figure>

<p>安装完依赖以后还要下载一些openwrt主分支中没有加入的源代码，这些都是诸如kernel、package之类的大号源码，需要从官方<strong>对应的版本库</strong>中拉取到本地</p>
<p>这里需要注意：版本！</p>
<p>在拉取之前应该确定你想要编译的内核版本</p>
<p>常用的大版本有14、15、16、17、18、19，小版本从.1到.9不等，各个版本差异都比较大，大版本之间软件包基本是不可能通用的，小版本之间的软件包安装也存在各种问题，所以<strong>选版本的时候尽量考虑清楚</strong></p>
<p>使用指令<code>git checkout openwrt-xx.xx</code>来切换到某个指定的内核版本，可以通过<strong>git指令</strong>查看各个版本间的不同</p>
<p>选择版本后就要添加软件扩展包了：</p>
<p>首先</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp feeds.conf.default feeds.conf</span><br></pre></td></tr></table></figure>

<p>设置所需要使用的源，然后</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./scripts/feeds update -a</span><br><span class="line">./scripts/feeds install -a</span><br></pre></td></tr></table></figure>

<p>更新并安装扩展程序</p>
<p>完成后应该可以看到OpenWrt目录如下：</p>
<ul>
<li>config 编译选项配置文件目录: 包含全局编译设置，开发人员设置和内核编译设置</li>
<li>include 就是普通的头文件目录，但是也包含了各种脚本和Makefile</li>
<li>package 软件包目录</li>
<li>scripts 环境脚本、下载补丁脚本、Makefile等</li>
<li>target 嵌入式平台移植包</li>
<li>toolchain 编译器和C库工具链</li>
<li>tools 用于生成固件的辅助工具</li>
<li>dl 下载的软件包目录</li>
</ul>
<p>顺带一提，在编译完成时还能看到build_dir和staging_dir，二者分别是中间文件目录和编译安装目录</p>
<p>在完成配置后可以使用<code>make defconfig</code>来测试编译环境是否配置正确</p>
<blockquote>
<p>千万注意不要被老版本的配环境资料误导，包括本篇！不要看见一个差不多的资料就从里面复制粘贴指令！</p>
<p>一定要选择适合自己系统的配环境资料，最好查阅官方文档！虽然会麻烦一点但是可以很大程度上避免滚挂系统！</p>
<p>不要问我怎么知道的，我只能说linux双系统有风险，滚挂系统重装好麻烦的！</p>
</blockquote>
<h4 id="menuconfig"><a href="#menuconfig" class="headerlink" title="menuconfig"></a>menuconfig</h4><p>配完环境以后就可以进行半可视化配置内核、应用程序的menuconfig了</p>
<p>先使用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>

<p><strong>打开menuconfig半图形化配置界面，在里面添加需要选用的组件</strong></p>
<p>操作：键盘上下移动光标，左右选择底部按键，回车是确认，空格是设置选择模式，选项最前面的选择模式有[*]表示编译进固件，[M]表示编译成安装包，[ ]表示不选择，esc是返回上级菜单，按?是帮助，按/是搜索</p>
<p>注意一般应用程序编译成安装包等进入系统后再安装，kmod内核驱动要编译进固件，带opkg字样的东西一定要编译进固件，不然没法安其他包</p>
<p><strong>配置选项定义</strong></p>
<table>
<thead>
<tr>
<th align="center">配置选项</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Target System</td>
<td align="left">目标平台，对应目录openwrt/target/linux 里的目录</td>
</tr>
<tr>
<td align="center">Subtarget</td>
<td align="left">目录 openwrt/target/linux/(目标) 里的子目录，定义特定目标</td>
</tr>
<tr>
<td align="center">Target Profile</td>
<td align="left">目标描述文件，在subtarget目录下面的profile目录中</td>
</tr>
<tr>
<td align="center">Target Images</td>
<td align="left">编译生成目标固件的控制选项</td>
</tr>
<tr>
<td align="center">Global build settings</td>
<td align="left">全局编译设置，按默认设置进行编译就可以</td>
</tr>
<tr>
<td align="center">Advanced configuration options</td>
<td align="left">高级配置选项，无需理会</td>
</tr>
<tr>
<td align="center">Build the OpenWrt Image Builder</td>
<td align="left">可以编译出一个编译系统供其它主机安装</td>
</tr>
<tr>
<td align="center">Build the OpenWrt SDK</td>
<td align="left">编译生成SDK开发包，提供给其它主机进行应用开发</td>
</tr>
<tr>
<td align="center">Package the OpenWrt-based Toolchain</td>
<td align="left">生成开发工具链包，提供给其它主机进行应用开发</td>
</tr>
<tr>
<td align="center">Image configuration</td>
<td align="left">控制是否打开feed.conf中的模块</td>
</tr>
<tr>
<td align="center">Base system</td>
<td align="left">基本软件包选择，主要是busybox组件</td>
</tr>
<tr>
<td align="center">Boot Loaders</td>
<td align="left">引导系统的系统，不用管它</td>
</tr>
<tr>
<td align="center">Development</td>
<td align="left">开发包、开发工具，如gcc、gdb之类</td>
</tr>
<tr>
<td align="center">Firmware</td>
<td align="left">特定硬件的固件</td>
</tr>
<tr>
<td align="center">Kernel modules</td>
<td align="left">内核模块、内核配置选项</td>
</tr>
<tr>
<td align="center">Languages</td>
<td align="left">软件开发语言选择</td>
</tr>
<tr>
<td align="center">Libraries</td>
<td align="left">动态链接库选择</td>
</tr>
<tr>
<td align="center">Network</td>
<td align="left">网络功能模块选择</td>
</tr>
<tr>
<td align="center">Utillities</td>
<td align="left">一些实用工具模块</td>
</tr>
</tbody></table>
<p>（上面内容摘录自<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e2b5a292392e%EF%BC%89">https://www.jianshu.com/p/e2b5a292392e）</a></p>
<p>完成选择后就可以保存退出了，生成的文件会让你命名，一般直接保持默认<code>.config</code>即可</p>
<blockquote>
<p>在这个项目里，我遇到的最大问题就是在menuconfig的时候安装进模块的软件包无法使用，于是只能和OpenWrt内核版本、底层硬件驱动、网口配置斗智斗勇……在一般情况下面对嵌入式设备一定要首先考虑在menuconfig的时候安装软件包，否则后续的操作有可能反而比menuconfig复杂——尤其是在安装额外的kmod，也就是内核驱动时。自行编译的内核是具有独立的md5码的，并不能和官方的bin文件对应的md5码吻合，这就导致下载软件包的时候kmod无法匹配内核，所以要使用强制安装，而又因为你的内核是自行编译的，所以很有可能会出现因为内核版本不对而很多程序无法运行，甚至运行时崩溃的情况</p>
</blockquote>
<h4 id="漫长的编译"><a href="#漫长的编译" class="headerlink" title="漫长的编译"></a>漫长的编译</h4><p>make就完事了，make的时候可以换各种姿势</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">make V=s #输出编译信息，第一次编译一般用这个，单核编译小水管不得不品尝</span><br><span class="line">make V=99 #上面这个的老版本用法</span><br><span class="line"></span><br><span class="line">make -j12 #j后面跟你的cpu核心数，对amd cpu很友好，但是不会输出编译信息，如果要反复编译还是比较适合的，省时间</span><br><span class="line">make clean #重新编译之前记得用一下，不然下次编译可能出现莫名其妙的错误</span><br></pre></td></tr></table></figure>

<p>特别地，现在GitHub有一个叫Actions的服务，有人利用这个服务制作了一套<a target="_blank" rel="noopener" href="https://github.com/P3TERX/Actions-OpenWrt">在线编译OpenWrt的系统</a></p>
<p>主要有以下特色：</p>
<ul>
<li><strong>免费！快速！一次编译成功率高！</strong></li>
<li>一键快速自动多线程编译</li>
<li>无需搭建编译环境，上手就用，用完就扔</li>
</ul>
<p>根据<a target="_blank" rel="noopener" href="https://p3terx.com/archives/build-openwrt-with-github-actions.html">项目的中文介绍页面</a>里面的介绍一步步来就可以实现在线编译了（记得提前准备一个GitHub账号）</p>
<p>其中比较友好的是可以支持SSH连接到GitHub Actions虚拟服务器环境，直接在服务器上menuconfig</p>
<blockquote>
<p>编译的时候出现了很多错误，不要嫌麻烦，挨个查看改正就行，第一次编译难免出错，正常情况下改一天肯定是能编译出来的</p>
<p>不过后续烧录能不能识别嘛……祈祷自己的设备比较常见吧；特种设备采用特殊器件装特殊系统……自求多福，运气好总能成功的</p>
</blockquote>
<h3 id="上位机连接到OpenWrt"><a href="#上位机连接到OpenWrt" class="headerlink" title="上位机连接到OpenWrt"></a>上位机连接到OpenWrt</h3><p>终于完成了整个系统的编译，接下来就能尝试烧录并连接到设备了。烧录过程和设备具体硬件配置有关</p>
<h3 id="烧录"><a href="#烧录" class="headerlink" title="烧录"></a>烧录</h3><p>如果你使用的是普通路由器，一般来说连上LAN口，登录网关地址，里面的选项里会有一个更新固件，直接把bin文件上传，点击烧录就可以了；如果使用的是一般的嵌入式设备，一般可以选择使用openocd配合jtag进行烧录，只要900+rmb氪入一套jlink基本可以完美烧录（笑）上面两个方法都太简单（没钱买设备是个人问题，有钱人烧录都很简单的）。下面介绍一下常用的三种烧录方法：</p>
<ol>
<li><p><strong>uBoot烧录</strong></p>
<p>一般来说设备出厂以后都会烧录<strong>uBoot</strong>，这个东西和grub有点像，但是它工作在嵌入式领域，可以支持Linux、安卓、FreeBSD等系统的引导，支持MIPS、x86、ARM、RISC-V等等各种架构的CPU，而OpenWrt对应使用的uBoot往往会着重增强网络能力，因此一般OpenWrt设备的uBoot都会自带TFTP协议的功能，并且会打开一个操作界面，因此可以直接参考厂商给出的说明，按以下步骤启动设备</p>
<ul>
<li>连接LAN口到上位机</li>
<li>修改上位机IP为厂商指定的静态IP地址，并按照地址设定子网掩码</li>
<li>下位机设备断电，按住Boot按键（或者叫WPS按键）（当然如果没有这个按键应该从Boot引脚到地焊接一根跳线）</li>
<li>将设备上电</li>
<li>保持按键一段时间，等待设备从uBoot启动（类似于按住进入键盘上某个键进入BIOS设置界面）</li>
<li>松开按键并在上位机打开厂商指定的IP地址（浏览器打开，别想着用什么奇奇怪怪的软件）</li>
<li>选择固件、上传、等待</li>
<li>等到足够长时间以后（具体多长要参考厂商说明）修改LAN口为dhcp或默认设置的静态IP</li>
<li>尝试正常连接路由器</li>
</ul>
<p>如果中间没有操作界面，可以尝试反复ping要连接的uBoot地址，如果能ping通那就是连上了，之后使用类似下面的uboot命令（由厂商决定）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tftp 固件保存地址 要上传的固件</span><br><span class="line">erase 固件启动地址 + $固件大小</span><br><span class="line">cp 固件保存地址 固件启动地址 $固件大小</span><br><span class="line">set bootcmd 固件启动地址</span><br><span class="line">save</span><br><span class="line">boot</span><br></pre></td></tr></table></figure>

<p>总体过程就是：上传-擦除原本固件-复制上传的固件到启动位置-设置固件启动位置-保存-重启设备</p>
<p>uBoot功能很强大，在某种程度上说它就像桌面版linux的livecd一样，只要uboot不刷坏，设备就可以说是不死的，一直可以通过重新进入uboot的方式刷新系统</p>
<blockquote>
<p>顺便提一下，对于14.07版本的内核，应用在MT7621上时，安装kmod-usb-ehci与kmod-usb-hid可能会导致冲突让系统崩溃，就是因为同时安装了他俩让我不得不重新刷机好几次</p>
</blockquote>
</li>
<li><p><strong>luci界面升级</strong></p>
<p>就是上面说过的登入网关以后从配置界面上传固件升级的过程，但是一般来说会保留原来系统的配置，所以最好刷更新的固件，而不是刷老版本固件，否则会有可能变砖，还需要用第一种方法再刷一次</p>
</li>
<li><p><strong>烧录器烧录</strong></p>
<p>如果uBoot损坏、网口有问题甚至Flash挂了，那就必须使用这种方法了。</p>
<p>一般来说需要使用专门的Flash烧录器配合上位机软件对准Flash的引脚进行烧录，Flash烧录器有1.8V、3.3V、5V三种，一般来说现在的SPI Flash（最典型的W25Q128）使用3.3V烧录器就可以，但是很多设备都用上了低功耗Flash，这就需要一个电平转换板或者直接使用1.8V烧录器进行烧录。如果是最为极端的情况，Flash挂了，那就必须把Flash拆下来，换一个新Flash上去再烧录</p>
</li>
</ol>
<blockquote>
<p>在艰难的配环境过程中，某个不愿透露姓名的学长就把Flash整废了，好巧不巧那块Flash还是特殊封装的贴片元件，极其难焊接，于是只能购入巨贵的专用烧录板，烧录新的Flash以后再装上去。由于没碰见过这种情况+快递速度缓慢，流程整整走了一周。</p>
<p>笔者接手项目以后，还遇到了uBoot死活不启动的情况，检查电路以后发现是板上的Boot线路被莫名划坏一道，于是补好了铜线才得以启动uBoot</p>
<p><strong>新手注意：遇到uBoot不启动不要慌，较大可能是你按的时间不够久或者操作有疏忽导致uBoot启动被跳过了，只要认真多试几遍总能成功，在期间善用百度很关键</strong></p>
</blockquote>
<h4 id="Luci"><a href="#Luci" class="headerlink" title="Luci"></a>Luci</h4><p>完成系统烧录以后，上电，上位机连上LAN口，等待几分钟，浏览器打开网关地址（一般是<code>192.168.1.1</code>），一般来说就能进入一个登陆界面，这就是OpenWrt的<strong>Luci界面</strong></p>
<p>通过这个界面可以对设备的大多数设置进行调整，这里不多作介绍，都是很直接了当的东西</p>
<p>在某些角落会留着language的设置栏，在这里可以选择语言，省去啃生肉的烦恼</p>
<h4 id="串口终端"><a href="#串口终端" class="headerlink" title="串口终端"></a>串口终端</h4><p>最传统登录Linux的方法当然是串口终端——不论嵌入式linux还是服务器linux</p>
<blockquote>
<p>TTL串口是人类的好朋友</p>
</blockquote>
<p>这种方法不必多说，折腾过树莓派的人都懂，串口调试器连接UART Tx、Rx、GND，重启设备，开启Putty或者XShell，之后开机信息就会从界面喷涌而出</p>
<h4 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h4><p>这种方法很适合具有WiFi功能的OpenWrt设备，能够省掉一根网线。不过有网线连接的时候也很实用，对于linux来说命令行总是比可视化可靠。</p>
<p>连上网线ping通后，直接</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh 用户名(一般是root)@目标设备IP</span><br></pre></td></tr></table></figure>

<p>就可以登录到OpenWrt了</p>
<h4 id="任何其他Linux发行版允许的登录方式"><a href="#任何其他Linux发行版允许的登录方式" class="headerlink" title="任何其他Linux发行版允许的登录方式"></a>任何其他Linux发行版允许的登录方式</h4><p>只要在内核里面使能了某个可行的登陆方式，并且硬件允许它运行，那么用户就能用这种方式进行登录OpenWrt</p>
<p>毕竟这可是Linux啊！</p>
<h3 id="联网"><a href="#联网" class="headerlink" title="联网"></a>联网</h3><p>强调一下：==如果是必须的kmod还是应该先想好然后在编译内核阶段完成安装==</p>
<p>一般来说正常安装了网络设备驱动和普通luci界面的设备直接插上网线或者通过luci界面配置好wifi以后就可以联网了，但是如果无法联网可能有以下几个原因：</p>
<ol>
<li>编译内核时没有把网络设备驱动编译进去（一般来说是默认添加且不能修改的，但是谁知道用户会做出什么逆天操作）</li>
<li>外部设备不支持联网（一般是硬件坏了，弄个交换机上OpenWrt还不如多花点钱买个带千/万兆网口的）</li>
<li>配置问题</li>
</ol>
<p>1、2点需要重新编译或者检查硬件甚至重新选型，非常难以解决，所以一定要避免这两种问题出现；第三种相对容易解决一些，根据百度到的教程一步步来即可，一般来说都是因为路由器接口/netif/wpa/交换机接口配置出错，依次排除不要着急</p>
<blockquote>
<p>在我调试这个板子的时候发生了一件很绝望的事情：板子无法联网，但是能够在内网登录luci界面并ssh。刚开始我以为是软件问题，先去查找了一遍OpenWrt的官方文档，通过luci界面配置了一遍接口，但是无济于事；然后又ssh进去通过vi查找配置文件，无果；因为项目进度逼的比较紧，于是只能换用离线装软件包的方法。等到折腾了一大通硬装软件包以后才想起来检查硬件问题，最后发现是开头说的网络变压器电路问题导致无法联网</p>
<p>所以嵌入式编程<strong>一定要先排除硬件问题</strong>！</p>
</blockquote>
<h3 id="包管理器"><a href="#包管理器" class="headerlink" title="包管理器"></a>包管理器</h3><p>OpenWrt最与众不同的一点就是它配备了<strong>opkg</strong>包管理器，它和apt、yum、pacman等指令使用方式类似，能够<em>不是很智能地智能解决</em>软件包依赖问题：<em>只能解决一点点</em>。一般来说自动解决需要一层依赖的软件包安装还是可以的，但是为了安全起见还是一步一步的安装软件包吧。opkg常用指令如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">opkg install </span><br><span class="line">opkg remove</span><br><span class="line">opkg update</span><br><span class="line">opkg upgrade</span><br></pre></td></tr></table></figure>

<p>软件包管理器的设置位于<code>/etc/opkg</code>中</p>
<p>这个包管理器也是支持<strong>换源</strong>的，如果某个软件源不好连接，完全可以更换当前使用的软件源，使用luci界面就可以轻松换源，如果非要使用命令行也可以像ubuntu那样直接编辑设置文件来换源</p>
<p>具体操作网上有很多，不再赘述，特别指出善用下面的指令可以快速更换软件源的域名</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i</span><br></pre></td></tr></table></figure>

<p>特别地，安装软件包时如果碰到了kmod字样的软件包，就说明这是一个内核驱动包，在安装它的时候很可能会遇到内核版本不正确的情况——因为自行编译的OpenWrt生成时会自动携带一个经过修改的md5码，它往往和已有的内核驱动应该对应的验证码不一致，因此会出现报错，这种情况下在安装指令后面加上如下参数就可以解决问题了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--force-depends</span><br></pre></td></tr></table></figure>

<p>如果还是不行，甚至出现系统崩溃、变砖的情况，就要考虑是否是自己的软件源选错抑或是自己编译的内核版本不对了</p>
<p>这就是为什么在上面反复强调要注意内核版本与内核驱动</p>
<p><strong>snapshot版本和release版本区别</strong></p>
<p>我们经常会看到软件源中的某些项目版本以release或snapshots结尾，一般来说snapshots版本代表正在开发中的版本（快照版本,一般处于开发阶段），release代表比较稳定的发布版本（这次迭代的所有功能都已经完成）</p>
<blockquote>
<p>换源的操作对于嵌入式Linux，或者说OpenWrt来说不是很重要，但是在面对很难处理的软件bug时可以考虑换源来解决，我在处理项目时通过多次换源解决了一些软件包的依赖问题，使用到的源如下：</p>
<p>清华源 src/gz barrier_breaker_base <a target="_blank" rel="noopener" href="http://mirrors.tuna.tsinghua.edu.cn/openwrt/barrier_breaker/14.07/ramips/mt7621/packages/base">http://mirrors.tuna.tsinghua.edu.cn/openwrt/barrier_breaker/14.07/ramips/mt7621/packages/base</a></p>
<p>稳定版官方源 src/gz barrier_breaker_base <a target="_blank" rel="noopener" href="http://downloads.openwrt.org/snapshots/trunk/ramips/mt7621/packages/base">http://downloads.openwrt.org/snapshots/trunk/ramips/mt7621/packages/base</a></p>
<p>快照版官方源 src/gz barrier_breaker_base <a target="_blank" rel="noopener" href="http://downloads.openwrt.org/snapshots/trunk/ramips/mt7621/packages/base">http://downloads.openwrt.org/snapshots/trunk/ramips/mt7621/packages/base</a></p>
<p>存档版官方源src/gz barrier_breaker_base <a target="_blank" rel="noopener" href="https://archive.openwrt.org/snapshots/trunk/ramips/mt7621/packages/base">https://archive.openwrt.org/snapshots/trunk/ramips/mt7621/packages/base</a></p>
<p><strong>主要的思路就是查看自己要安装的软件包都需要什么依赖，然后对照依赖版本寻找对应的md5码，再根据md5码选择支持的官方源</strong></p>
<p>在换源的时候可能会遇到下面的报错：Package xxx version xxx has no valid architecture, ignoring.</p>
<p>这是因为源指定的系统和设备上刷入的系统md5码不符合，可以直接在/etc/opkg.conf文件中加入对系统支持的architecture的设置，也就是在文件中添加下面的内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arch all 100</span><br><span class="line">arch &lt;arch类型1&gt; 200</span><br><span class="line">arch &lt;arch类型2&gt; 300</span><br></pre></td></tr></table></figure>

<p>arch类型可以在源下面的package目录内配置文件中查找到，我使用的配置如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arch all 100</span><br><span class="line">arch mips 200</span><br><span class="line">arch ramips 300</span><br><span class="line">arch unkown 400</span><br></pre></td></tr></table></figure>

<p>换用<a target="_blank" rel="noopener" href="https://archive.openwrt.org/">官方archive源</a>也可以帮助解决一些老版本不兼容的问题</p>
</blockquote>
<h3 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h3><p>只要登陆进luci界面，再让设备联网就可以轻松地进行可视化安装，并且luci界面还会将软件包依赖关系列出来，非常简便；命令行下的安装过程也不算复杂，和ubuntu、centos等发行版的软件安装方法类似</p>
<p>一般我们用opkg安装软件有两种方式：</p>
<ul>
<li><p>是连上网络后从官方网站安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">opkg update</span><br><span class="line">opkg install xxx</span><br></pre></td></tr></table></figure></li>
<li><p>把软件下载到上位机（直接进入软件源网页，通过ftp下载即可），通过winscp或者linux下使用scp指令传到路由器tmp目录，再使用指令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opkg install xxx.ipk</span><br></pre></td></tr></table></figure>

<p>安装</p>
</li>
</ul>
<p>如果路由暂时上不了网，就无法使用前一种方法，后一种方法又有些麻烦，其实除此之外还可以通过上位机开启ftp/http服务，让设备接入来实现“在内网”安装：</p>
<ol>
<li><p>在本机上开ftp/http/其他网络服务</p>
</li>
<li><p>修改/etc/opkgconfig，将第一行的网址（也就是软件源地址）改成上位机服务器放安装包的服务目录</p>
</li>
<li><p>从软件源下载需要的安装包到服务目录</p>
</li>
<li><p>把软件源的packages文件下载到服务目录</p>
</li>
<li><p>使用指令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">opkg update</span><br><span class="line">opkg install xxx</span><br></pre></td></tr></table></figure>

<p>安装软件</p>
</li>
</ol>
<blockquote>
<p>上面提到了本地安装软件包的方法，所以在这里特别提一下，<strong>实际上安装非常麻烦</strong>，所以尽量不要使用这种方法</p>
</blockquote>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">嵌入式Linux</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2021/11/19/OpenWrt%E4%B8%8E%E5%B5%8C%E5%85%A5%E5%BC%8FLinux/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-ESP32-IDF学习8【电源管理与低功耗模式】" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A08%E3%80%90%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86%E4%B8%8E%E4%BD%8E%E5%8A%9F%E8%80%97%E6%A8%A1%E5%BC%8F%E3%80%91/">ESP32_IDF学习8【电源管理与低功耗模式】</a>
    </h1>
  

        
<!-- 显示阅读次数-->
<!--  -->
<!--显示阅读次数完毕 -->

        
        <a href="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A08%E3%80%90%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86%E4%B8%8E%E4%BD%8E%E5%8A%9F%E8%80%97%E6%A8%A1%E5%BC%8F%E3%80%91/" class="archive-article-date">
  	<time datetime="2021-11-19T07:04:24.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2021-11-19</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="电源管理"><a href="#电源管理" class="headerlink" title="电源管理"></a>电源管理</h1><p>ESP-IDF中集成的电源管理算法可以根据应用程序组件的需求，调整外围总线 (APB) 频率、CPU 频率，并使芯片进入 Light-sleep 模式，尽可能减少运行应用程序的功耗</p>
<p>应用程序组件可以通过创建和获取电源管理锁来控制功耗</p>
<p>编译时可使用CONFIG_PM_ENABLE选项启用电源管理功能</p>
<h2 id="电源管理配置"><a href="#电源管理配置" class="headerlink" title="电源管理配置"></a>电源管理配置</h2><p>（摘自官网）启用电源管理功能将会增加中断延迟。额外延迟与多个因素有关，例如CPU频率、单/双核模式、是否需要进行频率切换等（CPU 频率为 240 MHz 且未启用频率调节时，最小额外延迟为 0.2 us；如果启用频率调节，且在中断入口将频率由 40 MHz 调节至 80 MHz，则最大额外延迟为 40 us）</p>
<p>应用程序可以通过调用esp_pm_configure()函数启用动态调频（DFS）功能和自动light-sleep模式。</p>
<p>通过esp_pm_config_esp32_t结构体来设置相关参数，如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">esp_pm_config_esp32_t</span>//<span class="title">pm</span>代表<span class="title">power</span> <span class="title">management</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> max_freq_mhz;<span class="comment">//最大CPU频率，也就是获取ESP_PM_CPU_FREQ_MAX锁后使用的频率，单位MHz</span></span><br><span class="line">    <span class="keyword">int</span> min_freq_mhz;<span class="comment">//最小CPU频率，也就是获取ESP_PM_APB_FREQ_MAX锁后使用的频率，单位MHz，可设置为晶振频率值或晶振频率除以一个整数，但是需要注意10MHz是生成1MHz的REF_TICK默认时钟所需的最小频率</span></span><br><span class="line">    <span class="keyword">bool</span> light_sleep_enable;<span class="comment">//当未获得任何管理锁时，决定系统是否需要自动进入light-sleep状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="电源管理锁与管理算法"><a href="#电源管理锁与管理算法" class="headerlink" title="电源管理锁与管理算法"></a>电源管理锁与管理算法</h2><p><strong>应用程序可以通过获取或释放管理锁来控制电源管理算法</strong></p>
<p>ESP32 支持下表中所述的三种电源管理锁。</p>
<table>
<thead>
<tr>
<th>电源管理锁</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ESP_PM_CPU_FREQ_MAX</td>
<td>请求使用esp_pm_configure将CPU频率设置为最大值。ESP32可以将该值设置为 80 MHz、160 MHz 或 240 MHz。</td>
</tr>
<tr>
<td>ESP_PM_APB_FREQ_MAX</td>
<td>请求将APB频率设置为最大值，ESP32支持的最大频率为80MHz</td>
</tr>
<tr>
<td>ESP_PM_NO_LIGHT_SLEEP</td>
<td>禁止自动切换至Light-sleep模式</td>
</tr>
</tbody></table>
<p>如果没有获取任何管理锁，调用esp_pm_configure()将启动Light-sleep模式</p>
<p>Light-sleep模式持续时间由以下因素决定：1.处于阻塞状态的FreeRTOS任务书；2.高分辨率定时器API注册的计数器数量</p>
<h2 id="动态调频和外设驱动"><a href="#动态调频和外设驱动" class="headerlink" title="动态调频和外设驱动"></a>动态调频和外设驱动</h2><p>启用动态调频后，APB频率可在一个RTOS滴答周期内多次更改。有些外设不受APB频率变更的影响，但有些外设可能会出现问题</p>
<p>UART、LEDC、RMT不受APB频率变更的影响</p>
<p>SPI master、I2C、I2S、SDMMC可以感知动态调频并在调频期间使用ESP_PM_APB_FREQ_MAX锁</p>
<p>启用SPI slave、以太网、wifi、蓝牙、CAN时，将占用ESP_PM_APB_FREQ_MAX锁</p>
<p>MCPWM、PCNT、Sigma-delta、Timer Group无法感知动态调频，需要应用程序自行获取、释放管理锁</p>
<p>ESP32 在内置<strong>Deep-sleep低功耗模式</strong>、<strong>RTC外设</strong>和<strong>ULP协处理器</strong>的支持下，可以满足多种应用场景下的低功耗需求</p>
<p>（ULP协处理器见最后部分）</p>
<h1 id="低功耗模式"><a href="#低功耗模式" class="headerlink" title="低功耗模式"></a>低功耗模式</h1><p>ESP32可以进入light-sleep和deep-sleep模式，还能进入一个用于相对较低功耗运行的modem-sleep模式</p>
<p>注意：<strong>进入低功耗模式前，应用程序必须关闭wifi和蓝牙设备</strong>，如果需要维持wifi连接，应当使用modem-sleep模式，在这个模式下当需要wifi驱动执行时系统会自动唤醒来维持wifi连接</p>
<h2 id="light-sleep"><a href="#light-sleep" class="headerlink" title="light-sleep"></a>light-sleep</h2><p>==CPU暂停运行，wifi/蓝牙基带和射频关闭。RTC、ULP运行，任何唤醒事件都会唤醒芯片==</p>
<p>在light-sleep模式下，数字外设、大部分内存和CPU都会被停用（停用时钟），电源功耗也会降低，从light-sleep模式下唤醒后外设和CPU会接回时钟源并继续工作，他们的外部状态会被保存</p>
<p><strong>这个模式可以理解为电脑的挂起休眠</strong></p>
<h2 id="deep-sleep"><a href="#deep-sleep" class="headerlink" title="deep-sleep"></a>deep-sleep</h2><p>==CPU、大部分外设掉电，wifi/蓝牙基带和射频关闭，进有RTC、ULP运行，wifi和蓝牙连接数据被转移到RTC内存中。仅有一部分中断源会唤醒芯片==</p>
<p>deep-sleep模式下，由APB_CLK时钟提供是时钟源的CPU、大部分内存和所有数字外设都会掉电；只有片上RTC控制器、RTC外设、ULP和RTC内存会被保留电源</p>
<p><strong>这个模式可以理解为电脑的断电休眠</strong></p>
<p>Deep-sleep模式下支持从以下唤醒源触发的设备唤醒</p>
<ul>
<li>定时器</li>
<li>touchpad</li>
<li>Ext(0)：RTC IO中某个指定GPIO满足指定电平即唤醒</li>
<li>Ext(1)：RTC IO中某些指定GPIO同时满足指定电平才能唤醒</li>
<li>ULP协处理器</li>
</ul>
<p>睡眠唤醒源可以在进入light-sleep或deep-sleep之前的任何时间设置</p>
<p>特别地，应用程序可以调用esp_sleep_pd_config()函数来让RTC外设和RTC内存掉电</p>
<p>设置好中断源后可以使用esp_light_sleep_start()和esp_deep_sleep_start()来进入睡眠模式</p>
<h3 id="中断源"><a href="#中断源" class="headerlink" title="中断源"></a>中断源</h3><p>使用esp_sleep_disable_wakeup_source()来停用某个已经设置的中断源</p>
<p>设置中断源的方法如下</p>
<h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p>RTC控制器自带一个能够在预定义时间后进行唤醒的定时器</p>
<p>这个换新模式不需要在睡眠期间为RTC外设或RTC内存上电</p>
<p>使用esp_sleep_enable_timer_wakeup()使能这个功能</p>
<h4 id="触摸检测"><a href="#触摸检测" class="headerlink" title="触摸检测"></a>触摸检测</h4><p>RTC IO模块包括了一套触摸传感器中断触发唤醒的逻辑，需要在MCU进入睡眠之前配置好触摸中断唤醒</p>
<p>只有在RTC外设没有被强行上电的时候才能使用这个唤醒模式</p>
<p>使用esp_sleep_enable_touchpad_wakeup()函数来使能这个中断源</p>
<h4 id="特定外部引脚"><a href="#特定外部引脚" class="headerlink" title="特定外部引脚"></a>特定外部引脚</h4><p>RTC IO模块包括了一套GPIO触发唤醒的逻辑。如果这个中断源被使能，RTC外设需要保持上电状态。因为RTC IO模组在这个模式中被使能，中断上拉或下拉电阻也会被使用到，它们需要通过rtc_gpio_pullup_en()和rtc_gpio_pulldown_en()函数设置</p>
<p>调用esp_sleep_enable_ext0_wakeup()函数来使能这个中断源</p>
<p>此外，也可以使用多个GPIO同时触发唤醒</p>
<p>配置API如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">esp_sleep_pd_config(ESP_PD_DOMAIN_RTC_PERIPH, ESP_PD_OPTION_ON);<span class="comment">//开启特定GPIO唤醒</span></span><br><span class="line">gpio_pullup_dis(gpio_num);<span class="comment">//配置gpio_num为上拉</span></span><br><span class="line">gpio_pulldown_en(gpio_num);<span class="comment">//配置gpio_num为下拉</span></span><br><span class="line">rtc_gpio_isolate(gpio_num);<span class="comment">//配置gpio_num为高阻态</span></span><br><span class="line"></span><br><span class="line">rtc_gpio_deinit(gpio_num);<span class="comment">//使用这个函数来取消配置引脚</span></span><br></pre></td></tr></table></figure>

<p>rtc_gpio_isolate()可以用于防止进入休眠后由GPIO产生的额外功耗</p>
<h4 id="ULP协处理器"><a href="#ULP协处理器" class="headerlink" title="ULP协处理器"></a>ULP协处理器</h4><p>可以使用esp_sleep_enable_ulp_wakeup()来启用ULP协处理器指令唤醒</p>
<h4 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h4><p>除了特定的外部引脚触发唤醒，还可以<strong>在light-sleep下</strong>使用gpio_wakeup_enable()来设定任意GPIO的高/低电平触发唤醒</p>
<p>在进入睡眠模式之前使用esp_sleep_enable_gio_wakeup()来使能该唤醒源</p>
<h4 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h4><p><strong>在light-sleep下</strong>可以使用esp_sleep_enable_uart_wakeup()来启用UART触发唤醒</p>
<p>若开启该触发源，当睡眠状态的ESP32收到来自外部设备的UART输入的数个上升沿时，会自动唤醒，该上升沿数目可以用uart_set_wakeup_threshold()函数配置；在这个触发信号被接收之前，所有信息不会被接收——这就意味着外部设备需要发送额外的字符给ESP32来让它唤醒</p>
<h2 id="modem-sleep"><a href="#modem-sleep" class="headerlink" title="modem-sleep"></a>modem-sleep</h2><p>==CPU运行、可配置时钟，wifi/蓝牙基带和射频关闭，但会维持wifi连接==</p>
<h1 id="RTC外设"><a href="#RTC外设" class="headerlink" title="RTC外设"></a>RTC外设</h1><p>RTC外设不仅包括RTC，还包括了片上温度传感器、ADC、RTC-GPIO和touchpad外设</p>
<h1 id="ULP协处理器-1"><a href="#ULP协处理器-1" class="headerlink" title="ULP协处理器"></a>ULP协处理器</h1><p>ULP（Ultra Low Power超低功耗）协处理器是一种简单的<strong>有限状态机</strong>（FSM）。在主处理器处于Deep-sleep深度睡眠模式时，它可以使用ADC、温度传感器和外部IIC传感器执行测量操作。ULP协处理器可以访问RTC慢速内存区域（RTC_SLOW_MEM）及RTC_CNTL、RTC_IO、SARADC等外设寄存器。ULP协处理器使用<strong>32位固定宽度的指令</strong>、<strong>32位内存寻址</strong>，配备<strong>4个16位通用寄存器</strong></p>
<h2 id="ULP协处理器编程"><a href="#ULP协处理器编程" class="headerlink" title="ULP协处理器编程"></a>ULP协处理器编程</h2><p>ULP协处理器代码是用<strong>汇编</strong>语言编写的，并使用<strong>binutils-esp32ulp工具链</strong>进行编译</p>
<p>开发环境被集成到ESP-IDF中</p>
<p>编译方法如下：</p>
<ol>
<li><p>ULP代码必须导入到一个或多个.S扩展文件中，源文件必须放在组件目录中一个独立的目录（如ulp/）</p>
</li>
<li><p>注册后从组件CMakeLists.txt中调用ulp_embed_binary，示例如下</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">idf_component_register()</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(ulp_app_name ulp_<span class="variable">$&#123;COMPONENT_NAME&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(ulp_s_sources ulp/ulp_assembly_source_file.S)</span><br><span class="line"><span class="keyword">set</span>(ulp_exp_dep_srcs <span class="string">&quot;ulp_c_source_file.c&quot;</span>) <span class="comment">#二进制文件命名</span></span><br><span class="line"></span><br><span class="line">ulp_embed_binary(<span class="variable">$&#123;ulp_app_name&#125;</span> <span class="string">&quot;$&#123;ulp_s_sources&#125;&quot;</span> <span class="string">&quot;$&#123;ulp_exp_dep_srcs&#125;&quot;</span>) <span class="comment"># 导入二进制文件</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用常规方法编译应用程序，ULP程序会被自动生成</p>
<p>构建系统的内部编译步骤如下：</p>
<ol>
<li>通过C预处理器运行每个.S文件，生成依赖文件和经过预处理的程序集文件</li>
<li>运行汇编器进行编译</li>
<li>通过C预处理器运行链接器脚本模板（位于components/ulp/ld目录）</li>
<li>将目标文件链接到.elf输出文件</li>
<li>将elf中的内容转储为.bin二进制文件</li>
<li>使用esp32ulp-elf-nm工具在elf文件中生成全局符号列表</li>
<li>创建LD导出脚本和头文件</li>
<li>将生成的二进制文件添加到要嵌入应用程序的二进制文件列表中</li>
</ol>
<p>总体过程和在mcu中嵌入二进制格式的其他文件类似，只是多出了编译的几步</p>
</li>
</ol>
<h2 id="使用ULP程序"><a href="#使用ULP程序" class="headerlink" title="使用ULP程序"></a>使用ULP程序</h2><p><strong>在ULP程序中定义的全局符号也可以在主程序中使用</strong></p>
<p>如果要从主程序访问ULP程序变量，应先<strong>使用include语句包含生成的头文件</strong>，这样就可以像访问常规变量一样访问ulp程序变量</p>
<p>注意：<strong>ULP程序在RTC内存中只能使用32位字的低16位，因为寄存器是16位的并且不具备从字的高位加载的指令</strong></p>
<p>主应用程序需要<strong>调用ulp_load_binary函数</strong>将ULP程序加载到RTC内存中，然后<strong>调用ulp_run函数</strong>启动ULP程序。ULP协处理器由定时器启动，而调用ulp_run则可启动此定时器，定时器为RTC_SLOW_CLK的Tick事件计数（默认情况下，Tick由内部150 KHz晶振器生成）。一旦定时器为所选的SENS_ULP_CP_SLEEP_CYCx_REG寄存器的Tick事件计数，ULP协处理器就会启动，并调用ulp_run的入口点开始运行程序。程序保持运行，直到遇到halt指令或非法指令。一旦程序停止，ULP协处理器电源关闭，定时器再次启动。</p>
<p>使用 <code>SENS_ULP_CP_SLEEP_CYCx_REG</code> 寄存器 (x = 0..4) 设置 Tick 数值。第一次启动 ULP 时，使用 <code>SENS_ULP_CP_SLEEP_CYC0_REG</code> 设置定时器 Tick 数值，之后，ULP 程序可以使用 <code>sleep</code> 指令来另外选择 <code>SENS_ULP_CP_SLEEP_CYCx_REG</code> 寄存器</p>
<h2 id="汇编指令集参考"><a href="#汇编指令集参考" class="headerlink" title="汇编指令集参考"></a>汇编指令集参考</h2><p>ESP32与ESP32S2的汇编指令集并不相同，详情参考官网即可</p>
<p><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/release-v4.1/api-guides/ulp_instruction_set.html">ESP32指令集参考</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/release-v4.1/api-guides/ulps2_instruction_set.html">ESP32S2指令集参考</a></p>
<p>汇编大同小异，下面给出几个常见的指令</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NOP</td>
<td>空指令</td>
</tr>
<tr>
<td>SUB R1,R2,R3</td>
<td>R1=R2-R3</td>
</tr>
<tr>
<td>AND R1,R2,R3</td>
<td>R1=R2&amp;R3</td>
</tr>
<tr>
<td>OR R1,R2,R3</td>
<td>R1=R2|R3</td>
</tr>
<tr>
<td>LSH R1,R2,R3</td>
<td>R1=R2&lt;&lt;R3</td>
</tr>
<tr>
<td>RSH R1,R2,R3</td>
<td>R1=R2&gt;&gt;R3</td>
</tr>
<tr>
<td>MOVE R1,R2</td>
<td>R1=R2</td>
</tr>
<tr>
<td>ST R1,R2,k</td>
<td>MEM[R2+k]=R1</td>
</tr>
<tr>
<td>LD R1,R2,k</td>
<td>R1=MEM[R2+k]</td>
</tr>
<tr>
<td>JUMP R1</td>
<td>跳转到R1所在地址</td>
</tr>
<tr>
<td>HALT</td>
<td>协处理器停机</td>
</tr>
<tr>
<td>WAKE</td>
<td>协处理器唤醒</td>
</tr>
<tr>
<td>SLEEP k</td>
<td>协处理器睡眠k个时间单位</td>
</tr>
<tr>
<td>REG_RD Addr,HIGH,LOW</td>
<td>读外设寄存器地址为Addr从LOW到HIGH的内容</td>
</tr>
<tr>
<td>REG_WR Addr,HIGH,LOW,Data</td>
<td>将Data写入外设寄存器地址为Addr从LOW到HIGH的内容</td>
</tr>
</tbody></table>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">ESP32</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A08%E3%80%90%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86%E4%B8%8E%E4%BD%8E%E5%8A%9F%E8%80%97%E6%A8%A1%E5%BC%8F%E3%80%91/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-ESP32-IDF学习7【ESP32上的FreeRTOS】" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A07%E3%80%90ESP32%E4%B8%8A%E7%9A%84FreeRTOS%E3%80%91/">ESP32_IDF学习7【ESP32上的FreeRTOS】</a>
    </h1>
  

        
<!-- 显示阅读次数-->
<!--  -->
<!--显示阅读次数完毕 -->

        
        <a href="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A07%E3%80%90ESP32%E4%B8%8A%E7%9A%84FreeRTOS%E3%80%91/" class="archive-article-date">
  	<time datetime="2021-11-19T07:03:30.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2021-11-19</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="Bootloader"><a href="#Bootloader" class="headerlink" title="Bootloader"></a>Bootloader</h1><p>ESP32的Bootloader（引导加载程序）主要执行以下任务：</p>
<ol>
<li>内部模块的基础初始化配置</li>
<li>根据<strong>分区表</strong>和<strong>ota_data</strong>（如果存在）选择需要引导的应用程序（app）分区</li>
<li>将应用程序映像加载到 RAM（IRAM和DRAM）中</li>
<li>完成以上工作后把控制权转交给应用程序</li>
</ol>
<p><strong>引导加载程序位于Flash的偏移地址0x1000处</strong></p>
<h2 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h2><p>每片ESP32的flash可以包含多个应用程序，以及多种不同类型的数据（例如校准数据、文件系统数据、参数存储器数据等），使用<strong>分区表</strong>对这些程序和数据进行规划</p>
<p>ESP32 在flash的<strong>默认偏移地址0x8000</strong>处烧写一张分区表</p>
<p>该分区表的长度为0xC00字节，<strong>最多可以保存95条分区表条目</strong>。分区表数据后还保存着该表的MD5校验和用于验证分区表的完整性。此外，如果芯片使能了安全启动功能，该分区表后还会保存签名信息</p>
<p>分区表中的每个条目都包括以下几个部分：Name（标签）、Type（app、data 等）、SubType 以及在flash中的偏移量（分区的加载地址）</p>
<p>烧写到ESP32中的分区表采用二进制格式，而不是CSV文件本身。ESP-IDF提供了gen_esp32part.py工具来配置、构建分区表</p>
<h2 id="默认分区表"><a href="#默认分区表" class="headerlink" title="默认分区表"></a>默认分区表</h2><p>menuconfig中自带了两套分区表，如果编写大程序会经常遇到空间不足的问题（特别是当你像我一样买了16MB超大FLASH的白金纪念典藏款ESP32-WROOM-32E，甚至还想外挂一个W25Q128（16MB）时会经常感觉默认分区表把FLASH都浪费了），但是很适合学习开发使用</p>
<ul>
<li>Single factory app, no OTA</li>
<li>Factory app, two OTA definitions</li>
</ul>
<p>两个选项，都将出厂应用程序烧录至flash的0x10000偏移地址处，但是一个没有OTA分区，一个有OTA分区</p>
<p>它们都在0x10000 (64KB)偏移地址处存放一个标记为 “factory” 的二进制应用程序，且Bootloader将默认加载这个应用程序</p>
<p>分区表中还定义了两个数据区域，分别用于存储NVS库专用分区和PHY初始化数据</p>
<p>带OTA分区的<code>Factory app, two OTA definitions</code>里还新增了otadata的数据分区，用于保存OTA升级所需的数据，Bootloader还会查询该分区的数据来 判断从哪个OTA应用程序分区加载程序，如果这个分区为空则会执行出厂程序</p>
<h2 id="自定义分区表"><a href="#自定义分区表" class="headerlink" title="自定义分区表"></a>自定义分区表</h2><p>在menuconfig里选择了“自定义分区表”选项后，输入该分区表的路径和完整文件名就可以使用自定义分区表了</p>
<p>分区表以CSV的格式书写，用“#”注释；offset字段可以为空，程序会自动计算并填充该分区的偏移地址，但size字段一定要填写好</p>
<p>说明如下（抄自官网文档）</p>
<ul>
<li><p>Name字段可以是任何有意义的名称，但不能超过 16 个字符（之后的内容将被截断）</p>
</li>
<li><p>Type 字段可以指定为app (0) 或data (1)，也可以直接使用数字0-254（或者十六进制 0x00-0xFE）；但<strong>0x00-0x3F不得使用</strong>（预留给 esp-idf 的核心功能）；bootloader将忽略 app (0) 和 data (1) 以外的其他分区类型</p>
</li>
<li><p>SubType 字段长度为8位，内容与具体Type有关。目前esp-idf仅仅规定了“app”和“data”两种子类型</p>
<ul>
<li>当 Type 定义为 <code>app</code> 时，SubType 字段可以指定为 factory (0)，ota_0 (0x10) … ota_15 (0x1F) 或者 test (0x20)</li>
<li>当 Type 定义为 <code>data</code> 时，SubType 字段可以指定为 ota (0)，phy (1)，nvs (2) 或者 nvs_keys (4)</li>
</ul>
<p>其中factory (0) 是Bootloader默认跳转到的app分区；ota(0)是OTA数据分区；nvs(2)是NVS专用的分区，最好分配至少0x3000字节的空间；nvs_keys(4)是密钥分区，用于NVS加密相关功能；phy(1)是用于存放PHY初始化数据的分区，默认配置下phy分区并不启用，会直接将phy初始化数据编译至应用程序中，使能CONFIG_ESP32_PHY_INIT_DATA_IN_PARTITION后才能使用该分区</p>
</li>
<li><p>分区若为指定偏移地址，则会紧跟着前一个分区之后开始。若此分区为首个分区，则将紧跟着分区表开始。app 分区的偏移地址必须要与 0x10000 (64K) 对齐，如果将偏移字段留空，<code>gen_esp32part.py</code> 工具会自动计算得到一个满足对齐要求的偏移地址。如果 app 分区的偏移地址没有与 0x10000 (64K) 对齐，则该工具会报错</p>
</li>
<li><p>Flags 分区当前仅支持 <code>encrypted</code> 标记。如果 Flags 字段设置为 <code>encrypted</code>，且已启用Flash Encryption（FLASH加密）功能，则该分区将会被加密</p>
</li>
</ul>
<p>通过改动示例分区表就能配置新的分区表</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Name,   Type, SubType, Offset,   Size, Flags</span></span><br><span class="line"><span class="comment"># 注意，如果你增大了引导加载程序的大小，请确保更新偏移量，避免和其它分区发生重叠</span></span><br><span class="line">nvs,      data, nvs,     <span class="number">0</span>x9000,   <span class="number">0</span>x4000 <span class="comment"># NVS分区</span></span><br><span class="line">otadata,  data, ota,     <span class="number">0</span>xd000,   <span class="number">0</span>x2000 <span class="comment"># OTA数据分区</span></span><br><span class="line">phy_init, data, phy,     <span class="number">0</span>xf000,   <span class="number">0</span>x1000 <span class="comment"># 初始化分区</span></span><br><span class="line">factory,  <span class="number">0</span>,    <span class="number">0</span>,       <span class="number">0</span>x10000,  <span class="number">1</span>M <span class="comment"># 工厂分区</span></span><br><span class="line"><span class="keyword">test</span>,     <span class="number">0</span>,    <span class="keyword">test</span>,    ,         <span class="number">512</span>K <span class="comment"># 保留分区</span></span><br><span class="line">ota_0,    <span class="number">0</span>,    ota_0,   ,         <span class="number">512</span>K <span class="comment"># 第一OTA分区，一般用于OTA烧录</span></span><br><span class="line">ota_1,    <span class="number">0</span>,    ota_1,   ,         <span class="number">512</span>K <span class="comment"># 第二OTA分区，一般用于OTA回滚或备份</span></span><br></pre></td></tr></table></figure>

<h2 id="出厂程序"><a href="#出厂程序" class="headerlink" title="出厂程序"></a>出厂程序</h2><p>出厂程序就是按下复位按钮后从串口喷涌而出的那一堆自检信息</p>
<p>自定义出厂程序还可以把自己想要的图标通过字符画的形式扔进去，开机的时候就会刷出来，比如可以刷个Ubuntu字符画假装移植了linux（误）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">                         ./+o+-</span><br><span class="line">                 yyyyy- -yyyyyy+</span><br><span class="line">              ://+//////-yyyyyyo</span><br><span class="line">          .++ .:/++++++/-.+sss/`</span><br><span class="line">        .:++o:  /++++++++/:--:/-</span><br><span class="line">       o:+o+:++.`..```.-/oo+++++/</span><br><span class="line">      .:+o:+o/.          `+sssoo+/</span><br><span class="line"> .++/+:+oo+o:`             /sssooo.</span><br><span class="line">/+++//+:`oo+o               /::--:.</span><br><span class="line">\+/+o+++`o++o               ++////.</span><br><span class="line"> .++.o+++oo+:`             /dddhhh.</span><br><span class="line">      .+.o+oo:.          `oddhhhh+</span><br><span class="line">       \+.++o+o``-````.:ohdhhhhh+</span><br><span class="line">        `:o+++ `ohhhhhhhhyo++os:</span><br><span class="line">          .o:`.syhhhhhhh/.oo++o`</span><br><span class="line">              /osyyyyyyo++ooo+++/</span><br><span class="line">                  ````` +oo+++o\:</span><br><span class="line">                         `oo++.</span><br></pre></td></tr></table></figure>

<h2 id="恢复出厂设置"><a href="#恢复出厂设置" class="headerlink" title="恢复出厂设置"></a>恢复出厂设置</h2><p>通过设置CONFIG_BOOTLOADER_FACTORY_RESET来使能GPIO触发恢复出厂设置</p>
<p>恢复出厂设置时将进行以下操作：</p>
<ol>
<li>清除所有数据分区</li>
<li>从工厂分区启动</li>
</ol>
<h2 id="自定义Bootloader"><a href="#自定义Bootloader" class="headerlink" title="自定义Bootloader"></a>自定义Bootloader</h2><p>用户可以自定义当前的Bootloader</p>
<ol>
<li>复制<code>/esp-idf/components/bootloader</code>文件夹到项目目录</li>
<li>编辑<code>/your_project/components/bootloader/subproject/ain/bootloader_main.c</code>文件</li>
</ol>
<p>注意：<strong>在引导加载程序的代码中，用户不可以使用驱动和其他组件提供的函数</strong>，如果确实需要，应该将该功能的实现部分放在bootloader目录中（会增加引导程序的大小）</p>
<p>目前，引导程序被限制在了分区表之前的区域（分区表位于0x8000地址处）</p>
<h1 id="应用级程序追踪"><a href="#应用级程序追踪" class="headerlink" title="应用级程序追踪"></a>应用级程序追踪</h1><p>ESP-IDF提供实用的dubug功能，能够通过menuconfig开启，并通过调用库函数进行使用，可以通过JTAG在ESP32和主机之间传输debug logs，可用于：</p>
<ul>
<li>跟踪特定应用程序</li>
<li>记录日志到主机</li>
<li>基于SEGGEr SystemView进行系统行为分析</li>
</ul>
<p>在程序中<code>#incldue &quot;esp_app_trace.h&quot;</code>即可使用相关库函数</p>
<p>当前这个debug功能已经比较完善，可以用来做调试，但是因为它通过库函数进行数据发送，可能会对正常程序执行造成干扰，使用位置需要注意</p>
<h1 id="FreeRTOS简介"><a href="#FreeRTOS简介" class="headerlink" title="FreeRTOS简介"></a>FreeRTOS简介</h1><p><em>详细内容可以参考FreeRTOS相关教程</em></p>
<p><strong>以下内容应当由接触过RTOS的同学学习，如果你还没碰过RTOS，还像我这样遇上了老师发的离谱作业，千万不要慌，先去按照下面这些标题百度/google/bing一通，弄得差不多再读一读下面的API讲解应该就能糊弄过去了</strong></p>
<p>顾名思义，freeRTOS是free的RTOS，具有以下特点：</p>
<ul>
<li>FREE！FreeRTOS使用LGPL协议，开源且可用于商业，很自由（虽然FSF那帮人可能觉得LGPL不够自由）</li>
<li>小内核、模块化、扩展性强</li>
<li>高效、便于使用</li>
<li><strong>用户无需关心时间信息</strong>，内核中的相关模块会负责处理计时任务和线程调度</li>
</ul>
<h2 id="内核组成"><a href="#内核组成" class="headerlink" title="内核组成"></a>内核组成</h2><p>FreeRTOS是一个可裁剪、可剥夺型（也可根据用户需要裁剪为不可剥夺型）的多任务内核，<strong>不设置任务数限制</strong>。</p>
<p>内涵和基于硬件适配层实现跨平台移植</p>
<h3 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h3><p>这里参考的FreeRTOS源码是在<a target="_blank" rel="noopener" href="https://freertos.org/">官网</a>上下载到的/freertos/FreeRTOSv10.4.1/FreeRTOS/Source目录下的部分</p>
<p>FreeRTOS-Plus包含kernal之外的系统常用功能组件</p>
<p>Source目录下才是kernal相关源码</p>
<ul>
<li>list.c任务链表模块</li>
<li>queue.c消息队列模块</li>
<li>tasks.c任务配置模块</li>
<li>timers.c系统定时器模块</li>
<li>event_groups.c事件集模块</li>
<li>include目录是各种头文件</li>
</ul>
<h3 id="任务管理（线程管理、线程调度）"><a href="#任务管理（线程管理、线程调度）" class="headerlink" title="任务管理（线程管理、线程调度）"></a>任务管理（线程管理、线程调度）</h3><h4 id="优先级抢占式调度算法"><a href="#优先级抢占式调度算法" class="headerlink" title="优先级抢占式调度算法"></a>优先级抢占式调度算法</h4><p>最低优先级是0，<strong>优先级数字越大，当前任务越优先</strong></p>
<p><strong>不同任务可以共用同一个优先级</strong></p>
<h3 id="时间管理（时钟节拍）"><a href="#时间管理（时钟节拍）" class="headerlink" title="时间管理（时钟节拍）"></a>时间管理（时钟节拍）</h3><p>FreeRTOS使用系统节拍（systick）确定其运行时钟，这个系统节拍由硬件定时器中断引起</p>
<p>使用<strong>configCPU_CLOCK_HZ</strong>设置当前硬件平台CPU的系统时钟，单位Hz</p>
<p>使用<strong>configTICK_RATE_HZ</strong>设置FreeRTOS的时间片频率（1秒钟可以切换多少次任务），单位Hz</p>
<h4 id="ESP32的硬件定时器"><a href="#ESP32的硬件定时器" class="headerlink" title="ESP32的硬件定时器"></a>ESP32的硬件定时器</h4><p>ESP32提供两组硬件定时器，每组包含两个64位通用定时器，共<strong>4个通用定时器</strong>，分别标记为TIMER0-3。</p>
<p>所有定时器均包括16位预分频器和64位自动重载向上/向下计数器</p>
<h5 id="定时器初始化"><a href="#定时器初始化" class="headerlink" title="定时器初始化"></a>定时器初始化</h5><p>使用timer_config_t结构体配置定时器参数，然后将这个结构体作为参数传递给timer_init()函数来进行定时器初始化</p>
<p>可设置的参数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_config_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">timer_alarm_t</span> alarm_en;<span class="comment">//是否使能报警</span></span><br><span class="line">	<span class="keyword">timer_start_t</span> counter_en;<span class="comment">//是否是能计数器</span></span><br><span class="line">    <span class="keyword">timer_intr_mode_t</span> intr_type;<span class="comment">//选择定时器警报上触发的中断类型</span></span><br><span class="line">    <span class="keyword">timer_count_dir_t</span> counter_dir;<span class="comment">//选择向上/向下计数</span></span><br><span class="line">    <span class="keyword">timer_autoreload_t</span> auto_reload;<span class="comment">//设置计数器是否在定时器警报上使用auto_reload自动重载首个计数值，或者继续递增/递减</span></span><br><span class="line">    <span class="keyword">uint32_t</span> divider;<span class="comment">//计数器分频器，可设置为2-65536，用作输入的80MHz APB_CLK时钟的分频系数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用timer_get_copnfig()获取定时器设置的当前值</p>
<h5 id="定时器控制"><a href="#定时器控制" class="headerlink" title="定时器控制"></a>定时器控制</h5><ol>
<li>开启定时器</li>
</ol>
<p>设置timer_config_t::counter_en位true后调用timer_init()初始化即可开启定时器</p>
<p>或者也可以直接调用timer_start()来开启定时器</p>
<p>调用timer_pause()随时暂停定时器</p>
<ol start="2">
<li>设置计数值</li>
</ol>
<p>可以通过调用timer_set_counter_value()来指定定时器的首个计数值</p>
<p>使用timer_get_counter_value()或timer_get_counter_time_sec()检查定时器的当前值</p>
<ol start="3">
<li>设置警报</li>
</ol>
<p>先调用函数timer_set_alarm_value()设置警报值，再调用timer_set_alarm()使能警报，或在初始化阶段通过设置初始化结构体来设置警报值并开启警报</p>
<p><strong>当警报使能且定时器到达警报值后，可以触发中断或重新加载</strong></p>
<p>如果auto_reload已使能，定时器的计数器将重新加载，从之前设置好的值重新计数，使用timer_set_counter_value()预先设置该值</p>
<p>如果已设置警报值且定时器已经超过该值，则将立即触发警报</p>
<p><strong>警报一旦触发，将自动关闭，需要重新使能以再次触发</strong></p>
<p>使用timer_get_alarm_value()来获取特定的警报值</p>
<p>调用函数timer_isr_register()来为特定定时器组和定时器注册中断服务程序</p>
<p>使用timer_group_intr_enable()来使能定时器组的中断程序，使用timer_enable_intr()使能某定时器的中断程序；使用timer_group_intr_disable()和timer_disable_intr()关闭对应的中断程序</p>
<p>在中断服务程序中处理中断时，需要明确地清除中断状态位，通过以下设置来清除某定时器的中断状态位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TIMERGN.int_clr_timers.tM = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TIMERGN中的N代表定时器组别编号，可设置0或1</span></span><br><span class="line"><span class="comment">//tM中的M代表定时器编号，可设置为0或1</span></span><br><span class="line"></span><br><span class="line">TIMERG0.int_clr_timers.t1 = <span class="number">1</span>;<span class="comment">//清除定时器组别0中定时器1的中断状态位</span></span><br></pre></td></tr></table></figure>

<h4 id="ESP32中的FreeRTOS时钟"><a href="#ESP32中的FreeRTOS时钟" class="headerlink" title="ESP32中的FreeRTOS时钟"></a>ESP32中的FreeRTOS时钟</h4><p>ESP32中的FreeRTOS使用任意硬件定时器通过开启警报中断模式来实现系统时钟（systick）</p>
<p>定时器计数器到达预设警报值后，将触发中断，调用相关API来让RTOS的系统时钟+1</p>
<p>一般这个API由PRO_CPU执行</p>
<h3 id="内存管理（内存堆）"><a href="#内存管理（内存堆）" class="headerlink" title="内存管理（内存堆）"></a>内存管理（内存堆）</h3><p>FreeRTOS可以使用四种内存分配方案</p>
<ol>
<li>heap1.c</li>
</ol>
<p>分配简单，时间确定，实时性强</p>
<p>只分配内存不回收内存，容易造成资源浪费</p>
<ol start="2">
<li>heap2.c</li>
</ol>
<p>链表式内存块结构分配</p>
<p>动态分配、最佳匹配</p>
<p>容易造成内存碎片且时间不可控</p>
<ol start="3">
<li>heap3.c</li>
</ol>
<p>调用标准库函数分配内存</p>
<p>速度较慢且内存分配时间不确定</p>
<ol start="4">
<li>heap4.c</li>
</ol>
<p>按照物理地址对内存进行排序</p>
<p>使相邻的内存空间可以合并</p>
<p>容易造成内存碎片且合并效率低</p>
<h3 id="通信管理（消息队列、事件集、信号量、互斥量）"><a href="#通信管理（消息队列、事件集、信号量、互斥量）" class="headerlink" title="通信管理（消息队列、事件集、信号量、互斥量）"></a>通信管理（消息队列、事件集、信号量、互斥量）</h3><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>使用FIFO队列的数据结构处理消息的存储和传输</p>
<p>消息发出后被缓存到FIFO队尾，其他任务可以调用接收消息的API接收队首的消息，该消息被接收后，后面的消息会自动前进</p>
<h3 id="事件集"><a href="#事件集" class="headerlink" title="事件集"></a>事件集</h3><p>用于取代全局变量标志，更加安全（但<strong>更慢</strong>）</p>
<h1 id="ESP32上的FreeRTOS"><a href="#ESP32上的FreeRTOS" class="headerlink" title="ESP32上的FreeRTOS"></a>ESP32上的FreeRTOS</h1><p>【翻译自官网】==普通的FreeRTOS运行在单核上，不彳亍！我们的ESP32-FreeRTOS能运行在双核，彳亍！==</p>
<p>众所周知，ESP32是物美价廉的双核SoC，CPU0和CPU1同时运行、共享内存。乐鑫修改了普通的FreeRTOS，让它能够支持SMP（symmetric multiprocessing对称多处理），所以ESP32的FreeRTOS变成了基于FreeRTOS v8.2.0的Xtensa架构移植版SMP RTOS</p>
<p><strong>下面对移植版的FreeRTOS简称为SMP RTOS</strong>，</p>
<p>【补充】对称多处理（SMP）架构是一种两个或多个CPU共享同一内存公共链路的计算机体系结构</p>
<p><em>他改变了FreeRTOS</em></p>
<h2 id="backport"><a href="#backport" class="headerlink" title="backport"></a>backport</h2><p>v9.0版本的FreeRTOS特性被部分移植到了基于v8.0版本的ESP32-SMP-RTOS中</p>
<p>任务删除机制使用v9.0版本的：使用vTaskDelete()后任务会被立刻删除；如果任务在此时正好被另一个核心运行，那么释放内存的步骤会被交给空闲线程（空闲任务）</p>
<p>也引入了TLSP（Thread Local Storage Pointers线程本地存储指针）机制，当任务删除时删除回调函数会被自动执行，这个函数用于释放被TLSP指向的内存区域</p>
<ul>
<li><p>TLSP是指向TCB存储区的指针，它可以让每个任务都有自己独立的一套数据结构指针系统；SMP RTOS也提供了通过删除回调函数和TLSP执行的任务删除机制：当任务删除函数被调用，任务转到空闲线程后触发这个回调函数，可以配置为自动删除任务的内存空间，但是<strong>不要在这个回调函数中加入阻塞的、延时的、临界区等相关代码！尽可能让回调函数短小来确保系统实时性</strong></p>
</li>
<li><p>回调函数的类型是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*TlsDeleteCallbackFunction_t)(<span class="keyword">int</span>,<span class="keyword">void</span>*)</span><br></pre></td></tr></table></figure>

<p>这里针对c语言基础不太好的老哥解释一下：这是一个函数指针，它指向一个“以int型变量和任意指针为参数”，“无返回值”的函数</p>
<p>第一个参数是关联的TLSP的序号，第二个参数是TLSP自身（它本身就是个指针）</p>
<p>如果一个删除回调函数设置为空，那么用户需要在TLSP被删除之前手动释放指向关联的TLSP指向部分的内存，否则就会造成TLSP指向的部分内存变成“无主内存”，导致内存溢出</p>
</li>
</ul>
<h2 id="双核任务"><a href="#双核任务" class="headerlink" title="双核任务"></a>双核任务</h2><p>使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BaseType_t <span class="title">xTaskCreatePinnedToCore</span><span class="params">(TaskFunction_t pvTaskCode,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> pcName,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">const</span> <span class="keyword">uint32_t</span> usStackDepth,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">void</span> *<span class="keyword">const</span> pvParameters,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   UBaseType_t uxPriority,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   TaskHandle_t *<span class="keyword">const</span> pvCreatedTask,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">const</span> BaseType_t xCoreID)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">TaskHandle_t <span class="title">xTaskCreateStaticPinnedToCore</span><span class="params">(TaskFunction_t pvTaskCode,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> pcName,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="keyword">const</span> <span class="keyword">uint32_t</span> ulStackDepth,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="keyword">void</span> *<span class="keyword">const</span> pvParameters,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           UBaseType_t uxPriority,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           StackType_t *<span class="keyword">const</span> pxStackBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           StaticTask_t *<span class="keyword">const</span> pxTaskBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="keyword">const</span> BaseType_t xCoreID)</span></span></span><br></pre></td></tr></table></figure>

<p>创建SMP任务</p>
<p>最后的xCoreID设置为0或1，分别表示单独在PRO_CPU或APP_CPU上运行任务，也可以设置tskNO_AFINITY来允许任务在两个核心上运行</p>
<p>SMP RTOS使用<strong>轮询调度算法</strong>来进行任务调度，然而当两个相同优先级的任务同时处于就绪态时会被轮询算法跳过。应当通过任务阻塞或设置宽优先级的方式避免这种情况</p>
<p>任务挂起仅会对独立的核心起效，另一个核心上运行的任务不会受到任务挂起的影响</p>
<p>传统FreeRTOS的xTaskCreate()和xTaskCreateStatic()函数被以内联函数的形式重定义为上述两个函数，并默认使用tskNO_AFFINITY作为xCoreID的参数</p>
<p>每个任务控制块（TCB Task Control Block）将xCoreID作为一个成员存储起来，因此每个核心都会调用调度器来选择一个任务来运行，<strong>调度器会根据xCoreID成员变量决定是否让被核心请求运行的任务在该核心上运行</strong>（人话：核心请求运行某个任务，调度器会查看这个任务的xCoreID成员变量，如果符合这个核心，就让任务运行，否则会将任务放到任务链表尾并让当前核心尝试申请下一个任务）</p>
<h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>传统的FreeRTOS通过vTaskSwitchContext()函数执行线程调度。这个函数会从就绪任务链表（由处于就绪态的任务组成）中选取最高优先级的任务来运行。但在SMP RTOS中，每个核心都会独立调用vTaskSwitchContext()来从两个核心共用的就绪任务链表中选取任务来执行。SMP RTOS与传统FreeRTOS关于任务调度的区别如下所示：</p>
<ul>
<li><p>轮询调度算法：一般的FreeRTOS会在每个任务之间执行轮询调度，不会遗漏任何任务（一般通过遍历链表的方法进行轮询）；而SMP RTOS可能会在轮询调度多个相同优先级的就绪态任务中跳过其中的一部分</p>
<p>传统FreeRTOS中，使用pxReadyTasksList这个链表结构体来管理就绪态任务链表，相同优先级的任务被挂到相同链表上，这些链表被按照优先级从高到低挂到pxReadyTasksList链表中，pxIndex指针会指向刚刚被调用过的TCB</p>
<p>图示如下：</p>
</li>
</ul>
<p><img src="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A07%E3%80%90ESP32%E4%B8%8A%E7%9A%84FreeRTOS%E3%80%91/.%5CESP32_IDF%E5%AD%A6%E4%B9%A0_ESP32%E4%B8%8A%E7%9A%84FreeRTOS%5Cfreertos-ready-task-list.png"></p>
<p>然而在SMP RTOS中，就绪链表被两个核心共享，因此pxReadyTasksList会包含固定在两个不同核心上的任务，共用一个核心调用调度器时会发生抢占资源的情况，这种情况下资源调度器会查询TCB的xCoreID成员变量来决定一个任务是否被允许在当前请求执行的CPU上运行。虽然每个TCB都有一个xCoreID成员变量，但每个优先级链表中只有一个pxIndex，因此<strong>调度器从某个核心被调用并遍历链表时，他会跳过被标记为另一个核心才能执行的任务</strong>，如果另一个核心在此之后请求调度器分配任务，则pxIndex会从头开始遍历链表，来自另一个核心的上一个调度器并不会在当前核心的当前调度器的考虑范围内；当一个核心正在执行任务时，另一个核心请求分配任务，会从当前pxIndex的位置向后进行遍历。这就导致了一个问题：</p>
<p><img src="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A07%E3%80%90ESP32%E4%B8%8A%E7%9A%84FreeRTOS%E3%80%91/.%5CESP32_IDF%E5%AD%A6%E4%B9%A0_ESP32%E4%B8%8A%E7%9A%84FreeRTOS.assets%5Cfreertos-ready-task-list-smp-pxIndex.png" alt="ESP-IDF pxIndex Behavior"></p>
<p>如上图所示，蓝色和橙色标明了由哪个CPU执行这个任务，当任务A被PRO_CPU执行时，APP_CPU申请分配任务，调度器自动从1向后遍历，找到了任务C；之后任务A完成，PRO_CPU请求分配任务，调度器从2向后遍历找到了任务3——这就导致任务B被跳过了！</p>
<p>解决的方法是<strong>确保每个任务都会进入一段时间的阻塞态来让他们从就绪任务链表中移除，或是让每个任务分配不同的优先级</strong></p>
<h2 id="中断同步"><a href="#中断同步" class="headerlink" title="中断同步"></a>中断同步</h2><p>CPU0和CPU1的中断不同步</p>
<p>不要想当然地用任务延迟函数来进行两个核心之间的任务同步，如果<strong>需要任务同步可以使用信号量</strong>来进行</p>
<ul>
<li>调度器阻塞：一般的FreeRTOS中，使用vTaskSuspendAll()来挂起调度器，这会阻止任务调度，但是中断服务函数ISR还是会运行；在SMP RTOS中，vTaskSuspendAll()只会阻止一个CPU的任务调度，另一个CPU还是会运行，这个机制很可能会引起数据阻塞、任务不同步等情况，所以最好不要使用vTaskSuspendAll()而是换用互斥量来保护临界区</li>
<li>SMP RTOS中，两个核心在相同的系统时钟下可能并没有运行在相同状态——两个核心的调度器、时钟控制等等都是独立的，<strong>时钟中断也是异步的</strong>；传统FreeRTOS中时钟中断会触发一个xTaskIncrementTick()的函数，使得系统时钟计数器+1，创造出了系统节拍，通过vTaskDelay()可以通过系统节拍进行延时等任务；但在SMP RTOS中使用PRO_CPU处理来自硬件定时器的中断，并创造出系统节拍（换句话说<strong>PRO_CPU是SMP RTOS的心脏</strong>），因为各种软硬件原因，中断并不会同时到达两个核心，因此两个核心任务很可能产生异步行为，<strong>延时函数绝对不应当被作为一种同步线程（任务）的方法</strong></li>
</ul>
<h2 id="临界区与互斥量"><a href="#临界区与互斥量" class="headerlink" title="临界区与互斥量"></a>临界区与互斥量</h2><p>SMP RTOS会使用互斥量访问临界区，流程如下</p>
<ol>
<li>某任务获取临界区互斥量</li>
<li>关闭线程调度器</li>
<li>关闭当前核心中断</li>
<li>完成任务</li>
<li>开启当前核心中断</li>
<li>开启线程调度器</li>
<li>释放互斥量</li>
<li>其他任务可以访问临界区</li>
</ol>
<p>在此期间如果另外核心的任务需要访问该资源，需要获取相同的互斥量，但它会被挂起直到当前持有互斥量的任务完成</p>
<p>详细内容可以参考官网</p>
<h2 id="硬件浮点运算的限制"><a href="#硬件浮点运算的限制" class="headerlink" title="硬件浮点运算的限制"></a>硬件浮点运算的限制</h2><p>ESP32支持单精度浮点运算硬件加速。但是使用硬件加速会受到一些SMP RTOS的行为限制。使用浮点数会被自动固定在单一CPU上运行，且浮点数不能在中断服务例程中使用</p>
<p>ESP32不支持双精度浮点数的硬件加速，因此双精度浮点数的运算时间可能比单精度的运算时间慢很多！</p>
<h2 id="可视化编辑"><a href="#可视化编辑" class="headerlink" title="可视化编辑"></a>可视化编辑</h2><p>可使用ESP-IDF的menuconfig可视化地配置SMP RTOS相关参数</p>
<h2 id="官方库中的事件处理函数"><a href="#官方库中的事件处理函数" class="headerlink" title="官方库中的事件处理函数"></a>官方库中的事件处理函数</h2><p>wifi、以太网、IP、蓝牙这些组件都使用事件event和状态机FSM让应用程序处理状态变化</p>
<p>esp_event库文件用于取代传统的事件循环，让ESP-IDF的事件处理更加方便。所有可能能事件类型和事件数据结构都需要在system_event_id_t枚举和system_event_info_t联合中定义；而在的事件循环</p>
<p>使用esp_event_loop_init()来处理事件循环，应用程序通常需要设置一个事件处理函数</p>
<p>传统的事件处理函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">event_handler</span><span class="params">(<span class="keyword">void</span> *ctx, <span class="keyword">system_event_t</span> *event)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>需要向esp_event_loop_init()传入一个专门的上下文指针，当使用wifi、以太网、IP协议栈时往往会产生事件，这些事件都会被保存在事件队列中等待收取，每个处理函数都会获取一个指向事件结构体的指针，这个指针用于描述现在队首的事件，这个事件被用联合标注：event_id、event_info，通常应用程序使用switch结构体与状态机来处理不同种类的事件</p>
<p>所以在wifi、蓝牙、IP协议栈相关代码中经常会看到大段的switch语句</p>
<p><strong>当需要将事件传送到其他任务中时，应用程序需要将全部结构体都复制下来并进行传输</strong></p>
<p>特别地，蓝牙通常使用回调函数来进行事件处理，这些回调函数可以用来收取、发送、处理特定的蓝牙协议栈消息；通常也配合各种结构体来使用</p>
<h1 id="ESP32移植FreeRTOS的API简介"><a href="#ESP32移植FreeRTOS的API简介" class="headerlink" title="ESP32移植FreeRTOS的API简介"></a>ESP32移植FreeRTOS的API简介</h1><p>这里以示例程序+API简介的方式介绍ESP32上的FreeRTOS特性，我对FreeRTOS也处在学习阶段（从RTThread和GNU/Linux入手的RTOS），可能会存在不少漏洞，见谅TAT</p>
<h2 id="系统控制"><a href="#系统控制" class="headerlink" title="系统控制"></a>系统控制</h2><p>FreeRTOS以任务为程序的最小执行单元，相当于RTT里的线程，拥有自己的上下文。使用信号量、事件集、队列进行线程间同步与通信</p>
<p>下面是一些控制系统常用的宏定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">configUSE_PREEMPTION<span class="comment">//选择1为抢占式调度器，0则是协作式调度器</span></span><br><span class="line">configCPU_CLOCK_HZ<span class="comment">//MCU内核的工作频率，单位Hz；对不同的移植代码也可能不使用这个参数</span></span><br><span class="line">configTICK_RATE_HZ<span class="comment">//FreeRTOS时钟心跳，也就是FreeRTOS用到的定时中断的产生频率</span></span><br><span class="line">configMAX_PRIORITIES<span class="comment">//程序中可以使用的最大优先级</span></span><br><span class="line">configMINIMAL_STACK_SIZE<span class="comment">//任务堆栈的最小大小</span></span><br><span class="line">configTOTAL_HEAP_SIZE<span class="comment">//堆空间大小；只有当程序中采用FreeRTOS提供的内存分配算法时才会用到</span></span><br><span class="line">configMAX_TASK_NAME_LEN<span class="comment">//任务名称最大的长度，包括最后的&#x27;\0&#x27;结束字节，单位字节</span></span><br><span class="line">    </span><br><span class="line">configUSE_COUNTING_SEMAPHORES<span class="comment">//是否使用信号量</span></span><br><span class="line">configUSE_RECURSIVE_MUTEXES<span class="comment">//是否使用互斥量递归持有</span></span><br><span class="line">configUSE_MUTEXES<span class="comment">//是否使用互斥量</span></span><br><span class="line">configUSE_TIMERS<span class="comment">//是否使用软件定时器</span></span><br><span class="line"></span><br><span class="line">configTIMER_TASK_PRIORITY<span class="comment">//设置软件定时器任务的优先级</span></span><br><span class="line">configTIMER_QUEUE_LENGTH<span class="comment">//设置软件定时器任务中用到的命令队列的长度</span></span><br><span class="line">configTIMER_TASK_STACK_DEPTH<span class="comment">//设置软件定时器任务需要的任务堆栈大小</span></span><br></pre></td></tr></table></figure>

<h2 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个在单核心运行的任务</span></span><br><span class="line"><span class="function">BaseType_t <span class="title">xTaskCreatePinnedToCore</span><span class="params">(TaskFunction_t pvTaskCode,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> pcName,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">const</span> <span class="keyword">uint32_t</span> usStackDepth,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">void</span> *<span class="keyword">const</span> pvParameters,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   UBaseType_t uxPriority,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   TaskHandle_t *<span class="keyword">const</span> pvCreatedTask,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">const</span> BaseType_t xCoreID)</span><span class="comment">//固定执行该任务的核心，不需要则填tskNO_AFFINITY</span></span></span><br><span class="line"><span class="function"><span class="comment">//用于一般地创建任务，这个API被内联到了双核心交替运行任务的API上</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BaseType_t <span class="title">xTaskCreate</span><span class="params">(TaskFunction_t pvTaskCode,<span class="comment">//任务入口函数指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> pcName,<span class="comment">//任务名</span></span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">const</span> <span class="keyword">uint32_t</span> usStackDepth,<span class="comment">//任务堆栈大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">void</span> *<span class="keyword">const</span> pvParameters,<span class="comment">//任务创建时传入的参数，如果任务入口函数没有参数则填NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">                              UBaseType_t uxPriority,<span class="comment">//任务优先级，数字越大优先级越高</span></span></span></span><br><span class="line"><span class="params"><span class="function">                              TaskHandle_t *<span class="keyword">const</span> pvCreatedTask)</span><span class="comment">//任务回传句柄，如果没有任务回传值则设置为NULL</span></span></span><br></pre></td></tr></table></figure>

<p>除了这两个API用于创建动态任务外，还可以使用以下API创建静态任务</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TaskHandle_t <span class="title">xTaskCreateStaticPinnedToCore</span><span class="params">(TaskFunction_t pvTaskCode, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> pcName, <span class="keyword">const</span> <span class="keyword">uint32_t</span> ulStackDepth, <span class="keyword">void</span> *<span class="keyword">const</span> pvParameters, UBaseType_t uxPriority, StackType_t *<span class="keyword">const</span> pxStackBuffer, StaticTask_t *<span class="keyword">const</span> pxTaskBuffer, <span class="keyword">const</span> BaseType_t xCoreID)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> TaskHandle_t <span class="title">xTaskCreateStatic</span><span class="params">(TaskFunction_t pvTaskCode, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> pcName, <span class="keyword">const</span> <span class="keyword">uint32_t</span> ulStackDepth, <span class="keyword">void</span> *<span class="keyword">const</span> pvParameters, UBaseType_t uxPriority, StackType_t *<span class="keyword">const</span> pxStackBuffer, StaticTask_t *<span class="keyword">const</span> pxTaskBuffer)</span></span></span><br></pre></td></tr></table></figure>

<p>下面是创建任务的例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task</span><span class="params">(<span class="keyword">void</span>* pvPar)</span><span class="comment">//这个任务传入了参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m %s\r\n&quot;</span>,(<span class="keyword">char</span> *)pvPar);<span class="comment">//传入的参数在这里调用</span></span><br><span class="line">        </span><br><span class="line">		vTaskDelay(<span class="number">1000</span>/portTICK_PERIOD_MS);<span class="comment">//将任务转入阻塞态一段时间来达到延时效果</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vTaskDelay(pdMS_TO_TICKS(<span class="number">100</span>));<span class="comment">//等待系统初始化</span></span><br><span class="line"></span><br><span class="line">    xTaskCreatePinnedToCore(task,<span class="comment">//任务入口函数名作为函数指针调用</span></span><br><span class="line">    		               <span class="string">&quot;task1&quot;</span>,<span class="comment">//任务名</span></span><br><span class="line">			                <span class="number">2048</span>,<span class="comment">//任务栈</span></span><br><span class="line">			               <span class="string">&quot;task1&quot;</span>,<span class="comment">//传给任务函数的参数</span></span><br><span class="line">			                <span class="number">2</span>,<span class="comment">//任务优先级</span></span><br><span class="line">			               <span class="literal">NULL</span>,<span class="comment">//任务回传句柄</span></span><br><span class="line">			               tskNO_AFFINITY);<span class="comment">//这个任务将不会固定在某个核心上执行</span></span><br><span class="line">    xTaskCreate(task,<span class="string">&quot;task2&quot;</span>,<span class="number">2048</span>,<span class="string">&quot;task2&quot;</span>,<span class="number">2</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//创建不固定在某个核心上运行的任务，如果对双核利用没有要求，一般情况下可以直接使用这个函数</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        vTaskDelay(<span class="number">1000</span>/portTICK_PERIOD_MS);<span class="comment">//app_main()也被看作一个任务，所以需要设置任务切换</span></span><br><span class="line">    &#125;</span><br><span class="line">    vTaskDelete();<span class="comment">//不会执行到此，但如果不加上面的死循环则必须用这个指令删除任务防止内存溢出或程序跑飞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用下面的API进行任务延时</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使当前任务挂起xTicksToDelay的时间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vTaskDelay</span><span class="params">(<span class="keyword">const</span> TickType_t xTicksToDelay)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//根据系统时间向后延迟到pxPreviousWakeTime</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vTaskDelayUntil</span><span class="params">(TickType_t *<span class="keyword">const</span> pxPreviousWakeTime,<span class="comment">//任务开始挂起的时间, 第一次使用时必须用当前时间初始化</span></span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">const</span> TickType_t xTimeIncrement)</span><span class="comment">//每次进入挂起的时间</span></span></span><br></pre></td></tr></table></figure>

<p>两个API的不同点在于vTaskDelay()从当前时间开始xTicksToDelay的时间延迟；vTaskDelayUntil()根据pxPreviousWakeTime和xTimeIncrement计算延迟的时间，延迟到系统时钟为pxPreviousWakeTime时，每次进入延迟的时间为xTimeIncrement</p>
<p>下面是使用例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vTaskDelay(<span class="number">10</span>);<span class="comment">//直接延迟10个时钟周期</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用下面的函数可以完成恒定频率的任务</span></span><br><span class="line"><span class="keyword">const</span> TickType_t xFrequency=<span class="number">10</span>;</span><br><span class="line">TickType_t xLastWakeTime=xTaskGetTickCount();<span class="comment">//获取当前系统时间</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	vTaskDelayUntil(&amp;xLastWakeTime,xFrequency);<span class="comment">//重复xFrequency延迟</span></span><br></pre></td></tr></table></figure>

<p>vTaskDelayUntil()可能不太好理解，建议写几个程序验证一下</p>
<h2 id="任务调度-1"><a href="#任务调度-1" class="headerlink" title="任务调度"></a>任务调度</h2><p>使用以下API控制任务调度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vTaskStartScheduler();<span class="comment">//启动任务调度器</span></span><br><span class="line">vTaskEndScheduler();<span class="comment">//停止使用任务调度器，这将释放所有内核分配的内存资源，但不会释放由程序分配的资源</span></span><br></pre></td></tr></table></figure>

<h2 id="队列通信与空闲任务"><a href="#队列通信与空闲任务" class="headerlink" title="队列通信与空闲任务"></a>队列通信与空闲任务</h2><p><strong>队列（消息队列）是任务通信的主要形式</strong></p>
<p>队列用于在任务和任务之间以及任务和中断之间发送消息。队列消息会使用线程安全FIFO进行传输</p>
<p>可以使用队列API函数指定阻塞时间，阻塞时间代表任务进入阻塞状态，等待队列中数据或者等待队列空间变为可以使用时的最大系统节拍数。当一个以上任务在同一个队列中被阻塞时，高优先级的任务先解除阻塞</p>
<p>使用<code>#include &quot;queue.h&quot;</code>来使用队列相关的API</p>
<p>项目（消息）在队列中传送时，通过复制而不是引用进入FIFO，需要在传递项目到队列时为每个项目分配同样的大小</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建新队列，返回这个队列的句柄</span></span><br><span class="line"><span class="function">xQueueHandle <span class="title">xQueueCreate</span> <span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> portBASE_TYPE uxQueueLength,<span class="comment">//队列中包含最大项目数量</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> portBASE_TYPE uxItemSize<span class="comment">//队列中每个项目所需的字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传递项目到队列</span></span><br><span class="line"><span class="function">portBASE_TYPE <span class="title">xQueueSend</span> <span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">    xQueueHandle xQueue,<span class="comment">//要传进的队列 </span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> <span class="keyword">void</span> * pvItemToQueue,<span class="comment">//要传项目的指针 </span></span></span></span><br><span class="line"><span class="params"><span class="function">    portTickType xTicksToWait<span class="comment">//等待的最大时间量（单位：系统时钟） </span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从队列接收一个项目</span></span><br><span class="line"><span class="function">portBASE_TYPE <span class="title">xQueueReceive</span> <span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">    xQueueHandle xQueue,<span class="comment">//项目所在队列的句柄 </span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">void</span> *pvBuffer,<span class="comment">//指向缓冲区的指针，接收的项目会被复制进去 </span></span></span></span><br><span class="line"><span class="params"><span class="function">    portTickType xTicksToWait<span class="comment">//任务中断并等待队列中可用空间的最大时间 </span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从中断传递项目到一个队列中的后面</span></span><br><span class="line"><span class="function">portBASE_TYPE <span class="title">xQueueSendFromISR</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	xQueueHandle pxQueue,<span class="comment">//将项目传进的队列</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> <span class="keyword">void</span> *pvItemToQueue,<span class="comment">//项目的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">	portBASE_TYPE *pxHigherPriorityTaskWoken<span class="comment">//因空间数据问题被挂起的任务是否解锁</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">/* 如果传进队列而导致因空间数据问题被挂起的任务解锁，并且解锁的任务的优先级高于当前运行任务，</span></span><br><span class="line"><span class="comment">xQueueSendFromISR 将设置 *pxHigherPriorityTaskWoken 到 pdTRUE</span></span><br><span class="line"><span class="comment">当pxHigherPriorityTaskWoken被设置为pdTRUE 时，则在中断退出之前将请求任务切换 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//中断时从队列接收一个项目</span></span><br><span class="line"><span class="function">portBASE_TYPE <span class="title">xQueueReceiveFromISR</span> <span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">    xQueueHandle pxQueue,<span class="comment">//发送项目的队列的句柄 </span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">void</span> *pvBuffer,<span class="comment">//指向缓冲区的指针，接收的项目会被复制进去 </span></span></span></span><br><span class="line"><span class="params"><span class="function">    portBASE_TYPE *pxTaskWoken<span class="comment">//任务将被锁住来等待队列中的可用空间</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vQueueUnregisterQueue</span> <span class="params">(xQueueHandle xQueue)</span></span>;<span class="comment">//要移除队列的句柄</span></span><br></pre></td></tr></table></figure>

<h2 id="信号量与互斥量"><a href="#信号量与互斥量" class="headerlink" title="信号量与互斥量"></a>信号量与互斥量</h2><p>使用<code>#include &quot;semphr.h&quot;</code>后才能使用信号量相关API</p>
<p>互斥量是特殊的信号量，一般可以用信号量/互斥量替代裸机编程中的全局变量标志</p>
<p>信号量的两种典型应用</p>
<h3 id="事件计数"><a href="#事件计数" class="headerlink" title="事件计数"></a>事件计数</h3><p>事件处理程序在每次事件发生时发送信号量；任务处理程序会在每次处理事件时请求信号量</p>
<p>这样一边递增信号量，一边递减信号量，计数值为事件发生和事件处理两者间的差值</p>
<p>若计数值为正，则存在没有处理的事件</p>
<p>一般此时将信号量计数值初始化为0</p>
<h3 id="资源管理（临界区）"><a href="#资源管理（临界区）" class="headerlink" title="资源管理（临界区）"></a>资源管理（临界区）</h3><p>如果系统中存在临界区（多个线程/应用程序同时需要使用的硬件资源）时，一般使用信号量来进行管理</p>
<p>使用信号量计数值指示出可用的资源数量，当计数值降为0时表示没有空闲资源</p>
<p>任务使用临界区时申请信号量，而不再访问临界区前返还信号量</p>
<p>这种情况下应该将信号量的计数值初始化为临界区系统资源的值</p>
<h3 id="互斥量与二值信号量"><a href="#互斥量与二值信号量" class="headerlink" title="互斥量与二值信号量"></a>互斥量与二值信号量</h3><p>互斥量是一种特殊的二值信号量，又被称为<strong>互斥锁</strong></p>
<p><strong>二值信号量</strong>就是只有两个可用值的信号量，比如一个只包含了0和1的信号量</p>
<p>互斥锁包含一个优先级继承机制，而信号量没有。这个特点决定了二值信号量适合实现线程间（任务间）同步；互斥锁更适合实现简单的互斥</p>
<p>当有另外一个具有更高优先级的任务试图获取同一个互斥锁时，已经获得互斥锁的任务的优先级会被提升，已经获得互斥锁的任务将继承试图获取同一互斥锁的任务的优先级。这意味着互斥锁必须总是要返还的，否则高优先级的任务将永远也不能获取互斥锁，而低优先级的任务将不会放弃优先级的继承。这就避免了出现互斥锁卡死的bug</p>
<p>二值信号量并不需要在得到后立即释放，任务同步可以通过一个任务/中断持续释放信号量而另外一个持续获得信号量来实现</p>
<p>互斥锁与二元信号量均赋值为xSemaphoreHandle类型，可以在任何此类型参数的API 函数中使用</p>
<p>注意：<strong>互斥类型的信号量不能在中断服务程序中使用</strong></p>
<p>下面介绍互斥量和信号量的相关API</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建递归的互斥锁</span></span><br><span class="line"><span class="function">xSemaphoreHandle <span class="title">xSemaphoreCreateRecursiveMutex</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一个递归的互斥锁可以重复地被其所有者“获取”</span></span><br><span class="line"><span class="comment">在其所有者为每次的成功“获取”请求调用xSemaphoreGiveRecursive()前，此互斥锁不会再次可用</span></span><br><span class="line"><span class="comment">也就是说，一个任务重复获取同一个互斥锁n次，则需要在释放互斥锁n次后，其他任务才可以使用此互斥锁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取信号量与互斥锁</span></span><br><span class="line">xSemaphoreTake ( </span><br><span class="line">    xSemaphoreHandle xSemaphore,<span class="comment">//将被获得的信号量句柄</span></span><br><span class="line">    portTickType xBlockTime<span class="comment">//等待信号量可用的时钟滴答次数</span></span><br><span class="line">);<span class="comment">//获得信号量</span></span><br><span class="line"></span><br><span class="line">xSemaphoreTakeRecursive ( </span><br><span class="line">    xSemaphoreHandle xMutex,<span class="comment">//将被获得的互斥锁句柄</span></span><br><span class="line">    portTickType xBlockTime<span class="comment">//等待互斥锁可用的时钟滴答次数 </span></span><br><span class="line">);<span class="comment">//递归获得互斥锁信号量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//释放信号量</span></span><br><span class="line">xSemaphoreGive (xSemaphoreHandle xSemaphore);</span><br><span class="line"><span class="comment">//递归释放互斥锁信号量</span></span><br><span class="line">xSemaphoreGiveRecursive (xSemaphoreHandle xMutex);</span><br><span class="line"><span class="comment">//从中断释放信号量</span></span><br><span class="line">xSemaphoreGiveFromISR ( </span><br><span class="line">    xSemaphoreHandle xSemaphore,<span class="comment">//将被释放的信号量的句柄 </span></span><br><span class="line">    portBASE_TYPE *pxHigherPriorityTaskWoken<span class="comment">//因空间数据问题被挂起的任务是否解锁</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="事件集-1"><a href="#事件集-1" class="headerlink" title="事件集"></a>事件集</h2><p>FreeRTOS的事件可以理解为多个二值信号量的组合</p>
<p>事件只与任务相关联，事件之间相互独立；事件仅用于同步，不提供数据传输功能</p>
<p>事件无排队性，多次向任务设置同一事件，如果任务还未来得及读走，则等效于只设置一次；允许多个任务对同一事件进行读写操作</p>
<p><strong>事件通常可以用来替代裸机编程中的if/switch语句配合枚举/全局变量标志</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EventGroupHandle_t <span class="title">xEventGroupCreate</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//创建事件标志组，返回事件标志组的句柄</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置事件标志位</span></span><br><span class="line"><span class="function">EventBits_t <span class="title">xEventGroupSetBits</span><span class="params">(EventGroupHandle_t xEventGroup,<span class="comment">//事件标志组句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">const</span> EventBits_t uxBitsToSet<span class="comment">//事件标志位</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;<span class="comment">//注意使用前一定要创建对应的事件标志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从中断服务程序中设置事件标志位</span></span><br><span class="line"><span class="function">BaseType_t <span class="title">EventGroupSetBitsFromISR</span><span class="params">(EventGroupHandle_t xEventGroup,<span class="comment">//事件标志组句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">const</span> EventBits_t uxBitsToSet,<span class="comment">//事件标志位设置</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                    BaseType_t *pxHigherPriorityTaskWoken<span class="comment">//高优先级任务是否被唤醒的状态保存</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="ESP-IDF中的事件循环库"><a href="#ESP-IDF中的事件循环库" class="headerlink" title="ESP-IDF中的事件循环库"></a>ESP-IDF中的事件循环库</h3><p>为了处理wifi、蓝牙、网络接口等外设中大量的状态变化，一般会使用状态机（FSM），而指示状态就需要用到事件集。ESP-IDF中提供了可用的<strong>事件循环</strong>。向默认事件循环发送事件相当于事件的handler依次执行队列中的命令</p>
<p>事件循环被囊括在<strong>事件循环库</strong>（event loop library）中。事件循环库允许组件将事件发布到事件循环，而当其他组件被注册到事件循环且设置了对应的处理函数时，程序会自动地在事件发生时执行处理程序。</p>
<p>在ESP32的魔改版FreeRTOS中很少使用正经的事件集，而是使用ESP-IDF提供的更方便的事件循环</p>
<p>使用<code>#include &quot;esp_event.h&quot;</code>即可开启事件循环库功能</p>
<p>使用流程如下：</p>
<ol>
<li><p>用户定义一个事件处理函数，该函数被必须与esp_event_handler_t具有相同的结构（也就是说该函数是esp_event_handler_t类型的函数指针）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span></span></span><br><span class="line"><span class="function"><span class="title">void</span> <span class="params">(*<span class="keyword">esp_event_handler_t</span>)</span><span class="params">(<span class="keyword">void</span> *event_handler_arg,<span class="comment">//事件处理函数的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">esp_event_base_t</span> event_base,<span class="comment">//指向引发事件子程序的特殊指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">int32_t</span> event_id,<span class="comment">//事件的ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">void</span> *event_data)</span><span class="comment">//事件数据</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>esp_event_loop_create()</code>函数创建一个事件循环，该API会传回一个esp_event_loop_handle_t类型的指针用于指向事件循环。每个用该API创建的事件循环都被称为<strong>用户事件循环</strong>；除此之外，还可以使用一种称为<strong>默认事件循环</strong>的特殊事件循环（默认事件循环是系统自带的事件循环，实际上只使用默认事件循环就足够了，相关内容在之后叙述）</p>
</li>
<li><p>使用<code>esp_event_handler_register_with()</code>函数将事件处理函数<strong>注册</strong>到事件循环（注意：一个处理函数可以被注册到多个不同的事件循环中！）</p>
</li>
<li><p>开始运行程序</p>
</li>
<li><p>使用<code>esp_event_post_to</code>发送一个事件到目标事件循环</p>
</li>
<li><p>事件处理函数收取该事件并进行处理</p>
</li>
<li><p>使用<code>esp_event_handler_unregister_with</code>来取消注册某个事件处理函数</p>
</li>
<li><p>使用<code>esp_event_loop_delete</code>删除不再需要的事件循环</p>
</li>
</ol>
<p>官方给出的流程代码描述如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.定义事件处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run_on_event</span><span class="params">(<span class="keyword">void</span>* handler_arg, <span class="keyword">esp_event_base_t</span> base, <span class="keyword">int32_t</span> id, <span class="keyword">void</span>* event_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//2.配置esp_event_loop_args_t结构体来配置事件循环</span></span><br><span class="line">    <span class="keyword">esp_event_loop_args_t</span> loop_args = &#123;</span><br><span class="line">        .queue_size = ...,</span><br><span class="line">        .task_name = ...</span><br><span class="line">        .task_priority = ...,</span><br><span class="line">        .task_stack_size = ...,</span><br><span class="line">        .task_core_id = ...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个用户事件循环</span></span><br><span class="line">    <span class="keyword">esp_event_loop_handle_t</span> loop_handle;</span><br><span class="line">    esp_event_loop_create(&amp;loop_args, &amp;loop_handle);</span><br><span class="line">    <span class="comment">//3.注册事件处理函数</span></span><br><span class="line">    esp_event_handler_register_with(loop_handle, MY_EVENT_BASE, MY_EVENT_ID, run_on_event, ...);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//4.事件源使用以下API将事件发送到事件循环，随后事件处理函数会根据其中的逻辑进行处理</span></span><br><span class="line">    <span class="comment">//这一系列操作可以跨任务使用</span></span><br><span class="line">    esp_event_post_to(loop_handle, MY_EVENT_BASE, MY_EVENT_ID, ...)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//5.解除注册一个事件处理函数</span></span><br><span class="line">    esp_event_handler_unregister_with(loop_handle, MY_EVENT_BASE, MY_EVENT_ID, run_on_event);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//6.删除一个不需要的事件循环</span></span><br><span class="line">    esp_event_loop_delete(loop_handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用如下函数来声明和定义事件</p>
<p>一个事件由两部分标识组成：<strong>事件类型</strong>和<strong>事件ID</strong></p>
<p>事件类型标识了一个独立的事件组；事件ID区分在该组内的事件</p>
<p>==可以将事件类型视为人的姓，事件ID是人的名==</p>
<p>使用以下两个宏函数来声明、定义事件类型。一般地，在程序中使用XXX_EVENT的形式来定义一个事件类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ESP_EVENT_DECLARE_BASE(EVENT_BASE)<span class="comment">//声明事件类型</span></span><br><span class="line">ESP_EVENT_DEFINE_BASE(EVENT_BASE)<span class="comment">//定义事件类型</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//事件类型举例：WIFI_EVENT</span></span><br></pre></td></tr></table></figure>

<p>一般使用枚举变量来定义事件ID，如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    EVENT_ID_1,</span><br><span class="line">    EVENT_ID_2,</span><br><span class="line">    EVENT_ID_3,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当注册一个事件处理函数到不同事件循环后，<strong>事件循环可以根据不同的事件类型和事件ID来区分应该执行哪一个事件处理函数</strong></p>
<p>可以使用ESP_EVENT_ANY_BASE和ESP_EVENT_ANY_ID作为注册事件处理函数的参数，这样事件处理函数就可以处理发到当前注册事件循环上的任何事件</p>
<h3 id="默认事件循环"><a href="#默认事件循环" class="headerlink" title="默认事件循环"></a>默认事件循环</h3><p>默认事件循环是一种系统事件（如wifi、蓝牙事件等）使用的特殊事件循环。特殊的一点是它的句柄被隐藏起来，用户无法直接使用。用户只能通过一系列固定的API来操作这个事件循环</p>
<p>API如下表所示</p>
<table>
<thead>
<tr>
<th>用户事件循环</th>
<th>默认事件循环</th>
<th>事件循环API</th>
</tr>
</thead>
<tbody><tr>
<td>esp_event_loop_create()</td>
<td>esp_event_loop_create_default()</td>
<td>创建</td>
</tr>
<tr>
<td>esp_event_loop_delete()</td>
<td>esp_event_loop_delete_default()</td>
<td>删除</td>
</tr>
<tr>
<td>esp_event_handler_register_with()</td>
<td>esp_event_handler_register()</td>
<td>注册处理函数</td>
</tr>
<tr>
<td>esp_event_handler_unregister_with()</td>
<td>esp_event_handler_unregister()</td>
<td>取消注册处理函数</td>
</tr>
<tr>
<td>esp_event_post_to()</td>
<td>esp_event_post()</td>
<td>事件源发送事件到事件循环</td>
</tr>
</tbody></table>
<p>除了API区别和系统事件会自动发送到默认事件循环外，<strong>两者并没有更多差别</strong>，所以说用户可以将自定义的事件直接发送到默认事件循环，这比用户定义的事件循环更节约内存且<strong>更方便</strong>！</p>
<p>==任务、队列和事件循环是ESP32中最常用也是最特殊的SMP FreeRTOS API==</p>
<h3 id="事件循环库API简介"><a href="#事件循环库API简介" class="headerlink" title="事件循环库API简介"></a>事件循环库API简介</h3><p>使用以下API控制事件循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_event_loop_create_default</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//创建默认事件循环</span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_event_loop_delete_default</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//删除默认事件循环</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建用户事件循环</span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_event_loop_create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">esp_event_loop_args_t</span> *event_loop_args,<span class="comment">//事件循环参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">esp_event_loop_handle_t</span> *event_loop)</span></span>;<span class="comment">//事件循环句柄</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//删除用户事件循环</span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_event_loop_delete</span><span class="params">(<span class="keyword">esp_event_loop_handle_t</span> event_loop)</span></span>;<span class="comment">//事件循环</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_event_loop_run</span><span class="params">(<span class="keyword">esp_event_loop_handle_t</span> event_loop, TickType_t ticks_to_run)</span></span>;</span><br><span class="line"><span class="comment">//将时间分配到一个事件循环，不常用，注意事项一大堆懒得看了——总之详细用法请参考官网API简介    </span></span><br></pre></td></tr></table></figure>

<p>使用以下API来注册/注销事件处理函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将事件处理程序注册到系统事件循环</span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_event_handler_register</span><span class="params">(<span class="keyword">esp_event_base_t</span> event_base,<span class="comment">//事件类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">int32_t</span> event_id,<span class="comment">//事件ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">esp_event_handler_t</span> event_handler,<span class="comment">//事件处理函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">void</span> *event_handler_arg)</span></span>;<span class="comment">//事件处理函数的参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将事件处理程序注册到用户事件循环</span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_event_handler_register_with</span><span class="params">(<span class="keyword">esp_event_loop_handle_t</span> event_loop,<span class="comment">//要注册到的事件循环</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="keyword">esp_event_base_t</span> event_base,<span class="comment">//事件类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="keyword">int32_t</span> event_id,<span class="comment">//事件ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="keyword">esp_event_handler_t</span> event_handler,<span class="comment">//事件处理函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="keyword">void</span> *event_handler_arg)</span></span>;<span class="comment">//事件处理函数的参数</span></span><br><span class="line"><span class="comment">//取消注册（系统事件循环）</span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_event_handler_unregister</span><span class="params">(<span class="keyword">esp_event_base_t</span> event_base,<span class="comment">//事件类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="keyword">int32_t</span> event_id,<span class="comment">//事件ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="keyword">esp_event_handler_t</span> event_handler)</span></span>;<span class="comment">//事件处理函数</span></span><br><span class="line"><span class="comment">//取消注册（用户事件循环）</span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_event_handler_unregister_with</span><span class="params">(<span class="keyword">esp_event_loop_handle_t</span> event_loop,<span class="comment">//要取消注册的事件循环</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="keyword">esp_event_base_t</span> event_base,<span class="comment">//事件类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="keyword">int32_t</span> event_id,<span class="comment">//事件ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="keyword">esp_event_handler_t</span> event_handler)</span></span>;<span class="comment">//事件处理函数</span></span><br></pre></td></tr></table></figure>

<p>可以使用ESP_EVENT_ANY_BASE 和ESP_EVENT_ANY_ID来取消注册所有事件循环上的事件处理函数</p>
<p>使用以下API来发送事件到事件循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送事件到系统事件循环</span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_event_post</span><span class="params">(<span class="keyword">esp_event_base_t</span> event_base,<span class="comment">//事件类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">int32_t</span> event_id,<span class="comment">//事件ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">void</span> *event_data,<span class="comment">//事件数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">size_t</span> event_data_size,<span class="comment">//事件数据的大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">                         TickType_t ticks_to_wait)</span></span>;<span class="comment">//等待时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//发送事件到用户事件循环</span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_event_post_to</span><span class="params">(<span class="keyword">esp_event_loop_handle_t</span> event_loop,<span class="comment">//要发送到的用户事件循环的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">esp_event_base_t</span> event_base,<span class="comment">//事件类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">int32_t</span> event_id,<span class="comment">//事件ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">void</span> *event_data,<span class="comment">//事件数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">size_t</span> event_data_size,<span class="comment">//事件数据的大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            TickType_t ticks_to_wait)</span><span class="comment">//等待时间</span></span></span><br></pre></td></tr></table></figure>

<p>事件循环库函数会保留事件数据的副本并自动控制副本的存活时间</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">ESP32</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A07%E3%80%90ESP32%E4%B8%8A%E7%9A%84FreeRTOS%E3%80%91/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-ESP32-IDF学习6【HTTP服务器】" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A06%E3%80%90HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%91/">ESP32_IDF学习6【HTTP服务器】</a>
    </h1>
  

        
<!-- 显示阅读次数-->
<!--  -->
<!--显示阅读次数完毕 -->

        
        <a href="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A06%E3%80%90HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%91/" class="archive-article-date">
  	<time datetime="2021-11-19T07:02:50.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2021-11-19</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="TCP-IP组件"><a href="#TCP-IP组件" class="headerlink" title="TCP/IP组件"></a>TCP/IP组件</h1><p>ESP系列提供了实现TCP/IP协议栈的库函数，<code>#include &lt;esp_netif.h&gt;</code>即可使用这些库函数</p>
<p>特点如下：</p>
<ul>
<li>提供TCP/IP协议栈的应用抽象层</li>
<li>提供线程保护</li>
<li>目前只用于lwIP TCP/IP协议栈（lwIP：Light Weight IP Protocol，支持在嵌入式设备中使用的小型TCP/IP协议栈，占用内存较少）</li>
<li>具有丰富的API库函数</li>
<li>大多数情况下，应用程序不需要直接调用组件的API，而是从默认的网络事件处理函数中调用</li>
<li>不兼容idf4.1以下使用的TCP/IP适配器相关函数，需修改代码进行迁移</li>
</ul>
<p>ESP-NETIF结构如下（摘自官方文档）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">                 |          (A) USER CODE                 |</span><br><span class="line">                 |                                        |</span><br><span class="line">    .............| init          settings      events     |</span><br><span class="line">    .            +----------------------------------------+</span><br><span class="line">    .               .                |           *</span><br><span class="line">    .               .                |           *</span><br><span class="line">--------+        +===========================+   *     +-----------------------+</span><br><span class="line">        |        | new/config     get/set    |   *     |                       |</span><br><span class="line">        |        |                           |...*.....| init                  |</span><br><span class="line">        |        |---------------------------|   *     |                       |</span><br><span class="line">  init  |        |                           |****     |                       |</span><br><span class="line">  start |********|  event handler            |*********|  DHCP                 |</span><br><span class="line">  stop  |        |                           |         |                       |</span><br><span class="line">        |        |---------------------------|         |                       |</span><br><span class="line">        |        |                           |         |    NETIF              |</span><br><span class="line">  +-----|        |                           |         +-----------------+     |</span><br><span class="line">  | glue|----&lt;---|  esp_netif_transmit       |--&lt;------| netif_output    |     |</span><br><span class="line">  |     |        |                           |         |                 |     |</span><br><span class="line">  |     |----&gt;---|  esp_netif_receive        |--&gt;------| netif_input     |     |</span><br><span class="line">  |     |        |                           |         + ----------------+     |</span><br><span class="line">  |     |....&lt;...|  esp_netif_free_rx_buffer |...&lt;.....| packet buffer         |</span><br><span class="line">  +-----|        |                           |         |                       |</span><br><span class="line">        |        |                           |         |         (D)           |</span><br><span class="line">  (B)   |        |          (C)              |         +-----------------------+</span><br><span class="line">--------+        +===========================+</span><br><span class="line">communication                                                NETWORK STACK</span><br><span class="line">DRIVER                   ESP-NETIF</span><br></pre></td></tr></table></figure>

<p>其中……代表初始化；—-&gt;—或—&lt;—-代表数据包走向；******代表操作系统的事件调用；|代表用户代码的设置和运行时的配置</p>
<h2 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ol>
<li>初始化IO驱动</li>
<li>创建一个ESP-NETIF的实例并进行如下配置：<ol>
<li>特殊属性</li>
<li>网络协议栈相关设置</li>
<li>IO设置</li>
</ol>
</li>
<li>将IO驱动句柄和NETIF实例关联</li>
<li>配置事件处理函数，至少需要：<ol>
<li>默认处理函数：用于普通的来自IO驱动器或其他特殊的接口的事件调用</li>
<li>register处理函数：用故意相关联的应用程序事件调用</li>
</ol>
</li>
</ol>
<h3 id="运行时配置"><a href="#运行时配置" class="headerlink" title="运行时配置"></a>运行时配置</h3><ol>
<li>获取当前TCP/IP设置</li>
<li>收取IP事件</li>
<li>控制应用程序的FSM</li>
</ol>
<h1 id="配置的实例"><a href="#配置的实例" class="headerlink" title="配置的实例"></a>配置的实例</h1><h2 id="WiFi默认初始化"><a href="#WiFi默认初始化" class="headerlink" title="WiFi默认初始化"></a>WiFi默认初始化</h2><p>使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_netif_t</span> *<span class="title">esp_netif_create_default_wifi_ap</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//初始化wifi为ap模式</span></span><br><span class="line"><span class="function"><span class="keyword">esp_netif_t</span> *<span class="title">esp_netif_create_default_wifi_sta</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//初始化wifi为STA模式</span></span><br></pre></td></tr></table></figure>

<p>两个API进行默认状态的wifi初始化，函数会返回对应的esp-netif实例</p>
<p>注意：创建的实例如果不再运行时需要停止并释放内存空间，且不能被多次创建</p>
<p>==如果需要使用AP+STA模式，两个接口都需要被创建==</p>
<h2 id="相关库函数"><a href="#相关库函数" class="headerlink" title="相关库函数"></a>相关库函数</h2><ol>
<li>初始化</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">esp_netif_init(<span class="keyword">void</span>);<span class="comment">//初始化组件</span></span><br><span class="line">esp_netif_deinit(<span class="keyword">void</span>);<span class="comment">//销毁组件</span></span><br><span class="line">esp_netif_new(<span class="keyword">const</span> <span class="keyword">esp_netif_config_t</span> *esp_netif_config);<span class="comment">//根据配置结构体esp_netif_config创建一个新esp-netif实例</span></span><br><span class="line">esp_netif_destroy(<span class="keyword">esp_netif_t</span> *esp_netif);<span class="comment">//删除一个esp-netif实例</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">esp_netif_set_driver_config(<span class="keyword">esp_netif_t</span> *esp_netif, <span class="keyword">const</span> <span class="keyword">esp_netif_driver_ifconfig_t</span> *driver_config);</span><br><span class="line"><span class="comment">//设置与esp-netif对象关联的IO驱动器</span></span><br><span class="line">esp_netif_attach(<span class="keyword">esp_netif_t</span> *esp_netif, esp_netif_iodriver_handle driver_handle);</span><br><span class="line"><span class="comment">//关联esp-netif对象与IO驱动器</span></span><br><span class="line"><span class="comment">//可以在完成关联后调用处理函数来进行回调或启动驱动器任务</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">esp_netif_receive(<span class="keyword">esp_netif_t</span> *esp_netif, <span class="keyword">void</span> *buffer, <span class="keyword">size_t</span> len, <span class="keyword">void</span> *eb);</span><br><span class="line"><span class="comment">//从应用向TCP/IP协议栈发送包</span></span><br><span class="line">esp_netif_action_start(<span class="keyword">void</span> *esp_netif, <span class="keyword">esp_event_base_t</span> base, <span class="keyword">int32_t</span> event_id, <span class="keyword">void</span> *data);</span><br><span class="line"><span class="comment">//自动启用TCP/IP协议（使能如DHCP的功能）</span></span><br><span class="line">esp_netif_action_stop(<span class="keyword">void</span> *esp_netif, <span class="keyword">esp_event_base_t</span> base, <span class="keyword">int32_t</span> event_id, <span class="keyword">void</span> *data);</span><br><span class="line"><span class="comment">//停止向TCP/IP协议栈发送包</span></span><br><span class="line"></span><br><span class="line">esp_netif_action_got_ip(<span class="keyword">void</span> *esp_netif, <span class="keyword">esp_event_base_t</span> base, <span class="keyword">int32_t</span> event_id, <span class="keyword">void</span> *data);</span><br><span class="line"><span class="comment">//获取当前IP</span></span><br><span class="line">esp_netif_set_mac(<span class="keyword">esp_netif_t</span> *esp_netif, <span class="keyword">uint8_t</span> mac[]);</span><br><span class="line"><span class="comment">//设置当前MAC地址</span></span><br><span class="line">esp_netif_set_hostname(<span class="keyword">esp_netif_t</span> *esp_netif, <span class="keyword">const</span> <span class="keyword">char</span> *hostname);</span><br><span class="line"><span class="comment">//设置当前主机名</span></span><br><span class="line">esp_netif_get_hostname(<span class="keyword">esp_netif_t</span> *esp_netif, <span class="keyword">const</span> <span class="keyword">char</span> **hostname);</span><br><span class="line"><span class="comment">//获取当前主机名</span></span><br><span class="line">esp_netif_get_ip_info(<span class="keyword">esp_netif_t</span> *esp_netif, <span class="keyword">esp_netif_ip_info_t</span> *ip_info);</span><br><span class="line"><span class="comment">//获取当前IP地址相关信息</span></span><br><span class="line">esp_netif_set_ip_info(<span class="keyword">esp_netif_t</span> *esp_netif, <span class="keyword">const</span> <span class="keyword">esp_netif_ip_info_t</span> *ip_info);</span><br><span class="line"><span class="comment">//设置当前IP地址相关信息</span></span><br><span class="line"></span><br><span class="line">esp_netif_get_netif_impl_index(<span class="keyword">esp_netif_t</span> *esp_netif);</span><br><span class="line"><span class="comment">//获取当前网络接口的代号</span></span><br><span class="line"></span><br><span class="line">esp_netif_dhcps_option(<span class="keyword">esp_netif_t</span> *esp_netif,</span><br><span class="line">                       <span class="keyword">esp_netif_dhcp_option_mode_t</span> opt_op,</span><br><span class="line">                       <span class="keyword">esp_netif_dhcp_option_id_t</span> opt_id,</span><br><span class="line">                       <span class="keyword">void</span> *opt_val,</span><br><span class="line">                       <span class="keyword">uint32_t</span> opt_len);</span><br><span class="line"><span class="comment">//配置DHCP服务器</span></span><br><span class="line">esp_netif_dhcpc_option(<span class="keyword">esp_netif_t</span> *esp_netif,</span><br><span class="line">                       <span class="keyword">esp_netif_dhcp_option_mode_t</span> opt_op,</span><br><span class="line">                       <span class="keyword">esp_netif_dhcp_option_id_t</span> opt_id,</span><br><span class="line">                       <span class="keyword">void</span> *opt_val,</span><br><span class="line">                       <span class="keyword">uint32_t</span> opt_len)</span><br><span class="line"><span class="comment">//配置DHCP客户端</span></span><br><span class="line">esp_netif_dhcpc_start(<span class="keyword">esp_netif_t</span> *esp_netif);<span class="comment">//开启DHCP客户端</span></span><br><span class="line">esp_netif_dhcpc_stop(<span class="keyword">esp_netif_t</span> *esp_netif);<span class="comment">//停止DHCP客户端</span></span><br><span class="line">esp_netif_dhcps_start(<span class="keyword">esp_netif_t</span> *esp_netif);<span class="comment">//开启DHCP服务器</span></span><br><span class="line">esp_netif_dhcps_stop(<span class="keyword">esp_netif_t</span> *esp_netif);<span class="comment">//关闭DHCP服务器</span></span><br><span class="line">esp_netif_dhcpc_get_status(<span class="keyword">esp_netif_t</span> *esp_netif, <span class="keyword">esp_netif_dhcp_status_t</span> *status);</span><br><span class="line"><span class="comment">//获取当前DHCP客户端状态</span></span><br><span class="line">esp_netif_dhcps_get_status(<span class="keyword">esp_netif_t</span> *esp_netif, <span class="keyword">esp_netif_dhcp_status_t</span> *status);</span><br><span class="line"><span class="comment">//获取当前DHCP服务器状态</span></span><br><span class="line"></span><br><span class="line">esp_netif_set_dns_info(<span class="keyword">esp_netif_t</span> *esp_netif, <span class="keyword">esp_netif_dns_type_t</span> type, <span class="keyword">esp_netif_dns_info_t</span> *dns);</span><br><span class="line"><span class="comment">//设置DNS服务器信息</span></span><br><span class="line">esp_netif_get_dns_info(<span class="keyword">esp_netif_t</span> *esp_netif, <span class="keyword">esp_netif_dns_type_t</span> type, <span class="keyword">esp_netif_dns_info_t</span> *dns);</span><br><span class="line"><span class="comment">//获取DNS服务器信息</span></span><br><span class="line"></span><br><span class="line">esp_netif_create_ip6_linklocal(<span class="keyword">esp_netif_t</span> *esp_netif);<span class="comment">//创建本地IPv6地址</span></span><br><span class="line">esp_netif_set_ip4_addr(<span class="keyword">esp_ip4_addr_t</span> *addr, <span class="keyword">uint8_t</span> a, <span class="keyword">uint8_t</span> b, <span class="keyword">uint8_t</span> c, <span class="keyword">uint8_t</span> d);<span class="comment">//设置本地IPv4地址</span></span><br><span class="line">esp_netif_get_ip6_global(<span class="keyword">esp_netif_t</span> *esp_netif, <span class="keyword">esp_ip6_addr_t</span> *if_ip6)<span class="comment">//创建全局IPv6地址</span></span><br><span class="line">esp_netif_get_ip6_linklocal(<span class="keyword">esp_netif_t</span> *esp_netif, <span class="keyword">esp_ip6_addr_t</span> *if_ip6);<span class="comment">//获取本地IPv6地址</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>事件处理函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">esp_wifi_set_default_wifi_sta_handlers(<span class="keyword">void</span>);</span><br><span class="line">esp_wifi_set_default_wifi_ap_handlers(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>默认设置</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">esp_netif_create_default_wifi_ap(<span class="keyword">void</span>);</span><br><span class="line">esp_netif_create_default_wifi_sta(<span class="keyword">void</span>);</span><br><span class="line">esp_netif_create_default_wifi_mesh_netifs(<span class="keyword">esp_netif_t</span> **p_netif_sta, <span class="keyword">esp_netif_t</span> **p_netif_ap);</span><br></pre></td></tr></table></figure>

<h1 id="HTTP-Server组件"><a href="#HTTP-Server组件" class="headerlink" title="HTTP Server组件"></a>HTTP Server组件</h1><p>原文地址：<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/release-v4.1/api-reference/protocols/esp_http_server.html">https://docs.espressif.com/projects/esp-idf/zh_CN/release-v4.1/api-reference/protocols/esp_http_server.html</a></p>
<p>HTTP Server 组件提供了在 ESP32 上运行轻量级 Web 服务器的功能</p>
<p>使用步骤：</p>
<ol>
<li>使用httpd_start()创建HTTP Server的实例</li>
</ol>
<p>API会根据具体配置为其分配内存和资源，该函数返回指向服务器实例的指针（句柄）</p>
<p>服务器使用两个套接字，其中一个用于监听HTTP流量（TCP类型），一个用来处理控制信号（UDP类型），它们在服务器的任务循环中轮流使用。TCP 流量被解析为 HTTP 请求，根据请求的 URI （Uniform Resource Identifier统一资源标志符，表示web上每一种可用的资源）来调用用户注册的处理程序，在处理程序中需要发送回 HTTP 响应数据包。</p>
<p><strong>URI通常由三部分组成：资源的命名机制；存放资源的主机名；资源自身的名称</strong>。另外，常说的URL是URI的一个子集（Uniform Resource Locator统一资源定位符），URL是一种具体的URI，它是URI的一个子集，它不仅唯一标识资源，而且还提供了定位该资源的信息。URL是Internet上描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，<strong>URL的格式由三部分组成：第一部分是协议(或称为服务方式)；第二部分是存有该资源的主机IP地址(有时也包括端口号)；第三部分是主机资源的具体地址，如目录和文件名等</strong>。第一部分和第二部分用“://”符号隔开，第二部分和第三部分用“/”符号隔开。第一部分和第二部分是不可缺少的，第三部分有时可以省略。 </p>
<p>使用结构体httpd_config_t来配置服务器的各种设定（任务优先级、堆栈大小）</p>
<p>API和结构体如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">httpd_start(<span class="keyword">httpd_handle_t</span> *handle, <span class="keyword">const</span> <span class="keyword">httpd_config_t</span> *config);<span class="comment">//开启HTTP服务器并分配内存资源</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例应用</span></span><br><span class="line"><span class="function"><span class="keyword">httpd_handle_t</span> <span class="title">start_webserver</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">//可以使用以下宏函数来初始化httpd_config为默认值</span></span><br><span class="line">     <span class="keyword">httpd_config_t</span> config = HTTPD_DEFAULT_CONFIG();</span><br><span class="line">     <span class="comment">//设置服务器句柄为空</span></span><br><span class="line">     <span class="keyword">httpd_handle_t</span> server = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//启动HTTP服务器</span></span><br><span class="line">     <span class="keyword">if</span> (httpd_start(&amp;server, &amp;config) == ESP_OK)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">//注册uri句柄</span></span><br><span class="line">         httpd_register_uri_handler(server, &amp;uri_get);</span><br><span class="line">         httpd_register_uri_handler(server, &amp;uri_post);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//返回服务器句柄，如果启动失败则句柄为空</span></span><br><span class="line">     <span class="keyword">return</span> server;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">httpd_config</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> task_priority;<span class="comment">//RTOS服务器任务优先级</span></span><br><span class="line">    <span class="keyword">size_t</span> stack_size;<span class="comment">//服务器任务的最大栈大小</span></span><br><span class="line">    BaseType_t core_id;<span class="comment">//服务器任务运行在哪个CPU core上</span></span><br><span class="line">    <span class="keyword">uint16_t</span> server_port;<span class="comment">//服务器使用的端口号</span></span><br><span class="line">    <span class="keyword">uint16_t</span> ctrl_port;<span class="comment">//在服务器组件间异步交换控制信号的UDP端口号</span></span><br><span class="line">    <span class="keyword">uint16_t</span> max_open_sockets;<span class="comment">//最大连接的套接字/客户端数量</span></span><br><span class="line">    <span class="keyword">uint16_t</span> max_uri_handlers;<span class="comment">//最大允许的uri句柄数量</span></span><br><span class="line">    <span class="keyword">uint16_t</span> max_resp_headers;<span class="comment">//最大允许的HTTP响应头</span></span><br><span class="line">    <span class="keyword">uint16_t</span> backlog_conn;<span class="comment">//积压链接的数量</span></span><br><span class="line">    <span class="keyword">bool</span> lru_purge_enable;<span class="comment">//是否清除最近使用的连接</span></span><br><span class="line">    <span class="keyword">uint16_t</span> recv_wait_timeout;<span class="comment">//接收函数的超时时间</span></span><br><span class="line">    <span class="keyword">uint16_t</span> send_wait_timeout;<span class="comment">//发送函数的超时时间</span></span><br><span class="line">    <span class="keyword">void</span> *global_user_ctx;<span class="comment">//全局用户上下文，专门用于存储服务器上下文中的用户数据</span></span><br><span class="line">    <span class="keyword">httpd_free_ctx_fn_t</span> global_user_ctx_free_fn;<span class="comment">//释放空间函数</span></span><br><span class="line">    <span class="keyword">void</span> *global_transport_ctx;<span class="comment">//全局传输上下文，用于存储部分解码或加密使用到的数据，和全局用户上下文意昂需要用free()函数释放内存空间，除非global_transport_ctx_free_fn被指定</span></span><br><span class="line">    <span class="keyword">httpd_free_ctx_fn_t</span> global_transport_ctx_free_fn;<span class="comment">//释放空间函数</span></span><br><span class="line">    <span class="keyword">httpd_open_func_t</span> open_fn;<span class="comment">//自定义session开启回调函数，在新的session开启时被调用</span></span><br><span class="line">    <span class="keyword">httpd_close_func_t</span> close_fn;<span class="comment">//自定义session关闭回调函数</span></span><br><span class="line">    <span class="keyword">httpd_uri_match_func_t</span> uri_match_fn;<span class="comment">//URI匹配函数，用于在搜索到匹配的URI时调用</span></span><br><span class="line">&#125;<span class="keyword">httpd_config_t</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置URI处理程序</li>
</ol>
<p>使用httpd_register_uri_handler()完成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//API原型</span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">httpd_register_uri_handler</span><span class="params">(<span class="keyword">httpd_handle_t</span> handle, <span class="keyword">const</span> <span class="keyword">httpd_uri_t</span> *uri_handler)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//示例</span></span></span><br><span class="line"><span class="function"><span class="comment">//URI处理函数</span></span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">my_uri_handler</span><span class="params">(<span class="keyword">httpd_req_t</span>* req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//收取请求、处理并发送响应</span></span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">//出错状态</span></span><br><span class="line">    <span class="keyword">if</span> (....)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//返回错误</span></span><br><span class="line">        <span class="keyword">return</span> ESP_FAIL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成功状态</span></span><br><span class="line">    <span class="keyword">return</span> ESP_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//URI句柄结构体</span></span><br><span class="line"><span class="keyword">httpd_uri_t</span> my_uri &#123;</span><br><span class="line">    .uri      = <span class="string">&quot;/my_uri/path/xyz&quot;</span>,<span class="comment">//相关的URI</span></span><br><span class="line">    .method   = HTTPD_GET,<span class="comment">//方法</span></span><br><span class="line">    .handler  = my_uri_handler,<span class="comment">//URI处理函数</span></span><br><span class="line">    .user_ctx = <span class="literal">NULL</span><span class="comment">//指向用户上下文数据的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册句柄</span></span><br><span class="line"><span class="keyword">if</span> (httpd_register_uri_handler(server_handle, &amp;my_uri) != ESP_OK)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//如果注册失败就....</span></span><br><span class="line">   ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过传入httpd_uri_t结构体类型的对象来注册 URI 处理程序</p>
<ol start="3">
<li>使用httpd_stop()函数停止HTTP服务器</li>
</ol>
<p>该API会根据传入的句柄停止服务器并释放相关联的内存和资源。这是一个阻塞函数——首先给服务器任务发送停止信号，然后等待其终止。期间服务器任务会关闭所有已打开的连接，删除已注册的 URI 处理程序，并将所有会话的上下文数据重置为空。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">httpd_stop</span><span class="params">(<span class="keyword">httpd_handle_t</span> handle)</span></span>;<span class="comment">//根据传入的服务器句柄停止指向的服务器</span></span><br></pre></td></tr></table></figure>

<p>可以使用以下的代码来安全地停止服务器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例应用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop_webserver</span><span class="params">(<span class="keyword">httpd_handle_t</span> server)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">//确保指针非空</span></span><br><span class="line">     <span class="keyword">if</span> (server != <span class="literal">NULL</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         httpd_stop(server);<span class="comment">//停止服务器</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* URI 处理函数，在客户端发起 GET /uri 请求时被调用 */</span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">get_handler</span><span class="params">(<span class="keyword">httpd_req_t</span> *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 发送回简单的响应数据包 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>[] resp = <span class="string">&quot;URI GET Response&quot;</span>;</span><br><span class="line">    httpd_resp_send(req, resp, <span class="built_in">strlen</span>(resp));</span><br><span class="line">    <span class="keyword">return</span> ESP_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* URI 处理函数，在客户端发起 POST /uri 请求时被调用 */</span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">post_handler</span><span class="params">(<span class="keyword">httpd_req_t</span> *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 定义 HTTP POST 请求数据的目标缓存区</span></span><br><span class="line"><span class="comment">     * httpd_req_recv() 只接收 char* 数据，但也可以是任意二进制数据（需要类型转换）</span></span><br><span class="line"><span class="comment">     * 对于字符串数据，null 终止符会被省略，content_len 会给出字符串的长度 */</span></span><br><span class="line">    <span class="keyword">char</span>[<span class="number">100</span>] content;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果内容长度大于缓冲区则截断 */</span></span><br><span class="line">    <span class="keyword">size_t</span> recv_size = MIN(req-&gt;content_len, <span class="keyword">sizeof</span>(content));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = httpd_req_recv(req, content, recv_size);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)<span class="comment">/* 返回 0 表示连接已关闭 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 检查是否超时 */</span></span><br><span class="line">        <span class="keyword">if</span> (ret == HTTPD_SOCK_ERR_TIMEOUT) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 如果是超时，可以调用 httpd_req_recv() 重试</span></span><br><span class="line"><span class="comment">             * 简单起见，这里我们直接响应 HTTP 408（请求超时）错误给客户端 */</span></span><br><span class="line">            httpd_resp_send_408(req);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 如果发生了错误，返回 ESP_FAIL 可以确保底层套接字被关闭 */</span></span><br><span class="line">        <span class="keyword">return</span> ESP_FAIL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送简单的响应数据包 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>[] resp = <span class="string">&quot;URI POST Response&quot;</span>;</span><br><span class="line">    httpd_resp_send(req, resp, <span class="built_in">strlen</span>(resp));</span><br><span class="line">    <span class="keyword">return</span> ESP_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* GET /uri 的 URI 处理结构 */</span></span><br><span class="line"><span class="keyword">httpd_uri_t</span> uri_get = &#123;</span><br><span class="line">    .uri      = <span class="string">&quot;/uri&quot;</span>,</span><br><span class="line">    .method   = HTTP_GET,</span><br><span class="line">    .handler  = get_handler,</span><br><span class="line">    .user_ctx = <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* POST /uri 的 URI 处理结构 */</span></span><br><span class="line"><span class="keyword">httpd_uri_t</span> uri_post = &#123;</span><br><span class="line">    .uri      = <span class="string">&quot;/uri&quot;</span>,</span><br><span class="line">    .method   = HTTP_POST,</span><br><span class="line">    .handler  = post_handler,</span><br><span class="line">    .user_ctx = <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 启动 Web 服务器的函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">httpd_handle_t</span> <span class="title">start_webserver</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 生成默认的配置参数 */</span></span><br><span class="line">    <span class="keyword">httpd_config_t</span> config = HTTPD_DEFAULT_CONFIG();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 置空 esp_http_server 的实例句柄 */</span></span><br><span class="line">    <span class="keyword">httpd_handle_t</span> server = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 启动 httpd server */</span></span><br><span class="line">    <span class="keyword">if</span> (httpd_start(&amp;server, &amp;config) == ESP_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 注册 URI 处理程序 */</span></span><br><span class="line">        httpd_register_uri_handler(server, &amp;uri_get);</span><br><span class="line">        httpd_register_uri_handler(server, &amp;uri_post);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果服务器启动失败，返回的句柄是 NULL */</span></span><br><span class="line">    <span class="keyword">return</span> server;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 停止 Web 服务器的函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop_webserver</span><span class="params">(<span class="keyword">httpd_handle_t</span> server)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (server)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 停止 httpd server */</span></span><br><span class="line">        httpd_stop(server);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">ESP32</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A06%E3%80%90HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%91/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-ESP32-IDF学习5【SPIFFS与数据加密】" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A05%E3%80%90SPIFFS%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E3%80%91/">ESP32_IDF学习5【SPIFFS与数据加密】</a>
    </h1>
  

        
<!-- 显示阅读次数-->
<!--  -->
<!--显示阅读次数完毕 -->

        
        <a href="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A05%E3%80%90SPIFFS%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E3%80%91/" class="archive-article-date">
  	<time datetime="2021-11-19T07:02:08.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2021-11-19</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="VFS虚拟文件系统"><a href="#VFS虚拟文件系统" class="headerlink" title="VFS虚拟文件系统"></a>VFS虚拟文件系统</h1><p>虚拟文件系统 (VFS) 组件可为一些驱动提供一个统一接口。有了该接口，用户可像操作普通文件一样操作虚拟文件。这类驱动程序可以是 FAT、SPIFFS 等真实文件系统，也可以是有文件类接口的设备驱动程序——官方文档</p>
<p>说人话就是<strong>ESP32可以支持运行嵌入式文件系统</strong></p>
<p>目前ESP-IDF实现的功能如下：</p>
<ul>
<li>按名读取/写入文件</li>
<li>兼容POSIX和C库函数文件操作</li>
<li>不会对路径中的点<code>.</code>或<code>..</code>进行特殊处理（不会将其视为对当前目录或上一级目录的引用）</li>
</ul>
<p>已注册的VFS驱动程序均有一个路径前缀与之关联，此路径前缀即为分区的挂载点。如果挂载点中嵌套了其他挂载点，则在打开文件时使用<strong>具有最长匹配路径前缀的挂载点</strong>。挂载点名称必须以路径分隔符<code>/</code>开头，且分隔符后至少包含一个字符</p>
<p><strong>执行打开文件操作时，FS驱动程序仅得到文件的相对路径</strong></p>
<h2 id="标准IO流"><a href="#标准IO流" class="headerlink" title="标准IO流"></a>标准IO流</h2><p>如果在menuconfig中没有将<code>UART for console output</code>设置为<code>None</code>，则<code>stdin</code>、<code>stdout</code>和<code>stderr</code>将<strong>默认从UART读取或写入</strong>。<strong>UART0或UART1都可以用作标准IO</strong>。因此可以直接调用stdio.h中的相关库函数。<em>默认情况下，UART0使用115200波特率，TX管脚为 GPIO1，RX管脚为GPIO3；VFS使用简单的函数对UART进行读写操作</em>，也可以在menuconfig中更改参数。</p>
<p>所有IO数据放进UART的FIFO前，写操作将处于忙等待busy-wait（阻塞）状态，读操作处于非阻塞，仅返回FIFO中已有数据。由于读操作为非阻塞，高层级的C库函数调用（如 fscanf(“%d\n”, &amp;var)等）可能获取不到所需结果。如果应用程序使用UART驱动，则可以调用 <code>esp_vfs_dev_uart_use_driver</code>函数来让VFS使用驱动中断、读写阻塞功能等。也可以调用<code>esp_vfs_dev_uart_use_nonblocking</code>来使用非阻塞函数</p>
<p>此外，VFS还为输入和输出提供可选的换行符转换功能，可以通过menuconfig来设置输出结尾的换行符</p>
<h3 id="标准流IO与移植的FreeRTOS"><a href="#标准流IO与移植的FreeRTOS" class="headerlink" title="标准流IO与移植的FreeRTOS"></a>标准流IO与移植的FreeRTOS</h3><p><strong>stdin、stdout和stderr的FILE指针（对象句柄）在所有FreeRTOS任务之间共享</strong>，指向这些对象的指针分别存储在每个任务的<code>struct _reent</code>中</p>
<p>为了处理各个任务之间的文件指针临界区，预处理器把如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fprintf(stderr, &quot;42\n&quot;);</span><br></pre></td></tr></table></figure>

<p>解释为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fprintf(__getreent()-&gt;_stderr, &quot;42\n&quot;);</span><br></pre></td></tr></table></figure>

<p>__getreent函数返回一个指向struct _reent的指针</p>
<p><strong>每个任务的TCB都拥有一个struct _reent结构体，用于在本任务内处理文件而不影响其他任务</strong></p>
<h1 id="FATFS文件系统"><a href="#FATFS文件系统" class="headerlink" title="FATFS文件系统"></a>FATFS文件系统</h1><p>ESP-IDF使用FatFs库来实现FAT文件系统</p>
<p>在文件中调用<code>#include &quot;esp_vfs_fat.h&quot;</code>和<code>#include &quot;esp_vfs.h&quot;</code>后可以在FLASH中通过C标准库和POSIX的API经过VFS使用FatFs库的大多数功能</p>
<p>经由这一功能可以实现SD卡的读取</p>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol>
<li>调用esp_vfs_fat_register()指定挂载文件系统的<strong>路径前缀</strong>、<strong>FatFs驱动编号</strong>和一个<strong>用于接收指向FATFS结构指针的变量</strong></li>
<li>调用ff_diskio_register()为上述步骤中的驱动编号<strong>注册磁盘I/O驱动</strong></li>
<li>调用 FatFs 函数f_mount，或f_fdisk，f_mkfs，并使用<strong>与传递到esp_vfs_fat_register()相同的驱动编号挂载文件系统</strong></li>
<li>调用 <strong>C 标准库和 POSIX API</strong> 对路径中带有步骤 1 中所述前缀的文件执行打开、读取、写入、擦除、复制等操作</li>
<li><strong>关闭</strong>所有打开的<strong>文件</strong></li>
<li>调用f_mount并使用NULL FATFS<em>参数为与上述编号相同的驱动*<em>卸载文件系统</em></em></li>
<li>调用FatFs函数 ff_diskio_register()并使用NULL ff_diskio_impl_t<em>参数和相同的驱动编号来*<em>释放注册的磁盘I/O驱动</em></em></li>
<li>调用esp_vfs_fat_unregister_path()并使用文件系统挂载的路径<strong>将 FatFs 从 NVS 中移除</strong>，并<strong>释放步骤 1 中分配的 FatFs 结构</strong></li>
</ol>
<p>除了需要提前注册、挂载文件系统外，其他操作和正常的FATFS使用没有区别</p>
<h2 id="磨损均衡"><a href="#磨损均衡" class="headerlink" title="磨损均衡"></a>磨损均衡</h2><p>ESP32使用的FLASH具备扇区结构，每个扇区仅允许有限次数的擦除/修改操作，ESP-IDF提供磨损均衡组件用于平衡各个扇区之间的损耗。提供两种模式：1. 性能模式（先将数据保存在RAM中，擦除扇区，然后将数据存储回FLASH）；2. 安全模式（数据先保存在FLASH中空余扇区，擦除扇区后，数据即存储回去）</p>
<p><strong>设备默认使用性能模式且将扇区大小定为512字节</strong>。磨损均衡组件<strong>不会</strong>将数据缓存在RAM中。写入和擦除函数直接修改FLASH，函数返回后，FLASH即完成修改。</p>
<p>常用API如下：</p>
<ul>
<li><p><code>wl_mount(const esp_partition_t *partition, wl_handle_t *out_handle)</code></p>
<p>为指定分区挂载并初始化磨损均衡模块，通过out_handle传出句柄</p>
</li>
<li><p><code>wl_unmount(wl_handle_t handle)</code></p>
<p>卸载分区并释放磨损均衡模块</p>
</li>
<li><p><code>wl_erase_range(wl_handle_t handle, size_t start_addr, size_t size)</code></p>
<p>擦除FLASH中从start_addr开始大小为size的地址范围</p>
</li>
<li><p><code>wl_write(wl_handle_t handle, size_t dest_addr, const void *src, size_t size)</code></p>
<p>将数据用指针src引用后写入分区从dest_addr开始大小为size的区域</p>
</li>
<li><p><code>wl_read(wl_handle_t handle, size_t src_addr, void *dest, size_t size)</code></p>
<p>从分区读取从src_addr开始大小为size的数据</p>
</li>
<li><p><code>wl_size(wl_handle_t handle)</code></p>
<p>返回可用内存的大小（以字节为单位）</p>
</li>
<li><p><code>wl_sector_size(wl_handle_t handle)</code></p>
<p>返回一个扇区的大小</p>
</li>
</ul>
<p>上面的wl_handle_t为WL句柄，可通过wl_mount的output参数传出</p>
<p>结合使用磨损均衡与FATFS示例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">wl_handle_t</span> s_wl_handle = WL_INVALID_HANDLE;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *base_path = <span class="string">&quot;/spiflash&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化VFS-FATFS</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">esp_vfs_fat_mount_config_t</span> mount_config = &#123;</span><br><span class="line">            .max_files = <span class="number">4</span>,</span><br><span class="line">            .format_if_mount_failed = <span class="literal">true</span>,</span><br><span class="line">            .allocation_unit_size = CONFIG_WL_SECTOR_SIZE</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//挂载FATFS</span></span><br><span class="line">    <span class="keyword">esp_err_t</span> err = esp_vfs_fat_spiflash_mount(base_path, <span class="string">&quot;storage&quot;</span>, &amp;mount_config, &amp;s_wl_handle);</span><br><span class="line">    <span class="keyword">if</span> (err != ESP_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">&quot;Failed to mount FATFS (%s)&quot;</span>, esp_err_to_name(err));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//打开文件并写入</span></span><br><span class="line">    FILE *f = fopen(<span class="string">&quot;/spiflash/hello.txt&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">&quot;Failed to open file for writing&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(f, <span class="string">&quot;written using ESP-IDF %s\n&quot;</span>, esp_get_idf_version());</span><br><span class="line">    fclose(f);</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;File written&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开文件并读取</span></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Reading file&quot;</span>);</span><br><span class="line">    f = fopen(<span class="string">&quot;/spiflash/hello.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">&quot;Failed to open file for reading&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">128</span>];</span><br><span class="line">    fgets(line, <span class="keyword">sizeof</span>(line), f);</span><br><span class="line">    fclose(f);</span><br><span class="line">    <span class="comment">// strip newline</span></span><br><span class="line">    <span class="keyword">char</span> *pos = <span class="built_in">strchr</span>(line, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pos)</span><br><span class="line">    &#123;</span><br><span class="line">        *pos = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Read from file: &#x27;%s&#x27;&quot;</span>, line);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//卸载FATFA</span></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Unmounting FAT filesystem&quot;</span>);</span><br><span class="line">    ESP_ERROR_CHECK( esp_vfs_fat_spiflash_unmount(base_path, s_wl_handle));</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Done&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用外部FLASH挂载FATFS示例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_flash.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_flash_spi_init.h&quot;</span><span class="comment">//外部FLASH</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_partition.h&quot;</span><span class="comment">//加载额外分区表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_vfs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_vfs_fat.h&quot;</span><span class="comment">//VFS-FATFS</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_system.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">wl_handle_t</span> s_wl_handle = WL_INVALID_HANDLE;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *base_path = <span class="string">&quot;/extflash&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">esp_flash_t</span>* <span class="title">init_ext_flash</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">esp_partition_t</span>* <span class="title">add_partition</span><span class="params">(<span class="keyword">esp_flash_t</span>* ext_flash, <span class="keyword">const</span> <span class="keyword">char</span>* partition_label)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">list_data_partitions</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">mount_fatfs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* partition_label)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">get_fatfs_usage</span><span class="params">(<span class="keyword">size_t</span>* out_total_bytes, <span class="keyword">size_t</span>* out_free_bytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">esp_flash_t</span>* flash = init_ext_flash();<span class="comment">//初始化SPI总线及外部FLASH</span></span><br><span class="line">    <span class="keyword">if</span> (flash == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将外部FLASH加入分区表</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *partition_label = <span class="string">&quot;storage&quot;</span>;</span><br><span class="line">    add_partition(flash, partition_label);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//列出当前分区</span></span><br><span class="line">    list_data_partitions();</span><br><span class="line">    <span class="comment">//在分区内挂载FATFS</span></span><br><span class="line">    <span class="keyword">if</span> (!mount_fatfs(partition_label))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示FATFS大小信息</span></span><br><span class="line">    <span class="keyword">size_t</span> bytes_total, bytes_free;</span><br><span class="line">    get_fatfs_usage(&amp;bytes_total, &amp;bytes_free);</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;FAT FS: %d kB total, %d kB free&quot;</span>, bytes_total / <span class="number">1024</span>, bytes_free / <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建文件</span></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Opening file&quot;</span>);</span><br><span class="line">    FILE *f = fopen(<span class="string">&quot;/extflash/hello.txt&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">&quot;Failed to open file for writing&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(f, <span class="string">&quot;Written using ESP-IDF %s\n&quot;</span>, esp_get_idf_version());</span><br><span class="line">    fclose(f);</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;File written&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取文件</span></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Reading file&quot;</span>);</span><br><span class="line">    f = fopen(<span class="string">&quot;/extflash/hello.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">&quot;Failed to open file for reading&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">128</span>];</span><br><span class="line">    fgets(line, <span class="keyword">sizeof</span>(line), f);</span><br><span class="line">    fclose(f);</span><br><span class="line">    <span class="keyword">char</span> *pos = <span class="built_in">strchr</span>(line, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pos)</span><br><span class="line">    &#123;</span><br><span class="line">        *pos = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Read from file: &#x27;%s&#x27;&quot;</span>, line);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">esp_flash_t</span>* <span class="title">init_ext_flash</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化SPI总线</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">spi_bus_config_t</span> bus_config = &#123;</span><br><span class="line">        .mosi_io_num = VSPI_IOMUX_PIN_NUM_MOSI,</span><br><span class="line">        .miso_io_num = VSPI_IOMUX_PIN_NUM_MISO,</span><br><span class="line">        .sclk_io_num = VSPI_IOMUX_PIN_NUM_CLK,</span><br><span class="line">        .quadwp_io_num = <span class="number">-1</span>,</span><br><span class="line">        .quadhd_io_num = <span class="number">-1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">	<span class="comment">//初始化SPI FLASH设备</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">esp_flash_spi_device_config_t</span> device_config = &#123;</span><br><span class="line">        .host_id = VSPI_HOST,</span><br><span class="line">        .cs_id = <span class="number">0</span>,</span><br><span class="line">        .cs_io_num = VSPI_IOMUX_PIN_NUM_CS,</span><br><span class="line">        .io_mode = SPI_FLASH_DIO,</span><br><span class="line">        .speed = ESP_FLASH_40MHZ</span><br><span class="line">    &#125;;</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Initializing external SPI Flash&quot;</span>);</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Pin assignments:&quot;</span>);</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;MOSI: %2d   MISO: %2d   SCLK: %2d   CS: %2d&quot;</span>,</span><br><span class="line">        bus_config.mosi_io_num, bus_config.miso_io_num,</span><br><span class="line">        bus_config.sclk_io_num, device_config.cs_io_num</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//应用设置</span></span><br><span class="line">    ESP_ERROR_CHECK(spi_bus_initialize(VSPI_HOST, &amp;bus_config, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//将设备挂载到SPI总线</span></span><br><span class="line">    <span class="keyword">esp_flash_t</span>* ext_flash;</span><br><span class="line">    ESP_ERROR_CHECK(spi_bus_add_flash_device(&amp;ext_flash, &amp;device_config));</span><br><span class="line">    <span class="comment">//初始化外部FLASH设备</span></span><br><span class="line">    <span class="keyword">esp_err_t</span> err = esp_flash_init(ext_flash);</span><br><span class="line">    <span class="keyword">if</span> (err != ESP_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">&quot;Failed to initialize external Flash: %s (0x%x)&quot;</span>, esp_err_to_name(err), err);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出ID和空间大小进行检测</span></span><br><span class="line">    <span class="keyword">uint32_t</span> id;</span><br><span class="line">    ESP_ERROR_CHECK(esp_flash_read_id(ext_flash, &amp;id));</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Initialized external Flash, size=%d KB, ID=0x%x&quot;</span>, ext_flash-&gt;size / <span class="number">1024</span>, id)</span><br><span class="line">    <span class="keyword">return</span> ext_flash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">esp_partition_t</span>* <span class="title">add_partition</span><span class="params">(<span class="keyword">esp_flash_t</span>* ext_flash, <span class="keyword">const</span> <span class="keyword">char</span>* partition_label)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Adding external Flash as a partition, label=\&quot;%s\&quot;, size=%d KB&quot;</span>, partition_label, ext_flash-&gt;size / <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">esp_partition_t</span>* fat_partition;</span><br><span class="line">    <span class="comment">//注册外部分区表</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_partition_register_external(ext_flash, <span class="number">0</span>, ext_flash-&gt;size, partition_label, ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_DATA_FAT, &amp;fat_partition));</span><br><span class="line">    <span class="keyword">return</span> fat_partition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">list_data_partitions</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取当前删去句柄</span></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Listing data partitions:&quot;</span>);</span><br><span class="line">    <span class="keyword">esp_partition_iterator_t</span> it = esp_partition_find(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_ANY, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//以链表形式遍历扇区</span></span><br><span class="line">    <span class="keyword">for</span> (; it != <span class="literal">NULL</span>; it = esp_partition_next(it))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">esp_partition_t</span> *part = esp_partition_get(it);</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;- partition &#x27;%s&#x27;, subtype %d, offset 0x%x, size %d kB&quot;</span>,</span><br><span class="line">        part-&gt;label, part-&gt;subtype, part-&gt;address, part-&gt;size / <span class="number">1024</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//释放当前分区迭代器</span></span><br><span class="line">    esp_partition_iterator_release(it);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">mount_fatfs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* partition_label)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//挂载FAT文件系统到外部FLASH</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">esp_vfs_fat_mount_config_t</span> mount_config = &#123;</span><br><span class="line">            .max_files = <span class="number">4</span>,</span><br><span class="line">            .format_if_mount_failed = <span class="literal">true</span>,</span><br><span class="line">            .allocation_unit_size = CONFIG_WL_SECTOR_SIZE</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">esp_err_t</span> err = esp_vfs_fat_spiflash_mount(base_path, partition_label, &amp;mount_config, &amp;s_wl_handle);</span><br><span class="line">    <span class="keyword">if</span> (err != ESP_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">&quot;Failed to mount FATFS (%s)&quot;</span>, esp_err_to_name(err));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">get_fatfs_usage</span><span class="params">(<span class="keyword">size_t</span>* out_total_bytes, <span class="keyword">size_t</span>* out_free_bytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FATFS *fs;<span class="comment">//文件系统指针</span></span><br><span class="line">    <span class="keyword">size_t</span> free_clusters;</span><br><span class="line">    <span class="keyword">int</span> res = f_getfree(<span class="string">&quot;0:&quot;</span>, &amp;free_clusters, &amp;fs);</span><br><span class="line">    assert(res == FR_OK);</span><br><span class="line">    <span class="keyword">size_t</span> total_sectors = (fs-&gt;n_fatent - <span class="number">2</span>) * fs-&gt;csize;</span><br><span class="line">    <span class="keyword">size_t</span> free_sectors = free_clusters * fs-&gt;csize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//假设扇区总大小&lt;4GB，对SPI FLASH应为真</span></span><br><span class="line">    <span class="keyword">if</span> (out_total_bytes != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *out_total_bytes = total_sectors * fs-&gt;ssize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (out_free_bytes != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *out_free_bytes = free_sectors * fs-&gt;ssize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="SPIFFS文件系统"><a href="#SPIFFS文件系统" class="headerlink" title="SPIFFS文件系统"></a>SPIFFS文件系统</h1><p>SPIFFS 是一个用于 SPI NOR flash 设备的嵌入式文件系统，支持磨损均衡、文件系统一致性检查等功能——官方文档。</p>
<p>目前位置SPIFFS还是一个不完全的文件系统：不支持目录，只能生成扁平结构；不是实时栈，每次写操作耗时不等；不支持检测或处理已损坏的块等</p>
<p>但是这玩意确实很好用</p>
<p>使用spiffsgen.py工具就可以配置SPIFFS，shell中使用格式如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python spiffsgen.py &lt;image_size&gt; &lt;base_dir&gt; &lt;output_file&gt;</span><br></pre></td></tr></table></figure>

<p>其中image_size为分区大小，<strong>base_dir为SPIFFS映像所在目录，output_file为SPIFFS映像输出文件</strong></p>
<p>也可以使用CMake工具进行配置：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spiffs_create_partition_image(&lt;partition&gt; &lt;base_dir&gt; [FLASH_IN_PROJECT] [DEPENDS dep dep dep...])</span><br><span class="line"></span><br><span class="line">//使用例</span><br><span class="line">spiffs_create_partition_image(my_spiffs_partition my_folder FLASH_IN_PROJECT)</span><br></pre></td></tr></table></figure>

<p>CMake配置自动传递给spiffsgen.py工具生成映像。单独调用 <code>spiffsgen.py</code> 时需要用到 <em>image_size</em> 参数，但在CMake中调用<code>spiffs_create_partition_image</code>时仅需要 <em>partition</em> 参数，<strong>映像大小将直接从当前工程的分区表中获取</strong>。</p>
<p>注意：在CMake中使用<code>spiffs_create_partition_image</code>，需从组件CMakeLists.txt文件调用</p>
<p>下面是一个标准的SPIFFS分区表示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Name,   Type, SubType, Offset,  Size, Flags</span><br><span class="line"># Note: if you have increased the bootloader size, make sure to update the offsets to avoid overlap</span><br><span class="line">nvs,      data, nvs,     0x9000,  0x6000,</span><br><span class="line">phy_init, data, phy,     0xf000,  0x1000,</span><br><span class="line">factory,  app,  factory, 0x10000, 1M,</span><br><span class="line">storage,  data, spiffs,  ,        0xF0000, </span><br></pre></td></tr></table></figure>

<p><strong>需要使用SubType=spiffs标识出某一分区是SPIFFS存储分区</strong></p>
<h2 id="SPIFFS配置与API参考"><a href="#SPIFFS配置与API参考" class="headerlink" title="SPIFFS配置与API参考"></a>SPIFFS配置与API参考</h2><p>在文件中调用<code>#include &quot;esp_spiffs.h&quot;</code>就可以使用相关API</p>
<p>使用以下API初始化SPIFFS到虚拟文件系统</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_vfs_spiffs_register</span><span class="params">(<span class="keyword">const</span> <span class="keyword">esp_vfs_spiffs_conf_t</span> *conf)</span></span></span><br></pre></td></tr></table></figure>

<p>esp_vfs_spiffs_conf_t是SPIFFS文件系统初始化结构体，应如下配置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">esp_vfs_spiffs_conf_t</span> conf = &#123;</span><br><span class="line">	.base_path = <span class="string">&quot;/spiffs&quot;</span>,<span class="comment">//根目录</span></span><br><span class="line">	.partition_label = <span class="literal">NULL</span>,<span class="comment">//分区表的标签</span></span><br><span class="line">	.max_files = <span class="number">5</span>,<span class="comment">//该目录下能存储的最大文件数目</span></span><br><span class="line">	.format_if_mount_failed = <span class="literal">true</span><span class="comment">//如果挂载失败则会格式化文件系统</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>更多API如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_vfs_spiffs_unregister</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *partition_label)</span></span>;<span class="comment">//取消VFS上的SPIFFS初始化</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">esp_spiffs_mounted</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *partition_label)</span></span>;<span class="comment">//检查文件系统是否挂载</span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_spiffs_format</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *partition_label)</span></span>;<span class="comment">//格式化当前分区的文件系统</span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_spiffs_info</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *partition_label, <span class="keyword">size_t</span> *total_bytes, <span class="keyword">size_t</span> *used_bytes)</span></span>;<span class="comment">//获取某分区文件系统的参数    </span></span><br></pre></td></tr></table></figure>

<h2 id="用C库函数进行SPIFFS文件读写"><a href="#用C库函数进行SPIFFS文件读写" class="headerlink" title="用C库函数进行SPIFFS文件读写"></a>用C库函数进行SPIFFS文件读写</h2><p>可以使用POSIX和C库函数在SPIFFS写入和读取数据</p>
<p>下面是官方给出的使用例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化SPIFFS</span></span><br><span class="line">    <span class="keyword">esp_vfs_spiffs_conf_t</span> conf = &#123;</span><br><span class="line">      .base_path = <span class="string">&quot;/spiffs&quot;</span>,</span><br><span class="line">      .partition_label = <span class="literal">NULL</span>,</span><br><span class="line">      .max_files = <span class="number">5</span>,</span><br><span class="line">      .format_if_mount_failed = <span class="literal">true</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">esp_err_t</span> ret = esp_vfs_spiffs_register(&amp;conf);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检测SPIFFS初始化是否正常</span></span><br><span class="line">    <span class="keyword">if</span> (ret != ESP_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ret == ESP_FAIL)</span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGE(TAG, <span class="string">&quot;Failed to mount or format filesystem&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ret == ESP_ERR_NOT_FOUND)</span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGE(TAG, <span class="string">&quot;Failed to find SPIFFS partition&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGE(TAG, <span class="string">&quot;Failed to initialize SPIFFS (%s)&quot;</span>, esp_err_to_name(ret));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> total = <span class="number">0</span>, used = <span class="number">0</span>;</span><br><span class="line">    ret = esp_spiffs_info(conf.partition_label, &amp;total, &amp;used);</span><br><span class="line">    <span class="keyword">if</span> (ret != ESP_OK)</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">&quot;Failed to get SPIFFS partition information (%s)&quot;</span>, esp_err_to_name(ret));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;Partition size: total: %d, used: %d&quot;</span>, total, used);</span><br><span class="line"></span><br><span class="line">    FILE* f = fopen(<span class="string">&quot;/spiffs/hello.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);<span class="comment">//打开文件</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">&quot;Failed to open file for writing&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(f, <span class="string">&quot;Hello World!\n&quot;</span>);<span class="comment">//写入文件</span></span><br><span class="line">    fclose(f);<span class="comment">//关闭文件</span></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;File written&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (stat(<span class="string">&quot;/spiffs/foo.txt&quot;</span>, &amp;st) == <span class="number">0</span>)<span class="comment">//检测文件是否存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        unlink(<span class="string">&quot;/spiffs/foo.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rename(<span class="string">&quot;/spiffs/hello.txt&quot;</span>, <span class="string">&quot;/spiffs/foo.txt&quot;</span>) != <span class="number">0</span>)<span class="comment">//重命名</span></span><br><span class="line">    &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">&quot;Rename failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f = fopen(<span class="string">&quot;/spiffs/foo.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);<span class="comment">//打开文件</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">&quot;Failed to open file for reading&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">64</span>];</span><br><span class="line">    fgets(line, <span class="keyword">sizeof</span>(line), f);<span class="comment">//读取文件</span></span><br><span class="line">    fclose(f);<span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">char</span>* pos = <span class="built_in">strchr</span>(line, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pos)</span><br><span class="line">    &#123;</span><br><span class="line">        *pos = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Read from file: &#x27;%s&#x27;&quot;</span>, line);</span><br><span class="line"></span><br><span class="line">    esp_vfs_spiffs_unregister(conf.partition_label);<span class="comment">//解除SIFFS挂载</span></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;SPIFFS unmounted&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="FLASH加密"><a href="#FLASH加密" class="headerlink" title="FLASH加密"></a>FLASH加密</h1><p>FLASH加密功能用于加密与ESP32搭载使用的SPI Flash中的内容。启用FLASH加密功能后，物理读取SPI FLASH便无法恢复大部分FLASH内容。通过明文数据烧录ESP32可应用加密功能，<strong>若已启用加密功能，引导加载程序会在首次启动时对数据进行加密</strong>。</p>
<p>FLASH加密功能与密钥同样稳固，但并非所有数据都是加密存储且无法防止攻击者获取FLASH的高层次布局信息</p>
<p><strong>为了防止攻击者直接恶意修改固件，推荐搭配使用FLASH加密与安全启动</strong>，但启用安全启动时，OTA</p>
<p>启用FLASH加密后，系统将默认加密下列类型的FLASH数据：</p>
<ul>
<li>BootLoader</li>
<li>分区表</li>
<li>所有app类型的分区</li>
</ul>
<p>其他类型的FLASH数据将视情况进行加密：</p>
<ul>
<li>如果已启用安全启动，则会加密安全启动引导加载程序摘要</li>
<li>分区表中标有加密标记的分区</li>
</ul>
<p>注意：==启用 Flash 加密将限制后续 ESP32 更新==</p>
<p>FLASH加密分为两种模式：开发模式和生产模式</p>
<h2 id="使用FLASH加密"><a href="#使用FLASH加密" class="headerlink" title="使用FLASH加密"></a>使用FLASH加密</h2><p>一般地，<strong>只要在menuconfig中设置使用加密并使用加密方式烧录即可使用FLASH加密</strong></p>
<ol>
<li><p>开发模式：可使用 ESP32 内部生成的密钥或外部主机生成的密钥在开发中运行FLASH加密</p>
</li>
<li><p>生产模式：使用ESP32生成的FLASH加密密钥</p>
</li>
</ol>
<p>在程序中使用<code>#include &quot;esp_flash_encrypt.h&quot;</code>、<code>#include &quot;esp_efuse_table.h&quot;</code>、<code>#include &quot;esp_efuse.h&quot;</code>、<code>#include &quot;soc/efuse_reg.h&quot;</code>后可以使用相关API</p>
<p>分区表如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Name,   Type, SubType, Offset,  Size, Flags</span><br><span class="line">nvs,        data, nvs,      <span class="number">0x9000</span>,  <span class="number">0x6000</span>,</span><br><span class="line"># Extra partition to demonstrate reading/writing of encrypted flash</span><br><span class="line">storage,    data, <span class="number">0xff</span>,     <span class="number">0xf000</span>,  <span class="number">0x1000</span>, encrypted</span><br><span class="line">factory,    app,  factory,  <span class="number">0x10000</span>, <span class="number">1</span>M,</span><br></pre></td></tr></table></figure>

<p>如果所有分区都需以加密格式更新，则可使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">idf.py encrypted-flash monitor</span><br></pre></td></tr></table></figure>

<p>只要 <code>FLASH_CRYPT_CNT</code> eFuse 设置为奇数位的值，所有通过MMU的FLASH缓存访问的FLASH内容都将被透明解密：MMU FLASH缓存将无条件解密所有数据</p>
<ol start="3">
<li>释放模式下，UART引导加载程序无法执行FLASH加密操作，<strong>只能使用OTA</strong>下载已经加密过的映像</li>
</ol>
<p>可通过调用函数esp_flash_encryption_enabled()来确认当前是否已启用FLASH加密</p>
<p>可通过调用函数esp_get_flash_encryption_mode()来识别使用的FLASH加密模式</p>
<p>使用分区读取函数esp_partition_read()来读取加密分区的数据</p>
<p>下面是使用FLASH加密的示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;soc/efuse_reg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_efuse.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_system.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_spi_flash.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_partition.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_flash_encrypt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_efuse_table.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_IDF_TARGET_ESP32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TARGET_CRYPT_CNT_EFUSE  ESP_EFUSE_FLASH_CRYPT_CNT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TARGET_CRYPT_CNT_WIDTH  7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> CONFIG_IDF_TARGET_ESP32S2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TARGET_CRYPT_CNT_EFUSE ESP_EFUSE_SPI_BOOT_CRYPT_CNT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TARGET_CRYPT_CNT_WIDTH  3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_flash_encryption_status</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//输出FLASH加密状态</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print_flash_encryption_status();<span class="comment">//像函数中使用API才能访问加密分区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_flash_encryption_status</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> flash_crypt_cnt = <span class="number">0</span>;</span><br><span class="line">    esp_efuse_read_field_blob(TARGET_CRYPT_CNT_EFUSE, &amp;flash_crypt_cnt, TARGET_CRYPT_CNT_WIDTH);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FLASH_CRYPT_CNT eFuse value is %d\n&quot;</span>, flash_crypt_cnt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">esp_flash_enc_mode_t</span> mode = esp_get_flash_encryption_mode();</span><br><span class="line">    <span class="keyword">if</span> (mode == ESP_FLASH_ENC_MODE_DISABLED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Flash encryption feature is disabled\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Flash encryption feature is enabled in %s mode\n&quot;</span>,</span><br><span class="line">            mode == ESP_FLASH_ENC_MODE_DEVELOPMENT ? <span class="string">&quot;DEVELOPMENT&quot;</span> : <span class="string">&quot;RELEASE&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sdkconfig中的相关条目如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_SECURE_FLASH_ENC_ENABLED=y</span><br><span class="line">CONFIG_SECURE_FLASH_ENCRYPTION_MODE_DEVELOPMENT=y</span><br><span class="line">CONFIG_SECURE_BOOT_ALLOW_ROM_BASIC=y</span><br><span class="line">CONFIG_SECURE_BOOT_ALLOW_JTAG=y</span><br><span class="line">CONFIG_SECURE_FLASH_UART_BOOTLOADER_ALLOW_ENC=y</span><br><span class="line">CONFIG_SECURE_FLASH_UART_BOOTLOADER_ALLOW_DEC=y</span><br><span class="line">CONFIG_SECURE_FLASH_UART_BOOTLOADER_ALLOW_CACHE=y</span><br><span class="line">CONFIG_SECURE_FLASH_REQUIRE_ALREADY_ENABLED=y</span><br></pre></td></tr></table></figure>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">ESP32</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A05%E3%80%90SPIFFS%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E3%80%91/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-ESP32-IDF学习4【SPI与外部存储器】" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A04%E3%80%90SPI%E4%B8%8E%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%91/">ESP32_IDF学习4【SPI与外部存储器】</a>
    </h1>
  

        
<!-- 显示阅读次数-->
<!--  -->
<!--显示阅读次数完毕 -->

        
        <a href="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A04%E3%80%90SPI%E4%B8%8E%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%91/" class="archive-article-date">
  	<time datetime="2021-11-19T07:01:22.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2021-11-19</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<p>注意：<strong>所有SPI相关的API都不能在中断服务函数或上下文切换期间使用，因为SPI相关的API都调用了互斥量，可能会造成系统错误</strong></p>
<h1 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h1><p>调用<code>#include &quot;driver/spi_master.h&quot;</code>或<code>#include &quot;driver/spi_slave.h&quot;</code>来使用API组件</p>
<p>ESP32集成了<strong>4个SPI外设</strong></p>
<p>SPI0和SPI1通过总线仲裁器共享一条信号总线，用于在模组内部访问FLASH（SoC FLASH），不会对用户开放</p>
<p>SPI2和SPI3是<strong>通用SPI控制器</strong>，有时也被称为HSPI和VSPI，这里的HSPI和VSPI没有实际区别，只是为了标识两个SPI，他们都既可以作为主机使用也可以作为从机使用。SPI控制器拥有独立的信号总线，每条总线都有三条片选（CS）信号，也就是说每个控制器都能驱动最多3个SPI从器件。这两个SPI控制器对用户开放</p>
<p>相关概念参考SPI协议，以下内容默认读者学习过SPI、QSPI基础知识。</p>
<p>表格翻译自官网</p>
<table>
<thead>
<tr>
<th>概念</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Host</strong></td>
<td>作为SPI主设备使用的ESP32片上SPI外设，目前只能使用SPI2或SPI3</td>
</tr>
<tr>
<td><strong>Device</strong></td>
<td>片外SPI从设备</td>
</tr>
<tr>
<td><strong>Bus</strong></td>
<td>SPI信号总线，通常包括MISO、MOSI、SCLK、多条CS线、可选的QUADWP和QUADHD线</td>
</tr>
<tr>
<td><strong>MISO</strong></td>
<td>Master in Slave out</td>
</tr>
<tr>
<td><strong>MOSI</strong></td>
<td>Master in Slave out</td>
</tr>
<tr>
<td><strong>SCLK</strong></td>
<td>同步时钟</td>
</tr>
<tr>
<td><strong>CS</strong></td>
<td>片选信号</td>
</tr>
<tr>
<td><strong>QUADWP</strong></td>
<td>写保护信号，当且仅当使用QSPI时启用</td>
</tr>
<tr>
<td><strong>QUADHD</strong></td>
<td>保持信号，当且仅当使用QSPI时启用</td>
</tr>
<tr>
<td><strong>Assertion</strong></td>
<td>启用某条信号线的行为；相反的行为称为<em>de-assertion</em>.</td>
</tr>
<tr>
<td><strong>Transaction</strong></td>
<td>启动片选、传输数据、结束传输、断开片选这一系列传输过程称为一次传输。传输是原子性的，不能被中断</td>
</tr>
<tr>
<td><strong>Launch edge</strong></td>
<td>源寄存器触发<em>launches</em>信号到总线的时钟边沿</td>
</tr>
<tr>
<td><strong>Latch edge</strong></td>
<td>源寄存器触发<em>latches in</em>信号刀纵线的时钟边沿</td>
</tr>
</tbody></table>
<p>对应的SPI-GPIO映射表如下所示</p>
<table>
<thead>
<tr>
<th>引脚对应的GPIO</th>
<th>SPI2</th>
<th>SPI3</th>
</tr>
</thead>
<tbody><tr>
<td>CS0*</td>
<td>15</td>
<td>5</td>
</tr>
<tr>
<td>SCLK</td>
<td>14</td>
<td>18</td>
</tr>
<tr>
<td>MISO</td>
<td>12</td>
<td>19</td>
</tr>
<tr>
<td>MOSI</td>
<td>13</td>
<td>23</td>
</tr>
<tr>
<td>QUADWP</td>
<td>2</td>
<td>22</td>
</tr>
<tr>
<td>QUADHD</td>
<td>4</td>
<td>21</td>
</tr>
</tbody></table>
<h2 id="SPI-Master"><a href="#SPI-Master" class="headerlink" title="SPI Master"></a>SPI Master</h2><p>ESP32内部的SPI控制器可设置为主模式（Master），基本特点如下</p>
<ul>
<li>适应多线程环境</li>
<li>可配置DMA辅助传输</li>
<li>在同一信号线上自动分配时间处理来自不同设备的的多路数据</li>
</ul>
<p>但是SPI控制器不是永远安全的，用户最好<strong>重构代码来让每个SPI外设在同一时间只被一个任务访问（避免临界区出现）</strong>或<strong>使用互斥量来处理临界区</strong></p>
<p>临界区相关的处理参考RTOS部分</p>
<h3 id="SPI传输时序"><a href="#SPI传输时序" class="headerlink" title="SPI传输时序"></a>SPI传输时序</h3><p>SPI的传输格式有以下五个组成部分</p>
<ol>
<li>指令数据段</li>
</ol>
<p>主机发送0-16位指令</p>
<ol start="2">
<li>地址数据段</li>
</ol>
<p>主机发送0-64位地址</p>
<ol start="3">
<li>写入数据</li>
</ol>
<p>主机向外设发送数据，允许附带可选的指令和地址数据，但这些数据无法从电器层面区分</p>
<ol start="4">
<li>空段</li>
</ol>
<p>用于同步时序</p>
<ol start="5">
<li>读取数据</li>
</ol>
<p>外设向主机发送数据</p>
<p>物理层传输属性由spi_bus_config_t结构体、spi_transaction_t结构体和spi_device_interface_config_t结构体设置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//spi_bus_config_t用于配置GPIO的SPI复用引脚和SPI控制器</span></span><br><span class="line"><span class="comment">//注意：如果不使用QSPI可以直接不初始化quadwp_io_num和quadhd_io_num，总线会自动关闭未被配置的信号线</span></span><br><span class="line"><span class="comment">//如果不使用某线应将其设置为-1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_bus_config_t</span>=</span>&#123;</span><br><span class="line">	.miso_io_num,<span class="comment">//MISO信号线，可复用为QSPI的D0</span></span><br><span class="line">	.mosi_io_num,<span class="comment">//MOSI信号线，可复用为QSPI的D1</span></span><br><span class="line">	.sclk_io_num,<span class="comment">//SCLK信号线</span></span><br><span class="line">	.quadwp_io_num,<span class="comment">//WP信号线，专用于QSPI的D2</span></span><br><span class="line">	.quadhd_io_num,<span class="comment">//HD信号线，专用于QSPI的D3</span></span><br><span class="line">	.max_transfer_sz,<span class="comment">//最大传输数据大小，单位字节，默认为4094</span></span><br><span class="line">    .intr_flags,<span class="comment">//中断指示位</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//spi_transaction_t用于配置SPI的数据格式</span></span><br><span class="line"><span class="comment">//注意：这个结构体只定义了一种SPI传输格式，如果需要多种SPI传输则需要定义多个结构体并进行实例化</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_transaction_t</span>=</span>&#123;</span><br><span class="line">    .cmd,<span class="comment">//指令数据，其长度在spi_device_interface_config_t中的command_bits设置</span></span><br><span class="line">    .addr,<span class="comment">//地址数据，其长度在spi_device_interface_config_t中的address_bits设置</span></span><br><span class="line">	.length,<span class="comment">//数据总长度，单位：比特</span></span><br><span class="line">    .rxlength,<span class="comment">//接收到的数据总长度，应小于length，如果设置为0则默认设置为length</span></span><br><span class="line">	.flags,<span class="comment">//SPI传输属性设置</span></span><br><span class="line">	.user,<span class="comment">//用户定义变量，可以用来存储传输ID等注释信息</span></span><br><span class="line">    .tx_buffer,<span class="comment">//发送数据缓存区指针</span></span><br><span class="line">    .tx_data,<span class="comment">//发送数据</span></span><br><span class="line">    .rx_buffer,<span class="comment">//接收数据缓存区指针，如果启用DMA则需要至少4个字节</span></span><br><span class="line">    .rx_data<span class="comment">//如果设置了SPI_TRANS_USE_RXDATA，数据会被这个变量直接接收</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//spi_device_interface_config_t用于配置SPI协议情况</span></span><br><span class="line"><span class="comment">//需要根据从设备的数据手册进行设置</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_device_interface_config_t</span>=</span>&#123;</span><br><span class="line">	.command_bits,<span class="comment">//默认控制位长度，设置为0-16</span></span><br><span class="line">    .address_bits,<span class="comment">//默认地址位长度，设置为0-64</span></span><br><span class="line">    .dummy_bits,<span class="comment">//在地址和数据位段之间插入的dummy位长度，用于匹配时序，一般可以保持默认</span></span><br><span class="line">	.clock_speed_hz,<span class="comment">//时钟频率，设置的是80MHz的分频系数，单位为Hz</span></span><br><span class="line">	.mode,<span class="comment">//SPI模式，设置为0-3</span></span><br><span class="line">    .duty_cycle_pos,<span class="comment">//</span></span><br><span class="line">    .cs_ena_pretrans,<span class="comment">//传输前CS信号的建立时间，只在半双工模式下有用</span></span><br><span class="line">    .cs_ena_posttrans,<span class="comment">//传输时CS信号的保持时间</span></span><br><span class="line">    .input_delay_ns,<span class="comment">//从机的最大合法数据传输时间</span></span><br><span class="line">	.spics_io_num,<span class="comment">//设置GPIO复用为CS引脚</span></span><br><span class="line">	.queue_size,<span class="comment">//传输队列大小，决定了等待传输数据的数量</span></span><br><span class="line">	.flags,<span class="comment">//SPI设备属性设置</span></span><br><span class="line">	.pre_cb,<span class="comment">//传输开始时的回调函数</span></span><br><span class="line">	.post_cb,<span class="comment">//传输结束时的回调函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>SPI主机可以发起全双工/半双工的通信，全双工通信中，<strong>总传输数据长度由spi_device_interface_config_t::command_bits、spi_device_interface_config_t::address_bits、spi_transaction_t::length决定</strong>，spi_transaction_t::rxlength仅决定了缓存区接收数据的长度；但半双工通信中，读写不同步，<strong>总传输数据长度由只spi_transaction_t::length和spi_transaction_t::rxlength决定</strong></p>
<p>指令和地址数据段是可选的，不是所有SPI设备都需要指令和/或数据，所以在spi_device_interface_config_t结构体中，如果设置command_bits和address_bits为0，就不会发送指令和数据</p>
<p>读写数据段也是可选的，如果rx_buffer设置为NULL，SPI_TRANS_USE_RXDATA没有定义，则读取数据段会被跳过；同理，如果tx_buffer设置为NULL，SPI_TRANS_USE_TXDATA没有定义，则写入数据段会被跳过</p>
<p>ESP32的驱动提供了两种传输方式：</p>
<ol>
<li>中断传输：发送、接收时触发中断</li>
<li>轮询传输：轮询SPI设备状态，如果空闲则可以调用函数</li>
</ol>
<p>两种模式也可以同时使用，但是实现代码较复杂</p>
<p>官网给出解释为</p>
<blockquote>
<h3 id="Notes-on-Sending-Mixed-Transactions-to-the-Same-Device"><a href="#Notes-on-Sending-Mixed-Transactions-to-the-Same-Device" class="headerlink" title="Notes on Sending Mixed Transactions to the Same Device"></a>Notes on Sending Mixed Transactions to the Same Device</h3><p>To reduce coding complexity, send only one type of transactions  (interrupt or polling) to one Device. However, you still can send both  interrupt and polling transactions alternately. The notes below explain  how to do this.</p>
<p>The polling transactions should be initiated only after all the polling and interrupt transactions are finished.</p>
<p>Since an unfinished polling transaction blocks other transactions, please do not forget to call the function <a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/release-v4.1/api-reference/peripherals/spi_master.html#_CPPv422spi_device_polling_end19spi_device_handle_t10TickType_t"><code>spi_device_polling_end()</code></a> after <a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/release-v4.1/api-reference/peripherals/spi_master.html#_CPPv424spi_device_polling_start19spi_device_handle_tP17spi_transaction_t10TickType_t"><code>spi_device_polling_start()</code></a> to allow other transactions or to allow other Devices to use the bus.  Remember that if there is no need to switch to other tasks during your  polling transaction, you can initiate a transaction with <a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/release-v4.1/api-reference/peripherals/spi_master.html#_CPPv427spi_device_polling_transmit19spi_device_handle_tP17spi_transaction_t"><code>spi_device_polling_transmit()</code></a> so that it will be ended automatically.</p>
<p>In-flight polling transactions are disturbed by the ISR operation to  accommodate interrupt transactions. Always make sure that all the  interrupt transactions sent to the ISR are finished before you call <a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/release-v4.1/api-reference/peripherals/spi_master.html#_CPPv424spi_device_polling_start19spi_device_handle_tP17spi_transaction_t10TickType_t"><code>spi_device_polling_start()</code></a>. To do that, you can keep calling <a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/release-v4.1/api-reference/peripherals/spi_master.html#_CPPv427spi_device_get_trans_result19spi_device_handle_tPP17spi_transaction_t10TickType_t"><code>spi_device_get_trans_result()</code></a> until all the transactions are returned.</p>
<p>To have better control of the calling sequence of functions, send  mixed transactions to the same Device only within a single task.</p>
</blockquote>
<p>也就是说轮询模式下的两个API相当于开关，一个让CPU进入轮询状态，一个让CPU退出轮询状态，需要配合使用；中断模式下的API相当于一个指令，让SPI控制器在发送/接收完毕时发出中断告知CPU，CPU接收到中断后执行中断服务函数；轮询状态下应当保证没有中断，否则会影响实时性，但是中断状态下CPU可以干别的事</p>
<h3 id="SPI传输模式"><a href="#SPI传输模式" class="headerlink" title="SPI传输模式"></a>SPI传输模式</h3><h4 id="中断传输"><a href="#中断传输" class="headerlink" title="中断传输"></a>中断传输</h4><p>中断传输期间，CPU可以执行其他任务。传输结束时，SPI外设触发中断，CPU调用任务处理函数进行处理</p>
<p>注意：一个任务可以排列多个传输序列，驱动程序会自动在中断服务程序（ISR）中对传输结果进行处理；但是中断传输会导致很多中断，如果设置中断任务太多还会影响日常任务运行降低实时性能</p>
<h4 id="轮询传输"><a href="#轮询传输" class="headerlink" title="轮询传输"></a>轮询传输</h4><p>轮询传输会轮询SPI外设的状态寄存器（官网原文为状态位）直到传输完成</p>
<p>轮询传输可以节约ISR队列挂起等待和线程（任务）上下文切换所需时间，但是会导致CPU占用</p>
<p>使用API spi_device_polling_end()来进行轮询，这个API至少需要1us时间解除对其他任务的阻塞；官方推荐使用spi_device_acquire_bus()和spi_device_release_bus()来进行调度</p>
<h3 id="SPI使用"><a href="#SPI使用" class="headerlink" title="SPI使用"></a>SPI使用</h3><ol>
<li>设定并初始化GPIO复用为SPI</li>
</ol>
<p>调用spi_bus_initialize()来初始化SPI总线，使用spi_bus_config_t结构体设置GPIO引脚</p>
<p><strong>注意不使用的信号线要设置为-1</strong></p>
   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">spi_bus_initialize</span><span class="params">(<span class="keyword">spi_host_device_t</span> host,<span class="comment">//SPI设备号</span></span></span></span><br><span class="line"><span class="params"><span class="function">                           	 <span class="keyword">const</span> <span class="keyword">spi_bus_config_t</span> *bus_config,<span class="comment">//总线GPIO设置</span></span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">int</span> dma_chan)</span><span class="comment">//使用的DMA通道</span></span></span><br><span class="line"><span class="function"><span class="comment">//总线初始化API</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果使能了DMA通道，所有传输和使用的数据接收缓冲区都应该在支持DMA访问的内存区域中申请</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">spi_host_device_t</span></span>=&#123;</span><br><span class="line">	SPI1_HOST=<span class="number">0</span>,</span><br><span class="line">	SPI2_HOST,</span><br><span class="line">	SPI3_HOST,</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">//dma_chan只能设置为0，1，2；设置为0则不启用DMA</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用spi_bus_add_device()设置SPI控制器设备</li>
</ol>
<p>该步骤的目的是通知FreeRTOS驱动有一个SPI设备连接到了总线上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">spi_bus_add_device</span><span class="params">(<span class="keyword">spi_host_device_t</span> host,<span class="comment">//SPI设备号</span></span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">const</span> <span class="keyword">spi_device_interface_config_t</span> *dev_config,<span class="comment">//数据格式设置</span></span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">spi_device_handle_t</span> *handle)</span><span class="comment">//设备句柄   </span></span></span><br></pre></td></tr></table></figure>

<p>这个API会根据spi_device_interface_config_t结构体初始化一个SPI外设并规定具体的时序</p>
<p>注意不要过度使用：<strong>ESP32只有2个可用的SPI控制器，一个SPI控制器只有三个CS信号线，最多能控制6个从设备</strong></p>
<p>全双工下，SPI最高速度可达80MHz，一般使用40Mhz；而半双工下，最高只能达到26MHz</p>
<ol start="3">
<li><p>设置一个或多个spi_transaction_t结构体来配置传输的数据格式</p>
<p>注意：<strong>需要等待当前传输完成后再发起新的传输</strong></p>
<ol>
<li>中断模式</li>
</ol>
<p>使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">spi_device_queue_trans</span><span class="params">(<span class="keyword">spi_device_handle_t</span> handle,<span class="comment">//SPI设备句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">spi_transaction_t</span> *trans_desc,<span class="comment">//要执行的传输</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                 TickType_t ticks_to_wait)</span><span class="comment">//等待时间，如果设置为MAX_DELAY则会等待到队满</span></span></span><br><span class="line"><span class="function"><span class="comment">//将要执行的传输放入SPI传输队列</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">spi_device_get_trans_result</span><span class="params">(<span class="keyword">spi_device_handle_t</span> handle,<span class="comment">//SPI设备句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">spi_transaction_t</span> **trans_desc,<span class="comment">//之前执行的传输的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                      TickType_t ticks_to_wait)</span><span class="comment">//等待时间</span></span></span><br><span class="line"><span class="function"><span class="comment">//获取此前由spi_device_queue_trans发起传输的结果</span></span></span><br></pre></td></tr></table></figure>

<p>来将一个传输加入待传输队列</p>
<p>可以通过spi_device_get_trans_result()查询传输结果；也可以将所有结果放入以下API，使用中断处理函数和FSM来设定各种传输结果对应的操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">spi_device_transmit</span><span class="params">(<span class="keyword">spi_device_handle_t</span> handle,<span class="comment">//SPI设备句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">spi_transaction_t</span> *trans_desc)</span><span class="comment">//要执行的传输</span></span></span><br><span class="line"><span class="function"><span class="comment">//发起一次SPI传输，等待完成并返回结果，该函数和spi_device_queue_trans+spi_device_get_trans_result共同使用等价</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>轮询模式</li>
</ol>
<p>使用以下API来发起轮询模式的传输</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">spi_device_polling_transmit</span><span class="params">(<span class="keyword">spi_device_handle_t</span> handle,<span class="comment">//SPI设备句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">spi_transaction_t</span> *trans_desc)</span><span class="comment">//要执行的传输  </span></span></span><br><span class="line"><span class="function"><span class="comment">//发起一次轮询模式下的传输，等待完成后返回结果</span></span></span><br><span class="line"><span class="function"><span class="comment">//此函数和spi_device_polling_start+spi_device_polling_end共同使用等价</span></span></span><br></pre></td></tr></table></figure>

<p>如果需要再发送传输中间插入其他代码，可以使用以下两个API</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">spi_device_polling_start</span><span class="params">(<span class="keyword">spi_device_handle_t</span> handle,<span class="comment">//SPI设备句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">spi_transaction_t</span> *trans_desc,<span class="comment">//要执行的传输</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                   TickType_t ticks_to_wait)</span><span class="comment">//等待时间</span></span></span><br><span class="line"><span class="function"><span class="comment">//立刻发起一次轮询模式传输</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">spi_device_polling_end</span><span class="params">(<span class="keyword">spi_device_handle_t</span> handle,<span class="comment">//SPI设备句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                 TickType_t ticks_to_wait)</span><span class="comment">//等待时间</span></span></span><br><span class="line"><span class="function"><span class="comment">//使CPU保持轮询直到传输完成，这个任务直到成功完成才能结束且是非阻塞的——其他线程（任务）可以在传输期间占用CPU（当然会降低效率）</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>发送/接收数据</p>
</li>
</ol>
<p>可以使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">spi_device_acquire_bus</span><span class="params">(<span class="keyword">spi_device_handle_t</span> device, TickType_t wait)</span></span>;<span class="comment">//释放总线</span></span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spi_device_release_bus</span><span class="params">(<span class="keyword">spi_device_handle_t</span> dev)</span></span>;<span class="comment">//释放总线</span></span><br></pre></td></tr></table></figure>

<p>来让主设备一直占用总线，可以在两个API调用期间间断地发送数据</p>
<p>可以使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">spi_bus_remove_device</span><span class="params">(<span class="keyword">spi_device_handle_t</span> handle)</span></span></span><br><span class="line"><span class="function"><span class="comment">//将设备从SPI总线上移除</span></span></span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">spi_bus_free</span><span class="params">(<span class="keyword">spi_host_device_t</span> host)</span></span></span><br><span class="line"><span class="function"><span class="comment">//释放总线</span></span></span><br></pre></td></tr></table></figure>

<p>来解除目标设备对SPI总线的占用，并释放系统资源</p>
<h3 id="传输速率"><a href="#传输速率" class="headerlink" title="传输速率"></a>传输速率</h3><p>SPI传输速率与以下因素有关：</p>
<ul>
<li>传输间隔</li>
<li>SPI时钟频率（主要因素）</li>
<li>SPI控制函数与回调函数的执行延迟</li>
</ul>
<p>典型的传输间隔如下所示：</p>
<table>
<thead>
<tr>
<th></th>
<th>典型传输时间 (us)</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>中断模式</td>
<td>轮询模式</td>
</tr>
<tr>
<td>使用DMA</td>
<td>24</td>
<td>8</td>
</tr>
<tr>
<td>不使用DMA</td>
<td>22</td>
<td>7</td>
</tr>
</tbody></table>
<h2 id="SPI-Slave"><a href="#SPI-Slave" class="headerlink" title="SPI Slave"></a>SPI Slave</h2><p>SPI从设备驱动负责处理ESP32作为从设备的情况</p>
<p>SPI2和SPI3也能独立地作为从设备使用，支持全双工四线SPI、半双工DSPI、半双工QSPI，支持收发64字节数据和使能DMA传输</p>
<h3 id="从模式的基本配置"><a href="#从模式的基本配置" class="headerlink" title="从模式的基本配置"></a>从模式的基本配置</h3><p>使用spi_slave_interface_config_t结构体来设置SPI从模式的物理接口</p>
<p>使用spi_slave_transaction_t结构体设置从模式下的数据格式和数据缓冲区大小等</p>
<p>使用spi_transaction_t结构体配置单独收取/单独发送等特殊情况的传输数据格式</p>
<p>结构体原型如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置</span></span><br><span class="line"><span class="keyword">spi_device_interface_config_t</span> devcfg=&#123;</span><br><span class="line">	.command_bits=<span class="number">0</span>,</span><br><span class="line">    .address_bits=<span class="number">0</span>,</span><br><span class="line">	.dummy_bits=<span class="number">0</span>,</span><br><span class="line">    .clock_speed_hz=<span class="number">5000000</span>,</span><br><span class="line">	.duty_cycle_pos=<span class="number">128</span>, <span class="comment">//50% duty cycle</span></span><br><span class="line">    .mode=<span class="number">0</span>,</span><br><span class="line">	.spics_io_num=GPIO_CS,</span><br><span class="line">	.cs_ena_posttrans=<span class="number">3</span>,</span><br><span class="line"><span class="comment">//Keep the CS low 3 cycles after transaction, to stop slave from missing the last bit when CS has less propagation delay than CLK</span></span><br><span class="line">    .queue_size=<span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于配置SPI从机接口的spi_slave_interface_config_t结构体</span></span><br><span class="line"><span class="keyword">spi_slave_interface_config_t</span> slvcfg=&#123;</span><br><span class="line">	.mode,<span class="comment">//SPI模式，配置为0-3</span></span><br><span class="line">	.spics_io_num,<span class="comment">//片选信号线复用IO</span></span><br><span class="line">	.queue_size,<span class="comment">//传输队列大小，设置同时最多有多少挂起的传输</span></span><br><span class="line">	.flags,<span class="comment">//接口属性，使用位或运算符|连接各属性参数</span></span><br><span class="line">	.post_setup_cb,<span class="comment">//SPI寄存器加载新数据时调用的回调函数</span></span><br><span class="line">	.post_trans_cb<span class="comment">//传输完成回调函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//描述一次SPI传输的结构体</span></span><br><span class="line"><span class="keyword">spi_slave_transaction_t</span></span><br><span class="line">&#123;</span><br><span class="line">    .length,<span class="comment">//总数据长度</span></span><br><span class="line">    .trans_len,<span class="comment">//传输数据长度</span></span><br><span class="line">    .tx_buffer,<span class="comment">//数据发送缓冲区指针</span></span><br><span class="line">    .rx_buffer,<span class="comment">//数据接收缓冲区指针</span></span><br><span class="line">	.user<span class="comment">//用户定义变量，一般用于存储本次传输的ID</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意：上述长度的单位是比特</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于配置SPI总线的spi_bus_config_t结构体</span></span><br><span class="line"><span class="keyword">spi_bus_config_t</span> buscfg=&#123;</span><br><span class="line">	.mosi_io_num=GPIO_MOSI,</span><br><span class="line">	.miso_io_num=GPIO_MISO,</span><br><span class="line">    .sclk_io_num=GPIO_SCLK,</span><br><span class="line">    .quadwp_io_num = <span class="number">-1</span>,</span><br><span class="line">	.quadhd_io_num = <span class="number">-1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//未使用的参数应设置为-1</span></span><br></pre></td></tr></table></figure>

<p>如果spi_slave_interface_config_t::rx_buffer=NULL，则跳过读取数据段；如果spi_slave_interface_config_t::tx_buffer=NULL，则跳过写入数据段</p>
<p>传输开始前，应当配置好一个或以上的spi_slave_transaction_t结构体</p>
<p>注意：<strong>如果传输的数据大于32字节，需要使能DMA通道1或通道2</strong>，如果<strong>不使用DMA，应将dma_chan参数设置为0</strong></p>
<h3 id="传输相关API与使用步骤"><a href="#传输相关API与使用步骤" class="headerlink" title="传输相关API与使用步骤"></a>传输相关API与使用步骤</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所有形式的SPI设备都需要调用这个API来进行初始化</span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">spi_bus_initialize</span><span class="params">(<span class="keyword">spi_host_device_t</span> host,<span class="comment">//SPI设备号</span></span></span></span><br><span class="line"><span class="params"><span class="function">                           	 <span class="keyword">const</span> <span class="keyword">spi_bus_config_t</span> *bus_config,<span class="comment">//总线GPIO设置</span></span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">int</span> dma_chan)</span><span class="comment">//使用的DMA通道</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//SPI从设备初始化</span></span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">spi_slave_initialize</span><span class="params">(<span class="keyword">spi_host_device_t</span> host,<span class="comment">//SPI设备号</span></span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">const</span> <span class="keyword">spi_bus_config_t</span> *bus_config,<span class="comment">//SPI总线设置</span></span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">const</span> <span class="keyword">spi_slave_interface_config_t</span> *slave_config,<span class="comment">//SPI接口设置</span></span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">int</span> dma_chan)</span><span class="comment">//使用的DMA通道</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//卸载SPI从设备驱动</span></span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">spi_slave_free</span><span class="params">(<span class="keyword">spi_host_device_t</span> host)</span><span class="comment">//SPI设备号</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//发起SPI从设备队列传输数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">spi_slave_queue_trans</span><span class="params">(<span class="keyword">spi_host_device_t</span> host,<span class="comment">//SPI设备号</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">const</span> <span class="keyword">spi_slave_transaction_t</span> *trans_desc,<span class="comment">//传输的数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                TickType_t ticks_to_wait)</span><span class="comment">//等待时间</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 将一条SPI消息挂到SPI传输队列，并等待发送 */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//获取队列传输数据的结果</span></span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">spi_slave_get_trans_result</span><span class="params">(<span class="keyword">spi_host_device_t</span> host,<span class="comment">//SPI设备号</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">spi_slave_transaction_t</span> **trans_desc,<span class="comment">//传输数据指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                     TickType_t ticks_to_wait)</span><span class="comment">//等待时间  </span></span></span><br><span class="line"><span class="function"><span class="comment">/* 在使用spi_slave_queue_trans到使用spi_slave_get_trans_result之间，CPU会轮询传输结果，使用该API获取结果 */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//发起一次SPI传输</span></span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">spi_slave_transmit</span><span class="params">(<span class="keyword">spi_host_device_t</span> host,<span class="comment">//SPI设备号</span></span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">spi_slave_transaction_t</span> *trans_desc,<span class="comment">//传输的数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">                             TickType_t ticks_to_wait)</span><span class="comment">//等待时间</span></span></span><br><span class="line"><span class="function"><span class="comment">//该函数与连用spi_slave_queue_trans和spi_slave_get_trans_result效果相同</span></span></span><br></pre></td></tr></table></figure>

<ol>
<li>使用spi_bus_config_t结构体和spi_bus_initialize()函数创建SPI总线</li>
<li>使用spi_device_interface_config_t结构体和spi_bus_add_device()函数向SPI总线上添加新设备</li>
<li>使用spi_slave_queue_trans、spi_slave_get_trans_result、spi_slave_transmit三个API进行传输数据</li>
<li>如果需要卸载SPI从设备驱动，使用spi_slave_free</li>
</ol>
<p>注意：==如果使用了DMA，需要保证使用pvPortMallocCaps(size, MALLOC_CAP_DMA)为缓冲区开辟内存，这样可以保障DMA能够访问到这些缓冲区==</p>
<p>DMA和初始化API的配置与主模式类似，驱动函数的使用方法也类似，在此不做介绍，关注API即可</p>
<h2 id="目前存在的DMA缺陷（摘自官网）"><a href="#目前存在的DMA缺陷（摘自官网）" class="headerlink" title="目前存在的DMA缺陷（摘自官网）"></a>目前存在的DMA缺陷（摘自官网）</h2><blockquote>
<h2 id="Restrictions-and-Known-Issues"><a href="#Restrictions-and-Known-Issues" class="headerlink" title="Restrictions and Known Issues"></a>Restrictions and Known Issues</h2><ol>
<li><p>If DMA is enabled, the rx buffer should be word-aligned (starting from a 32-bit boundary and having a length of multiples of 4 bytes).  Otherwise, DMA may write incorrectly or not in a boundary aligned  manner. The driver reports an error if this condition is not satisfied.</p>
<p>Also, a Host should write lengths that are multiples of 4 bytes. The data with inappropriate lengths will be discarded.</p>
</li>
<li><p>Furthermore, DMA requires SPI modes 1 and 3. For SPI modes 0 and  2, the MISO signal has to be launched half a clock cycle earlier to meet the timing. The new timing is as follows:</p>
</li>
</ol>
<blockquote>
<p><img src="https://docs.espressif.com/projects/esp-idf/zh_CN/release-v4.1/_images/spi_slave_miso_dma.png" alt="../../_images/spi_slave_miso_dma.png"></p>
</blockquote>
<p>If DMA is enabled, a Device’s launch edge is half of an SPI clock  cycle ahead of the normal time, shifting to the Master’s actual latch  edge. In this case, if the GPIO matrix is bypassed, the hold time for  data sampling is 68.75 ns and no longer a half of an SPI clock cycle. If the GPIO matrix is used, the hold time will increase to 93.75 ns. The  Host should sample the data immediately at the latch edge or communicate in SPI modes 1 or 3. If your Host cannot meet these timing  requirements, initialize your Device without DMA.</p>
</blockquote>
<ol>
<li>启用DMA时应当将收发缓存设定为字对齐模式（是4字节的倍数）</li>
<li>从机模式的DMA需要主机时钟的保持时间足够长才能工作，如果主机无法满足只能放弃使用DMA</li>
</ol>
<h1 id="SPI使用例"><a href="#SPI使用例" class="headerlink" title="SPI使用例"></a>SPI使用例</h1><p>参考esp-idf/example/peripheral/spi/部分示例</p>
<h1 id="SPI-FLASH组件"><a href="#SPI-FLASH组件" class="headerlink" title="SPI FLASH组件"></a>SPI FLASH组件</h1><p>以下内容部分摘自官网原文，黑体部分为强调和个人理解</p>
<p>SPI Flash 组件提供外部 flash 数据读取、写入、擦除和内存映射相关的 API 函数，同时也提供了更高层级的、面向分区的 API 函数（定义在分区表部分）</p>
<p>注意：<strong>ESP-IDF V4.0后饿FLASH API不再是原子的，如果 flash 操作地址有重叠，且写操作与读操作同时执行，读操作可能会返回一部分写入之前的数据，返回一部分写入之后的数据</strong></p>
<h2 id="FLASH设备的使用"><a href="#FLASH设备的使用" class="headerlink" title="FLASH设备的使用"></a>FLASH设备的使用</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>设置方式类似基本的SPI API调用，具体步骤如下</p>
<ol>
<li>调用spi_bus_initialize()初始化SPI总线</li>
<li>调用spi_bus_add_flash_device()将片外FLASH作为从设备挂载到SPI总线，并分配内存、填充esp_flash_t结构体、初始化CS信号线</li>
<li>调用esp_flash_init()与芯片进行通信（注意：目前多个FLASH芯片可以连接到同意总线，但尚不支持在同一个SPI总线上使用esp_flash_*和spi_device_*设备）</li>
</ol>
<h3 id="访问FLASH"><a href="#访问FLASH" class="headerlink" title="访问FLASH"></a>访问FLASH</h3><p>一般来说应尽量避免对主SPI flash芯片直接使用原始SPI flash函数，如需对主SPI flash芯片进行操作应使用分区表API</p>
<p>使用以下API访问片外SPI FLASH</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_flash_read</span><span class="params">(<span class="keyword">esp_flash_t</span> *chip,<span class="comment">//指向已识别FLASH对象地指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">void</span> *buffer,<span class="comment">//读取数据缓冲区指针，当保存在RAM且字对齐时具有更好的使用性能</span></span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">uint32_t</span> address,<span class="comment">//待读取数据的FLASH地址，必须小于chip-&gt;size</span></span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">uint32_t</span> length)</span></span>;<span class="comment">//待读取的数据长度</span></span><br><span class="line"><span class="comment">//将数据无对齐地从flash读取到RAM</span></span><br><span class="line"><span class="comment">//chip需要用esp_flash_init()初始化过才能使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_flash_write</span><span class="params">(<span class="keyword">esp_flash_t</span> *chip,<span class="comment">//指向已识别FLASH对象地指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">const</span> <span class="keyword">void</span> *buffer,<span class="comment">//写入数据缓冲区指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">uint32_t</span> address,<span class="comment">//待写入数据的FLASH地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">uint32_t</span> length)</span></span>;<span class="comment">//待写入的数据长度</span></span><br><span class="line"><span class="comment">//将数据无对齐地从RAM写入到 flash</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_flash_write_encrypted</span><span class="params">(<span class="keyword">esp_flash_t</span> *chip,<span class="comment">//指向已识别FLASH对象地指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">uint32_t</span> address,<span class="comment">//待写入数据的FLASH地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">const</span> <span class="keyword">void</span> *buffer,<span class="comment">//写入数据缓冲区指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">uint32_t</span> length)</span></span>;<span class="comment">//待写入的数据长度</span></span><br><span class="line"><span class="comment">//使用片上硬件FLASH加密外设，加密写入数据</span></span><br><span class="line"><span class="comment">//注意：地址和数据长度都应该是16位对齐</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_flash_read_encrypted</span><span class="params">(<span class="keyword">esp_flash_t</span> *chip,<span class="comment">//指向已识别FLASH对象地指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">uint32_t</span> address,<span class="comment">//待读取数据的FLASH地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">void</span> *out_buffer,<span class="comment">//读取数据缓冲区指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">uint32_t</span> length)</span></span>;<span class="comment">//待读取的数据长度</span></span><br><span class="line"><span class="comment">//使用片上硬件FLASH加密外设，加密读取数据</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_flash_erase_region</span><span class="params">(<span class="keyword">esp_flash_t</span> *chip,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">uint32_t</span> start,<span class="comment">//起始地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">uint32_t</span> len)</span></span>;<span class="comment">//擦除长度</span></span><br><span class="line"><span class="comment">//擦除 flash 中指定区域的数据</span></span><br><span class="line"><span class="comment">//注意：擦除的地址一定要和扇区对齐！！！</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_flash_erase_chip</span><span class="params">(<span class="keyword">esp_flash_t</span> *chip)</span></span>;<span class="comment">//擦除整个 flash</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_flash_get_size</span><span class="params">(<span class="keyword">esp_flash_t</span> *chip,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">uint32_t</span> *out_size)</span></span>;</span><br><span class="line"><span class="comment">//根据FLASH ID检测FLASH容量（以字节为单位）</span></span><br></pre></td></tr></table></figure>

<p>FLASH容量存储在<strong>引导程序映像头不烧录偏移量为0x1000的一个字段</strong></p>
<p>默认情况下烧录引导程序时，esptool会自动检测SPI FLASH容量并使用正确容量更新引导程序的头部；但是也可以设置CONFIG_ESPTOOLPY_FLASHSIZE生成固定FLASH容量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">esp_flash_t</span>//描述片外<span class="title">FLASH</span>的结构体，应当使用<span class="title">esp_flash_init</span>()进行初始化</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">spi_flash_host_driver_t</span> *host,<span class="comment">//SPI驱动结构体句柄</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">spi_flash_chip_t</span> *chip_drv,<span class="comment">//FLASH驱动“适配”结构体</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">esp_flash_os_functions_t</span> *os_func,</span><br><span class="line">    <span class="comment">//RTOS钩子函数，使用esp_flash_init_os_functions()设置</span></span><br><span class="line">    os_func_data,</span><br><span class="line">    <span class="comment">//RTOS钩子函数的参数</span></span><br><span class="line">	<span class="keyword">esp_flash_io_mode_t</span> read_mode,<span class="comment">//配置FLASH读取模式</span></span><br><span class="line">	<span class="keyword">uint32_t</span> size,<span class="comment">//FLASH容量，如果设置为0则会在初始化期间检测</span></span><br><span class="line">    <span class="keyword">uint32_t</span> chip_id<span class="comment">//检测FLASH ID</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SPI驱动结构体，配置主机驱动和上下文</span></span><br><span class="line"><span class="comment">//使用了c面向对象的方式，将方法（或者说是成员函数）用函数指针封装在结构体对象</span></span><br><span class="line"><span class="comment">//上面提到的那些API基本都被归纳进了这个结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_flash_host_driver_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *driver_data,<span class="comment">//驱动数据</span></span><br><span class="line">    <span class="keyword">esp_err_t</span> (*dev_config)(<span class="keyword">spi_flash_host_driver_t</span> *driver),<span class="comment">//设备驱动寄存器设置方法</span></span><br><span class="line">    <span class="keyword">esp_err_t</span> (*common_command)(<span class="keyword">spi_flash_host_driver_t</span> *driver, <span class="keyword">spi_flash_trans_t</span> *t),</span><br><span class="line">    <span class="comment">//用户定义传输指令方法</span></span><br><span class="line">    <span class="keyword">esp_err_t</span> (*read_id)(<span class="keyword">spi_flash_host_driver_t</span> *driver, <span class="keyword">uint32_t</span> *id),<span class="comment">//读取FLASH ID的方法</span></span><br><span class="line">    <span class="keyword">void</span> (*erase_chip)(<span class="keyword">spi_flash_host_driver_t</span> *driver),<span class="comment">//全片擦除方法</span></span><br><span class="line">    <span class="keyword">void</span> (*erase_sector)(<span class="keyword">spi_flash_host_driver_t</span> *driver, <span class="keyword">uint32_t</span> start_address),<span class="comment">//扇区擦除方法</span></span><br><span class="line">    <span class="keyword">void</span> (*erase_block)(<span class="keyword">spi_flash_host_driver_t</span> *driver, <span class="keyword">uint32_t</span> start_address),<span class="comment">//块擦除方法</span></span><br><span class="line">    <span class="keyword">esp_err_t</span> (*read_status)(<span class="keyword">spi_flash_host_driver_t</span> *driver, <span class="keyword">uint8_t</span> *out_sr),<span class="comment">//读取FLASH状态方法</span></span><br><span class="line">    <span class="keyword">esp_err_t</span> (*set_write_protect)(<span class="keyword">spi_flash_host_driver_t</span> *driver, <span class="keyword">bool</span> wp),<span class="comment">//关闭写保护方法</span></span><br><span class="line">    <span class="keyword">void</span> (*program_page)(<span class="keyword">spi_flash_host_driver_t</span> *driver,</span><br><span class="line">                         <span class="keyword">const</span> <span class="keyword">void</span> *buffer,</span><br><span class="line">                         <span class="keyword">uint32_t</span> address,</span><br><span class="line">                         <span class="keyword">uint32_t</span> length),</span><br><span class="line">    <span class="comment">//按页写入FLASH并检查最大写入字节数方法</span></span><br><span class="line">    <span class="keyword">bool</span> (*supports_direct_write)(<span class="keyword">spi_flash_host_driver_t</span> *driver, <span class="keyword">const</span> <span class="keyword">void</span> *p),</span><br><span class="line">    <span class="comment">//检查写入中是否需要申请新的页方法</span></span><br><span class="line">    <span class="keyword">bool</span> (*supports_direct_read)(<span class="keyword">spi_flash_host_driver_t</span> *driver, <span class="keyword">const</span> <span class="keyword">void</span> *p),</span><br><span class="line">    <span class="comment">//检查读取中是否需要申请新的页方法</span></span><br><span class="line">    <span class="keyword">int</span> max_write_bytes,<span class="comment">//每页的最大写入字节数</span></span><br><span class="line">	<span class="keyword">esp_err_t</span> (*read)(<span class="keyword">spi_flash_host_driver_t</span> *driver,</span><br><span class="line">                      <span class="keyword">void</span> *buffer,</span><br><span class="line">                      <span class="keyword">uint32_t</span> address,</span><br><span class="line">                      <span class="keyword">uint32_t</span> read_len)</span><br><span class="line">	<span class="comment">//从FLASH中读取数据并检查最大读取字节数方法</span></span><br><span class="line">	<span class="keyword">int</span> max_read_bytes,<span class="comment">//最大读取字节数</span></span><br><span class="line">    <span class="keyword">bool</span> (*host_idle)(<span class="keyword">spi_flash_host_driver_t</span> *driver),<span class="comment">//检查SPI主机是否空闲方法</span></span><br><span class="line">    <span class="keyword">esp_err_t</span> (*configure_host_io_mode)(<span class="keyword">spi_flash_host_driver_t</span> *driver,</span><br><span class="line">                                        <span class="keyword">uint32_t</span> command,</span><br><span class="line">                                        <span class="keyword">uint32_t</span> addr_bitlen,</span><br><span class="line">                                        <span class="keyword">int</span> dummy_bitlen_base,</span><br><span class="line">                                        <span class="keyword">esp_flash_io_mode_t</span> io_mode),</span><br><span class="line">    <span class="comment">//设置主机工作在不同的读取模式，响应补偿时间、设置IO模式方法</span></span><br><span class="line">    <span class="keyword">void</span> (*poll_cmd_done)(<span class="keyword">spi_flash_host_driver_t</span> *driver),<span class="comment">//使硬件保持轮询直到操作完毕方法</span></span><br><span class="line">    <span class="keyword">esp_err_t</span> (*flush_cache)(<span class="keyword">spi_flash_host_driver_t</span> *driver,</span><br><span class="line">                             <span class="keyword">uint32_t</span> addr,</span><br><span class="line">                             <span class="keyword">uint32_t</span> size)</span><br><span class="line">	<span class="comment">//清空主机（如SPI1）所用的缓存区方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化外部FLASH的示例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">esp_flash_t</span>* <span class="title">example_init_ext_flash</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">spi_bus_config_t</span> bus_config = &#123;</span><br><span class="line">        .mosi_io_num = VSPI_IOMUX_PIN_NUM_MOSI,</span><br><span class="line">        .miso_io_num = VSPI_IOMUX_PIN_NUM_MISO,</span><br><span class="line">        .sclk_io_num = VSPI_IOMUX_PIN_NUM_CLK,</span><br><span class="line">        .quadwp_io_num = <span class="number">-1</span>,</span><br><span class="line">        .quadhd_io_num = <span class="number">-1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">esp_flash_spi_device_config_t</span> device_config = &#123;</span><br><span class="line">        .host_id = VSPI_HOST,</span><br><span class="line">        .cs_id = <span class="number">0</span>,</span><br><span class="line">        .cs_io_num = VSPI_IOMUX_PIN_NUM_CS,</span><br><span class="line">        .io_mode = SPI_FLASH_DIO,</span><br><span class="line">        .speed = ESP_FLASH_40MHZ</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;初始化外部SPI FLASH&quot;</span>);</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;引脚设定:&quot;</span>);</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;MOSI: %2d   MISO: %2d   SCLK: %2d   CS: %2d&quot;</span>,</span><br><span class="line">        bus_config.mosi_io_num, bus_config.miso_io_num,</span><br><span class="line">        bus_config.sclk_io_num, device_config.cs_io_num</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化SPI总线</span></span><br><span class="line">    ESP_ERROR_CHECK(spi_bus_initialize(VSPI_HOST, &amp;bus_config, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//将FLASH设备添加到SPI总线</span></span><br><span class="line">    <span class="keyword">esp_flash_t</span>* ext_flash;</span><br><span class="line">    ESP_ERROR_CHECK(spi_bus_add_flash_device(&amp;ext_flash, &amp;device_config));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接、检查FLASH并进行初始化</span></span><br><span class="line">    <span class="keyword">esp_err_t</span> err = esp_flash_init(ext_flash);</span><br><span class="line">    <span class="keyword">if</span> (err != ESP_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">&quot;连接外部FLASH失败: %s (0x%x)&quot;</span>, esp_err_to_name(err), err);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行 输出ID和大小 任务</span></span><br><span class="line">    <span class="keyword">uint32_t</span> id;</span><br><span class="line">    ESP_ERROR_CHECK(esp_flash_read_id(ext_flash, &amp;id));</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Initialized external Flash, size=%d KB, ID=0x%x&quot;</span>, ext_flash-&gt;size / <span class="number">1024</span>, id);</span><br><span class="line">    <span class="keyword">return</span> ext_flash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">ESP32</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A04%E3%80%90SPI%E4%B8%8E%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%91/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-ESP32-IDF学习3【经典蓝牙与BLE】" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A03%E3%80%90%E7%BB%8F%E5%85%B8%E8%93%9D%E7%89%99%E4%B8%8EBLE%E3%80%91/">ESP32_IDF学习3【经典蓝牙与BLE】</a>
    </h1>
  

        
<!-- 显示阅读次数-->
<!--  -->
<!--显示阅读次数完毕 -->

        
        <a href="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A03%E3%80%90%E7%BB%8F%E5%85%B8%E8%93%9D%E7%89%99%E4%B8%8EBLE%E3%80%91/" class="archive-article-date">
  	<time datetime="2021-11-19T07:00:10.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2021-11-19</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<p>在这里着重记述低功耗蓝牙BLE相关内容，库函数部分翻译自乐鑫官网文档</p>
<h1 id="低功耗蓝牙（BLE）协议栈"><a href="#低功耗蓝牙（BLE）协议栈" class="headerlink" title="低功耗蓝牙（BLE）协议栈"></a>低功耗蓝牙（BLE）协议栈</h1><p>低功耗蓝牙协议是蓝牙通信协议的一种，BLE协议栈就是实现低功耗蓝牙协议的代码</p>
<h2 id="层次协议"><a href="#层次协议" class="headerlink" title="层次协议"></a>层次协议</h2><p>蓝牙协议规定了两个层次的协议，分别为<strong>蓝牙核心协议</strong>（Bluetooth Core）和<strong>蓝牙应用层协议</strong>（Bluetooth Application）</p>
<p>蓝牙核心协议就是对蓝牙技术本身的规范，不涉及其应用方式</p>
<p>蓝牙应用层协议是在蓝牙核心协议的基础上，根据具体的应用需求定义出的特定策略</p>
<p>蓝牙协议栈框图如下所示：</p>
<p><img src="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A03%E3%80%90%E7%BB%8F%E5%85%B8%E8%93%9D%E7%89%99%E4%B8%8EBLE%E3%80%91/653161-20191204145125985-356995077.png" alt="https://img2018.cnblogs.com/blog/653161/201912/653161-20191204145125985-356995077.png"></p>
<h2 id="蓝牙核心协议（Bluetooth-Core）"><a href="#蓝牙核心协议（Bluetooth-Core）" class="headerlink" title="蓝牙核心协议（Bluetooth Core）"></a>蓝牙核心协议（Bluetooth Core）</h2><p>蓝牙核心协议包含BLE Controller和BLE Host两部分</p>
<p>Controller负责定义RF、Baseband等偏硬件的规范</p>
<p>Host负责在逻辑链路的基础上，进行更为友好的封装，这样就可以屏蔽掉蓝牙技术的细节，让Bluetooth Application更为方便的使用</p>
<p>==Controller是工作在物理层、数据链路层、网络层、传输层的协议，Host则是工作在传输层 、会话层、表示层、应用层的协议，Host将Controller封装成可被配置为函数的形式供程序使用==</p>
<p><img src="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A03%E3%80%90%E7%BB%8F%E5%85%B8%E8%93%9D%E7%89%99%E4%B8%8EBLE%E3%80%91/653161-20191204145156859-489087209.png" alt="https://img2018.cnblogs.com/blog/653161/201912/653161-20191204145156859-489087209.png"></p>
<h3 id="包含的层次简介"><a href="#包含的层次简介" class="headerlink" title="包含的层次简介"></a>包含的层次简介</h3><ol>
<li>物理层（PHY）</li>
</ol>
<p>用于指定BLE所用的无线频段、调制解调方式和方法等</p>
<p>BLE工作在1Mbps自适应跳频的GFSK射频，免于许可证的2.4GHz ISM（工业、课学、医疗）频段</p>
<p><strong>可以直观理解为规定了BLE的天线部分</strong></p>
<ol start="2">
<li>链路层（LL——Link Layer）</li>
</ol>
<p><strong>BLE协议栈的核心</strong></p>
<p><strong>相当于TCP/IP协议中的数据链路层（负责选择哪个射频通道，管理当前链路）+网络层（负责识别和发送空中数据包）+传输层（负责保证数据包安全、完整的发送、接收、重传等）</strong></p>
<ol start="3">
<li>主机控制接口层（HCI——Host Controller Interface）</li>
</ol>
<p>这一层是<strong>可选</strong>的，HCI主要用于2颗IC实现BLE协议栈的场合，用于贵方两者的通信协议和通信命令等</p>
<h2 id="蓝牙应用协议（Bluetooth-Application）"><a href="#蓝牙应用协议（Bluetooth-Application）" class="headerlink" title="蓝牙应用协议（Bluetooth Application）"></a>蓝牙应用协议（Bluetooth Application）</h2><h3 id="包含的层次简介-1"><a href="#包含的层次简介-1" class="headerlink" title="包含的层次简介"></a>包含的层次简介</h3><ol start="4">
<li>通用访问配置文件层（GAP——Generic access profile）</li>
</ol>
<p><strong>实际配置中常接触到的一层</strong></p>
<p>GAP是对LL层有效数据包（payload）进行解析的两种方式中最简单的一种，主要用于<strong>广播、扫描、发起连接</strong>这些具体行为</p>
<ol start="5">
<li>逻辑链路控制及自适应协议层（L2CAP——Logical Link Control and Adaptation Protocol）</li>
</ol>
<p>这一层是对LL的简单封装，在L2CAP中区分出是使用加密通道还是普通通道，同时负责连接间隔的管理</p>
<ol start="6">
<li>安全管理层（SM——Security Manager）</li>
</ol>
<p>负责管理BLE连接的加密、安全，需要兼顾安全性和用户使用的便利性</p>
<ol start="7">
<li>属性协议层（ATT——Attribute protocol）</li>
</ol>
<p><strong>实际配置中最常接触到的一层</strong></p>
<p>负责定义用户命令和命令操作的数据（如读写数据等）</p>
<p>详细内容见后文【BLE的两种模式】和【ATT简述】</p>
<ol start="8">
<li>通用属性配置文件层（GATT——Generic Attribute profile）</li>
</ol>
<p><strong>实际配置中常接触到的一层</strong></p>
<p>用于规范attribute中的数据内容（attribute见后文【BLE的两种模式】），并使用分组（group）来对attribute进行分类管理</p>
<p>一般地，BLE在没有GATT的情况下也能跑，只不过互联互通会出现问题</p>
<p>BLE<strong>需要在GATT和各种应用profile的支持</strong>下才能实现最便捷高效稳定的通信</p>
<h1 id="BT与BLE的区别"><a href="#BT与BLE的区别" class="headerlink" title="BT与BLE的区别"></a>BT与BLE的区别</h1><p>当前的蓝牙协议分为基础率/增强数据率（BR/EDR）和低耗能（LE）两种技术类型</p>
<p>经典蓝牙统称BT，低功耗蓝牙称为BLE</p>
<h2 id="经典蓝牙模块（BT）"><a href="#经典蓝牙模块（BT）" class="headerlink" title="经典蓝牙模块（BT）"></a>经典蓝牙模块（BT）</h2><blockquote>
<p>泛指支持蓝牙协议在4.0以下的模块，一般用于数据量比较大的传输。</p>
</blockquote>
<p><strong>经典蓝牙模块</strong>可再细分为：<strong>传统蓝牙模块和高速蓝牙模块</strong>。</p>
<p><strong>传统蓝牙模块</strong>在2004年推出，主要代表是支持蓝牙2.1协议的模块，在智能手机爆发的</p>
<p>时期得到广泛支持。</p>
<p><strong>高速蓝牙模块</strong>在2009年推出，速率提高到约24Mbps，是传统蓝牙模块的八倍。</p>
<h2 id="低功耗蓝牙模块（BLE）"><a href="#低功耗蓝牙模块（BLE）" class="headerlink" title="低功耗蓝牙模块（BLE）"></a>低功耗蓝牙模块（BLE）</h2><blockquote>
<p>指支持蓝牙协议4.0或更高的模块，也称为BLE模块（Bluetooth Low Energy Module）,最大的特点是成功和功耗的降低。</p>
</blockquote>
<p>蓝牙低功耗技术采用可变连接时间间隔，这个间隔根据具体应用可以设置为几毫秒到几秒不等。</p>
<p>另外，因为BLE技术采用非常快速的连接方式，因此可以处于“非连接”状态（节省能源），此时链路两端相互间仅能知晓对方，必要时可以才开启链路，然后在尽可能短的时间内关闭链路。</p>
<h2 id="其他分类"><a href="#其他分类" class="headerlink" title="其他分类"></a>其他分类</h2><p>按用途来分：蓝牙模块有<strong>数据</strong>蓝牙模块，<strong>语音</strong>蓝牙模块，<strong>串口</strong>蓝牙模块和<strong>车载</strong>蓝牙模块</p>
<p>按芯片设计来分：蓝牙模块有flash版本和ROM版本。前者一般是BGA封装（球栅阵列封装），外置flash；后者一般是LCC封装（表面贴装型封装），外接EEPROM。</p>
<h1 id="BLE的两种模式"><a href="#BLE的两种模式" class="headerlink" title="BLE的两种模式"></a>BLE的两种模式</h1><ol>
<li>客户端 Client</li>
</ol>
<p>请求数据服务</p>
<p><strong>客户端</strong>可以主动搜索并连接附近的服务端</p>
<p>客户端类似蹭网的</p>
<ol start="2">
<li>服务端Server</li>
</ol>
<p>提供数据服务</p>
<p><strong>服务端</strong>不需要进行主动设置，只要开启广播就可以让附近的客户端搜索到，并提供连接</p>
<p>服务端类似被蹭网的wifi</p>
<p>如果想要让ESP处于别人随时可以搜索连接的情况要配置为服务端；如果想让ESP通过扫描连接周围可连接的蓝牙设备，需要把它设置成客户端，<strong>正好和WiFi模式的设定相反</strong></p>
<p>Server通过<strong>characteristic</strong>对数据进行封装，多个characteristic组成一个Service——Server是一个基本的BLE应用，如果某个<em>Service</em>是一个蓝牙联盟定义的标准服务，也可以称其为<em>profile</em></p>
<p>要具体了解这些内容需要先了解属性协议层ATT</p>
<h2 id="ATT简述"><a href="#ATT简述" class="headerlink" title="ATT简述"></a>ATT简述</h2><p><img src="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A03%E3%80%90%E7%BB%8F%E5%85%B8%E8%93%9D%E7%89%99%E4%B8%8EBLE%E3%80%91/653161-20191204145156859-489087209.png" alt="https://img2018.cnblogs.com/blog/653161/201912/653161-20191204145156859-489087209.png"></p>
<p>属性协议层ATT（Attribute Protocol）是GATT和GAP的基础，它定义了BLE协议栈上层的数据结构和组织方式；在层内，它定义了属性（Attribute）的内容，规定了访问属性的方法和权限</p>
<p>属性是一个数据结构，<strong>它包括了数据类型和数据值，可以像C语言的结构体那样构造</strong></p>
<p>属性包括三种类型：<strong>服务项</strong>、<strong>特征值</strong>和<strong>描述符</strong>，三者呈包含关系：服务项包含一个或多个特征值，特征值包含一个或多个描述符，多个服务项组织在一起，构成<strong>属性规范（Attribute Profile）</strong></p>
<h3 id="属性的种类和分组"><a href="#属性的种类和分组" class="headerlink" title="属性的种类和分组"></a>属性的种类和分组</h3><p>属性大致可以分为三种类型：<strong>服务项Profile</strong>、<strong>特征值Characteristic</strong>和<strong>描述符Descriptor</strong></p>
<p>最顶级为Profile, 下面是多个服务项(Service), 服务项下面是多个特征值(Characteristic), 特征值下面是多个描述符(Descriptor)</p>
<p>每个设备都包含以下必要的特征值和服务项：</p>
<p>PROFILE</p>
<ul>
<li>Generic Access Service（Primary Service）<ul>
<li>Device Name（Characteristic）</li>
<li>Appearance（Characteristic）</li>
</ul>
</li>
<li>Generic Attribute Service（Primary Service）<ul>
<li>Service Changed（Characteristic）<ul>
<li>CCCD（Descriptor）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="服务项Service"><a href="#服务项Service" class="headerlink" title="服务项Service"></a>服务项Service</h3><p>服务项这种类型本身并不包含数据，仅仅相当于是一个<strong>容器</strong>，用来<strong>容纳特征值</strong></p>
<h3 id="特征值characteristic"><a href="#特征值characteristic" class="headerlink" title="特征值characteristic"></a>特征值characteristic</h3><p>特征值用于<strong>保存用户数据</strong>，但它也有自己的UUID——可以把它看作一个变量，变量里存着数据（用户数据），也有自己的地址信息（UUID）</p>
<p>使用特征值时，也要遵循“先声明再赋值”的步骤——先声明特征值自身，再声明它的项</p>
<p>一个characteristic包含三种条目：</p>
<ol>
<li>characteristic声明：每个characteristic的分界符，解析时一旦遇到一个声明，就可以认为接下来又是一个新的characteristic；声明还包含了接下来characteristic值的读写属性等</li>
<li>characteristic值：数据的值</li>
<li>characteristic描述符：数据的额外信息</li>
</ol>
<p>一般BLE的属性体系在系统中以GattDB表示，即<strong>属性数据库</strong>，gattDB是BLE协议栈在内存中开辟的一段专有区域，会在特定的时候写入Flash进行保存，并在启动时读取出来回写到内存中去，但<strong>并非所有的BLE数据通信是操作gattDB</strong></p>
<p>characteristic用<strong>Attribute</strong>数据结构来实现</p>
<h3 id="属性Attribute的数据结构"><a href="#属性Attribute的数据结构" class="headerlink" title="属性Attribute的数据结构"></a>属性Attribute的数据结构</h3><p>Attribute由四部分组成：</p>
<ol>
<li><p>属性句柄Attribute handle：可以视为<strong>指向属性实体的指针</strong>，对端设备通过属性句柄来访问某个属性，大小2字节，起始于0x0001，系统初始化时，各属性的句柄逐步+1，但最大不超过0xFFFF</p>
</li>
<li><p>属性类型Attribute type：用以区分当前属性是服务项或是特征值等，用通用唯一识别码（<strong>UUID</strong>）标识的16字节十六进制字符串（形如f6257d37-34e5-41dd-8f40-e308210498b4，从网上抄来的示例，如有雷同那就是雷同）表示。一个合法的UUID，一定是随机的、全球唯一的，不应该出现两个相同的UUID。属性类型分类如下：</p>
<ul>
<li>首要服务项Primary Service</li>
<li>次要服务项Secondary Service</li>
<li>包含服务项Include</li>
<li>特征值Characteristic</li>
</ul>
<p>他们与UUID的映射关系如下：</p>
<ul>
<li>0x1800 – 0x26FF ：服务项类型</li>
<li>0x2700 – 0x27FF ：单位</li>
<li>0x2800 – 0x28FF ：属性类型</li>
<li>0x2900 – 0x29FF ：描述符类型</li>
<li>0x2A00 – 0x7FFF ：特征值类型</li>
</ul>
<p>为了减少传输的数据量，BLE协议做了一个转换约定，给定一个固定的16字节模板，只设置2个字节为变化量，其他为常量，2字节的UUID在系统内部会被替换，进而转换成标准的16字节UUID；反之，如果一个特征值的UUID是16字节的，在系统内部它的属性类型也可能写成第3、4字节组成的双字节</p>
<p>示例如下：</p>
<p>UUID模板为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000XXXX-0000-1000-8000-00805F9B34FB</span><br></pre></td></tr></table></figure>

<p>其中从左数第3、4个字节“XXXX”就是变化位，其他为固定位。如：UUID=0x2A00在系统内部会转换成00002A00-0000-1000-8000-00805F9B34FB。</p>
</li>
<li><p>属性值Attribute value：真正的数据值，大小为0-512字节。如果该属性是服务项类型或者是特征值声明类型，那么它的属性值就是UUID等信息；如果是普通的特征值，则属性值是用户的数据，属性值需要预留空间以保存用户数据，<strong>可以将属性值的预留空间看做I2C的数据空间，操作特征值里的用户数据，就是对那块内存空间进行读写</strong>，==所以启用蓝牙后会占用额外的内存==</p>
</li>
<li><p>属性权限Attribute permissions：Attribute的权限属性，主要有四种：</p>
<ul>
<li>访问权限（Access Permission）：只读或只写或读写</li>
<li>加密权限（Encryption Permission）：加密或不加密</li>
<li>认证权限（Authentication Permission）：需要认证或无需认证。指相互确认对方身份，BLE中所说的“认证”过程就是设备配对</li>
<li>授权权限（Authorization Permission）：需要授权或无需授权。指对授信设备开放权利</li>
</ul>
<p>授权的管控等级要高于认证，认证的设备未必被授权，授权的设备一定是认证的——<strong>认证是授权的充分不必要条件</strong>。认证是设备配对，两边都符合协议规定就行，但是授权取决于Server设备对Client设备的主动许可。</p>
<p>一个没有经过认证的设备，被称为<strong>未知设备（Unknown Device）</strong>；经过了认证，该设备会在绑定信息中被标记为Untrusted，被称为<strong>不可信设备（Untrusted Device）</strong>；经过了认证，并且在绑定信息中被标记为Trusted的设备被称为<strong>可信设备（Trusted Device）</strong></p>
<p>具体的权限示例如下所示：</p>
<ul>
<li>Open（随意读写）</li>
<li>No Access（禁止读写）</li>
<li>Authentication（需要配对才能读写，分成很多子类型用于适配配对的类型）</li>
<li>Authorization（允许应用在回调函数中读写）</li>
<li>Signed（签名后才能随意读写）</li>
</ul>
</li>
</ol>
<h3 id="属性协议ATT-PDU"><a href="#属性协议ATT-PDU" class="headerlink" title="属性协议ATT PDU"></a>属性协议ATT PDU</h3><p>拥有一组属性的设备称为服务端（Server）；读写该属性值的设备称为客户端（Client）</p>
<p>Client和Server之间通过<strong>ATT PDU</strong>通信</p>
<p>属性协议ATT PDU共有6种，如下表所示：</p>
<table>
<thead>
<tr>
<th>ATT PDU种类</th>
<th>发送方向</th>
<th>触发响应</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Command</td>
<td>Client -&gt; Server</td>
<td>–</td>
<td>客户端发送Command，服务器无需任何返回</td>
</tr>
<tr>
<td>Request</td>
<td>Client -&gt; Server</td>
<td>Response</td>
<td>客户端发送Request，服务器需要返回一个Response，表明服务器收到</td>
</tr>
<tr>
<td>Response</td>
<td>Server -&gt; Client</td>
<td>–</td>
<td></td>
</tr>
<tr>
<td>Notification</td>
<td>Server -&gt; Client</td>
<td>–</td>
<td>服务器发送Notification，户端无需任何返回</td>
</tr>
<tr>
<td>Indication</td>
<td>Server -&gt; Client</td>
<td>Confirmation</td>
<td>服务器发送Indication，客户端需要返回一个Confirmation，表明客户端收到</td>
</tr>
<tr>
<td>Confirmation</td>
<td>Client -&gt; Server</td>
<td>–</td>
<td></td>
</tr>
</tbody></table>
<p>BLE下，所有命令都是“必达”的，每个命令发送完毕后，发送者会等待ACK信息（类似I2C），如果收到了ACK包，发起方认为命令完成；否则发起方会一直重传该命令直到超时导致BLE连接断开（类似CAN的出错重发机制），可以说<strong>只要数据包放到了协议栈射频FIFO中，蓝牙协议栈就能保证该数据包“必达”对方</strong>，但是没有回复相对有回复就是“不太可靠”，这时候就需要特殊的“有回复属性”</p>
<h3 id="Request后缀"><a href="#Request后缀" class="headerlink" title="Request后缀"></a>Request后缀</h3><p>特别地，如果一个命令需要response，那么可以在相应命令后面加上request后缀，这个response包<strong>在应用层有回调事件</strong>，可以用于触发特殊的功能，这是默认的协议ACK恢复不具有的，采用request/response方式，应用层可以按顺序地发送一些数据包；如果一个命令只需要ACK而不需要response，那么它的后面就不会带request</p>
<p>然而Request/response会大大降低通信的吞吐率，因为request/response必须在不同的连接间隔中出现，这就导致两个连接间隔最多只能发一个数据包，而不带request后缀的ATT命令就没有这个问题——一般情况下，在同一个连接间隔中可以同时发多个数据包，这样将大大提高数据的吞吐率</p>
<p>常用的带request命令：所有read命令，writerequest，indication等</p>
<p>常用的不带request命令：write command，notification等</p>
<h2 id="通用属性协议GATT简述"><a href="#通用属性协议GATT简述" class="headerlink" title="通用属性协议GATT简述"></a>通用属性协议GATT简述</h2><p>GATT(Generic Attribute Profile)，描述了一种使用ATT的服务框架。该框架定义了服务(Server)和服务属性(characteristic)的过程(Procedure)及格式，负责处理具体数据段通过蓝牙连接的发送和接收</p>
<p>**==现在的BLE大多建立在GATT协议之上==**，GATT建立在ATT和L2CAP之上，GATT需要使用通用访问协议GAP来确定设备的连接</p>
<p><img src="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A03%E3%80%90%E7%BB%8F%E5%85%B8%E8%93%9D%E7%89%99%E4%B8%8EBLE%E3%80%91/653161-20191204145156859-489087209.png" alt="https://img2018.cnblogs.com/blog/653161/201912/653161-20191204145156859-489087209.png"></p>
<h3 id="通用访问协议GAP"><a href="#通用访问协议GAP" class="headerlink" title="通用访问协议GAP"></a>通用访问协议GAP</h3><p>GAP 使设备被其他设备可见，并决定了当前设备是否可以或者怎样与合同设备进行交互</p>
<p>GAP中，设备被分为<strong>外围设备Peripheral</strong>和<strong>中心设备Central</strong></p>
<p>外围设备：性能相对较弱、功耗相对低的设备，他们通常被连接到更加强大的中心设备</p>
<p>中心设备：性能相对较强、功耗较高的设备</p>
<h4 id="GAP广播"><a href="#GAP广播" class="headerlink" title="GAP广播"></a>GAP广播</h4><p>GAP 中外围设备不停向外广播以让中心设备知道它的存在。通过两种方式向外广播数据： </p>
<p>广播数据（Advertising Data Payload）：<em>必须的</em>，外设需要以此来和中心设备取得连接</p>
<p>扫描回复（Scan Response Data Payload）：<em>可选的</em>，中心设备可以向外围设备请求扫描回复，向其提供一些设备的额外信息</p>
<p>外围设备会设定一个广播建个，每个间隔中，它会重新发送自己的广播数据，<strong>广播间隔越长约省电，但同时更不容易被扫描到</strong></p>
<p>基于GATT广播的BLE连接只能是<strong>一个外围设备连接一个中心设备</strong>，可以理解成一个蓝牙耳机只能连接一台手机，不能同时连接两台手机</p>
<h4 id="GATT协议"><a href="#GATT协议" class="headerlink" title="GATT协议"></a>GATT协议</h4><p>GATT协议建立在ATT协议的基础上。将ATT协议中的Service、Characteristic 及对应数据都保存在一个查找表中，查找表使用16位的ID作为索引。建立GATT连接前必须先经过GAP协议</p>
<p><strong>GATT连接是独占的</strong>，也就是说同一个BLE外设（外部设备）同时只能被一个中心设备连接，一旦外设被连接，它就会停止GAP广播，对其它设备不可见；当设备断开时它又开始广播。</p>
<p>如果中心设备和外设<strong>需要双向通信，唯一的方式就是建立GATT连接</strong>，GAP通信是单向的，只能让中心设备向外设发送信息</p>
<p>GATT通信双方是C/S关系，外设作为GATT的Server，维持ATT查找表、Service、Characteristic定义；中心设备作为GATT的Client，向Server发起请求，所有通信事件都由中心设备Client发起，从Server接收响应。一旦连接建立，外设将会给中心设备建议一个<strong>连接间隔</strong>，中心设备<em>可以选择</em>在每个连接间隔尝试重新连接，检查是否有新数据，不过这个间隔只是建议，中心设备可以不严格按照这个间隔执行请求。</p>
<h4 id="GATT结构"><a href="#GATT结构" class="headerlink" title="GATT结构"></a>GATT结构</h4><p>GATT结构建立在ATT的属性Attribute数据结构之上（其实和ATT的那些东西一模一样）</p>
<p><strong>Attribute结构体组成种类不同的Characteristic，多个Characteristic被封装在Servce容器中，Characteristic和Service容器都有着自己的UUID（有官方认证的16位UUID和自定义的128位UUID），各种常用的Service集合成Profile</strong></p>
<p>BLE外设的通信主要通过Characteristic，通过在Characteristic中读写数据就实现了双向通信，也可以通过实现类似串口的Service来配置TxCharacteristic和RxCharacteristic，这些都是具体项目的选择了</p>
<h1 id="BLE从初始化到建立连接的过程简述"><a href="#BLE从初始化到建立连接的过程简述" class="headerlink" title="BLE从初始化到建立连接的过程简述"></a>BLE从初始化到建立连接的过程简述</h1><ol>
<li>外围设备开始广播，发送完一个广播包后T_IFS，开启射频Rx窗口接收来自中心设备的数据包</li>
<li>中心设备扫描到广播，在收取此广播T_IFS后如果开启了中心设备的扫描回复，中心设备将向外设发送回复</li>
<li>外设收取到中心设备的回复，做好接收准备，并返回ACK包</li>
<li>如果ACK包未被中心设备接收到，中心设备将一直发送回复直到超时，此期间内只要外设返回过一次ACK包就算连接成功</li>
<li>开始建立通信，后续中心设备将以收取到外设广播的时间为原点，以Connection Interval为周期向外设发送数据包，数据包将具有两个作用：<strong>同步两设备时钟</strong>和<strong>建立主从模式通信</strong></li>
</ol>
<p>外设每收到中心设备的一个包，就会把自己的时序原点重新设置，以和中心设备同步（Service向Client同步）</p>
<p>BLE通信在建立成功后变为主从模式，<strong>中心设备Central变为Master，外设Peripheral变为Slave</strong>，Slave只能在Master向它发送了一个包以后才能在规定的时间内把自己的数据回传给Master</p>
<ol start="6">
<li>连接建立成功</li>
<li>外设自动停止广播，其他设备无法再查找到该外设</li>
<li>按照以下时序进行通信，在中心设备发送包的间隔内，外设可以发送多个包</li>
</ol>
<p><img src="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A03%E3%80%90%E7%BB%8F%E5%85%B8%E8%93%9D%E7%89%99%E4%B8%8EBLE%E3%80%91/20190726193026779.png" alt="在这里插入图片描述"></p>
<ol start="8">
<li>需要连接断开时只需要中心设备停止连接（停止发送包）即可</li>
<li>中心设备可以将外设的addr写入Flash或SRAM等存储器件，保持监听此addr，当再次收到外设广播时就可以建立通信。BLE Server设备为了省电，当一段时间内没有数据要发送时，可以不再发送包，双方就会因为连接超时（connection timeout）断开，这时需要中心设备启动监听，这样，当BLE Server设备需要发送数据时，就可以再次连接</li>
</ol>
<h1 id="ESP的蓝牙外设配置"><a href="#ESP的蓝牙外设配置" class="headerlink" title="ESP的蓝牙外设配置"></a>ESP的蓝牙外设配置</h1><h2 id="蓝牙配置相关库函数"><a href="#蓝牙配置相关库函数" class="headerlink" title="蓝牙配置相关库函数"></a>蓝牙配置相关库函数</h2><h3 id="相关头文件及其作用"><a href="#相关头文件及其作用" class="headerlink" title="相关头文件及其作用"></a>相关头文件及其作用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;bt.h&quot;</span><span class="comment">//蓝牙控制器和VHCI设置头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_gap_ble_api.h&quot;</span><span class="comment">//GAP设置头文件，广播和连接相关参数配置</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_gatts_api.h&quot;</span><span class="comment">//GATT配置头文件，创建Service和Characteristic</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_bt_main.h&quot;</span><span class="comment">//蓝牙栈空间的初始化头文件</span></span></span><br></pre></td></tr></table></figure>

<h3 id="蓝牙控制器"><a href="#蓝牙控制器" class="headerlink" title="蓝牙控制器"></a>蓝牙控制器</h3><p>使用esp_bt_controller_init()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">esp_bt_controller_init(<span class="keyword">esp_bt_controller_config_t</span> *cfg);<span class="comment">//esp_bt_controller_config_t是蓝牙控制器配置结构体</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">esp_bt_controller_config_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> controller_task_stack_size;<span class="comment">//蓝牙控制器栈大小</span></span><br><span class="line">    <span class="keyword">uint8_t</span> controller_task_prio;<span class="comment">//蓝牙控制器任务优先级</span></span><br><span class="line">    <span class="keyword">uint8_t</span> hci_uart_no;<span class="comment">//使用哪个UART作为HCI的IO，仅能选择UART1或UART2串口</span></span><br><span class="line">	<span class="keyword">uint32_t</span> hci_uart_baudrate;<span class="comment">//HCI串口波特率</span></span><br><span class="line">    <span class="keyword">uint8_t</span> scan_duplicate_mode;<span class="comment">//重复扫描模式</span></span><br><span class="line">    <span class="keyword">uint8_t</span> scan_duplicate_type;<span class="comment">//重复扫描类型</span></span><br><span class="line">    <span class="keyword">uint16_t</span> normal_adv_size;<span class="comment">//普通广播报文大小</span></span><br><span class="line">    <span class="keyword">uint16_t</span> mesh_adv_size;<span class="comment">//mesh广播报文大小</span></span><br><span class="line">    <span class="keyword">uint16_t</span> send_adv_reserved_size;<span class="comment">//蓝牙控制器最小的内存大小（保留出发送报文所需的内存大小）</span></span><br><span class="line">    <span class="keyword">uint32_t</span> controller_debug_flag;<span class="comment">//蓝牙控制器debug log的属性</span></span><br><span class="line">    <span class="keyword">uint8_t</span> mode;<span class="comment">//BR/EDR/BLE/Dual模式选择</span></span><br><span class="line">	<span class="keyword">uint8_t</span> ble_max_conn;<span class="comment">//BLE模式最多连接个数</span></span><br><span class="line">    <span class="keyword">uint8_t</span> bt_max_acl_conn;<span class="comment">//BR或EDR最大的ACL连接个数</span></span><br><span class="line">    <span class="keyword">uint8_t</span> bt_sco_datapath;<span class="comment">//SCO数据路径 用于HCI或PCM模块</span></span><br><span class="line">	<span class="keyword">bool</span> auto_latency;<span class="comment">//BLE自动延迟，用于降低传统蓝牙的功耗</span></span><br><span class="line">    <span class="keyword">bool</span> bt_legacy_auth_vs_evt;<span class="comment">//BR/EDR传统的授权完毕事件，用于防止BIAS攻击</span></span><br><span class="line">    <span class="keyword">uint8_t</span> bt_max_sync_conn;<span class="comment">//BR/EDR最多的ACL连接数目，也可以在menuconfig中配配置</span></span><br><span class="line">    <span class="keyword">uint8_t</span> ble_sca;<span class="comment">//BLE晶振准确度指数</span></span><br><span class="line">    <span class="keyword">uint8_t</span> pcm_role;<span class="comment">//PCM角色，选择master或slave</span></span><br><span class="line">    <span class="keyword">uint8_t</span> pcm_polar;<span class="comment">//PCM触发极性，选择下降沿或上升沿</span></span><br><span class="line">    <span class="keyword">uint32_t</span> magic;<span class="comment">//神奇数字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化蓝牙控制器，==此函数只能被调用一次，且必须在其他蓝牙功能被调用之前调用==</p>
<p>使用esp_bt_controller_deinit()来取消初始化，用于关闭蓝牙并清除其占用的内存，还会将蓝牙任务删除</p>
<p>下面是蓝牙控制器的常用API</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">esp_bt_controller_enable(<span class="keyword">esp_bt_mode_t</span> mode);<span class="comment">//使能蓝牙控制器，mode是蓝牙模式，如果想要动态改变蓝牙模式不能直接调用该函数，应该先用下面的disable关闭蓝牙再使用该API来改变蓝牙模式</span></span><br><span class="line">esp_bt_controller_disable(<span class="keyword">void</span>);<span class="comment">//关闭蓝牙控制器</span></span><br><span class="line">sp_bt_controller_get_status(<span class="keyword">void</span>);<span class="comment">//获取蓝牙控制器状态</span></span><br><span class="line">esp_bt_get_mac(<span class="keyword">void</span>);<span class="comment">//获取蓝牙MAC地址</span></span><br><span class="line"></span><br><span class="line">esp_bt_controller_mem_release(<span class="keyword">esp_bt_mode_t</span> mode);<span class="comment">//释放蓝牙控制器的所有内存，包括BSS、数据和其他蓝牙使用的堆栈空间</span></span><br><span class="line"><span class="comment">//这个API仅仅应该再esp_bt_controller_init()或after esp_bt_controller_deinit()之前被调用</span></span><br><span class="line">esp_bt_mem_release(<span class="keyword">esp_bt_mode_t</span> mode);</span><br><span class="line"><span class="comment">//释放蓝牙控制器和蓝牙数据的所有内存，比esp_bt_controller_mem_release()更彻底</span></span><br><span class="line">esp_bt_sleep_enable(<span class="keyword">void</span>);<span class="comment">//让蓝牙进入睡眠模式，这个函数应该在esp_bt_controller_enable()被调用之后再调用</span></span><br></pre></td></tr></table></figure>

<p>特别地，官方文档中给出了一套在线升级蓝牙设备软件时的关闭流程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">esp_bluedroid_disable();</span><br><span class="line">esp_bluedroid_deinit();</span><br><span class="line">esp_bt_controller_disable();</span><br><span class="line">esp_bt_controller_deinit();</span><br><span class="line">esp_bt_mem_release(ESP_BT_MODE_BTDM);</span><br></pre></td></tr></table></figure>

<h3 id="经典蓝牙"><a href="#经典蓝牙" class="headerlink" title="经典蓝牙"></a>经典蓝牙</h3><p>用于蓝牙运行的API如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">esp_bluedroid_get_status(<span class="keyword">void</span>);<span class="comment">//获取蓝牙当前状态</span></span><br><span class="line"><span class="comment">//可能的状态如下所示</span></span><br><span class="line">ESP_BLUEDROID_STATUS_UNINITIALIZED==<span class="number">0</span><span class="comment">//未初始化</span></span><br><span class="line">ESP_BLUEDROID_STATUS_INITIALIZED<span class="comment">//已被初始化但是未开启</span></span><br><span class="line">ESP_BLUEDROID_STATUS_ENABLED<span class="comment">//初始化并开启</span></span><br><span class="line">    </span><br><span class="line">esp_bluedroid_enable(<span class="keyword">void</span>);<span class="comment">//使能蓝牙</span></span><br><span class="line">esp_bluedroid_disable(<span class="keyword">void</span>);<span class="comment">//关闭蓝牙</span></span><br><span class="line">esp_bluedroid_init(<span class="keyword">void</span>);<span class="comment">//初始化蓝牙并分配系统资源，它应该被第一个调用</span></span><br><span class="line">esp_bluedroid_deinit(<span class="keyword">void</span>);<span class="comment">//取消初始化蓝牙并将系统资源释放，用于蓝牙结束工作后的收尾</span></span><br></pre></td></tr></table></figure>

<p>用于设备蓝牙配置的API如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">esp_bt_dev_get_address(<span class="keyword">void</span>);<span class="comment">//获取当前设备蓝牙地址</span></span><br><span class="line">esp_bt_dev_set_device_name(<span class="keyword">const</span> <span class="keyword">char</span> *name);<span class="comment">//设置设备名</span></span><br></pre></td></tr></table></figure>

<p>这些函数都应该在蓝牙启用后被调用</p>
<h2 id="BLE-GAP相关库函数"><a href="#BLE-GAP相关库函数" class="headerlink" title="BLE-GAP相关库函数"></a>BLE-GAP相关库函数</h2><h3 id="外围设备库函数"><a href="#外围设备库函数" class="headerlink" title="外围设备库函数"></a>外围设备库函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">esp_ble_gap_start_advertising(<span class="keyword">esp_ble_adv_params_t</span> *adv_params);<span class="comment">//开始广播</span></span><br><span class="line">esp_ble_gap_stop_advertising(<span class="keyword">void</span>);<span class="comment">//停止广播</span></span><br><span class="line"></span><br><span class="line">esp_ble_gap_config_adv_data(<span class="keyword">esp_ble_adv_data_t</span> *adv_data);<span class="comment">//广播数据参数设置</span></span><br><span class="line"><span class="comment">//adv_data数据结构如下</span></span><br><span class="line"><span class="keyword">bool</span> set_scan_rsp<span class="comment">//设置是否需要扫描response</span></span><br><span class="line"><span class="keyword">bool</span> include_name<span class="comment">//广播内容是否包括设备名</span></span><br><span class="line"><span class="keyword">bool</span> include_txpower<span class="comment">//广播数据是否包括发射功率</span></span><br><span class="line"><span class="keyword">int</span> min_interval<span class="comment">//最小广播时间间隔</span></span><br><span class="line"><span class="comment">//计算公式：connIntervalmin = Conn_Interval_Min * 1.25 ms</span></span><br><span class="line"><span class="comment">//Conn_Interval_Min在0x0006到0x0C80之间，0xFFFF就是没有特定的最小值</span></span><br><span class="line"><span class="keyword">int</span> max_interval<span class="comment">//最大广播间隔</span></span><br><span class="line"><span class="comment">//计算公式：connIntervalmax = Conn_Interval_Max * 1.25 ms</span></span><br><span class="line"><span class="comment">//Conn_Interval_Max在0x0006到0x0C80之间，Conn_Interval_Max应大于等于Conn_Interval_Min</span></span><br><span class="line"><span class="comment">//0xFFFF代表没有特定的最大值</span></span><br><span class="line"><span class="keyword">int</span> appearance<span class="comment">//设备外形（External appearance）</span></span><br><span class="line"><span class="keyword">uint16_t</span> manufacturer_len<span class="comment">//生产商数据长度</span></span><br><span class="line"><span class="keyword">uint8_t</span> *p_manufacturer_data<span class="comment">//生产商数据指针</span></span><br><span class="line"><span class="keyword">uint16_t</span> service_data_len<span class="comment">//Service数据长度</span></span><br><span class="line"><span class="keyword">uint8_t</span> *p_service_data<span class="comment">//Service数据指针</span></span><br><span class="line"><span class="keyword">uint16_t</span> service_uuid_len<span class="comment">//Service的UUID长度</span></span><br><span class="line"><span class="keyword">uint8_t</span> *p_service_uuid<span class="comment">//Service的UUID数组指针</span></span><br><span class="line"><span class="keyword">uint8_t</span> flag<span class="comment">//广播属性（flag）</span></span><br><span class="line">    </span><br><span class="line">esp_ble_gap_config_adv_data_raw(<span class="keyword">uint8_t</span> *raw_data, <span class="keyword">uint32_t</span> raw_data_len);<span class="comment">//设置空的广播数据包，用户需要自行设置包的内容</span></span><br></pre></td></tr></table></figure>

<h3 id="中心设备库函数"><a href="#中心设备库函数" class="headerlink" title="中心设备库函数"></a>中心设备库函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">esp_ble_gap_start_scanning(<span class="keyword">uint32_t</span> duration);<span class="comment">//使用该函数让设备扫描附近正在广播的外设，duration为扫描间隔</span></span><br><span class="line">esp_ble_gap_stop_scanning(<span class="keyword">void</span>);<span class="comment">//停止扫描</span></span><br><span class="line"></span><br><span class="line">esp_ble_gap_set_scan_params(<span class="keyword">esp_ble_scan_params_t</span> *scan_params);<span class="comment">//设置扫描参数</span></span><br><span class="line">esp_ble_gap_register_callback(<span class="keyword">esp_gap_ble_cb_t</span> callback)<span class="comment">//间隔回调函数</span></span><br><span class="line">    </span><br><span class="line">esp_ble_gap_set_pkt_data_len(<span class="keyword">esp_bd_addr_t</span> remote_device, <span class="keyword">uint16_t</span> tx_data_length);<span class="comment">//设置最大数据包大小</span></span><br><span class="line"></span><br><span class="line">esp_ble_gap_set_prefer_conn_params(<span class="keyword">esp_bd_addr_t</span> bd_addr, <span class="keyword">uint16_t</span> min_conn_int, <span class="keyword">uint16_t</span> max_conn_int, <span class="keyword">uint16_t</span> slave_latency, <span class="keyword">uint16_t</span> supervision_tout);<span class="comment">//设置当默认连接参数无法使用时的优先连接参数，这个库函数只能用在中心设备master上</span></span><br><span class="line"></span><br><span class="line">esp_ble_gap_config_scan_rsp_data_raw(<span class="keyword">uint8_t</span> *raw_data, <span class="keyword">uint32_t</span> raw_data_len);<span class="comment">//设置空的response数据包，用户需要自行设置数据</span></span><br><span class="line"></span><br><span class="line">esp_ble_gap_read_rssi(<span class="keyword">esp_bd_addr_t</span> remote_addr);<span class="comment">//读取远程设备的RSSI，结果会在间隔回调函数中随ESP_GAP_BLE_READ_RSSI_COMPLETE_EVT事件返回</span></span><br></pre></td></tr></table></figure>

<h3 id="连接配置库函数"><a href="#连接配置库函数" class="headerlink" title="连接配置库函数"></a>连接配置库函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">esp_ble_gap_update_conn_params(<span class="keyword">esp_ble_conn_update_params_t</span> *params);<span class="comment">//在连接建立后更新连接参数</span></span><br><span class="line">esp_ble_gap_clear_rand_addr(<span class="keyword">void</span>);<span class="comment">//清空应用的随机地址</span></span><br><span class="line"></span><br><span class="line">esp_ble_gap_update_whitelist(<span class="keyword">bool</span> add_remove, <span class="keyword">esp_bd_addr_t</span> remote_bda, <span class="keyword">esp_ble_wl_addr_type_t</span> wl_addr_type);<span class="comment">//新建或移除白名单中的设备</span></span><br><span class="line">esp_ble_gap_get_whitelist_size(<span class="keyword">uint16_t</span> *length);<span class="comment">//获取白名单的大小</span></span><br><span class="line"></span><br><span class="line">esp_ble_gap_set_device_name(<span class="keyword">const</span> <span class="keyword">char</span> *name);<span class="comment">//设置本机设备名</span></span><br><span class="line">esp_ble_gap_get_local_used_addr(<span class="keyword">esp_bd_addr_t</span> local_used_addr, <span class="keyword">uint8_t</span> *addr_type);<span class="comment">//获取本机设备地址</span></span><br></pre></td></tr></table></figure>

<h2 id="GATT-Server的配置"><a href="#GATT-Server的配置" class="headerlink" title="GATT Server的配置"></a>GATT Server的配置</h2><h3 id="Server-Master"><a href="#Server-Master" class="headerlink" title="Server-Master"></a>Server-Master</h3><h4 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">esp_err_t</span> ret;<span class="comment">//用于debug</span></span><br><span class="line"><span class="keyword">esp_bt_controller_config_t</span> bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();<span class="comment">//设置蓝牙为默认参数</span></span><br><span class="line"></span><br><span class="line">ret = nvs_flash_init();<span class="comment">//初始化NVS</span></span><br><span class="line"><span class="keyword">if</span> (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND)</span><br><span class="line">&#123;</span><br><span class="line">	ESP_ERROR_CHECK(nvs_flash_erase());</span><br><span class="line">	ret = nvs_flash_init();</span><br><span class="line">&#125;</span><br><span class="line">ESP_ERROR_CHECK(ret);</span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;%s init NVS finished\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">ESP_ERROR_CHECK(esp_bt_controller_mem_release(ESP_BT_MODE_BLE));<span class="comment">//释放蓝牙所需空间</span></span><br><span class="line"></span><br><span class="line">ret = esp_bt_controller_init(&amp;bt_cfg);<span class="comment">//初始化蓝牙控制器</span></span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line">	ESP_LOGE(TAG, <span class="string">&quot;%s enable controller failed: %s\n&quot;</span>, __func__, esp_err_to_name(ret));</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ret = esp_bt_controller_enable(ESP_BT_MODE_BLE);<span class="comment">//使能蓝牙控制器</span></span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line">	ESP_LOGE(TAG, <span class="string">&quot;%s enable controller failed: %s\n&quot;</span>, __func__, esp_err_to_name(ret));</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ret = esp_bluedroid_init();<span class="comment">//初始化蓝牙栈bluedroid stack</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">蓝牙栈bluedroid stack包括了BT和BLE使用的基本的define和API</span></span><br><span class="line"><span class="comment">初始化蓝牙栈以后并不能直接使用蓝牙功能，</span></span><br><span class="line"><span class="comment">还需要用FSM管理蓝牙连接情况</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line">	ESP_LOGE(TAG, <span class="string">&quot;%s init bluetooth failed: %s\n&quot;</span>, __func__, esp_err_to_name(ret));</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ret = esp_bluedroid_enable();<span class="comment">//使能蓝牙栈</span></span><br><span class="line"><span class="keyword">if</span> (ret) </span><br><span class="line">&#123;</span><br><span class="line">	ESP_LOGE(TAG, <span class="string">&quot;%s enable bluetooth failed: %s\n&quot;</span>, __func__, esp_err_to_name(ret));</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;%s init bluetooth finished\n&quot;</span>, __func__);</span><br><span class="line"><span class="comment">//建立蓝牙的FSM</span></span><br><span class="line"><span class="comment">//这里使用回调函数来控制每个状态下的响应，需要将其在GATT和GAP层的回调函数注册</span></span><br><span class="line">ret = esp_ble_gatts_register_callback(BLE_gatts_event_handler);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line">	ESP_LOGE(TAG, <span class="string">&quot;gatts register error, error code = %x&quot;</span>, ret);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ret = esp_ble_gap_register_callback(BLE_gap_event_handler);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line">	ESP_LOGE(TAG, <span class="string">&quot;gap register error, error code = %x&quot;</span>, ret);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*BLE_gatts_event_handler和BLE_gap_event_handler处理蓝牙栈可能发生的所有情况，达到FSM的效果*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面创建了两个BLE GATT profile，相当于两个独立的应用程序</span></span><br><span class="line">ret = esp_ble_gatts_app_register(GATT_APP_A_ID);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line">	ESP_LOGE(TAG, <span class="string">&quot;gatts app register error, error code = %x&quot;</span>, ret);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ret = esp_ble_gatts_app_register(GATT_APP_B_ID);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line">	ESP_LOGE(TAG, <span class="string">&quot;gatts app register error, error code = %x&quot;</span>, ret);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有限状态机FSM（finite state machine），或者说状态机SM（state machine）是一种特殊的控制算法，能够根据<strong>控制信号</strong>按照<strong>预先设定的状态</strong>进行状态转移</p>
<p>若输出只和状态有关而与输入无关，则称为Moore状态机；若输出不仅和状态有关而且和输入有关系，则称为Mealy状态机</p>
<p>控制蓝牙的状态机一般为Moore状态机，随蓝牙所处的状态进行不同的操作（代码中通过switch语句进行控制）</p>
<p>Server的profile利用一个结构体来定义，结构体成员取决于在这个profile中执行的service和characteristic，如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gatts_profile_inst</span> &#123;</span></span><br><span class="line">    <span class="keyword">esp_gatts_cb_t</span> gatts_cb;<span class="comment">//GATT回调函数</span></span><br><span class="line">    <span class="keyword">uint16_t</span> gatts_if;<span class="comment">//GATT接口</span></span><br><span class="line">    <span class="keyword">uint16_t</span> app_id;<span class="comment">//应用的ID</span></span><br><span class="line">    <span class="keyword">uint16_t</span> conn_id;<span class="comment">//连接的ID</span></span><br><span class="line">    <span class="keyword">uint16_t</span> service_handle;<span class="comment">//Service句柄</span></span><br><span class="line">    <span class="keyword">esp_gatt_srvc_id_t</span> service_id;<span class="comment">//Service ID</span></span><br><span class="line">    <span class="keyword">uint16_t</span> char_handle;<span class="comment">//Characteristic句柄</span></span><br><span class="line">    <span class="keyword">esp_bt_uuid_t</span> char_uuid;<span class="comment">//Characteristic的UUID</span></span><br><span class="line">    <span class="keyword">esp_gatt_perm_t</span> perm;<span class="comment">//属性Attribute 授权</span></span><br><span class="line">    <span class="keyword">esp_gatt_char_prop_t</span> property;<span class="comment">//Characteristic的优先级</span></span><br><span class="line">    <span class="keyword">uint16_t</span> descr_handle;<span class="comment">//Client的Characteristic配置句柄</span></span><br><span class="line">    <span class="keyword">esp_bt_uuid_t</span> descr_uuid;<span class="comment">//Client的Characteristic UUID</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以将这个结构体进一步组合为结构体数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gatts_profile_inst</span> <span class="title">gl_profile_tab</span>[<span class="title">PROFILE_NUM</span>] =</span> &#123;</span><br><span class="line">    [PROFILE_A_APP_ID] = &#123;</span><br><span class="line">        .gatts_cb = gatts_profile_a_event_handler,</span><br><span class="line">        .gatts_if = ESP_GATT_IF_NONE,</span><br><span class="line">    [PROFILE_B_APP_ID] = &#123;</span><br><span class="line">        .gatts_cb = gatts_profile_b_event_handler,</span><br><span class="line">        .gatts_if = ESP_GATT_IF_NONE,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样使用类似<code>gl_profile_tab[i].gatts_if</code>的语句就可以访问结构体的成员，i用于指示第（i+1）个profile</p>
<p>使用上面的结构体数组来定义每个profile对应的GATT回调函数（gatts_profile_a_event_handler()、gatts_profile_b_event_handler()），就使得每个不同的profile使用不同的接口；初始化时，将gatts_if = ESP_GATT_IF_NONE，在之后通过各自的处理函数将profile连接到接口</p>
<p>最后使用esp_ble_gatts_app_register()这个API将应用的ID注册到GATT</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ret = esp_ble_gatts_app_register(GATT_APP_A_ID);<span class="comment">//run GATT app A register</span></span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line">	ESP_LOGE(TAG, <span class="string">&quot;gatts app register error, error code = %x&quot;</span>, ret);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ret = esp_ble_gatts_app_register(GATT_APP_B_ID);<span class="comment">//run GATT app B register</span></span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line">	ESP_LOGE(TAG, <span class="string">&quot;gatts app register error, error code = %x&quot;</span>, ret);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="GAP设置"><a href="#GAP设置" class="headerlink" title="GAP设置"></a>GAP设置</h4><p>使用esp_ble_adv_data_t结构体来配置GAP广播情况，并使用esp_ble_gap_config_adv_data()函数进行广播</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> set_scan_rsp;<span class="comment">//是否作为扫描的回应信号广播</span></span><br><span class="line">    <span class="keyword">bool</span> include_name;<span class="comment">//是否包括设备名</span></span><br><span class="line">    <span class="keyword">bool</span> include_txpower;<span class="comment">//是否包括信号的发射功率</span></span><br><span class="line">    <span class="keyword">int</span> min_interval;<span class="comment">//广播数据显示slave设备的连接最小时间间隔</span></span><br><span class="line">    <span class="keyword">int</span> max_interval;<span class="comment">//广播数据显示slave设备的连接最大时间间隔</span></span><br><span class="line">    <span class="keyword">int</span> appearance;<span class="comment">//设备外观（？）</span></span><br><span class="line">    <span class="keyword">uint16_t</span> manufacturer_len;<span class="comment">//附加数据长度</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *p_manufacturer_data;<span class="comment">//附加数据指针</span></span><br><span class="line">    <span class="keyword">uint16_t</span> service_data_len;<span class="comment">//Service数据长度</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *p_service_data;<span class="comment">//Service数据指针</span></span><br><span class="line">    <span class="keyword">uint16_t</span> service_uuid_len;<span class="comment">//Servic UUID长度</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *p_service_uuid;<span class="comment">//Servic UUID指针</span></span><br><span class="line">    <span class="keyword">uint8_t</span> flag;<span class="comment">//广播的发现模式，可选BLE_ADV_DATA_FLAG枚举值</span></span><br><span class="line">&#125; <span class="keyword">esp_ble_adv_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置示例</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">esp_ble_adv_data_t</span> adv_data = &#123;</span><br><span class="line">    .set_scan_rsp = <span class="literal">false</span>,</span><br><span class="line">    .include_name = <span class="literal">true</span>,</span><br><span class="line">    .include_txpower = <span class="literal">false</span>,</span><br><span class="line">    .min_interval = <span class="number">0x0006</span>, <span class="comment">//slave connection min interval, Time = min_interval * 1.25 msec=7.5ms</span></span><br><span class="line">    .max_interval = <span class="number">0x0010</span>, <span class="comment">//slave connection max interval, Time = max_interval * 1.25 msec=20ms</span></span><br><span class="line">    .appearance = <span class="number">0x00</span>,</span><br><span class="line">    .manufacturer_len = <span class="number">0</span>, <span class="comment">//TEST_MANUFACTURER_DATA_LEN</span></span><br><span class="line">    .p_manufacturer_data = <span class="literal">NULL</span>, <span class="comment">//&amp;test_manufacturer[0]</span></span><br><span class="line">    .service_data_len = <span class="number">0</span>,</span><br><span class="line">    .p_service_data = <span class="literal">NULL</span>,</span><br><span class="line">    .service_uuid_len = <span class="keyword">sizeof</span>(adv_service_uuid128),</span><br><span class="line">    .p_service_uuid = adv_service_uuid128,</span><br><span class="line">    .flag = (ESP_BLE_ADV_FLAG_GEN_DISC | ESP_BLE_ADV_FLAG_BREDR_NOT_SPT),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一个广播的有效数据是31字节，如果超过会导致超出部分被截掉</p>
<p>使用esp_ble_gap_config_adv_data_raw()和esp_ble_gap_config_scan_rsp_data_raw()函数可以广播自定义的空数据</p>
<p>广播数据设置完毕后，会自动进入ESP_GAP_BLE_ADV_DATA_SET_COMPLETE_EVT()或ESP_GAP_BLE_ADV_DATA_RAW_SET_COMPLETE_EVT状态，此时可以在gap_event_handler()中设置FSM控制程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BLE_gap_event_handler</span><span class="params">(<span class="keyword">esp_gap_ble_cb_event_t</span> event, <span class="keyword">esp_ble_gap_cb_param_t</span>* param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SET_RAW_ADV_DATA</span></span><br><span class="line">    <span class="keyword">case</span> ESP_GAP_BLE_ADV_DATA_RAW_SET_COMPLETE_EVT:</span><br><span class="line">        adv_config_done &amp;= (~adv_config_flag);</span><br><span class="line">        <span class="keyword">if</span> (adv_config_done == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            esp_ble_gap_start_advertising(&amp;adv_params);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ESP_GAP_BLE_SCAN_RSP_DATA_RAW_SET_COMPLETE_EVT:</span><br><span class="line">        adv_config_done &amp;= (~scan_rsp_config_flag);</span><br><span class="line">        <span class="keyword">if</span> (adv_config_done == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            esp_ble_gap_start_advertising(&amp;adv_params);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">case</span> ESP_GAP_BLE_ADV_DATA_SET_COMPLETE_EVT:</span><br><span class="line">        adv_config_done &amp;= (~adv_config_flag);</span><br><span class="line">        <span class="keyword">if</span> (adv_config_done == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            esp_ble_gap_start_advertising(&amp;adv_params);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ESP_GAP_BLE_SCAN_RSP_DATA_SET_COMPLETE_EVT:</span><br><span class="line">        adv_config_done &amp;= (~scan_rsp_config_flag);</span><br><span class="line">        <span class="keyword">if</span> (adv_config_done == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            esp_ble_gap_start_advertising(&amp;adv_params);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">case</span> ESP_GAP_BLE_ADV_START_COMPLETE_EVT:</span><br><span class="line">        <span class="comment">//advertising start complete event to indicate advertising start successfully or failed</span></span><br><span class="line">        <span class="keyword">if</span> (param-&gt;adv_start_cmpl.status != ESP_BT_STATUS_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGE(TAG, <span class="string">&quot;Advertising start failed\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ESP_GAP_BLE_ADV_STOP_COMPLETE_EVT:</span><br><span class="line">        <span class="keyword">if</span> (param-&gt;adv_stop_cmpl.status != ESP_BT_STATUS_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGE(TAG, <span class="string">&quot;Advertising stop failed\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGI(TAG, <span class="string">&quot;Stop adv successfully\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ESP_GAP_BLE_UPDATE_CONN_PARAMS_EVT:</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;update connection params status = %d, min_int = %d, max_int = %d,conn_int = %d,latency = %d, timeout = %d&quot;</span>,</span><br><span class="line">            param-&gt;update_conn_params.status,</span><br><span class="line">            param-&gt;update_conn_params.min_int,</span><br><span class="line">            param-&gt;update_conn_params.max_int,</span><br><span class="line">            param-&gt;update_conn_params.conn_int,</span><br><span class="line">            param-&gt;update_conn_params.latency,</span><br><span class="line">            param-&gt;update_conn_params.timeout);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要使用了esp_ble_gap_start_advertising()函数，GATT Server就会开始广播，在此之前还需要用esp_ble_adv_params_t结构体配置相关的参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//广播参数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> adv_int_min;</span><br><span class="line">	<span class="comment">//非定向和循环定向广播的最小时间间隔</span></span><br><span class="line">    <span class="comment">//间隔设置在0x0020到0x4000，默认0x0800（1.28s），实际时间=N * 0.625 ms，时间范围在20ms到10.24s</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint16_t</span> adv_int_max;</span><br><span class="line">    <span class="comment">//非定向和循环定向广播的最大时间间隔</span></span><br><span class="line">    <span class="comment">//间隔设置在0x0020到0x4000，默认0x0800（1.28s），实际时间=N * 0.625 ms，时间范围在20ms到10.24s</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">esp_ble_adv_type_t</span> adv_type;<span class="comment">//广播类型</span></span><br><span class="line">    <span class="keyword">esp_ble_addr_type_t</span> own_addr_type;<span class="comment">//拥有者的蓝牙设备地址类型</span></span><br><span class="line">    <span class="keyword">esp_bd_addr_t</span> peer_addr;<span class="comment">//附近的蓝牙设备地址</span></span><br><span class="line">    <span class="keyword">esp_ble_addr_type_t</span> peer_addr_type;<span class="comment">//附近的蓝牙设备地址类型</span></span><br><span class="line">    <span class="keyword">esp_ble_adv_channel_t</span> channel_map;<span class="comment">//广播通道映射</span></span><br><span class="line">    <span class="keyword">esp_ble_adv_filter_t</span> adv_filter_policy;<span class="comment">//广播过滤器设置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">esp_ble_adv_params_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置示例</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">esp_ble_adv_params_t</span> adv_params = &#123;</span><br><span class="line">    .adv_int_min        = <span class="number">0x20</span>,<span class="comment">//最小时间间隔</span></span><br><span class="line">    .adv_int_max        = <span class="number">0x40</span>,<span class="comment">//最大时间间隔</span></span><br><span class="line">    .adv_type           = ADV_TYPE_IND,</span><br><span class="line">    .own_addr_type      = BLE_ADDR_TYPE_PUBLIC,<span class="comment">//公共地址</span></span><br><span class="line">    <span class="comment">//.peer_addr            =默认</span></span><br><span class="line">    <span class="comment">//.peer_addr_type       =默认</span></span><br><span class="line">    .channel_map        = ADV_CHNL_ALL,<span class="comment">//全通道</span></span><br><span class="line">    .adv_filter_policy = ADV_FILTER_ALLOW_SCAN_ANY_CON_ANY,<span class="comment">//扫描所有连接</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>设置完毕后，可以使用esp_ble_gap_start_advertising()进行广播</p>
<p>注意：<strong>esp_ble_gap_config_adv_data()使用esp_ble_adv_data_t结构体进行设置，配置的是广播出去的数据；而esp_ble_gap_start_advertising()使用esp_ble_adv_params_t结构体进行设置，配置的是该怎样广播</strong></p>
<h1 id="经典蓝牙的子集SPP"><a href="#经典蓝牙的子集SPP" class="headerlink" title="经典蓝牙的子集SPP"></a>经典蓝牙的子集SPP</h1><p>蓝牙串口协议Serial Port Profile简写为SPP，SPP就是一种能在蓝牙设备之间创建串口进行数据传输的协议，最终目的是在两个不同设备（通信的两端）上的应用之间保证一条完整的通信路径</p>
<p>SPP的协议栈示意图如下</p>
<p><img src="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A03%E3%80%90%E7%BB%8F%E5%85%B8%E8%93%9D%E7%89%99%E4%B8%8EBLE%E3%80%91/image-20210205162726034.png" alt="image-20210205162726034"></p>
<h3 id="连接流程"><a href="#连接流程" class="headerlink" title="连接流程"></a>连接流程</h3><ol>
<li>创建虚拟连接</li>
<li>接受虚拟串口连接</li>
<li>在本地SDP数据上注册服务</li>
</ol>
<h3 id="SPP协议与GATT协议的对比"><a href="#SPP协议与GATT协议的对比" class="headerlink" title="SPP协议与GATT协议的对比"></a>SPP协议与GATT协议的对比</h3><table>
<thead>
<tr>
<th>经典蓝牙BT-SPP</th>
<th>低功耗蓝牙BLE-GATT</th>
</tr>
</thead>
<tbody><tr>
<td>速率高</td>
<td>灵活多变、集成很多profile</td>
</tr>
<tr>
<td>兼容性好</td>
<td>高速率传输时兼容性难以保障</td>
</tr>
<tr>
<td>对IOS不友好</td>
<td>对IOS很友好</td>
</tr>
<tr>
<td>APP编程不方便</td>
<td>开发资源丰富、接口多</td>
</tr>
</tbody></table>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">ESP32</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A03%E3%80%90%E7%BB%8F%E5%85%B8%E8%93%9D%E7%89%99%E4%B8%8EBLE%E3%80%91/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-ESP32-IDF学习2【WiFi】" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A02%E3%80%90WiFi%E3%80%91/">ESP32_IDF学习2【WiFi】</a>
    </h1>
  

        
<!-- 显示阅读次数-->
<!--  -->
<!--显示阅读次数完毕 -->

        
        <a href="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A02%E3%80%90WiFi%E3%80%91/" class="archive-article-date">
  	<time datetime="2021-11-19T06:59:28.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2021-11-19</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="WiFi外设配置"><a href="#WiFi外设配置" class="headerlink" title="WiFi外设配置"></a>WiFi外设配置</h1><p>ESP32/8266的Wi-Fi库支持配置及监控Wi-Fi连网功能</p>
<p>相关内容参考乐鑫的ESP32/8266文档<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/release-v4.1/api-reference/network/esp_wifi.html">https://docs.espressif.com/projects/esp-idf/zh_CN/release-v4.1/api-reference/network/esp_wifi.html</a></p>
<h2 id="基本模式"><a href="#基本模式" class="headerlink" title="基本模式"></a>基本模式</h2><ol>
<li><p>基站模式（又称<strong>STA模式</strong>或Client模式）：将ESP连接到附近的AP，此时<strong>相当于ESP在蹭网</strong></p>
</li>
<li><p><strong>AP模式</strong>（又称Soft-AP模式或Server模式）：将ESP设置为AP，可供周围设备连接，此时<strong>相当于ESP开热点</strong></p>
</li>
<li><p>AP-STA<strong>共存模式</strong>：ESP32既是接入点，同时又作为基站连接到另外一个接入点，此时<strong>相当于ESP连着隔壁wifi开热点给自家用</strong></p>
</li>
</ol>
<p>同时支持以上模式的安全模式（WPA、WPA2、WEP等），可以理解成<strong>安全蹭网</strong></p>
<h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><ol>
<li>主动/被动扫描附近AP，<strong>主动找别人家网蹭</strong></li>
<li>使用混杂模式监控IEEE802.11 Wi-Fi数据包，<strong>可以理解成ESP能看到你上了什么不可描述的网站</strong></li>
</ol>
<h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2><ol>
<li>初始化与设置</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">esp_wifi_init(<span class="keyword">const</span> <span class="keyword">wifi_init_config_t</span> *config)<span class="comment">//WiFi功能初始化，config为初始化结构体句柄</span></span><br><span class="line">esp_wifi_set_config(<span class="keyword">wifi_interface_t</span> interface, <span class="keyword">wifi_config_t</span> *conf)<span class="comment">//使能设置</span></span><br><span class="line">esp_wifi_set_mode(<span class="keyword">wifi_mode_t</span> mode)<span class="comment">//模式设置</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//可如下配置</span></span><br><span class="line">WIFI_MODE_NULL=<span class="number">0</span></span><br><span class="line">WIFI_MODE_STA<span class="comment">//STA模式</span></span><br><span class="line">WIFI_MODE_AP<span class="comment">//软AP模式</span></span><br><span class="line">WIFI_MODE_APSTA<span class="comment">//混合模式</span></span><br><span class="line">WIFI_MODE_MAX</span><br><span class="line">    </span><br><span class="line">esp_wifi_get_mode(<span class="keyword">wifi_mode_t</span> *mode)<span class="comment">//获取当前模式</span></span><br><span class="line">esp_wifi_get_config(<span class="keyword">wifi_interface_t</span> interface, <span class="keyword">wifi_config_t</span> *conf)<span class="comment">//获取当前设置</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>关闭WiFi</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">esp_wifi_stop()<span class="comment">//STA模式下断开wifi连接，AP模式下关闭热点并释放内存，共用模式下断开连接并关闭热点</span></span><br><span class="line">esp_wifi_deinit()<span class="comment">//释放曾在esp_wifi_init中申请的资源并停止WiFi工作，不需要wifi功能时可以使用</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>连接/断开WiFi</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用于STA模式 */</span></span><br><span class="line">esp_wifi_connect()<span class="comment">//连接WiFi</span></span><br><span class="line">esp_wifi_disconnect()<span class="comment">//断开WiFi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用于AP模式 */</span></span><br><span class="line">esp_wifi_deauth_sta(<span class="keyword">uint16_t</span> aid)<span class="comment">//停止对接入设备的授权——不让别人蹭网</span></span><br><span class="line">esp_wifi_ap_get_sta_aid(<span class="keyword">const</span> <span class="keyword">uint8_t</span> mac[<span class="number">6</span>], <span class="keyword">uint16_t</span> *aid)<span class="comment">//获取当前接入的设备信息</span></span><br><span class="line">esp_wifi_ap_get_sta_list(<span class="keyword">wifi_sta_list_t</span> *sta)<span class="comment">//获取当前接入的设备列表</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>扫描附近</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">esp_wifi_scan_start(<span class="keyword">const</span> <span class="keyword">wifi_scan_config_t</span> *config, <span class="keyword">bool</span> block)<span class="comment">//扫描AP以蹭网</span></span><br><span class="line"><span class="comment">/* 推荐最大扫描时间为1500ms */</span></span><br><span class="line">esp_wifi_scan_stop()<span class="comment">//在途中停止扫描</span></span><br><span class="line">esp_wifi_scan_get_ap_num(<span class="keyword">uint16_t</span> *number)<span class="comment">//获得最后一次扫描得到的AP号码</span></span><br><span class="line">esp_wifi_scan_get_ap_records(<span class="keyword">uint16_t</span> *number, <span class="keyword">wifi_ap_record_t</span> *ap_records)<span class="comment">//获取扫描记录</span></span><br><span class="line">esp_wifi_sta_get_ap_info(<span class="keyword">wifi_ap_record_t</span> *ap_info)<span class="comment">//获取当前连接wifi的相关信息</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//返回如下结构体的指针</span></span><br><span class="line"><span class="keyword">uint8_t</span> bssid[<span class="number">6</span>]<span class="comment">//MAC地址</span></span><br><span class="line"><span class="keyword">uint8_t</span> ssid[<span class="number">33</span>]<span class="comment">//SSID</span></span><br><span class="line"><span class="keyword">uint8_t</span> primary<span class="comment">//AP通道</span></span><br><span class="line"><span class="keyword">wifi_second_chan_t</span> second<span class="comment">//AP第二通道</span></span><br><span class="line"><span class="keyword">int8_t</span> rssi<span class="comment">//信号强度</span></span><br><span class="line"><span class="keyword">wifi_auth_mode_t</span> authmode<span class="comment">//认证模式</span></span><br><span class="line"><span class="keyword">wifi_cipher_type_t</span> pairwise_cipher<span class="comment">//PTK成对传输密钥，用于单播数据帧的加密解密</span></span><br><span class="line"><span class="keyword">wifi_cipher_type_t</span> group_cipher<span class="comment">//GTK组临时密钥，用于组播数据帧和广播数据帧的加密和解密</span></span><br><span class="line"><span class="keyword">wifi_ant_t</span> ant<span class="comment">//用于接收信号的天线引脚</span></span><br><span class="line"><span class="comment">/* 相关控制寄存器位 */</span></span><br><span class="line"><span class="keyword">uint32_t</span> phy_11b : <span class="number">1</span><span class="comment">//11b模式开启标志</span></span><br><span class="line"><span class="keyword">uint32_t</span> phy_11g : <span class="number">1</span><span class="comment">//11g模式开启标志</span></span><br><span class="line"><span class="keyword">uint32_t</span> phy_11n : <span class="number">1</span><span class="comment">//11n模式开启标志</span></span><br><span class="line"><span class="keyword">uint32_t</span> phy_lr : <span class="number">1</span><span class="comment">//低频模式开启标志</span></span><br><span class="line"><span class="keyword">uint32_t</span> wps : <span class="number">1</span><span class="comment">//WPS支持情况标志</span></span><br><span class="line"><span class="keyword">uint32_t</span> reserved : <span class="number">27</span><span class="comment">//寄存器保留位</span></span><br><span class="line"><span class="comment">/* 相关控制寄存器位 */</span></span><br><span class="line"><span class="keyword">wifi_country_t</span> country<span class="comment">//AP的国家信息</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>操作系统相关</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">esp_wifi_set_event_mask(<span class="keyword">uint32_t</span> mask)<span class="comment">//设置事件掩码</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>其他</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">esp_wifi_set_protocol(<span class="keyword">wifi_interface_t</span> ifx, <span class="keyword">uint8_t</span> protocol_bitmap)<span class="comment">//设置特殊接口的协议类型</span></span><br><span class="line"><span class="comment">//可选WIFI_PROTOCOL_11B、WIFI_PROTOCOL_11G、WIFI_PROTOCOL_11N)</span></span><br><span class="line">esp_wifi_get_protocol(<span class="keyword">wifi_interface_t</span> ifx, <span class="keyword">uint8_t</span> *protocol_bitmap)<span class="comment">//获取当前协议类型</span></span><br><span class="line">    </span><br><span class="line">sp_wifi_set_bandwidth(<span class="keyword">wifi_interface_t</span> ifx, <span class="keyword">wifi_bandwidth_t</span> bw)<span class="comment">//设置带宽</span></span><br><span class="line">esp_wifi_get_bandwidth(<span class="keyword">wifi_interface_t</span> ifx, <span class="keyword">wifi_bandwidth_t</span> *bw)<span class="comment">//获取当前带宽</span></span><br><span class="line">    </span><br><span class="line">sp_wifi_set_channel(<span class="keyword">uint8_t</span> primary, <span class="keyword">wifi_second_chan_t</span> second)<span class="comment">//设置primary/secondary通道</span></span><br><span class="line">esp_wifi_get_channel(<span class="keyword">uint8_t</span> *primary, <span class="keyword">wifi_second_chan_t</span> *second)<span class="comment">//获取当前使用的通道</span></span><br><span class="line">    </span><br><span class="line">esp_wifi_set_country(<span class="keyword">const</span> <span class="keyword">wifi_country_t</span> *country)<span class="comment">//设置当前的国家信息</span></span><br><span class="line">esp_wifi_get_country(<span class="keyword">wifi_country_t</span> *country)<span class="comment">//获取当前的国家信息</span></span><br><span class="line">    </span><br><span class="line">esp_wifi_set_mac(<span class="keyword">wifi_interface_t</span> ifx, <span class="keyword">const</span> <span class="keyword">uint8_t</span> mac[<span class="number">6</span>])<span class="comment">//设置当前mac地址</span></span><br><span class="line">esp_wifi_get_mac(<span class="keyword">wifi_interface_t</span> ifx, <span class="keyword">uint8_t</span> mac[<span class="number">6</span>])<span class="comment">//获取当前mac地址</span></span><br><span class="line">    </span><br><span class="line">esp_wifi_set_ant_gpio(<span class="keyword">const</span> <span class="keyword">wifi_ant_gpio_config_t</span> *config)<span class="comment">//设置天线引脚</span></span><br><span class="line">esp_wifi_get_ant_gpio(<span class="keyword">wifi_ant_gpio_config_t</span> *config)<span class="comment">//获取当前天线引脚</span></span><br><span class="line">esp_wifi_set_ant(<span class="keyword">const</span> <span class="keyword">wifi_ant_config_t</span> *config)<span class="comment">//设置天线设定</span></span><br><span class="line">esp_wifi_get_ant(<span class="keyword">wifi_ant_config_t</span> *config)<span class="comment">//获取当前天线设定</span></span><br><span class="line">    </span><br><span class="line">esp_wifi_set_promiscuous(<span class="keyword">bool</span> en)<span class="comment">//使能混杂模式</span></span><br><span class="line">esp_wifi_get_promiscuous(<span class="keyword">bool</span> *en)<span class="comment">//获取混杂模式</span></span><br><span class="line">esp_wifi_set_promiscuous_filter(<span class="keyword">const</span> <span class="keyword">wifi_promiscuous_filter_t</span> *filter)<span class="comment">//设置混杂模式过滤器，默认过滤除WIFI_PKT_MISC外的包</span></span><br><span class="line">esp_wifi_get_promiscuous_filter(<span class="keyword">wifi_promiscuous_filter_t</span> *filter)<span class="comment">//获取混杂模式过滤器</span></span><br><span class="line">esp_wifi_set_promiscuous_ctrl_filter(<span class="keyword">const</span> <span class="keyword">wifi_promiscuous_filter_t</span> *filter)<span class="comment">//使能混杂类型过滤器的子类型过滤</span></span><br><span class="line">esp_wifi_get_promiscuous_ctrl_filter(<span class="keyword">wifi_promiscuous_filter_t</span> *filter)<span class="comment">//获取混杂类型过滤器的子类型过滤</span></span><br><span class="line">esp_wifi_set_promiscuous_rx_cb(<span class="keyword">wifi_promiscuous_cb_t</span> cb)<span class="comment">//设置混杂模式监控回调函数  </span></span><br></pre></td></tr></table></figure>

<ol start="8">
<li>低功耗相关</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">esp_wifi_set_inactive_time(<span class="keyword">wifi_interface_t</span> ifx, <span class="keyword">uint16_t</span> sec)<span class="comment">//设置暂时休眠时间</span></span><br><span class="line">esp_wifi_get_ant(<span class="keyword">wifi_ant_config_t</span> *config)<span class="comment">//获取暂时休眠时间</span></span><br></pre></td></tr></table></figure>

<p>特征：大部分API都有对应的set和get两个方向，需要回传数据时使用get*，初始设置时使用set*</p>
<h3 id="AP模式初始化"><a href="#AP模式初始化" class="headerlink" title="AP模式初始化"></a>AP模式初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wifi_init_softap</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ESP_ERROR_CHECK(esp_netif_init());</span><br><span class="line">    ESP_ERROR_CHECK(esp_event_loop_create_default());</span><br><span class="line">    </span><br><span class="line">    esp_netif_create_default_wifi_ap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wifi_init_config_t</span> cfg = WIFI_INIT_CONFIG_DEFAULT();</span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_init(&amp;cfg));</span><br><span class="line">    ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT,</span><br><span class="line">                                                        ESP_EVENT_ANY_ID,</span><br><span class="line">                                                        &amp;wifi_event_handler,</span><br><span class="line">                                                        <span class="literal">NULL</span>,</span><br><span class="line">                                                        <span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wifi_config_t</span> wifi_config = &#123;</span><br><span class="line">        .ap = &#123;</span><br><span class="line">            .ssid = EXAMPLE_ESP_WIFI_SSID,</span><br><span class="line">            .ssid_len = <span class="built_in">strlen</span>(EXAMPLE_ESP_WIFI_SSID),</span><br><span class="line">            .channel = EXAMPLE_ESP_WIFI_CHANNEL,</span><br><span class="line">            .password = EXAMPLE_ESP_WIFI_PASS,</span><br><span class="line">            .max_connection = EXAMPLE_MAX_STA_CONN,</span><br><span class="line">            .authmode = WIFI_AUTH_WPA_WPA2_PSK</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(EXAMPLE_ESP_WIFI_PASS) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        wifi_config.ap.authmode = WIFI_AUTH_OPEN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP));</span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_AP, &amp;wifi_config));</span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_start());</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;wifi_init_softap finished. SSID:%s password:%s channel:%d&quot;</span>,</span><br><span class="line">             EXAMPLE_ESP_WIFI_SSID, EXAMPLE_ESP_WIFI_PASS, EXAMPLE_ESP_WIFI_CHANNEL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中主要用到了wifi_config_t这个结构体，它的内容如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> ssid[<span class="number">32</span>];<span class="comment">//SSID</span></span><br><span class="line">    <span class="keyword">uint8_t</span> password[<span class="number">64</span>];<span class="comment">//密码</span></span><br><span class="line">    <span class="keyword">uint8_t</span> ssid_len;<span class="comment">//SSID长度，若设为0则会自动查找到终止字符；否则会在规定长度处截断</span></span><br><span class="line">    <span class="keyword">uint8_t</span> channel;<span class="comment">//AP的通道</span></span><br><span class="line">    <span class="keyword">wifi_auth_mode_t</span> authmode;<span class="comment">//授权模式</span></span><br><span class="line">    <span class="keyword">uint8_t</span> ssid_hidden;<span class="comment">//是否广播SSID，默认为0-广播；设为1则不广播</span></span><br><span class="line">    <span class="keyword">uint8_t</span> max_connection;<span class="comment">//能连接的最大节点数量，默认为4，最大为4</span></span><br><span class="line">    <span class="keyword">uint16_t</span> beacon_interval;<span class="comment">//信标间隔，默认100ms，应设置在100-60000ms内</span></span><br><span class="line">&#125; <span class="keyword">wifi_ap_config_t</span>;</span><br></pre></td></tr></table></figure>

<h3 id="STA模式初始化"><a href="#STA模式初始化" class="headerlink" title="STA模式初始化"></a>STA模式初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wifi_init_sta</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s_wifi_event_group = xEventGroupCreate();</span><br><span class="line">    ESP_ERROR_CHECK(esp_netif_init());</span><br><span class="line">    ESP_ERROR_CHECK(esp_event_loop_create_default());</span><br><span class="line">    </span><br><span class="line">    esp_netif_create_default_wifi_sta();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wifi_init_config_t</span> cfg = WIFI_INIT_CONFIG_DEFAULT();</span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_init(&amp;cfg));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">esp_event_handler_instance_t</span> instance_any_id;</span><br><span class="line">    <span class="keyword">esp_event_handler_instance_t</span> instance_got_ip;</span><br><span class="line">    ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT,</span><br><span class="line">                                                        ESP_EVENT_ANY_ID,</span><br><span class="line">                                                        &amp;event_handler,</span><br><span class="line">                                                        <span class="literal">NULL</span>,</span><br><span class="line">                                                        &amp;instance_any_id));</span><br><span class="line">    ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT,</span><br><span class="line">                                                        IP_EVENT_STA_GOT_IP,</span><br><span class="line">                                                        &amp;event_handler,</span><br><span class="line">                                                        <span class="literal">NULL</span>,</span><br><span class="line">                                                        &amp;instance_got_ip));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wifi_config_t</span> wifi_config = &#123;</span><br><span class="line">        .sta = &#123;</span><br><span class="line">            .ssid = EXAMPLE_ESP_WIFI_SSID,</span><br><span class="line">            .password = EXAMPLE_ESP_WIFI_PASS,</span><br><span class="line">            <span class="comment">/* Setting a password implies station will connect to all security modes including WEP/WPA.</span></span><br><span class="line"><span class="comment">             * However these modes are deprecated and not advisable to be used. Incase your Access point</span></span><br><span class="line"><span class="comment">             * doesn&#x27;t support WPA2, these mode can be enabled by commenting below line */</span></span><br><span class="line">	     	.threshold.authmode = WIFI_AUTH_WPA2_PSK,</span><br><span class="line">            .pmf_cfg = &#123;</span><br><span class="line">                .capable = <span class="literal">true</span>,</span><br><span class="line">                .required = <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA) );</span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_STA, &amp;wifi_config) );</span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_start() );</span><br><span class="line"></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;wifi_init_sta finished.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Waiting until either the connection is established (WIFI_CONNECTED_BIT) or connection failed for the maximum</span></span><br><span class="line"><span class="comment">     * number of re-tries (WIFI_FAIL_BIT). The bits are set by event_handler() (see above) */</span></span><br><span class="line">    EventBits_t bits = xEventGroupWaitBits(s_wifi_event_group,</span><br><span class="line">            WIFI_CONNECTED_BIT | WIFI_FAIL_BIT,</span><br><span class="line">            pdFALSE,</span><br><span class="line">            pdFALSE,</span><br><span class="line">            portMAX_DELAY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* xEventGroupWaitBits() returns the bits before the call returned, hence we can test which event actually</span></span><br><span class="line"><span class="comment">     * happened. */</span></span><br><span class="line">    <span class="keyword">if</span> (bits &amp; WIFI_CONNECTED_BIT) &#123;</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;connected to ap SSID:%s password:%s&quot;</span>,</span><br><span class="line">                 EXAMPLE_ESP_WIFI_SSID, EXAMPLE_ESP_WIFI_PASS);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bits &amp; WIFI_FAIL_BIT) &#123;</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;Failed to connect to SSID:%s, password:%s&quot;</span>,</span><br><span class="line">                 EXAMPLE_ESP_WIFI_SSID, EXAMPLE_ESP_WIFI_PASS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">&quot;UNEXPECTED EVENT&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The event will not be processed after unregister */</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_event_handler_instance_unregister(IP_EVENT, IP_EVENT_STA_GOT_IP, instance_got_ip));</span><br><span class="line">    ESP_ERROR_CHECK(esp_event_handler_instance_unregister(WIFI_EVENT, ESP_EVENT_ANY_ID, instance_any_id));</span><br><span class="line">    vEventGroupDelete(s_wifi_event_group);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中主要用到了wifi_sta_config_t这个结构体，它的内容如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> ssid[<span class="number">32</span>];<span class="comment">//SSID</span></span><br><span class="line">    <span class="keyword">uint8_t</span> password[<span class="number">64</span>];<span class="comment">//密码</span></span><br><span class="line">    <span class="keyword">bool</span> bssid_set;<span class="comment">//是否设置目标AP的MAC地址，一般设为0；只有用户需要查看AP的MAC地址时才设为1</span></span><br><span class="line">    <span class="keyword">uint8_t</span> bssid[<span class="number">6</span>];<span class="comment">//目标AP的MAC地址</span></span><br><span class="line">    <span class="keyword">uint8_t</span> channel;<span class="comment">//目标AP的通道，如果未知设为0；范围是1-13</span></span><br><span class="line">&#125; <span class="keyword">wifi_sta_config_t</span>;</span><br></pre></td></tr></table></figure>

<h3 id="AP-STA共存模式"><a href="#AP-STA共存模式" class="headerlink" title="AP-STA共存模式"></a>AP-STA共存模式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">event_handler</span><span class="params">(<span class="keyword">void</span> *ctx, <span class="keyword">system_event_t</span> *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event-&gt;event_id)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> SYSTEM_EVENT_STA_START:</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;Connecting to AP&quot;</span>);</span><br><span class="line">        esp_wifi_connect();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> SYSTEM_EVENT_STA_GOT_IP:</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;Connected&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> SYSTEM_EVENT_STA_DISCONNECTED:</span><br><span class="line">        <span class="comment">//ESP_LOGI(TAG, &quot;Wifi disconnected, try to connect again...&quot;);</span></span><br><span class="line">        esp_wifi_connect();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ESP_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ESP_net_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ESP_ERROR_CHECK(esp_event_loop_init(event_handler, <span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">wifi_init_config_t</span> cfg = WIFI_INIT_CONFIG_DEFAULT();</span><br><span class="line">    ESP_ERROR_CHECK( esp_wifi_init(&amp;cfg) );</span><br><span class="line">    ESP_ERROR_CHECK( esp_wifi_set_storage(WIFI_STORAGE_RAM) );</span><br><span class="line">    ESP_ERROR_CHECK( esp_wifi_set_mode(WIFI_MODE_APSTA) );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wifi_config_t</span> sta_config = &#123;</span><br><span class="line">        .sta = &#123;</span><br><span class="line">            .ssid = TARGET_ESP_WIFI_SSID,</span><br><span class="line">            .password = TARGET_ESP_WIFI_PASS,</span><br><span class="line">            .bssid_set = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">wifi_config_t</span> ap_config = &#123;</span><br><span class="line">        .ap = &#123;</span><br><span class="line">            .ssid = AP_ESP_WIFI_SSID,</span><br><span class="line">            .password = AP_ESP_WIFI_PASS,</span><br><span class="line">            .ssid_len = <span class="number">0</span>,</span><br><span class="line">            .max_connection = AP_MAX_STA_CONN,</span><br><span class="line">            .authmode = WIFI_AUTH_WPA_PSK</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &amp;sta_config));</span><br><span class="line">    <span class="keyword">esp_err_t</span> tmp=esp_wifi_set_config(WIFI_IF_AP, &amp;ap_config);</span><br><span class="line"></span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_start());</span><br><span class="line">    esp_wifi_connect();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//init NVS</span></span><br><span class="line">    <span class="keyword">esp_err_t</span> ret = nvs_flash_init();</span><br><span class="line">    <span class="keyword">if</span> (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND)</span><br><span class="line">    &#123;</span><br><span class="line">        ESP_ERROR_CHECK(nvs_flash_erase());</span><br><span class="line">        ret = nvs_flash_init();</span><br><span class="line">    &#125;</span><br><span class="line">    ESP_ERROR_CHECK(ret);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//init wifi ap and station</span></span><br><span class="line">    ESP_net_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里使用了状态机（SM）的编程思路，【开始连接】-【连接完毕】-【丢失连接】几个状态切换中都会调用event_handler()进行处理并打印相关信息</p>
<h2 id="基本初始化方法"><a href="#基本初始化方法" class="headerlink" title="基本初始化方法"></a>基本初始化方法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置线程</span></span><br><span class="line"><span class="keyword">wifi_init_config_t</span> cfg = WIFI_INIT_CONFIG_DEFAULT();<span class="comment">//进行默认初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置wifi_config结构体来配置具体的wifi模式</span></span><br><span class="line"><span class="keyword">wifi_config_t</span> sta_wifi_config = &#123;</span><br><span class="line">        .sta = &#123;</span><br><span class="line">            .ssid = SSID,</span><br><span class="line">            .password = PASSWORD,</span><br><span class="line">	     	.threshold.authmode = WIFI_AUTH_WPA2_PSK,</span><br><span class="line">            .pmf_cfg = &#123;<span class="comment">//这里可省略</span></span><br><span class="line">                .capable = <span class="literal">true</span>,</span><br><span class="line">                .required = <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">wifi_config_t</span> ap_wifi_config = &#123;</span><br><span class="line">        .ap = &#123;</span><br><span class="line">            .ssid = SSID,</span><br><span class="line">            .ssid_len = <span class="built_in">strlen</span>(EXAMPLE_ESP_WIFI_SSID),</span><br><span class="line">            .channel = WIFI_CHANNEL,</span><br><span class="line">            .password = PASSWORD,</span><br><span class="line">            .max_connection = MAX_STA_CONN,<span class="comment">//这里可省略</span></span><br><span class="line">            .authmode = WIFI_AUTH_WPA_WPA2_PSK</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strlen</span>(PASSWORD) == <span class="number">0</span>)<span class="comment">//检查密码是否为空</span></span><br><span class="line">&#123;</span><br><span class="line">	wifi_config.ap.authmode = WIFI_AUTH_OPEN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查错误并使能设置</span></span><br><span class="line">ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &amp;sta_config));</span><br><span class="line"><span class="keyword">esp_err_t</span> tmp=esp_wifi_set_config(WIFI_IF_AP, &amp;ap_config);</span><br><span class="line"></span><br><span class="line">esp_wifi_connect();<span class="comment">//连接wifi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中间可加入ESP_LOGI()输出debg消息 */</span></span><br></pre></td></tr></table></figure>

<p>WiFi连接实际上使用的是一套异步的状态机，所有需要调用的外设都被ESP-IDF封装起来了，开发者只需要配置基本逻辑即可。流程如下：</p>
<ol>
<li><p>初始化用于存储WiFi配置数据（包括ssid和密码）的NVS</p>
</li>
<li><p>配置WiFi数据并将其写入WiFi外设（或NVS）</p>
</li>
<li><p>开启WiFi</p>
</li>
<li><p>设备自动根据外设寄存器内的配置连接附近WiFi，并根据当前连接情况向主程序发送事件集</p>
</li>
<li><p>开发者编写的状态机负责处理WiFi外设发来的事件，主要分成以下几种情况：</p>
<ul>
<li>WiFi已连接</li>
<li>WiFi未连接</li>
<li>找不到指定ssid的WiFi</li>
<li>连接丢失</li>
</ul>
<p>一般使用ESP-IDF中的<strong>默认事件循环</strong>来实现状态机</p>
<p>使用其中的<strong>事件类型</strong>和<strong>事件ID</strong>区分各个不同的具体时间</p>
</li>
</ol>
<p>关于ESP-IDF的事件集可以参考ESP32上移植的FreeRTOS相关教程</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">ESP32</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A02%E3%80%90WiFi%E3%80%91/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
    </nav>
  


          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2021 RedlightASl
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true,
		toc_hide_index: true,
		root: "/",
		innerArchive: true,
		showTags: false
	}
</script>

<script>!function(t){function n(e){if(r[e])return r[e].exports;var i=r[e]={exports:{},id:e,loaded:!1};return t[e].call(i.exports,i,i.exports,n),i.loaded=!0,i.exports}var r={};n.m=t,n.c=r,n.p="./",n(0)}([function(t,n,r){r(195),t.exports=r(191)},function(t,n,r){var e=r(3),i=r(52),o=r(27),u=r(28),c=r(53),f="prototype",a=function(t,n,r){var s,l,h,v,p=t&a.F,d=t&a.G,y=t&a.S,g=t&a.P,b=t&a.B,m=d?e:y?e[n]||(e[n]={}):(e[n]||{})[f],x=d?i:i[n]||(i[n]={}),w=x[f]||(x[f]={});d&&(r=n);for(s in r)l=!p&&m&&void 0!==m[s],h=(l?m:r)[s],v=b&&l?c(h,e):g&&"function"==typeof h?c(Function.call,h):h,m&&u(m,s,h,t&a.U),x[s]!=h&&o(x,s,v),g&&w[s]!=h&&(w[s]=h)};e.core=i,a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,a.U=64,a.R=128,t.exports=a},function(t,n,r){var e=r(6);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n,r){var e=r(126)("wks"),i=r(76),o=r(3).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n,r){var e=r(94),i=r(33);t.exports=function(t){return e(i(t))}},function(t,n,r){t.exports=!r(4)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(2),i=r(167),o=r(50),u=Object.defineProperty;n.f=r(10)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){t.exports=!r(18)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(14),i=r(22);t.exports=r(12)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(20),i=r(58),o=r(42),u=Object.defineProperty;n.f=r(12)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){var e=r(40)("wks"),i=r(23),o=r(5).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n,r){var e=r(67),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){var e=r(46);t.exports=function(t){return Object(e(t))}},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n,r){var e=r(63),i=r(34);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(21);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n,r){var e=r(11),i=r(66);t.exports=r(10)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(3),i=r(27),o=r(24),u=r(76)("src"),c="toString",f=Function[c],a=(""+f).split(c);r(52).inspectSource=function(t){return f.call(t)},(t.exports=function(t,n,r,c){var f="function"==typeof r;f&&(o(r,"name")||i(r,"name",n)),t[n]!==r&&(f&&(o(r,u)||i(r,u,t[n]?""+t[n]:a.join(String(n)))),t===e?t[n]=r:c?t[n]?t[n]=r:i(t,n,r):(delete t[n],i(t,n,r)))})(Function.prototype,c,function(){return"function"==typeof this&&this[u]||f.call(this)})},function(t,n,r){var e=r(1),i=r(4),o=r(46),u=function(t,n,r,e){var i=String(o(t)),u="<"+n;return""!==r&&(u+=" "+r+'="'+String(e).replace(/"/g,"&quot;")+'"'),u+">"+i+"</"+n+">"};t.exports=function(t,n){var r={};r[t]=n(u),e(e.P+e.F*i(function(){var n=""[t]('"');return n!==n.toLowerCase()||n.split('"').length>3}),"String",r)}},function(t,n,r){var e=r(115),i=r(46);t.exports=function(t){return e(i(t))}},function(t,n,r){var e=r(116),i=r(66),o=r(30),u=r(50),c=r(24),f=r(167),a=Object.getOwnPropertyDescriptor;n.f=r(10)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(24),i=r(17),o=r(145)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n){t.exports={}},function(t,n){t.exports=!0},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(14).f,i=r(8),o=r(15)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(40)("keys"),i=r(23);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(5),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n,r){var e=r(21);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(36),u=r(44),c=r(14).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){n.f=r(15)},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n,r){var e=r(4);t.exports=function(t,n){return!!t&&e(function(){n?t.call(null,function(){},1):t.call(null)})}},function(t,n,r){var e=r(53),i=r(115),o=r(17),u=r(16),c=r(203);t.exports=function(t,n){var r=1==t,f=2==t,a=3==t,s=4==t,l=6==t,h=5==t||l,v=n||c;return function(n,c,p){for(var d,y,g=o(n),b=i(g),m=e(c,p,3),x=u(b.length),w=0,S=r?v(n,x):f?v(n,0):void 0;x>w;w++)if((h||w in b)&&(d=b[w],y=m(d,w,g),t))if(r)S[w]=y;else if(y)switch(t){case 3:return!0;case 5:return d;case 6:return w;case 2:S.push(d)}else if(s)return!1;return l?-1:a||s?s:S}}},function(t,n,r){var e=r(1),i=r(52),o=r(4);t.exports=function(t,n){var r=(i.Object||{})[t]||Object[t],u={};u[t]=n(r),e(e.S+e.F*o(function(){r(1)}),"Object",u)}},function(t,n,r){var e=r(6);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(91),u=r(13),c="prototype",f=function(t,n,r){var a,s,l,h=t&f.F,v=t&f.G,p=t&f.S,d=t&f.P,y=t&f.B,g=t&f.W,b=v?i:i[n]||(i[n]={}),m=b[c],x=v?e:p?e[n]:(e[n]||{})[c];v&&(r=n);for(a in r)(s=!h&&x&&void 0!==x[a])&&a in b||(l=s?x[a]:r[a],b[a]=v&&"function"!=typeof x[a]?r[a]:y&&s?o(l,e):g&&x[a]==l?function(t){var n=function(n,r,e){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(n);case 2:return new t(n,r)}return new t(n,r,e)}return t.apply(this,arguments)};return n[c]=t[c],n}(l):d&&"function"==typeof l?o(Function.call,l):l,d&&((b.virtual||(b.virtual={}))[a]=l,t&f.R&&m&&!m[a]&&u(m,a,l)))};f.F=1,f.G=2,f.S=4,f.P=8,f.B=16,f.W=32,f.U=64,f.R=128,t.exports=f},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n,r){var e=r(26);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(183),i=r(1),o=r(126)("metadata"),u=o.store||(o.store=new(r(186))),c=function(t,n,r){var i=u.get(t);if(!i){if(!r)return;u.set(t,i=new e)}var o=i.get(n);if(!o){if(!r)return;i.set(n,o=new e)}return o},f=function(t,n,r){var e=c(n,r,!1);return void 0!==e&&e.has(t)},a=function(t,n,r){var e=c(n,r,!1);return void 0===e?void 0:e.get(t)},s=function(t,n,r,e){c(r,e,!0).set(t,n)},l=function(t,n){var r=c(t,n,!1),e=[];return r&&r.forEach(function(t,n){e.push(n)}),e},h=function(t){return void 0===t||"symbol"==typeof t?t:String(t)},v=function(t){i(i.S,"Reflect",t)};t.exports={store:u,map:c,has:f,get:a,set:s,keys:l,key:h,exp:v}},function(t,n,r){"use strict";if(r(10)){var e=r(69),i=r(3),o=r(4),u=r(1),c=r(127),f=r(152),a=r(53),s=r(68),l=r(66),h=r(27),v=r(73),p=r(67),d=r(16),y=r(75),g=r(50),b=r(24),m=r(180),x=r(114),w=r(6),S=r(17),_=r(137),O=r(70),E=r(32),P=r(71).f,j=r(154),F=r(76),M=r(7),A=r(48),N=r(117),T=r(146),I=r(155),k=r(80),L=r(123),R=r(74),C=r(130),D=r(160),U=r(11),W=r(31),G=U.f,B=W.f,V=i.RangeError,z=i.TypeError,q=i.Uint8Array,K="ArrayBuffer",J="Shared"+K,Y="BYTES_PER_ELEMENT",H="prototype",$=Array[H],X=f.ArrayBuffer,Q=f.DataView,Z=A(0),tt=A(2),nt=A(3),rt=A(4),et=A(5),it=A(6),ot=N(!0),ut=N(!1),ct=I.values,ft=I.keys,at=I.entries,st=$.lastIndexOf,lt=$.reduce,ht=$.reduceRight,vt=$.join,pt=$.sort,dt=$.slice,yt=$.toString,gt=$.toLocaleString,bt=M("iterator"),mt=M("toStringTag"),xt=F("typed_constructor"),wt=F("def_constructor"),St=c.CONSTR,_t=c.TYPED,Ot=c.VIEW,Et="Wrong length!",Pt=A(1,function(t,n){return Tt(T(t,t[wt]),n)}),jt=o(function(){return 1===new q(new Uint16Array([1]).buffer)[0]}),Ft=!!q&&!!q[H].set&&o(function(){new q(1).set({})}),Mt=function(t,n){if(void 0===t)throw z(Et);var r=+t,e=d(t);if(n&&!m(r,e))throw V(Et);return e},At=function(t,n){var r=p(t);if(r<0||r%n)throw V("Wrong offset!");return r},Nt=function(t){if(w(t)&&_t in t)return t;throw z(t+" is not a typed array!")},Tt=function(t,n){if(!(w(t)&&xt in t))throw z("It is not a typed array constructor!");return new t(n)},It=function(t,n){return kt(T(t,t[wt]),n)},kt=function(t,n){for(var r=0,e=n.length,i=Tt(t,e);e>r;)i[r]=n[r++];return i},Lt=function(t,n,r){G(t,n,{get:function(){return this._d[r]}})},Rt=function(t){var n,r,e,i,o,u,c=S(t),f=arguments.length,s=f>1?arguments[1]:void 0,l=void 0!==s,h=j(c);if(void 0!=h&&!_(h)){for(u=h.call(c),e=[],n=0;!(o=u.next()).done;n++)e.push(o.value);c=e}for(l&&f>2&&(s=a(s,arguments[2],2)),n=0,r=d(c.length),i=Tt(this,r);r>n;n++)i[n]=l?s(c[n],n):c[n];return i},Ct=function(){for(var t=0,n=arguments.length,r=Tt(this,n);n>t;)r[t]=arguments[t++];return r},Dt=!!q&&o(function(){gt.call(new q(1))}),Ut=function(){return gt.apply(Dt?dt.call(Nt(this)):Nt(this),arguments)},Wt={copyWithin:function(t,n){return D.call(Nt(this),t,n,arguments.length>2?arguments[2]:void 0)},every:function(t){return rt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},fill:function(t){return C.apply(Nt(this),arguments)},filter:function(t){return It(this,tt(Nt(this),t,arguments.length>1?arguments[1]:void 0))},find:function(t){return et(Nt(this),t,arguments.length>1?arguments[1]:void 0)},findIndex:function(t){return it(Nt(this),t,arguments.length>1?arguments[1]:void 0)},forEach:function(t){Z(Nt(this),t,arguments.length>1?arguments[1]:void 0)},indexOf:function(t){return ut(Nt(this),t,arguments.length>1?arguments[1]:void 0)},includes:function(t){return ot(Nt(this),t,arguments.length>1?arguments[1]:void 0)},join:function(t){return vt.apply(Nt(this),arguments)},lastIndexOf:function(t){return st.apply(Nt(this),arguments)},map:function(t){return Pt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},reduce:function(t){return lt.apply(Nt(this),arguments)},reduceRight:function(t){return ht.apply(Nt(this),arguments)},reverse:function(){for(var t,n=this,r=Nt(n).length,e=Math.floor(r/2),i=0;i<e;)t=n[i],n[i++]=n[--r],n[r]=t;return n},some:function(t){return nt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},sort:function(t){return pt.call(Nt(this),t)},subarray:function(t,n){var r=Nt(this),e=r.length,i=y(t,e);return new(T(r,r[wt]))(r.buffer,r.byteOffset+i*r.BYTES_PER_ELEMENT,d((void 0===n?e:y(n,e))-i))}},Gt=function(t,n){return It(this,dt.call(Nt(this),t,n))},Bt=function(t){Nt(this);var n=At(arguments[1],1),r=this.length,e=S(t),i=d(e.length),o=0;if(i+n>r)throw V(Et);for(;o<i;)this[n+o]=e[o++]},Vt={entries:function(){return at.call(Nt(this))},keys:function(){return ft.call(Nt(this))},values:function(){return ct.call(Nt(this))}},zt=function(t,n){return w(t)&&t[_t]&&"symbol"!=typeof n&&n in t&&String(+n)==String(n)},qt=function(t,n){return zt(t,n=g(n,!0))?l(2,t[n]):B(t,n)},Kt=function(t,n,r){return!(zt(t,n=g(n,!0))&&w(r)&&b(r,"value"))||b(r,"get")||b(r,"set")||r.configurable||b(r,"writable")&&!r.writable||b(r,"enumerable")&&!r.enumerable?G(t,n,r):(t[n]=r.value,t)};St||(W.f=qt,U.f=Kt),u(u.S+u.F*!St,"Object",{getOwnPropertyDescriptor:qt,defineProperty:Kt}),o(function(){yt.call({})})&&(yt=gt=function(){return vt.call(this)});var Jt=v({},Wt);v(Jt,Vt),h(Jt,bt,Vt.values),v(Jt,{slice:Gt,set:Bt,constructor:function(){},toString:yt,toLocaleString:Ut}),Lt(Jt,"buffer","b"),Lt(Jt,"byteOffset","o"),Lt(Jt,"byteLength","l"),Lt(Jt,"length","e"),G(Jt,mt,{get:function(){return this[_t]}}),t.exports=function(t,n,r,f){f=!!f;var a=t+(f?"Clamped":"")+"Array",l="Uint8Array"!=a,v="get"+t,p="set"+t,y=i[a],g=y||{},b=y&&E(y),m=!y||!c.ABV,S={},_=y&&y[H],j=function(t,r){var e=t._d;return e.v[v](r*n+e.o,jt)},F=function(t,r,e){var i=t._d;f&&(e=(e=Math.round(e))<0?0:e>255?255:255&e),i.v[p](r*n+i.o,e,jt)},M=function(t,n){G(t,n,{get:function(){return j(this,n)},set:function(t){return F(this,n,t)},enumerable:!0})};m?(y=r(function(t,r,e,i){s(t,y,a,"_d");var o,u,c,f,l=0,v=0;if(w(r)){if(!(r instanceof X||(f=x(r))==K||f==J))return _t in r?kt(y,r):Rt.call(y,r);o=r,v=At(e,n);var p=r.byteLength;if(void 0===i){if(p%n)throw V(Et);if((u=p-v)<0)throw V(Et)}else if((u=d(i)*n)+v>p)throw V(Et);c=u/n}else c=Mt(r,!0),u=c*n,o=new X(u);for(h(t,"_d",{b:o,o:v,l:u,e:c,v:new Q(o)});l<c;)M(t,l++)}),_=y[H]=O(Jt),h(_,"constructor",y)):L(function(t){new y(null),new y(t)},!0)||(y=r(function(t,r,e,i){s(t,y,a);var o;return w(r)?r instanceof X||(o=x(r))==K||o==J?void 0!==i?new g(r,At(e,n),i):void 0!==e?new g(r,At(e,n)):new g(r):_t in r?kt(y,r):Rt.call(y,r):new g(Mt(r,l))}),Z(b!==Function.prototype?P(g).concat(P(b)):P(g),function(t){t in y||h(y,t,g[t])}),y[H]=_,e||(_.constructor=y));var A=_[bt],N=!!A&&("values"==A.name||void 0==A.name),T=Vt.values;h(y,xt,!0),h(_,_t,a),h(_,Ot,!0),h(_,wt,y),(f?new y(1)[mt]==a:mt in _)||G(_,mt,{get:function(){return a}}),S[a]=y,u(u.G+u.W+u.F*(y!=g),S),u(u.S,a,{BYTES_PER_ELEMENT:n,from:Rt,of:Ct}),Y in _||h(_,Y,n),u(u.P,a,Wt),R(a),u(u.P+u.F*Ft,a,{set:Bt}),u(u.P+u.F*!N,a,Vt),u(u.P+u.F*(_.toString!=yt),a,{toString:yt}),u(u.P+u.F*o(function(){new y(1).slice()}),a,{slice:Gt}),u(u.P+u.F*(o(function(){return[1,2].toLocaleString()!=new y([1,2]).toLocaleString()})||!o(function(){_.toLocaleString.call([1,2])})),a,{toLocaleString:Ut}),k[a]=N?A:T,e||N||h(_,bt,T)}}else t.exports=function(){}},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n,r){var e=r(21),i=r(5).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n,r){t.exports=!r(12)&&!r(18)(function(){return 7!=Object.defineProperty(r(57)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){"use strict";var e=r(36),i=r(51),o=r(64),u=r(13),c=r(8),f=r(35),a=r(96),s=r(38),l=r(103),h=r(15)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n,r){var e=r(20),i=r(100),o=r(34),u=r(39)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(57)("iframe"),e=o.length;for(n.style.display="none",r(93).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(63),i=r(34).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(8),i=r(9),o=r(90)(!1),u=r(39)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){t.exports=r(13)},function(t,n,r){var e=r(76)("meta"),i=r(6),o=r(24),u=r(11).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(4)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n){t.exports=function(t,n,r,e){if(!(t instanceof n)||void 0!==e&&e in t)throw TypeError(r+": incorrect invocation!");return t}},function(t,n){t.exports=!1},function(t,n,r){var e=r(2),i=r(173),o=r(133),u=r(145)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(132)("iframe"),e=o.length;for(n.style.display="none",r(135).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(175),i=r(133).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n,r){var e=r(175),i=r(133);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(28);t.exports=function(t,n,r){for(var i in n)e(t,i,n[i],r);return t}},function(t,n,r){"use strict";var e=r(3),i=r(11),o=r(10),u=r(7)("species");t.exports=function(t){var n=e[t];o&&n&&!n[u]&&i.f(n,u,{configurable:!0,get:function(){return this}})}},function(t,n,r){var e=r(67),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n,r){var e=r(33);t.exports=function(t){return Object(e(t))}},function(t,n,r){var e=r(7)("unscopables"),i=Array.prototype;void 0==i[e]&&r(27)(i,e,{}),t.exports=function(t){i[e][t]=!0}},function(t,n,r){var e=r(53),i=r(169),o=r(137),u=r(2),c=r(16),f=r(154),a={},s={},n=t.exports=function(t,n,r,l,h){var v,p,d,y,g=h?function(){return t}:f(t),b=e(r,l,n?2:1),m=0;if("function"!=typeof g)throw TypeError(t+" is not iterable!");if(o(g)){for(v=c(t.length);v>m;m++)if((y=n?b(u(p=t[m])[0],p[1]):b(t[m]))===a||y===s)return y}else for(d=g.call(t);!(p=d.next()).done;)if((y=i(d,b,p.value,n))===a||y===s)return y};n.BREAK=a,n.RETURN=s},function(t,n){t.exports={}},function(t,n,r){var e=r(11).f,i=r(24),o=r(7)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(1),i=r(46),o=r(4),u=r(150),c="["+u+"]",f="​",a=RegExp("^"+c+c+"*"),s=RegExp(c+c+"*$"),l=function(t,n,r){var i={},c=o(function(){return!!u[t]()||f[t]()!=f}),a=i[t]=c?n(h):u[t];r&&(i[r]=a),e(e.P+e.F*c,"String",i)},h=l.trim=function(t,n){return t=String(i(t)),1&n&&(t=t.replace(a,"")),2&n&&(t=t.replace(s,"")),t};t.exports=l},function(t,n,r){t.exports={default:r(86),__esModule:!0}},function(t,n,r){t.exports={default:r(87),__esModule:!0}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}n.__esModule=!0;var i=r(84),o=e(i),u=r(83),c=e(u),f="function"==typeof c.default&&"symbol"==typeof o.default?function(t){return typeof t}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":typeof t};n.default="function"==typeof c.default&&"symbol"===f(o.default)?function(t){return void 0===t?"undefined":f(t)}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":void 0===t?"undefined":f(t)}},function(t,n,r){r(110),r(108),r(111),r(112),t.exports=r(25).Symbol},function(t,n,r){r(109),r(113),t.exports=r(44).f("iterator")},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n){t.exports=function(){}},function(t,n,r){var e=r(9),i=r(106),o=r(105);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){var e=r(88);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(19),i=r(62),o=r(37);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){t.exports=r(5).document&&document.documentElement},function(t,n,r){var e=r(56);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n,r){var e=r(56);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(60),i=r(22),o=r(38),u={};r(13)(u,r(15)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,r){var e=r(19),i=r(9);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){var e=r(23)("meta"),i=r(21),o=r(8),u=r(14).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(18)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n,r){var e=r(14),i=r(20),o=r(19);t.exports=r(12)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(37),i=r(22),o=r(9),u=r(42),c=r(8),f=r(58),a=Object.getOwnPropertyDescriptor;n.f=r(12)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(9),i=r(61).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(8),i=r(77),o=r(39)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,r){var e=r(41),i=r(33);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(41),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n,r){var e=r(41),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){"use strict";var e=r(89),i=r(97),o=r(35),u=r(9);t.exports=r(59)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){},function(t,n,r){"use strict";var e=r(104)(!0);r(59)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";var e=r(5),i=r(8),o=r(12),u=r(51),c=r(64),f=r(99).KEY,a=r(18),s=r(40),l=r(38),h=r(23),v=r(15),p=r(44),d=r(43),y=r(98),g=r(92),b=r(95),m=r(20),x=r(9),w=r(42),S=r(22),_=r(60),O=r(102),E=r(101),P=r(14),j=r(19),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(61).f=O.f=Z,r(37).f=X,r(62).f=tt,o&&!r(36)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(13)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){r(43)("asyncIterator")},function(t,n,r){r(43)("observable")},function(t,n,r){r(107);for(var e=r(5),i=r(13),o=r(35),u=r(15)("toStringTag"),c=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],f=0;f<5;f++){var a=c[f],s=e[a],l=s&&s.prototype;l&&!l[u]&&i(l,u,a),o[a]=o.Array}},function(t,n,r){var e=r(45),i=r(7)("toStringTag"),o="Arguments"==e(function(){return arguments}()),u=function(t,n){try{return t[n]}catch(t){}};t.exports=function(t){var n,r,c;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=u(n=Object(t),i))?r:o?e(n):"Object"==(c=e(n))&&"function"==typeof n.callee?"Arguments":c}},function(t,n,r){var e=r(45);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(30),i=r(16),o=r(75);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){"use strict";var e=r(3),i=r(1),o=r(28),u=r(73),c=r(65),f=r(79),a=r(68),s=r(6),l=r(4),h=r(123),v=r(81),p=r(136);t.exports=function(t,n,r,d,y,g){var b=e[t],m=b,x=y?"set":"add",w=m&&m.prototype,S={},_=function(t){var n=w[t];o(w,t,"delete"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"has"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"get"==t?function(t){return g&&!s(t)?void 0:n.call(this,0===t?0:t)}:"add"==t?function(t){return n.call(this,0===t?0:t),this}:function(t,r){return n.call(this,0===t?0:t,r),this})};if("function"==typeof m&&(g||w.forEach&&!l(function(){(new m).entries().next()}))){var O=new m,E=O[x](g?{}:-0,1)!=O,P=l(function(){O.has(1)}),j=h(function(t){new m(t)}),F=!g&&l(function(){for(var t=new m,n=5;n--;)t[x](n,n);return!t.has(-0)});j||(m=n(function(n,r){a(n,m,t);var e=p(new b,n,m);return void 0!=r&&f(r,y,e[x],e),e}),m.prototype=w,w.constructor=m),(P||F)&&(_("delete"),_("has"),y&&_("get")),(F||E)&&_(x),g&&w.clear&&delete w.clear}else m=d.getConstructor(n,t,y,x),u(m.prototype,r),c.NEED=!0;return v(m,t),S[t]=m,i(i.G+i.W+i.F*(m!=b),S),g||d.setStrong(m,t,y),m}},function(t,n,r){"use strict";var e=r(27),i=r(28),o=r(4),u=r(46),c=r(7);t.exports=function(t,n,r){var f=c(t),a=r(u,f,""[t]),s=a[0],l=a[1];o(function(){var n={};return n[f]=function(){return 7},7!=""[t](n)})&&(i(String.prototype,t,s),e(RegExp.prototype,f,2==n?function(t,n){return l.call(t,this,n)}:function(t){return l.call(t,this)}))}
},function(t,n,r){"use strict";var e=r(2);t.exports=function(){var t=e(this),n="";return t.global&&(n+="g"),t.ignoreCase&&(n+="i"),t.multiline&&(n+="m"),t.unicode&&(n+="u"),t.sticky&&(n+="y"),n}},function(t,n){t.exports=function(t,n,r){var e=void 0===r;switch(n.length){case 0:return e?t():t.call(r);case 1:return e?t(n[0]):t.call(r,n[0]);case 2:return e?t(n[0],n[1]):t.call(r,n[0],n[1]);case 3:return e?t(n[0],n[1],n[2]):t.call(r,n[0],n[1],n[2]);case 4:return e?t(n[0],n[1],n[2],n[3]):t.call(r,n[0],n[1],n[2],n[3])}return t.apply(r,n)}},function(t,n,r){var e=r(6),i=r(45),o=r(7)("match");t.exports=function(t){var n;return e(t)&&(void 0!==(n=t[o])?!!n:"RegExp"==i(t))}},function(t,n,r){var e=r(7)("iterator"),i=!1;try{var o=[7][e]();o.return=function(){i=!0},Array.from(o,function(){throw 2})}catch(t){}t.exports=function(t,n){if(!n&&!i)return!1;var r=!1;try{var o=[7],u=o[e]();u.next=function(){return{done:r=!0}},o[e]=function(){return u},t(o)}catch(t){}return r}},function(t,n,r){t.exports=r(69)||!r(4)(function(){var t=Math.random();__defineSetter__.call(null,t,function(){}),delete r(3)[t]})},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(3),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n,r){for(var e,i=r(3),o=r(27),u=r(76),c=u("typed_array"),f=u("view"),a=!(!i.ArrayBuffer||!i.DataView),s=a,l=0,h="Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(",");l<9;)(e=i[h[l++]])?(o(e.prototype,c,!0),o(e.prototype,f,!0)):s=!1;t.exports={ABV:a,CONSTR:s,TYPED:c,VIEW:f}},function(t,n){"use strict";var r={versions:function(){var t=window.navigator.userAgent;return{trident:t.indexOf("Trident")>-1,presto:t.indexOf("Presto")>-1,webKit:t.indexOf("AppleWebKit")>-1,gecko:t.indexOf("Gecko")>-1&&-1==t.indexOf("KHTML"),mobile:!!t.match(/AppleWebKit.*Mobile.*/),ios:!!t.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:t.indexOf("Android")>-1||t.indexOf("Linux")>-1,iPhone:t.indexOf("iPhone")>-1||t.indexOf("Mac")>-1,iPad:t.indexOf("iPad")>-1,webApp:-1==t.indexOf("Safari"),weixin:-1==t.indexOf("MicroMessenger")}}()};t.exports=r},function(t,n,r){"use strict";var e=r(85),i=function(t){return t&&t.__esModule?t:{default:t}}(e),o=function(){function t(t,n,e){return n||e?String.fromCharCode(n||e):r[t]||t}function n(t){return e[t]}var r={"&quot;":'"',"&lt;":"<","&gt;":">","&amp;":"&","&nbsp;":" "},e={};for(var u in r)e[r[u]]=u;return r["&apos;"]="'",e["'"]="&#39;",{encode:function(t){return t?(""+t).replace(/['<> "&]/g,n).replace(/\r?\n/g,"<br/>").replace(/\s/g,"&nbsp;"):""},decode:function(n){return n?(""+n).replace(/<br\s*\/?>/gi,"\n").replace(/&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,t).replace(/\u00a0/g," "):""},encodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},encodeBase16forJSON:function(t){if(!t)return t;t=t.replace(/[\u4E00-\u9FBF]/gi,function(t){return escape(t).replace("%u","\\u")});for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},decodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r+=2)n.push(String.fromCharCode("0x"+t.slice(r,r+2)));return n.join("")},encodeObject:function(t){if(t instanceof Array)for(var n=0,r=t.length;r>n;n++)t[n]=o.encodeObject(t[n]);else if("object"==(void 0===t?"undefined":(0,i.default)(t)))for(var e in t)t[e]=o.encodeObject(t[e]);else if("string"==typeof t)return o.encode(t);return t},loadScript:function(t){var n=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(n),n.setAttribute("src",t)},addLoadEvent:function(t){var n=window.onload;"function"!=typeof window.onload?window.onload=t:window.onload=function(){n(),t()}}}}();t.exports=o},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=function(t){for(var n=e(this),r=o(n.length),u=arguments.length,c=i(u>1?arguments[1]:void 0,r),f=u>2?arguments[2]:void 0,a=void 0===f?r:i(f,r);a>c;)n[c++]=t;return n}},function(t,n,r){"use strict";var e=r(11),i=r(66);t.exports=function(t,n,r){n in t?e.f(t,n,i(0,r)):t[n]=r}},function(t,n,r){var e=r(6),i=r(3).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n,r){var e=r(7)("match");t.exports=function(t){var n=/./;try{"/./"[t](n)}catch(r){try{return n[e]=!1,!"/./"[t](n)}catch(t){}}return!0}},function(t,n,r){t.exports=r(3).document&&document.documentElement},function(t,n,r){var e=r(6),i=r(144).set;t.exports=function(t,n,r){var o,u=n.constructor;return u!==r&&"function"==typeof u&&(o=u.prototype)!==r.prototype&&e(o)&&i&&i(t,o),t}},function(t,n,r){var e=r(80),i=r(7)("iterator"),o=Array.prototype;t.exports=function(t){return void 0!==t&&(e.Array===t||o[i]===t)}},function(t,n,r){var e=r(45);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(70),i=r(66),o=r(81),u={};r(27)(u,r(7)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n,r){"use strict";var e=r(69),i=r(1),o=r(28),u=r(27),c=r(24),f=r(80),a=r(139),s=r(81),l=r(32),h=r(7)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n){var r=Math.expm1;t.exports=!r||r(10)>22025.465794806718||r(10)<22025.465794806718||-2e-17!=r(-2e-17)?function(t){return 0==(t=+t)?t:t>-1e-6&&t<1e-6?t+t*t/2:Math.exp(t)-1}:r},function(t,n){t.exports=Math.sign||function(t){return 0==(t=+t)||t!=t?t:t<0?-1:1}},function(t,n,r){var e=r(3),i=r(151).set,o=e.MutationObserver||e.WebKitMutationObserver,u=e.process,c=e.Promise,f="process"==r(45)(u);t.exports=function(){var t,n,r,a=function(){var e,i;for(f&&(e=u.domain)&&e.exit();t;){i=t.fn,t=t.next;try{i()}catch(e){throw t?r():n=void 0,e}}n=void 0,e&&e.enter()};if(f)r=function(){u.nextTick(a)};else if(o){var s=!0,l=document.createTextNode("");new o(a).observe(l,{characterData:!0}),r=function(){l.data=s=!s}}else if(c&&c.resolve){var h=c.resolve();r=function(){h.then(a)}}else r=function(){i.call(e,a)};return function(e){var i={fn:e,next:void 0};n&&(n.next=i),t||(t=i,r()),n=i}}},function(t,n,r){var e=r(6),i=r(2),o=function(t,n){if(i(t),!e(n)&&null!==n)throw TypeError(n+": can't set as prototype!")};t.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(t,n,e){try{e=r(53)(Function.call,r(31).f(Object.prototype,"__proto__").set,2),e(t,[]),n=!(t instanceof Array)}catch(t){n=!0}return function(t,r){return o(t,r),n?t.__proto__=r:e(t,r),t}}({},!1):void 0),check:o}},function(t,n,r){var e=r(126)("keys"),i=r(76);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(2),i=r(26),o=r(7)("species");t.exports=function(t,n){var r,u=e(t).constructor;return void 0===u||void 0==(r=e(u)[o])?n:i(r)}},function(t,n,r){var e=r(67),i=r(46);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(122),i=r(46);t.exports=function(t,n,r){if(e(n))throw TypeError("String#"+r+" doesn't accept regex!");return String(i(t))}},function(t,n,r){"use strict";var e=r(67),i=r(46);t.exports=function(t){var n=String(i(this)),r="",o=e(t);if(o<0||o==1/0)throw RangeError("Count can't be negative");for(;o>0;(o>>>=1)&&(n+=n))1&o&&(r+=n);return r}},function(t,n){t.exports="\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"},function(t,n,r){var e,i,o,u=r(53),c=r(121),f=r(135),a=r(132),s=r(3),l=s.process,h=s.setImmediate,v=s.clearImmediate,p=s.MessageChannel,d=0,y={},g="onreadystatechange",b=function(){var t=+this;if(y.hasOwnProperty(t)){var n=y[t];delete y[t],n()}},m=function(t){b.call(t.data)};h&&v||(h=function(t){for(var n=[],r=1;arguments.length>r;)n.push(arguments[r++]);return y[++d]=function(){c("function"==typeof t?t:Function(t),n)},e(d),d},v=function(t){delete y[t]},"process"==r(45)(l)?e=function(t){l.nextTick(u(b,t,1))}:p?(i=new p,o=i.port2,i.port1.onmessage=m,e=u(o.postMessage,o,1)):s.addEventListener&&"function"==typeof postMessage&&!s.importScripts?(e=function(t){s.postMessage(t+"","*")},s.addEventListener("message",m,!1)):e=g in a("script")?function(t){f.appendChild(a("script"))[g]=function(){f.removeChild(this),b.call(t)}}:function(t){setTimeout(u(b,t,1),0)}),t.exports={set:h,clear:v}},function(t,n,r){"use strict";var e=r(3),i=r(10),o=r(69),u=r(127),c=r(27),f=r(73),a=r(4),s=r(68),l=r(67),h=r(16),v=r(71).f,p=r(11).f,d=r(130),y=r(81),g="ArrayBuffer",b="DataView",m="prototype",x="Wrong length!",w="Wrong index!",S=e[g],_=e[b],O=e.Math,E=e.RangeError,P=e.Infinity,j=S,F=O.abs,M=O.pow,A=O.floor,N=O.log,T=O.LN2,I="buffer",k="byteLength",L="byteOffset",R=i?"_b":I,C=i?"_l":k,D=i?"_o":L,U=function(t,n,r){var e,i,o,u=Array(r),c=8*r-n-1,f=(1<<c)-1,a=f>>1,s=23===n?M(2,-24)-M(2,-77):0,l=0,h=t<0||0===t&&1/t<0?1:0;for(t=F(t),t!=t||t===P?(i=t!=t?1:0,e=f):(e=A(N(t)/T),t*(o=M(2,-e))<1&&(e--,o*=2),t+=e+a>=1?s/o:s*M(2,1-a),t*o>=2&&(e++,o/=2),e+a>=f?(i=0,e=f):e+a>=1?(i=(t*o-1)*M(2,n),e+=a):(i=t*M(2,a-1)*M(2,n),e=0));n>=8;u[l++]=255&i,i/=256,n-=8);for(e=e<<n|i,c+=n;c>0;u[l++]=255&e,e/=256,c-=8);return u[--l]|=128*h,u},W=function(t,n,r){var e,i=8*r-n-1,o=(1<<i)-1,u=o>>1,c=i-7,f=r-1,a=t[f--],s=127&a;for(a>>=7;c>0;s=256*s+t[f],f--,c-=8);for(e=s&(1<<-c)-1,s>>=-c,c+=n;c>0;e=256*e+t[f],f--,c-=8);if(0===s)s=1-u;else{if(s===o)return e?NaN:a?-P:P;e+=M(2,n),s-=u}return(a?-1:1)*e*M(2,s-n)},G=function(t){return t[3]<<24|t[2]<<16|t[1]<<8|t[0]},B=function(t){return[255&t]},V=function(t){return[255&t,t>>8&255]},z=function(t){return[255&t,t>>8&255,t>>16&255,t>>24&255]},q=function(t){return U(t,52,8)},K=function(t){return U(t,23,4)},J=function(t,n,r){p(t[m],n,{get:function(){return this[r]}})},Y=function(t,n,r,e){var i=+r,o=l(i);if(i!=o||o<0||o+n>t[C])throw E(w);var u=t[R]._b,c=o+t[D],f=u.slice(c,c+n);return e?f:f.reverse()},H=function(t,n,r,e,i,o){var u=+r,c=l(u);if(u!=c||c<0||c+n>t[C])throw E(w);for(var f=t[R]._b,a=c+t[D],s=e(+i),h=0;h<n;h++)f[a+h]=s[o?h:n-h-1]},$=function(t,n){s(t,S,g);var r=+n,e=h(r);if(r!=e)throw E(x);return e};if(u.ABV){if(!a(function(){new S})||!a(function(){new S(.5)})){S=function(t){return new j($(this,t))};for(var X,Q=S[m]=j[m],Z=v(j),tt=0;Z.length>tt;)(X=Z[tt++])in S||c(S,X,j[X]);o||(Q.constructor=S)}var nt=new _(new S(2)),rt=_[m].setInt8;nt.setInt8(0,2147483648),nt.setInt8(1,2147483649),!nt.getInt8(0)&&nt.getInt8(1)||f(_[m],{setInt8:function(t,n){rt.call(this,t,n<<24>>24)},setUint8:function(t,n){rt.call(this,t,n<<24>>24)}},!0)}else S=function(t){var n=$(this,t);this._b=d.call(Array(n),0),this[C]=n},_=function(t,n,r){s(this,_,b),s(t,S,b);var e=t[C],i=l(n);if(i<0||i>e)throw E("Wrong offset!");if(r=void 0===r?e-i:h(r),i+r>e)throw E(x);this[R]=t,this[D]=i,this[C]=r},i&&(J(S,k,"_l"),J(_,I,"_b"),J(_,k,"_l"),J(_,L,"_o")),f(_[m],{getInt8:function(t){return Y(this,1,t)[0]<<24>>24},getUint8:function(t){return Y(this,1,t)[0]},getInt16:function(t){var n=Y(this,2,t,arguments[1]);return(n[1]<<8|n[0])<<16>>16},getUint16:function(t){var n=Y(this,2,t,arguments[1]);return n[1]<<8|n[0]},getInt32:function(t){return G(Y(this,4,t,arguments[1]))},getUint32:function(t){return G(Y(this,4,t,arguments[1]))>>>0},getFloat32:function(t){return W(Y(this,4,t,arguments[1]),23,4)},getFloat64:function(t){return W(Y(this,8,t,arguments[1]),52,8)},setInt8:function(t,n){H(this,1,t,B,n)},setUint8:function(t,n){H(this,1,t,B,n)},setInt16:function(t,n){H(this,2,t,V,n,arguments[2])},setUint16:function(t,n){H(this,2,t,V,n,arguments[2])},setInt32:function(t,n){H(this,4,t,z,n,arguments[2])},setUint32:function(t,n){H(this,4,t,z,n,arguments[2])},setFloat32:function(t,n){H(this,4,t,K,n,arguments[2])},setFloat64:function(t,n){H(this,8,t,q,n,arguments[2])}});y(S,g),y(_,b),c(_[m],u.VIEW,!0),n[g]=S,n[b]=_},function(t,n,r){var e=r(3),i=r(52),o=r(69),u=r(182),c=r(11).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){var e=r(114),i=r(7)("iterator"),o=r(80);t.exports=r(52).getIteratorMethod=function(t){if(void 0!=t)return t[i]||t["@@iterator"]||o[e(t)]}},function(t,n,r){"use strict";var e=r(78),i=r(170),o=r(80),u=r(30);t.exports=r(140)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){function r(t,n){t.classList?t.classList.add(n):t.className+=" "+n}t.exports=r},function(t,n){function r(t,n){if(t.classList)t.classList.remove(n);else{var r=new RegExp("(^|\\b)"+n.split(" ").join("|")+"(\\b|$)","gi");t.className=t.className.replace(r," ")}}t.exports=r},function(t,n){function r(){throw new Error("setTimeout has not been defined")}function e(){throw new Error("clearTimeout has not been defined")}function i(t){if(s===setTimeout)return setTimeout(t,0);if((s===r||!s)&&setTimeout)return s=setTimeout,setTimeout(t,0);try{return s(t,0)}catch(n){try{return s.call(null,t,0)}catch(n){return s.call(this,t,0)}}}function o(t){if(l===clearTimeout)return clearTimeout(t);if((l===e||!l)&&clearTimeout)return l=clearTimeout,clearTimeout(t);try{return l(t)}catch(n){try{return l.call(null,t)}catch(n){return l.call(this,t)}}}function u(){d&&v&&(d=!1,v.length?p=v.concat(p):y=-1,p.length&&c())}function c(){if(!d){var t=i(u);d=!0;for(var n=p.length;n;){for(v=p,p=[];++y<n;)v&&v[y].run();y=-1,n=p.length}v=null,d=!1,o(t)}}function f(t,n){this.fun=t,this.array=n}function a(){}var s,l,h=t.exports={};!function(){try{s="function"==typeof setTimeout?setTimeout:r}catch(t){s=r}try{l="function"==typeof clearTimeout?clearTimeout:e}catch(t){l=e}}();var v,p=[],d=!1,y=-1;h.nextTick=function(t){var n=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)n[r-1]=arguments[r];p.push(new f(t,n)),1!==p.length||d||i(c)},f.prototype.run=function(){this.fun.apply(null,this.array)},h.title="browser",h.browser=!0,h.env={},h.argv=[],h.version="",h.versions={},h.on=a,h.addListener=a,h.once=a,h.off=a,h.removeListener=a,h.removeAllListeners=a,h.emit=a,h.prependListener=a,h.prependOnceListener=a,h.listeners=function(t){return[]},h.binding=function(t){throw new Error("process.binding is not supported")},h.cwd=function(){return"/"},h.chdir=function(t){throw new Error("process.chdir is not supported")},h.umask=function(){return 0}},function(t,n,r){var e=r(45);t.exports=function(t,n){if("number"!=typeof t&&"Number"!=e(t))throw TypeError(n);return+t}},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=[].copyWithin||function(t,n){var r=e(this),u=o(r.length),c=i(t,u),f=i(n,u),a=arguments.length>2?arguments[2]:void 0,s=Math.min((void 0===a?u:i(a,u))-f,u-c),l=1;for(f<c&&c<f+s&&(l=-1,f+=s-1,c+=s-1);s-- >0;)f in r?r[c]=r[f]:delete r[c],c+=l,f+=l;return r}},function(t,n,r){var e=r(79);t.exports=function(t,n){var r=[];return e(t,!1,r.push,r,n),r}},function(t,n,r){var e=r(26),i=r(17),o=r(115),u=r(16);t.exports=function(t,n,r,c,f){e(n);var a=i(t),s=o(a),l=u(a.length),h=f?l-1:0,v=f?-1:1;if(r<2)for(;;){if(h in s){c=s[h],h+=v;break}if(h+=v,f?h<0:l<=h)throw TypeError("Reduce of empty array with no initial value")}for(;f?h>=0:l>h;h+=v)h in s&&(c=n(c,s[h],h,a));return c}},function(t,n,r){"use strict";var e=r(26),i=r(6),o=r(121),u=[].slice,c={},f=function(t,n,r){if(!(n in c)){for(var e=[],i=0;i<n;i++)e[i]="a["+i+"]";c[n]=Function("F,a","return new F("+e.join(",")+")")}return c[n](t,r)};t.exports=Function.bind||function(t){var n=e(this),r=u.call(arguments,1),c=function(){var e=r.concat(u.call(arguments));return this instanceof c?f(n,e.length,e):o(n,e,t)};return i(n.prototype)&&(c.prototype=n.prototype),c}},function(t,n,r){"use strict";var e=r(11).f,i=r(70),o=r(73),u=r(53),c=r(68),f=r(46),a=r(79),s=r(140),l=r(170),h=r(74),v=r(10),p=r(65).fastKey,d=v?"_s":"size",y=function(t,n){var r,e=p(n);if("F"!==e)return t._i[e];for(r=t._f;r;r=r.n)if(r.k==n)return r};t.exports={getConstructor:function(t,n,r,s){var l=t(function(t,e){c(t,l,n,"_i"),t._i=i(null),t._f=void 0,t._l=void 0,t[d]=0,void 0!=e&&a(e,r,t[s],t)});return o(l.prototype,{clear:function(){for(var t=this,n=t._i,r=t._f;r;r=r.n)r.r=!0,r.p&&(r.p=r.p.n=void 0),delete n[r.i];t._f=t._l=void 0,t[d]=0},delete:function(t){var n=this,r=y(n,t);if(r){var e=r.n,i=r.p;delete n._i[r.i],r.r=!0,i&&(i.n=e),e&&(e.p=i),n._f==r&&(n._f=e),n._l==r&&(n._l=i),n[d]--}return!!r},forEach:function(t){c(this,l,"forEach");for(var n,r=u(t,arguments.length>1?arguments[1]:void 0,3);n=n?n.n:this._f;)for(r(n.v,n.k,this);n&&n.r;)n=n.p},has:function(t){return!!y(this,t)}}),v&&e(l.prototype,"size",{get:function(){return f(this[d])}}),l},def:function(t,n,r){var e,i,o=y(t,n);return o?o.v=r:(t._l=o={i:i=p(n,!0),k:n,v:r,p:e=t._l,n:void 0,r:!1},t._f||(t._f=o),e&&(e.n=o),t[d]++,"F"!==i&&(t._i[i]=o)),t},getEntry:y,setStrong:function(t,n,r){s(t,n,function(t,n){this._t=t,this._k=n,this._l=void 0},function(){for(var t=this,n=t._k,r=t._l;r&&r.r;)r=r.p;return t._t&&(t._l=r=r?r.n:t._t._f)?"keys"==n?l(0,r.k):"values"==n?l(0,r.v):l(0,[r.k,r.v]):(t._t=void 0,l(1))},r?"entries":"values",!r,!0),h(n)}}},function(t,n,r){var e=r(114),i=r(161);t.exports=function(t){return function(){if(e(this)!=t)throw TypeError(t+"#toJSON isn't generic");return i(this)}}},function(t,n,r){"use strict";var e=r(73),i=r(65).getWeak,o=r(2),u=r(6),c=r(68),f=r(79),a=r(48),s=r(24),l=a(5),h=a(6),v=0,p=function(t){return t._l||(t._l=new d)},d=function(){this.a=[]},y=function(t,n){return l(t.a,function(t){return t[0]===n})};d.prototype={get:function(t){var n=y(this,t);if(n)return n[1]},has:function(t){return!!y(this,t)},set:function(t,n){var r=y(this,t);r?r[1]=n:this.a.push([t,n])},delete:function(t){var n=h(this.a,function(n){return n[0]===t});return~n&&this.a.splice(n,1),!!~n}},t.exports={getConstructor:function(t,n,r,o){var a=t(function(t,e){c(t,a,n,"_i"),t._i=v++,t._l=void 0,void 0!=e&&f(e,r,t[o],t)});return e(a.prototype,{delete:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).delete(t):n&&s(n,this._i)&&delete n[this._i]},has:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).has(t):n&&s(n,this._i)}}),a},def:function(t,n,r){var e=i(o(n),!0);return!0===e?p(t).set(n,r):e[t._i]=r,t},ufstore:p}},function(t,n,r){t.exports=!r(10)&&!r(4)(function(){return 7!=Object.defineProperty(r(132)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(6),i=Math.floor;t.exports=function(t){return!e(t)&&isFinite(t)&&i(t)===t}},function(t,n,r){var e=r(2);t.exports=function(t,n,r,i){try{return i?n(e(r)[0],r[1]):n(r)}catch(n){var o=t.return;throw void 0!==o&&e(o.call(t)),n}}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n){t.exports=Math.log1p||function(t){return(t=+t)>-1e-8&&t<1e-8?t-t*t/2:Math.log(1+t)}},function(t,n,r){"use strict";var e=r(72),i=r(125),o=r(116),u=r(17),c=r(115),f=Object.assign;t.exports=!f||r(4)(function(){var t={},n={},r=Symbol(),e="abcdefghijklmnopqrst";return t[r]=7,e.split("").forEach(function(t){n[t]=t}),7!=f({},t)[r]||Object.keys(f({},n)).join("")!=e})?function(t,n){for(var r=u(t),f=arguments.length,a=1,s=i.f,l=o.f;f>a;)for(var h,v=c(arguments[a++]),p=s?e(v).concat(s(v)):e(v),d=p.length,y=0;d>y;)l.call(v,h=p[y++])&&(r[h]=v[h]);return r}:f},function(t,n,r){var e=r(11),i=r(2),o=r(72);t.exports=r(10)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(30),i=r(71).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(24),i=r(30),o=r(117)(!1),u=r(145)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){var e=r(72),i=r(30),o=r(116).f;t.exports=function(t){return function(n){for(var r,u=i(n),c=e(u),f=c.length,a=0,s=[];f>a;)o.call(u,r=c[a++])&&s.push(t?[r,u[r]]:u[r]);return s}}},function(t,n,r){var e=r(71),i=r(125),o=r(2),u=r(3).Reflect;t.exports=u&&u.ownKeys||function(t){var n=e.f(o(t)),r=i.f;return r?n.concat(r(t)):n}},function(t,n,r){var e=r(3).parseFloat,i=r(82).trim;t.exports=1/e(r(150)+"-0")!=-1/0?function(t){var n=i(String(t),3),r=e(n);return 0===r&&"-"==n.charAt(0)?-0:r}:e},function(t,n,r){var e=r(3).parseInt,i=r(82).trim,o=r(150),u=/^[\-+]?0[xX]/;t.exports=8!==e(o+"08")||22!==e(o+"0x16")?function(t,n){var r=i(String(t),3);return e(r,n>>>0||(u.test(r)?16:10))}:e},function(t,n){t.exports=Object.is||function(t,n){return t===n?0!==t||1/t==1/n:t!=t&&n!=n}},function(t,n,r){var e=r(16),i=r(149),o=r(46);t.exports=function(t,n,r,u){var c=String(o(t)),f=c.length,a=void 0===r?" ":String(r),s=e(n);if(s<=f||""==a)return c;var l=s-f,h=i.call(a,Math.ceil(l/a.length));return h.length>l&&(h=h.slice(0,l)),u?h+c:c+h}},function(t,n,r){n.f=r(7)},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Map",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{get:function(t){var n=e.getEntry(this,t);return n&&n.v},set:function(t,n){return e.def(this,0===t?0:t,n)}},e,!0)},function(t,n,r){r(10)&&"g"!=/./g.flags&&r(11).f(RegExp.prototype,"flags",{configurable:!0,get:r(120)})},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Set",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t=0===t?0:t,t)}},e)},function(t,n,r){"use strict";var e,i=r(48)(0),o=r(28),u=r(65),c=r(172),f=r(166),a=r(6),s=u.getWeak,l=Object.isExtensible,h=f.ufstore,v={},p=function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},d={get:function(t){if(a(t)){var n=s(t);return!0===n?h(this).get(t):n?n[this._i]:void 0}},set:function(t,n){return f.def(this,t,n)}},y=t.exports=r(118)("WeakMap",p,d,f,!0,!0);7!=(new y).set((Object.freeze||Object)(v),7).get(v)&&(e=f.getConstructor(p),c(e.prototype,d),u.NEED=!0,i(["delete","has","get","set"],function(t){var n=y.prototype,r=n[t];o(n,t,function(n,i){if(a(n)&&!l(n)){this._f||(this._f=new e);var o=this._f[t](n,i);return"set"==t?this:o}return r.call(this,n,i)})}))},,,,function(t,n){"use strict";function r(){var t=document.querySelector("#page-nav");if(t&&!document.querySelector("#page-nav .extend.prev")&&(t.innerHTML='<a class="extend prev disabled" rel="prev">&laquo; Prev</a>'+t.innerHTML),t&&!document.querySelector("#page-nav .extend.next")&&(t.innerHTML=t.innerHTML+'<a class="extend next disabled" rel="next">Next &raquo;</a>'),yiliaConfig&&yiliaConfig.open_in_new){document.querySelectorAll(".article-entry a:not(.article-more-a)").forEach(function(t){var n=t.getAttribute("target");n&&""!==n||t.setAttribute("target","_blank")})}if(yiliaConfig&&yiliaConfig.toc_hide_index){document.querySelectorAll(".toc-number").forEach(function(t){t.style.display="none"})}var n=document.querySelector("#js-aboutme");n&&0!==n.length&&(n.innerHTML=n.innerText)}t.exports={init:r}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}function i(t,n){var r=/\/|index.html/g;return t.replace(r,"")===n.replace(r,"")}function o(){for(var t=document.querySelectorAll(".js-header-menu li a"),n=window.location.pathname,r=0,e=t.length;r<e;r++){var o=t[r];i(n,o.getAttribute("href"))&&(0,h.default)(o,"active")}}function u(t){for(var n=t.offsetLeft,r=t.offsetParent;null!==r;)n+=r.offsetLeft,r=r.offsetParent;return n}function c(t){for(var n=t.offsetTop,r=t.offsetParent;null!==r;)n+=r.offsetTop,r=r.offsetParent;return n}function f(t,n,r,e,i){var o=u(t),f=c(t)-n;if(f-r<=i){var a=t.$newDom;a||(a=t.cloneNode(!0),(0,d.default)(t,a),t.$newDom=a,a.style.position="fixed",a.style.top=(r||f)+"px",a.style.left=o+"px",a.style.zIndex=e||2,a.style.width="100%",a.style.color="#fff"),a.style.visibility="visible",t.style.visibility="hidden"}else{t.style.visibility="visible";var s=t.$newDom;s&&(s.style.visibility="hidden")}}function a(){var t=document.querySelector(".js-overlay"),n=document.querySelector(".js-header-menu");f(t,document.body.scrollTop,-63,2,0),f(n,document.body.scrollTop,1,3,0)}function s(){document.querySelector("#container").addEventListener("scroll",function(t){a()}),window.addEventListener("scroll",function(t){a()}),a()}var l=r(156),h=e(l),v=r(157),p=(e(v),r(382)),d=e(p),y=r(128),g=e(y),b=r(190),m=e(b),x=r(129);(function(){g.default.versions.mobile&&window.screen.width<800&&(o(),s())})(),(0,x.addLoadEvent)(function(){m.default.init()}),t.exports={}},,,,function(t,n,r){(function(t){"use strict";function n(t,n,r){t[n]||Object[e](t,n,{writable:!0,configurable:!0,value:r})}if(r(381),r(391),r(198),t._babelPolyfill)throw new Error("only one instance of babel-polyfill is allowed");t._babelPolyfill=!0;var e="defineProperty";n(String.prototype,"padLeft","".padStart),n(String.prototype,"padRight","".padEnd),"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function(t){[][t]&&n(Array,t,Function.call.bind([][t]))})}).call(n,function(){return this}())},,,function(t,n,r){r(210),t.exports=r(52).RegExp.escape},,,,function(t,n,r){var e=r(6),i=r(138),o=r(7)("species");t.exports=function(t){var n;return i(t)&&(n=t.constructor,"function"!=typeof n||n!==Array&&!i(n.prototype)||(n=void 0),e(n)&&null===(n=n[o])&&(n=void 0)),void 0===n?Array:n}},function(t,n,r){var e=r(202);t.exports=function(t,n){return new(e(t))(n)}},function(t,n,r){"use strict";var e=r(2),i=r(50),o="number";t.exports=function(t){if("string"!==t&&t!==o&&"default"!==t)throw TypeError("Incorrect hint");return i(e(this),t!=o)}},function(t,n,r){var e=r(72),i=r(125),o=r(116);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){var e=r(72),i=r(30);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){"use strict";var e=r(208),i=r(121),o=r(26);t.exports=function(){for(var t=o(this),n=arguments.length,r=Array(n),u=0,c=e._,f=!1;n>u;)(r[u]=arguments[u++])===c&&(f=!0);return function(){var e,o=this,u=arguments.length,a=0,s=0;if(!f&&!u)return i(t,r,o);if(e=r.slice(),f)for(;n>a;a++)e[a]===c&&(e[a]=arguments[s++]);for(;u>s;)e.push(arguments[s++]);return i(t,e,o)}}},function(t,n,r){t.exports=r(3)},function(t,n){t.exports=function(t,n){var r=n===Object(n)?function(t){return n[t]}:n;return function(n){return String(n).replace(t,r)}}},function(t,n,r){var e=r(1),i=r(209)(/[\\^$*+?.()|[\]{}]/g,"\\$&");e(e.S,"RegExp",{escape:function(t){return i(t)}})},function(t,n,r){var e=r(1);e(e.P,"Array",{copyWithin:r(160)}),r(78)("copyWithin")},function(t,n,r){"use strict";var e=r(1),i=r(48)(4);e(e.P+e.F*!r(47)([].every,!0),"Array",{every:function(t){return i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.P,"Array",{fill:r(130)}),r(78)("fill")},function(t,n,r){"use strict";var e=r(1),i=r(48)(2);e(e.P+e.F*!r(47)([].filter,!0),"Array",{filter:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(6),o="findIndex",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{findIndex:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(5),o="find",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{find:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(0),o=r(47)([].forEach,!0);e(e.P+e.F*!o,"Array",{forEach:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(53),i=r(1),o=r(17),u=r(169),c=r(137),f=r(16),a=r(131),s=r(154);i(i.S+i.F*!r(123)(function(t){Array.from(t)}),"Array",{from:function(t){var n,r,i,l,h=o(t),v="function"==typeof this?this:Array,p=arguments.length,d=p>1?arguments[1]:void 0,y=void 0!==d,g=0,b=s(h);if(y&&(d=e(d,p>2?arguments[2]:void 0,2)),void 0==b||v==Array&&c(b))for(n=f(h.length),r=new v(n);n>g;g++)a(r,g,y?d(h[g],g):h[g]);else for(l=b.call(h),r=new v;!(i=l.next()).done;g++)a(r,g,y?u(l,d,[i.value,g],!0):i.value);return r.length=g,r}})},function(t,n,r){"use strict";var e=r(1),i=r(117)(!1),o=[].indexOf,u=!!o&&1/[1].indexOf(1,-0)<0;e(e.P+e.F*(u||!r(47)(o)),"Array",{indexOf:function(t){return u?o.apply(this,arguments)||0:i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.S,"Array",{isArray:r(138)})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=[].join;e(e.P+e.F*(r(115)!=Object||!r(47)(o)),"Array",{join:function(t){return o.call(i(this),void 0===t?",":t)}})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=r(67),u=r(16),c=[].lastIndexOf,f=!!c&&1/[1].lastIndexOf(1,-0)<0;e(e.P+e.F*(f||!r(47)(c)),"Array",{lastIndexOf:function(t){if(f)return c.apply(this,arguments)||0;var n=i(this),r=u(n.length),e=r-1;for(arguments.length>1&&(e=Math.min(e,o(arguments[1]))),e<0&&(e=r+e);e>=0;e--)if(e in n&&n[e]===t)return e||0;return-1}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(1);e(e.P+e.F*!r(47)([].map,!0),"Array",{map:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(131);e(e.S+e.F*r(4)(function(){function t(){}return!(Array.of.call(t)instanceof t)}),"Array",{of:function(){for(var t=0,n=arguments.length,r=new("function"==typeof this?this:Array)(n);n>t;)i(r,t,arguments[t++]);return r.length=n,r}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduceRight,!0),"Array",{reduceRight:function(t){return i(this,t,arguments.length,arguments[1],!0)}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduce,!0),"Array",{reduce:function(t){return i(this,t,arguments.length,arguments[1],!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(135),o=r(45),u=r(75),c=r(16),f=[].slice;e(e.P+e.F*r(4)(function(){i&&f.call(i)}),"Array",{slice:function(t,n){var r=c(this.length),e=o(this);if(n=void 0===n?r:n,"Array"==e)return f.call(this,t,n);for(var i=u(t,r),a=u(n,r),s=c(a-i),l=Array(s),h=0;h<s;h++)l[h]="String"==e?this.charAt(i+h):this[i+h];return l}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(3);e(e.P+e.F*!r(47)([].some,!0),"Array",{some:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(26),o=r(17),u=r(4),c=[].sort,f=[1,2,3];e(e.P+e.F*(u(function(){f.sort(void 0)})||!u(function(){f.sort(null)})||!r(47)(c)),"Array",{sort:function(t){return void 0===t?c.call(o(this)):c.call(o(this),i(t))}})},function(t,n,r){r(74)("Array")},function(t,n,r){var e=r(1);e(e.S,"Date",{now:function(){return(new Date).getTime()}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=Date.prototype.getTime,u=function(t){return t>9?t:"0"+t};e(e.P+e.F*(i(function(){return"0385-07-25T07:06:39.999Z"!=new Date(-5e13-1).toISOString()})||!i(function(){new Date(NaN).toISOString()})),"Date",{toISOString:function(){
if(!isFinite(o.call(this)))throw RangeError("Invalid time value");var t=this,n=t.getUTCFullYear(),r=t.getUTCMilliseconds(),e=n<0?"-":n>9999?"+":"";return e+("00000"+Math.abs(n)).slice(e?-6:-4)+"-"+u(t.getUTCMonth()+1)+"-"+u(t.getUTCDate())+"T"+u(t.getUTCHours())+":"+u(t.getUTCMinutes())+":"+u(t.getUTCSeconds())+"."+(r>99?r:"0"+u(r))+"Z"}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50);e(e.P+e.F*r(4)(function(){return null!==new Date(NaN).toJSON()||1!==Date.prototype.toJSON.call({toISOString:function(){return 1}})}),"Date",{toJSON:function(t){var n=i(this),r=o(n);return"number"!=typeof r||isFinite(r)?n.toISOString():null}})},function(t,n,r){var e=r(7)("toPrimitive"),i=Date.prototype;e in i||r(27)(i,e,r(204))},function(t,n,r){var e=Date.prototype,i="Invalid Date",o="toString",u=e[o],c=e.getTime;new Date(NaN)+""!=i&&r(28)(e,o,function(){var t=c.call(this);return t===t?u.call(this):i})},function(t,n,r){var e=r(1);e(e.P,"Function",{bind:r(163)})},function(t,n,r){"use strict";var e=r(6),i=r(32),o=r(7)("hasInstance"),u=Function.prototype;o in u||r(11).f(u,o,{value:function(t){if("function"!=typeof this||!e(t))return!1;if(!e(this.prototype))return t instanceof this;for(;t=i(t);)if(this.prototype===t)return!0;return!1}})},function(t,n,r){var e=r(11).f,i=r(66),o=r(24),u=Function.prototype,c="name",f=Object.isExtensible||function(){return!0};c in u||r(10)&&e(u,c,{configurable:!0,get:function(){try{var t=this,n=(""+t).match(/^\s*function ([^ (]*)/)[1];return o(t,c)||!f(t)||e(t,c,i(5,n)),n}catch(t){return""}}})},function(t,n,r){var e=r(1),i=r(171),o=Math.sqrt,u=Math.acosh;e(e.S+e.F*!(u&&710==Math.floor(u(Number.MAX_VALUE))&&u(1/0)==1/0),"Math",{acosh:function(t){return(t=+t)<1?NaN:t>94906265.62425156?Math.log(t)+Math.LN2:i(t-1+o(t-1)*o(t+1))}})},function(t,n,r){function e(t){return isFinite(t=+t)&&0!=t?t<0?-e(-t):Math.log(t+Math.sqrt(t*t+1)):t}var i=r(1),o=Math.asinh;i(i.S+i.F*!(o&&1/o(0)>0),"Math",{asinh:e})},function(t,n,r){var e=r(1),i=Math.atanh;e(e.S+e.F*!(i&&1/i(-0)<0),"Math",{atanh:function(t){return 0==(t=+t)?t:Math.log((1+t)/(1-t))/2}})},function(t,n,r){var e=r(1),i=r(142);e(e.S,"Math",{cbrt:function(t){return i(t=+t)*Math.pow(Math.abs(t),1/3)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{clz32:function(t){return(t>>>=0)?31-Math.floor(Math.log(t+.5)*Math.LOG2E):32}})},function(t,n,r){var e=r(1),i=Math.exp;e(e.S,"Math",{cosh:function(t){return(i(t=+t)+i(-t))/2}})},function(t,n,r){var e=r(1),i=r(141);e(e.S+e.F*(i!=Math.expm1),"Math",{expm1:i})},function(t,n,r){var e=r(1),i=r(142),o=Math.pow,u=o(2,-52),c=o(2,-23),f=o(2,127)*(2-c),a=o(2,-126),s=function(t){return t+1/u-1/u};e(e.S,"Math",{fround:function(t){var n,r,e=Math.abs(t),o=i(t);return e<a?o*s(e/a/c)*a*c:(n=(1+c/u)*e,r=n-(n-e),r>f||r!=r?o*(1/0):o*r)}})},function(t,n,r){var e=r(1),i=Math.abs;e(e.S,"Math",{hypot:function(t,n){for(var r,e,o=0,u=0,c=arguments.length,f=0;u<c;)r=i(arguments[u++]),f<r?(e=f/r,o=o*e*e+1,f=r):r>0?(e=r/f,o+=e*e):o+=r;return f===1/0?1/0:f*Math.sqrt(o)}})},function(t,n,r){var e=r(1),i=Math.imul;e(e.S+e.F*r(4)(function(){return-5!=i(4294967295,5)||2!=i.length}),"Math",{imul:function(t,n){var r=65535,e=+t,i=+n,o=r&e,u=r&i;return 0|o*u+((r&e>>>16)*u+o*(r&i>>>16)<<16>>>0)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log10:function(t){return Math.log(t)/Math.LN10}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log1p:r(171)})},function(t,n,r){var e=r(1);e(e.S,"Math",{log2:function(t){return Math.log(t)/Math.LN2}})},function(t,n,r){var e=r(1);e(e.S,"Math",{sign:r(142)})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S+e.F*r(4)(function(){return-2e-17!=!Math.sinh(-2e-17)}),"Math",{sinh:function(t){return Math.abs(t=+t)<1?(i(t)-i(-t))/2:(o(t-1)-o(-t-1))*(Math.E/2)}})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S,"Math",{tanh:function(t){var n=i(t=+t),r=i(-t);return n==1/0?1:r==1/0?-1:(n-r)/(o(t)+o(-t))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{trunc:function(t){return(t>0?Math.floor:Math.ceil)(t)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(45),u=r(136),c=r(50),f=r(4),a=r(71).f,s=r(31).f,l=r(11).f,h=r(82).trim,v="Number",p=e[v],d=p,y=p.prototype,g=o(r(70)(y))==v,b="trim"in String.prototype,m=function(t){var n=c(t,!1);if("string"==typeof n&&n.length>2){n=b?n.trim():h(n,3);var r,e,i,o=n.charCodeAt(0);if(43===o||45===o){if(88===(r=n.charCodeAt(2))||120===r)return NaN}else if(48===o){switch(n.charCodeAt(1)){case 66:case 98:e=2,i=49;break;case 79:case 111:e=8,i=55;break;default:return+n}for(var u,f=n.slice(2),a=0,s=f.length;a<s;a++)if((u=f.charCodeAt(a))<48||u>i)return NaN;return parseInt(f,e)}}return+n};if(!p(" 0o1")||!p("0b1")||p("+0x1")){p=function(t){var n=arguments.length<1?0:t,r=this;return r instanceof p&&(g?f(function(){y.valueOf.call(r)}):o(r)!=v)?u(new d(m(n)),r,p):m(n)};for(var x,w=r(10)?a(d):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","),S=0;w.length>S;S++)i(d,x=w[S])&&!i(p,x)&&l(p,x,s(d,x));p.prototype=y,y.constructor=p,r(28)(e,v,p)}},function(t,n,r){var e=r(1);e(e.S,"Number",{EPSILON:Math.pow(2,-52)})},function(t,n,r){var e=r(1),i=r(3).isFinite;e(e.S,"Number",{isFinite:function(t){return"number"==typeof t&&i(t)}})},function(t,n,r){var e=r(1);e(e.S,"Number",{isInteger:r(168)})},function(t,n,r){var e=r(1);e(e.S,"Number",{isNaN:function(t){return t!=t}})},function(t,n,r){var e=r(1),i=r(168),o=Math.abs;e(e.S,"Number",{isSafeInteger:function(t){return i(t)&&o(t)<=9007199254740991}})},function(t,n,r){var e=r(1);e(e.S,"Number",{MAX_SAFE_INTEGER:9007199254740991})},function(t,n,r){var e=r(1);e(e.S,"Number",{MIN_SAFE_INTEGER:-9007199254740991})},function(t,n,r){var e=r(1),i=r(178);e(e.S+e.F*(Number.parseFloat!=i),"Number",{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.S+e.F*(Number.parseInt!=i),"Number",{parseInt:i})},function(t,n,r){"use strict";var e=r(1),i=r(67),o=r(159),u=r(149),c=1..toFixed,f=Math.floor,a=[0,0,0,0,0,0],s="Number.toFixed: incorrect invocation!",l="0",h=function(t,n){for(var r=-1,e=n;++r<6;)e+=t*a[r],a[r]=e%1e7,e=f(e/1e7)},v=function(t){for(var n=6,r=0;--n>=0;)r+=a[n],a[n]=f(r/t),r=r%t*1e7},p=function(){for(var t=6,n="";--t>=0;)if(""!==n||0===t||0!==a[t]){var r=String(a[t]);n=""===n?r:n+u.call(l,7-r.length)+r}return n},d=function(t,n,r){return 0===n?r:n%2==1?d(t,n-1,r*t):d(t*t,n/2,r)},y=function(t){for(var n=0,r=t;r>=4096;)n+=12,r/=4096;for(;r>=2;)n+=1,r/=2;return n};e(e.P+e.F*(!!c&&("0.000"!==8e-5.toFixed(3)||"1"!==.9.toFixed(0)||"1.25"!==1.255.toFixed(2)||"1000000000000000128"!==(0xde0b6b3a7640080).toFixed(0))||!r(4)(function(){c.call({})})),"Number",{toFixed:function(t){var n,r,e,c,f=o(this,s),a=i(t),g="",b=l;if(a<0||a>20)throw RangeError(s);if(f!=f)return"NaN";if(f<=-1e21||f>=1e21)return String(f);if(f<0&&(g="-",f=-f),f>1e-21)if(n=y(f*d(2,69,1))-69,r=n<0?f*d(2,-n,1):f/d(2,n,1),r*=4503599627370496,(n=52-n)>0){for(h(0,r),e=a;e>=7;)h(1e7,0),e-=7;for(h(d(10,e,1),0),e=n-1;e>=23;)v(1<<23),e-=23;v(1<<e),h(1,1),v(2),b=p()}else h(0,r),h(1<<-n,0),b=p()+u.call(l,a);return a>0?(c=b.length,b=g+(c<=a?"0."+u.call(l,a-c)+b:b.slice(0,c-a)+"."+b.slice(c-a))):b=g+b,b}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=r(159),u=1..toPrecision;e(e.P+e.F*(i(function(){return"1"!==u.call(1,void 0)})||!i(function(){u.call({})})),"Number",{toPrecision:function(t){var n=o(this,"Number#toPrecision: incorrect invocation!");return void 0===t?u.call(n):u.call(n,t)}})},function(t,n,r){var e=r(1);e(e.S+e.F,"Object",{assign:r(172)})},function(t,n,r){var e=r(1);e(e.S,"Object",{create:r(70)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperties:r(173)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperty:r(11).f})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("freeze",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(30),i=r(31).f;r(49)("getOwnPropertyDescriptor",function(){return function(t,n){return i(e(t),n)}})},function(t,n,r){r(49)("getOwnPropertyNames",function(){return r(174).f})},function(t,n,r){var e=r(17),i=r(32);r(49)("getPrototypeOf",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6);r(49)("isExtensible",function(t){return function(n){return!!e(n)&&(!t||t(n))}})},function(t,n,r){var e=r(6);r(49)("isFrozen",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(6);r(49)("isSealed",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(1);e(e.S,"Object",{is:r(180)})},function(t,n,r){var e=r(17),i=r(72);r(49)("keys",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("preventExtensions",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("seal",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(1);e(e.S,"Object",{setPrototypeOf:r(144).set})},function(t,n,r){"use strict";var e=r(114),i={};i[r(7)("toStringTag")]="z",i+""!="[object z]"&&r(28)(Object.prototype,"toString",function(){return"[object "+e(this)+"]"},!0)},function(t,n,r){var e=r(1),i=r(178);e(e.G+e.F*(parseFloat!=i),{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.G+e.F*(parseInt!=i),{parseInt:i})},function(t,n,r){"use strict";var e,i,o,u=r(69),c=r(3),f=r(53),a=r(114),s=r(1),l=r(6),h=r(26),v=r(68),p=r(79),d=r(146),y=r(151).set,g=r(143)(),b="Promise",m=c.TypeError,x=c.process,w=c[b],x=c.process,S="process"==a(x),_=function(){},O=!!function(){try{var t=w.resolve(1),n=(t.constructor={})[r(7)("species")]=function(t){t(_,_)};return(S||"function"==typeof PromiseRejectionEvent)&&t.then(_)instanceof n}catch(t){}}(),E=function(t,n){return t===n||t===w&&n===o},P=function(t){var n;return!(!l(t)||"function"!=typeof(n=t.then))&&n},j=function(t){return E(w,t)?new F(t):new i(t)},F=i=function(t){var n,r;this.promise=new t(function(t,e){if(void 0!==n||void 0!==r)throw m("Bad Promise constructor");n=t,r=e}),this.resolve=h(n),this.reject=h(r)},M=function(t){try{t()}catch(t){return{error:t}}},A=function(t,n){if(!t._n){t._n=!0;var r=t._c;g(function(){for(var e=t._v,i=1==t._s,o=0;r.length>o;)!function(n){var r,o,u=i?n.ok:n.fail,c=n.resolve,f=n.reject,a=n.domain;try{u?(i||(2==t._h&&I(t),t._h=1),!0===u?r=e:(a&&a.enter(),r=u(e),a&&a.exit()),r===n.promise?f(m("Promise-chain cycle")):(o=P(r))?o.call(r,c,f):c(r)):f(e)}catch(t){f(t)}}(r[o++]);t._c=[],t._n=!1,n&&!t._h&&N(t)})}},N=function(t){y.call(c,function(){var n,r,e,i=t._v;if(T(t)&&(n=M(function(){S?x.emit("unhandledRejection",i,t):(r=c.onunhandledrejection)?r({promise:t,reason:i}):(e=c.console)&&e.error&&e.error("Unhandled promise rejection",i)}),t._h=S||T(t)?2:1),t._a=void 0,n)throw n.error})},T=function(t){if(1==t._h)return!1;for(var n,r=t._a||t._c,e=0;r.length>e;)if(n=r[e++],n.fail||!T(n.promise))return!1;return!0},I=function(t){y.call(c,function(){var n;S?x.emit("rejectionHandled",t):(n=c.onrejectionhandled)&&n({promise:t,reason:t._v})})},k=function(t){var n=this;n._d||(n._d=!0,n=n._w||n,n._v=t,n._s=2,n._a||(n._a=n._c.slice()),A(n,!0))},L=function(t){var n,r=this;if(!r._d){r._d=!0,r=r._w||r;try{if(r===t)throw m("Promise can't be resolved itself");(n=P(t))?g(function(){var e={_w:r,_d:!1};try{n.call(t,f(L,e,1),f(k,e,1))}catch(t){k.call(e,t)}}):(r._v=t,r._s=1,A(r,!1))}catch(t){k.call({_w:r,_d:!1},t)}}};O||(w=function(t){v(this,w,b,"_h"),h(t),e.call(this);try{t(f(L,this,1),f(k,this,1))}catch(t){k.call(this,t)}},e=function(t){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1},e.prototype=r(73)(w.prototype,{then:function(t,n){var r=j(d(this,w));return r.ok="function"!=typeof t||t,r.fail="function"==typeof n&&n,r.domain=S?x.domain:void 0,this._c.push(r),this._a&&this._a.push(r),this._s&&A(this,!1),r.promise},catch:function(t){return this.then(void 0,t)}}),F=function(){var t=new e;this.promise=t,this.resolve=f(L,t,1),this.reject=f(k,t,1)}),s(s.G+s.W+s.F*!O,{Promise:w}),r(81)(w,b),r(74)(b),o=r(52)[b],s(s.S+s.F*!O,b,{reject:function(t){var n=j(this);return(0,n.reject)(t),n.promise}}),s(s.S+s.F*(u||!O),b,{resolve:function(t){if(t instanceof w&&E(t.constructor,this))return t;var n=j(this);return(0,n.resolve)(t),n.promise}}),s(s.S+s.F*!(O&&r(123)(function(t){w.all(t).catch(_)})),b,{all:function(t){var n=this,r=j(n),e=r.resolve,i=r.reject,o=M(function(){var r=[],o=0,u=1;p(t,!1,function(t){var c=o++,f=!1;r.push(void 0),u++,n.resolve(t).then(function(t){f||(f=!0,r[c]=t,--u||e(r))},i)}),--u||e(r)});return o&&i(o.error),r.promise},race:function(t){var n=this,r=j(n),e=r.reject,i=M(function(){p(t,!1,function(t){n.resolve(t).then(r.resolve,e)})});return i&&e(i.error),r.promise}})},function(t,n,r){var e=r(1),i=r(26),o=r(2),u=(r(3).Reflect||{}).apply,c=Function.apply;e(e.S+e.F*!r(4)(function(){u(function(){})}),"Reflect",{apply:function(t,n,r){var e=i(t),f=o(r);return u?u(e,n,f):c.call(e,n,f)}})},function(t,n,r){var e=r(1),i=r(70),o=r(26),u=r(2),c=r(6),f=r(4),a=r(163),s=(r(3).Reflect||{}).construct,l=f(function(){function t(){}return!(s(function(){},[],t)instanceof t)}),h=!f(function(){s(function(){})});e(e.S+e.F*(l||h),"Reflect",{construct:function(t,n){o(t),u(n);var r=arguments.length<3?t:o(arguments[2]);if(h&&!l)return s(t,n,r);if(t==r){switch(n.length){case 0:return new t;case 1:return new t(n[0]);case 2:return new t(n[0],n[1]);case 3:return new t(n[0],n[1],n[2]);case 4:return new t(n[0],n[1],n[2],n[3])}var e=[null];return e.push.apply(e,n),new(a.apply(t,e))}var f=r.prototype,v=i(c(f)?f:Object.prototype),p=Function.apply.call(t,v,n);return c(p)?p:v}})},function(t,n,r){var e=r(11),i=r(1),o=r(2),u=r(50);i(i.S+i.F*r(4)(function(){Reflect.defineProperty(e.f({},1,{value:1}),1,{value:2})}),"Reflect",{defineProperty:function(t,n,r){o(t),n=u(n,!0),o(r);try{return e.f(t,n,r),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(31).f,o=r(2);e(e.S,"Reflect",{deleteProperty:function(t,n){var r=i(o(t),n);return!(r&&!r.configurable)&&delete t[n]}})},function(t,n,r){"use strict";var e=r(1),i=r(2),o=function(t){this._t=i(t),this._i=0;var n,r=this._k=[];for(n in t)r.push(n)};r(139)(o,"Object",function(){var t,n=this,r=n._k;do{if(n._i>=r.length)return{value:void 0,done:!0}}while(!((t=r[n._i++])in n._t));return{value:t,done:!1}}),e(e.S,"Reflect",{enumerate:function(t){return new o(t)}})},function(t,n,r){var e=r(31),i=r(1),o=r(2);i(i.S,"Reflect",{getOwnPropertyDescriptor:function(t,n){return e.f(o(t),n)}})},function(t,n,r){var e=r(1),i=r(32),o=r(2);e(e.S,"Reflect",{getPrototypeOf:function(t){return i(o(t))}})},function(t,n,r){function e(t,n){var r,c,s=arguments.length<3?t:arguments[2];return a(t)===s?t[n]:(r=i.f(t,n))?u(r,"value")?r.value:void 0!==r.get?r.get.call(s):void 0:f(c=o(t))?e(c,n,s):void 0}var i=r(31),o=r(32),u=r(24),c=r(1),f=r(6),a=r(2);c(c.S,"Reflect",{get:e})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{has:function(t,n){return n in t}})},function(t,n,r){var e=r(1),i=r(2),o=Object.isExtensible;e(e.S,"Reflect",{isExtensible:function(t){return i(t),!o||o(t)}})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{ownKeys:r(177)})},function(t,n,r){var e=r(1),i=r(2),o=Object.preventExtensions;e(e.S,"Reflect",{preventExtensions:function(t){i(t);try{return o&&o(t),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(144);i&&e(e.S,"Reflect",{setPrototypeOf:function(t,n){i.check(t,n);try{return i.set(t,n),!0}catch(t){return!1}}})},function(t,n,r){function e(t,n,r){var f,h,v=arguments.length<4?t:arguments[3],p=o.f(s(t),n);if(!p){if(l(h=u(t)))return e(h,n,r,v);p=a(0)}return c(p,"value")?!(!1===p.writable||!l(v)||(f=o.f(v,n)||a(0),f.value=r,i.f(v,n,f),0)):void 0!==p.set&&(p.set.call(v,r),!0)}var i=r(11),o=r(31),u=r(32),c=r(24),f=r(1),a=r(66),s=r(2),l=r(6);f(f.S,"Reflect",{set:e})},function(t,n,r){var e=r(3),i=r(136),o=r(11).f,u=r(71).f,c=r(122),f=r(120),a=e.RegExp,s=a,l=a.prototype,h=/a/g,v=/a/g,p=new a(h)!==h;if(r(10)&&(!p||r(4)(function(){return v[r(7)("match")]=!1,a(h)!=h||a(v)==v||"/a/i"!=a(h,"i")}))){a=function(t,n){var r=this instanceof a,e=c(t),o=void 0===n;return!r&&e&&t.constructor===a&&o?t:i(p?new s(e&&!o?t.source:t,n):s((e=t instanceof a)?t.source:t,e&&o?f.call(t):n),r?this:l,a)};for(var d=u(s),y=0;d.length>y;)!function(t){t in a||o(a,t,{configurable:!0,get:function(){return s[t]},set:function(n){s[t]=n}})}(d[y++]);l.constructor=a,a.prototype=l,r(28)(e,"RegExp",a)}r(74)("RegExp")},function(t,n,r){r(119)("match",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("replace",2,function(t,n,r){return[function(e,i){"use strict";var o=t(this),u=void 0==e?void 0:e[n];return void 0!==u?u.call(e,o,i):r.call(String(o),e,i)},r]})},function(t,n,r){r(119)("search",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("split",2,function(t,n,e){"use strict";var i=r(122),o=e,u=[].push,c="split",f="length",a="lastIndex";if("c"=="abbc"[c](/(b)*/)[1]||4!="test"[c](/(?:)/,-1)[f]||2!="ab"[c](/(?:ab)*/)[f]||4!="."[c](/(.?)(.?)/)[f]||"."[c](/()()/)[f]>1||""[c](/.?/)[f]){var s=void 0===/()??/.exec("")[1];e=function(t,n){var r=String(this);if(void 0===t&&0===n)return[];if(!i(t))return o.call(r,t,n);var e,c,l,h,v,p=[],d=(t.ignoreCase?"i":"")+(t.multiline?"m":"")+(t.unicode?"u":"")+(t.sticky?"y":""),y=0,g=void 0===n?4294967295:n>>>0,b=new RegExp(t.source,d+"g");for(s||(e=new RegExp("^"+b.source+"$(?!\\s)",d));(c=b.exec(r))&&!((l=c.index+c[0][f])>y&&(p.push(r.slice(y,c.index)),!s&&c[f]>1&&c[0].replace(e,function(){for(v=1;v<arguments[f]-2;v++)void 0===arguments[v]&&(c[v]=void 0)}),c[f]>1&&c.index<r[f]&&u.apply(p,c.slice(1)),h=c[0][f],y=l,p[f]>=g));)b[a]===c.index&&b[a]++;return y===r[f]?!h&&b.test("")||p.push(""):p.push(r.slice(y)),p[f]>g?p.slice(0,g):p}}else"0"[c](void 0,0)[f]&&(e=function(t,n){return void 0===t&&0===n?[]:o.call(this,t,n)});return[function(r,i){var o=t(this),u=void 0==r?void 0:r[n];return void 0!==u?u.call(r,o,i):e.call(String(o),r,i)},e]})},function(t,n,r){"use strict";r(184);var e=r(2),i=r(120),o=r(10),u="toString",c=/./[u],f=function(t){r(28)(RegExp.prototype,u,t,!0)};r(4)(function(){return"/a/b"!=c.call({source:"a",flags:"b"})})?f(function(){var t=e(this);return"/".concat(t.source,"/","flags"in t?t.flags:!o&&t instanceof RegExp?i.call(t):void 0)}):c.name!=u&&f(function(){return c.call(this)})},function(t,n,r){"use strict";r(29)("anchor",function(t){return function(n){return t(this,"a","name",n)}})},function(t,n,r){"use strict";r(29)("big",function(t){return function(){return t(this,"big","","")}})},function(t,n,r){"use strict";r(29)("blink",function(t){return function(){return t(this,"blink","","")}})},function(t,n,r){"use strict";r(29)("bold",function(t){return function(){return t(this,"b","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!1);e(e.P,"String",{codePointAt:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="endsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{endsWith:function(t){var n=o(this,t,u),r=arguments.length>1?arguments[1]:void 0,e=i(n.length),f=void 0===r?e:Math.min(i(r),e),a=String(t);return c?c.call(n,a,f):n.slice(f-a.length,f)===a}})},function(t,n,r){"use strict";r(29)("fixed",function(t){return function(){return t(this,"tt","","")}})},function(t,n,r){"use strict";r(29)("fontcolor",function(t){return function(n){return t(this,"font","color",n)}})},function(t,n,r){"use strict";r(29)("fontsize",function(t){return function(n){return t(this,"font","size",n)}})},function(t,n,r){var e=r(1),i=r(75),o=String.fromCharCode,u=String.fromCodePoint;e(e.S+e.F*(!!u&&1!=u.length),"String",{fromCodePoint:function(t){for(var n,r=[],e=arguments.length,u=0;e>u;){if(n=+arguments[u++],i(n,1114111)!==n)throw RangeError(n+" is not a valid code point");r.push(n<65536?o(n):o(55296+((n-=65536)>>10),n%1024+56320))}return r.join("")}})},function(t,n,r){"use strict";var e=r(1),i=r(148),o="includes";e(e.P+e.F*r(134)(o),"String",{includes:function(t){return!!~i(this,t,o).indexOf(t,arguments.length>1?arguments[1]:void 0)}})},function(t,n,r){"use strict";r(29)("italics",function(t){return function(){return t(this,"i","","")}})},function(t,n,r){"use strict";var e=r(147)(!0);r(140)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";r(29)("link",function(t){return function(n){return t(this,"a","href",n)}})},function(t,n,r){var e=r(1),i=r(30),o=r(16);e(e.S,"String",{raw:function(t){for(var n=i(t.raw),r=o(n.length),e=arguments.length,u=[],c=0;r>c;)u.push(String(n[c++])),c<e&&u.push(String(arguments[c]));return u.join("")}})},function(t,n,r){var e=r(1);e(e.P,"String",{repeat:r(149)})},function(t,n,r){"use strict";r(29)("small",function(t){return function(){return t(this,"small","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="startsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{startsWith:function(t){var n=o(this,t,u),r=i(Math.min(arguments.length>1?arguments[1]:void 0,n.length)),e=String(t);return c?c.call(n,e,r):n.slice(r,r+e.length)===e}})},function(t,n,r){"use strict";r(29)("strike",function(t){return function(){return t(this,"strike","","")}})},function(t,n,r){"use strict";r(29)("sub",function(t){return function(){return t(this,"sub","","")}})},function(t,n,r){"use strict";r(29)("sup",function(t){return function(){return t(this,"sup","","")}})},function(t,n,r){"use strict";r(82)("trim",function(t){return function(){return t(this,3)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(10),u=r(1),c=r(28),f=r(65).KEY,a=r(4),s=r(126),l=r(81),h=r(76),v=r(7),p=r(182),d=r(153),y=r(206),g=r(205),b=r(138),m=r(2),x=r(30),w=r(50),S=r(66),_=r(70),O=r(174),E=r(31),P=r(11),j=r(72),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(71).f=O.f=Z,r(116).f=X,r(125).f=tt,o&&!r(69)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(27)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){"use strict";var e=r(1),i=r(127),o=r(152),u=r(2),c=r(75),f=r(16),a=r(6),s=r(3).ArrayBuffer,l=r(146),h=o.ArrayBuffer,v=o.DataView,p=i.ABV&&s.isView,d=h.prototype.slice,y=i.VIEW,g="ArrayBuffer";e(e.G+e.W+e.F*(s!==h),{ArrayBuffer:h}),e(e.S+e.F*!i.CONSTR,g,{isView:function(t){return p&&p(t)||a(t)&&y in t}}),e(e.P+e.U+e.F*r(4)(function(){return!new h(2).slice(1,void 0).byteLength}),g,{slice:function(t,n){if(void 0!==d&&void 0===n)return d.call(u(this),t);for(var r=u(this).byteLength,e=c(t,r),i=c(void 0===n?r:n,r),o=new(l(this,h))(f(i-e)),a=new v(this),s=new v(o),p=0;e<i;)s.setUint8(p++,a.getUint8(e++));return o}}),r(74)(g)},function(t,n,r){var e=r(1);e(e.G+e.W+e.F*!r(127).ABV,{DataView:r(152).DataView})},function(t,n,r){r(55)("Float32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Float64",8,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}},!0)},function(t,n,r){"use strict";var e=r(166);r(118)("WeakSet",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t,!0)}},e,!1,!0)},function(t,n,r){"use strict";var e=r(1),i=r(117)(!0);e(e.P,"Array",{includes:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)("includes")},function(t,n,r){var e=r(1),i=r(143)(),o=r(3).process,u="process"==r(45)(o);e(e.G,{asap:function(t){var n=u&&o.domain;i(n?n.bind(t):t)}})},function(t,n,r){var e=r(1),i=r(45);e(e.S,"Error",{isError:function(t){return"Error"===i(t)}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Map",{toJSON:r(165)("Map")})},function(t,n,r){var e=r(1);e(e.S,"Math",{iaddh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o+(e>>>0)+((i&u|(i|u)&~(i+u>>>0))>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{imulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>16,f=i>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>16)+((o*f>>>0)+(a&r)>>16)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{isubh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o-(e>>>0)-((~i&u|~(i^u)&i-u>>>0)>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{umulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>>16,f=i>>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>>16)+((o*f>>>0)+(a&r)>>>16)}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineGetter__:function(t,n){u.f(i(this),t,{get:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineSetter__:function(t,n){u.f(i(this),t,{set:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){var e=r(1),i=r(176)(!0);e(e.S,"Object",{entries:function(t){return i(t)}})},function(t,n,r){var e=r(1),i=r(177),o=r(30),u=r(31),c=r(131);e(e.S,"Object",{getOwnPropertyDescriptors:function(t){for(var n,r=o(t),e=u.f,f=i(r),a={},s=0;f.length>s;)c(a,n=f[s++],e(r,n));return a}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupGetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.get}while(r=u(r))}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupSetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.set}while(r=u(r))}})},function(t,n,r){var e=r(1),i=r(176)(!1);e(e.S,"Object",{values:function(t){return i(t)}})},function(t,n,r){"use strict";var e=r(1),i=r(3),o=r(52),u=r(143)(),c=r(7)("observable"),f=r(26),a=r(2),s=r(68),l=r(73),h=r(27),v=r(79),p=v.RETURN,d=function(t){return null==t?void 0:f(t)},y=function(t){var n=t._c;n&&(t._c=void 0,n())},g=function(t){return void 0===t._o},b=function(t){g(t)||(t._o=void 0,y(t))},m=function(t,n){a(t),this._c=void 0,this._o=t,t=new x(this);try{var r=n(t),e=r;null!=r&&("function"==typeof r.unsubscribe?r=function(){e.unsubscribe()}:f(r),this._c=r)}catch(n){return void t.error(n)}g(this)&&y(this)};m.prototype=l({},{unsubscribe:function(){b(this)}});var x=function(t){this._s=t};x.prototype=l({},{next:function(t){var n=this._s;if(!g(n)){var r=n._o;try{var e=d(r.next);if(e)return e.call(r,t)}catch(t){try{b(n)}finally{throw t}}}},error:function(t){var n=this._s;if(g(n))throw t;var r=n._o;n._o=void 0;try{var e=d(r.error);if(!e)throw t;t=e.call(r,t)}catch(t){try{y(n)}finally{throw t}}return y(n),t},complete:function(t){var n=this._s;if(!g(n)){var r=n._o;n._o=void 0;try{var e=d(r.complete);t=e?e.call(r,t):void 0}catch(t){try{y(n)}finally{throw t}}return y(n),t}}});var w=function(t){s(this,w,"Observable","_f")._f=f(t)};l(w.prototype,{subscribe:function(t){return new m(t,this._f)},forEach:function(t){var n=this;return new(o.Promise||i.Promise)(function(r,e){f(t);var i=n.subscribe({next:function(n){try{return t(n)}catch(t){e(t),i.unsubscribe()}},error:e,complete:r})})}}),l(w,{from:function(t){var n="function"==typeof this?this:w,r=d(a(t)[c]);if(r){var e=a(r.call(t));return e.constructor===n?e:new n(function(t){return e.subscribe(t)})}return new n(function(n){var r=!1;return u(function(){if(!r){try{if(v(t,!1,function(t){if(n.next(t),r)return p})===p)return}catch(t){if(r)throw t;return void n.error(t)}n.complete()}}),function(){r=!0}})},of:function(){for(var t=0,n=arguments.length,r=Array(n);t<n;)r[t]=arguments[t++];return new("function"==typeof this?this:w)(function(t){var n=!1;return u(function(){if(!n){for(var e=0;e<r.length;++e)if(t.next(r[e]),n)return;t.complete()}}),function(){n=!0}})}}),h(w.prototype,c,function(){return this}),e(e.G,{Observable:w}),r(74)("Observable")},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.set;e.exp({defineMetadata:function(t,n,r,e){u(t,n,i(r),o(e))}})},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.map,c=e.store;e.exp({deleteMetadata:function(t,n){var r=arguments.length<3?void 0:o(arguments[2]),e=u(i(n),r,!1);if(void 0===e||!e.delete(t))return!1;if(e.size)return!0;var f=c.get(n);return f.delete(r),!!f.size||c.delete(n)}})},function(t,n,r){var e=r(185),i=r(161),o=r(54),u=r(2),c=r(32),f=o.keys,a=o.key,s=function(t,n){var r=f(t,n),o=c(t);if(null===o)return r;var u=s(o,n);return u.length?r.length?i(new e(r.concat(u))):u:r};o.exp({getMetadataKeys:function(t){return s(u(t),arguments.length<2?void 0:a(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.get,f=e.key,a=function(t,n,r){if(u(t,n,r))return c(t,n,r);var e=o(n);return null!==e?a(t,e,r):void 0};e.exp({getMetadata:function(t,n){return a(t,i(n),arguments.length<3?void 0:f(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.keys,u=e.key;e.exp({getOwnMetadataKeys:function(t){
return o(i(t),arguments.length<2?void 0:u(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.get,u=e.key;e.exp({getOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.key,f=function(t,n,r){if(u(t,n,r))return!0;var e=o(n);return null!==e&&f(t,e,r)};e.exp({hasMetadata:function(t,n){return f(t,i(n),arguments.length<3?void 0:c(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.has,u=e.key;e.exp({hasOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(26),u=e.key,c=e.set;e.exp({metadata:function(t,n){return function(r,e){c(t,n,(void 0!==e?i:o)(r),u(e))}}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Set",{toJSON:r(165)("Set")})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!0);e(e.P,"String",{at:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(46),o=r(16),u=r(122),c=r(120),f=RegExp.prototype,a=function(t,n){this._r=t,this._s=n};r(139)(a,"RegExp String",function(){var t=this._r.exec(this._s);return{value:t,done:null===t}}),e(e.P,"String",{matchAll:function(t){if(i(this),!u(t))throw TypeError(t+" is not a regexp!");var n=String(this),r="flags"in f?String(t.flags):c.call(t),e=new RegExp(t.source,~r.indexOf("g")?r:"g"+r);return e.lastIndex=o(t.lastIndex),new a(e,n)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padEnd:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padStart:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!0)}})},function(t,n,r){"use strict";r(82)("trimLeft",function(t){return function(){return t(this,1)}},"trimStart")},function(t,n,r){"use strict";r(82)("trimRight",function(t){return function(){return t(this,2)}},"trimEnd")},function(t,n,r){r(153)("asyncIterator")},function(t,n,r){r(153)("observable")},function(t,n,r){var e=r(1);e(e.S,"System",{global:r(3)})},function(t,n,r){for(var e=r(155),i=r(28),o=r(3),u=r(27),c=r(80),f=r(7),a=f("iterator"),s=f("toStringTag"),l=c.Array,h=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],v=0;v<5;v++){var p,d=h[v],y=o[d],g=y&&y.prototype;if(g){g[a]||u(g,a,l),g[s]||u(g,s,d),c[d]=l;for(p in e)g[p]||i(g,p,e[p],!0)}}},function(t,n,r){var e=r(1),i=r(151);e(e.G+e.B,{setImmediate:i.set,clearImmediate:i.clear})},function(t,n,r){var e=r(3),i=r(1),o=r(121),u=r(207),c=e.navigator,f=!!c&&/MSIE .\./.test(c.userAgent),a=function(t){return f?function(n,r){return t(o(u,[].slice.call(arguments,2),"function"==typeof n?n:Function(n)),r)}:t};i(i.G+i.B+i.F*f,{setTimeout:a(e.setTimeout),setInterval:a(e.setInterval)})},function(t,n,r){r(330),r(269),r(271),r(270),r(273),r(275),r(280),r(274),r(272),r(282),r(281),r(277),r(278),r(276),r(268),r(279),r(283),r(284),r(236),r(238),r(237),r(286),r(285),r(256),r(266),r(267),r(257),r(258),r(259),r(260),r(261),r(262),r(263),r(264),r(265),r(239),r(240),r(241),r(242),r(243),r(244),r(245),r(246),r(247),r(248),r(249),r(250),r(251),r(252),r(253),r(254),r(255),r(317),r(322),r(329),r(320),r(312),r(313),r(318),r(323),r(325),r(308),r(309),r(310),r(311),r(314),r(315),r(316),r(319),r(321),r(324),r(326),r(327),r(328),r(231),r(233),r(232),r(235),r(234),r(220),r(218),r(224),r(221),r(227),r(229),r(217),r(223),r(214),r(228),r(212),r(226),r(225),r(219),r(222),r(211),r(213),r(216),r(215),r(230),r(155),r(302),r(307),r(184),r(303),r(304),r(305),r(306),r(287),r(183),r(185),r(186),r(342),r(331),r(332),r(337),r(340),r(341),r(335),r(338),r(336),r(339),r(333),r(334),r(288),r(289),r(290),r(291),r(292),r(295),r(293),r(294),r(296),r(297),r(298),r(299),r(301),r(300),r(343),r(369),r(372),r(371),r(373),r(374),r(370),r(375),r(376),r(354),r(357),r(353),r(351),r(352),r(355),r(356),r(346),r(368),r(377),r(345),r(347),r(349),r(348),r(350),r(359),r(360),r(362),r(361),r(364),r(363),r(365),r(366),r(367),r(344),r(358),r(380),r(379),r(378),t.exports=r(52)},function(t,n){function r(t,n){if("string"==typeof n)return t.insertAdjacentHTML("afterend",n);var r=t.nextSibling;return r?t.parentNode.insertBefore(n,r):t.parentNode.appendChild(n)}t.exports=r},,,,,,,,,function(t,n,r){(function(n,r){!function(n){"use strict";function e(t,n,r,e){var i=n&&n.prototype instanceof o?n:o,u=Object.create(i.prototype),c=new p(e||[]);return u._invoke=s(t,r,c),u}function i(t,n,r){try{return{type:"normal",arg:t.call(n,r)}}catch(t){return{type:"throw",arg:t}}}function o(){}function u(){}function c(){}function f(t){["next","throw","return"].forEach(function(n){t[n]=function(t){return this._invoke(n,t)}})}function a(t){function n(r,e,o,u){var c=i(t[r],t,e);if("throw"!==c.type){var f=c.arg,a=f.value;return a&&"object"==typeof a&&m.call(a,"__await")?Promise.resolve(a.__await).then(function(t){n("next",t,o,u)},function(t){n("throw",t,o,u)}):Promise.resolve(a).then(function(t){f.value=t,o(f)},u)}u(c.arg)}function e(t,r){function e(){return new Promise(function(e,i){n(t,r,e,i)})}return o=o?o.then(e,e):e()}"object"==typeof r&&r.domain&&(n=r.domain.bind(n));var o;this._invoke=e}function s(t,n,r){var e=P;return function(o,u){if(e===F)throw new Error("Generator is already running");if(e===M){if("throw"===o)throw u;return y()}for(r.method=o,r.arg=u;;){var c=r.delegate;if(c){var f=l(c,r);if(f){if(f===A)continue;return f}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(e===P)throw e=M,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);e=F;var a=i(t,n,r);if("normal"===a.type){if(e=r.done?M:j,a.arg===A)continue;return{value:a.arg,done:r.done}}"throw"===a.type&&(e=M,r.method="throw",r.arg=a.arg)}}}function l(t,n){var r=t.iterator[n.method];if(r===g){if(n.delegate=null,"throw"===n.method){if(t.iterator.return&&(n.method="return",n.arg=g,l(t,n),"throw"===n.method))return A;n.method="throw",n.arg=new TypeError("The iterator does not provide a 'throw' method")}return A}var e=i(r,t.iterator,n.arg);if("throw"===e.type)return n.method="throw",n.arg=e.arg,n.delegate=null,A;var o=e.arg;return o?o.done?(n[t.resultName]=o.value,n.next=t.nextLoc,"return"!==n.method&&(n.method="next",n.arg=g),n.delegate=null,A):o:(n.method="throw",n.arg=new TypeError("iterator result is not an object"),n.delegate=null,A)}function h(t){var n={tryLoc:t[0]};1 in t&&(n.catchLoc=t[1]),2 in t&&(n.finallyLoc=t[2],n.afterLoc=t[3]),this.tryEntries.push(n)}function v(t){var n=t.completion||{};n.type="normal",delete n.arg,t.completion=n}function p(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(h,this),this.reset(!0)}function d(t){if(t){var n=t[w];if(n)return n.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var r=-1,e=function n(){for(;++r<t.length;)if(m.call(t,r))return n.value=t[r],n.done=!1,n;return n.value=g,n.done=!0,n};return e.next=e}}return{next:y}}function y(){return{value:g,done:!0}}var g,b=Object.prototype,m=b.hasOwnProperty,x="function"==typeof Symbol?Symbol:{},w=x.iterator||"@@iterator",S=x.asyncIterator||"@@asyncIterator",_=x.toStringTag||"@@toStringTag",O="object"==typeof t,E=n.regeneratorRuntime;if(E)return void(O&&(t.exports=E));E=n.regeneratorRuntime=O?t.exports:{},E.wrap=e;var P="suspendedStart",j="suspendedYield",F="executing",M="completed",A={},N={};N[w]=function(){return this};var T=Object.getPrototypeOf,I=T&&T(T(d([])));I&&I!==b&&m.call(I,w)&&(N=I);var k=c.prototype=o.prototype=Object.create(N);u.prototype=k.constructor=c,c.constructor=u,c[_]=u.displayName="GeneratorFunction",E.isGeneratorFunction=function(t){var n="function"==typeof t&&t.constructor;return!!n&&(n===u||"GeneratorFunction"===(n.displayName||n.name))},E.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,c):(t.__proto__=c,_ in t||(t[_]="GeneratorFunction")),t.prototype=Object.create(k),t},E.awrap=function(t){return{__await:t}},f(a.prototype),a.prototype[S]=function(){return this},E.AsyncIterator=a,E.async=function(t,n,r,i){var o=new a(e(t,n,r,i));return E.isGeneratorFunction(n)?o:o.next().then(function(t){return t.done?t.value:o.next()})},f(k),k[_]="Generator",k.toString=function(){return"[object Generator]"},E.keys=function(t){var n=[];for(var r in t)n.push(r);return n.reverse(),function r(){for(;n.length;){var e=n.pop();if(e in t)return r.value=e,r.done=!1,r}return r.done=!0,r}},E.values=d,p.prototype={constructor:p,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=g,this.done=!1,this.delegate=null,this.method="next",this.arg=g,this.tryEntries.forEach(v),!t)for(var n in this)"t"===n.charAt(0)&&m.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=g)},stop:function(){this.done=!0;var t=this.tryEntries[0],n=t.completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(t){function n(n,e){return o.type="throw",o.arg=t,r.next=n,e&&(r.method="next",r.arg=g),!!e}if(this.done)throw t;for(var r=this,e=this.tryEntries.length-1;e>=0;--e){var i=this.tryEntries[e],o=i.completion;if("root"===i.tryLoc)return n("end");if(i.tryLoc<=this.prev){var u=m.call(i,"catchLoc"),c=m.call(i,"finallyLoc");if(u&&c){if(this.prev<i.catchLoc)return n(i.catchLoc,!0);if(this.prev<i.finallyLoc)return n(i.finallyLoc)}else if(u){if(this.prev<i.catchLoc)return n(i.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return n(i.finallyLoc)}}}},abrupt:function(t,n){for(var r=this.tryEntries.length-1;r>=0;--r){var e=this.tryEntries[r];if(e.tryLoc<=this.prev&&m.call(e,"finallyLoc")&&this.prev<e.finallyLoc){var i=e;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=n&&n<=i.finallyLoc&&(i=null);var o=i?i.completion:{};return o.type=t,o.arg=n,i?(this.method="next",this.next=i.finallyLoc,A):this.complete(o)},complete:function(t,n){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&n&&(this.next=n),A},finish:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),v(r),A}},catch:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.tryLoc===t){var e=r.completion;if("throw"===e.type){var i=e.arg;v(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,n,r){return this.delegate={iterator:d(t),resultName:n,nextLoc:r},"next"===this.method&&(this.arg=g),A}}}("object"==typeof n?n:"object"==typeof window?window:"object"==typeof self?self:this)}).call(n,function(){return this}(),r(158))}])</script><script src="/./main.0cf68a.js"></script><script>!function(){!function(e){var t=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(t),t.setAttribute("src",e)}("/slider.e37972.js")}()</script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
      
      
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">所有文章</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'friends')"><a href="javascript:void(0)" q-class="active:friends">友链</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">关于我</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">杂项</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">机器学习与机器视觉</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">电路设计</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">测试</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">电赛笔记</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">随笔</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">stm32</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">C语言进阶</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">ESP32</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">IoT</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">嵌入式Linux</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">FPGA</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、请确保node版本大于6.2<br/>2、在博客根目录（注意不是yilia根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            3、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: false
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    
    	<section class="tools-section tools-section-friends" q-show="friends">
  		
        <ul class="search-ul">
          
            <li class="search-li">
              <a href="https://dawncraft.cc/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>软院全栈dalao</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>广告位招租</a>
            </li>
          
        </ul>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">这个天天摸鱼的微电人，&lt;br/&gt;  二刺螈（迫真），&lt;br/&gt;  因为学不懂编程改行硬件的菜b，&lt;br/&gt;  是谁呢？&lt;br/&gt;  没错就是我(即答)</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>