<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>多级放大器简介</title>
    <url>/2021/11/14/%E5%A4%9A%E7%BA%A7%E6%94%BE%E5%A4%A7%E5%99%A8%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="多级放大器"><a href="#多级放大器" class="headerlink" title="多级放大器"></a>多级放大器</h1><p>常见的共射放大电路放大系数$\beta_V=-\frac{\beta R_{C}}{R_{b1}}$</p>
<h2 id="耦合方式"><a href="#耦合方式" class="headerlink" title="耦合方式"></a>耦合方式</h2><p>将多个单级基本放大电路合理连接即构成多级放大电路</p>
<p>组成多级放大电路的每个基本电路称为一<strong>级</strong>，级与级之间的连接称为<strong>级间耦合</strong></p>
<p>有下列四种常见的耦合方式</p>
<ul>
<li><p>直接耦合</p>
<p>  可以放大交流和缓慢变化的直流信号，便于集成化</p>
<p>  但是各级静态工作点会互相影响——基极和集电极电位会随着级数增加而上升；并且存在<strong>零点漂移</strong></p>
<p>  改进方法：</p>
<ol>
<li>在后级的射极接入电阻，提高后级基极电位，但是会导致第二级的放大倍数下降</li>
<li>在后级的射极接入稳压二极管并上拉电阻（启动电阻）到Vcc，可以使后级的放大倍数损失减小，但是会导致集电极电压的变化范围减小</li>
<li>在前级和后级之间使用反接的稳压二极管耦合，并在后级的基极接入下拉电阻到地，可以做到不损失放大倍数，但是稳压管噪声较大，会对输出信号造成影响</li>
<li>混合使用NPN管和PNP管（对管）直接耦合，可以较完美地实现需求，实际经常使用的电路就是这种</li>
</ol>
</li>
<li><p>阻容耦合</p>
<p>  在前级和后级之间使用电容进行耦合</p>
<p>  静态工作点相互独立，在分立元件电路中广泛使用；但集成电路中难以制造大容量电容，不便于集成化</p>
</li>
<li><p>变压器耦合</p>
<p>  过去广泛采用的耦合方式，利用变压器的阻抗变换功能，但是难以高频工作，过去经常使用这种方式实现收音机放大电路</p>
</li>
<li><p>光电耦合</p>
<p>  使用光耦器件进行前后级耦合，耦合效果好、抗干扰能力强，但是难以做到良好的线性放大</p>
</li>
</ul>
<h2 id="多级放大器动态分析"><a href="#多级放大器动态分析" class="headerlink" title="多级放大器动态分析"></a>多级放大器动态分析</h2><h3 id="性能参数"><a href="#性能参数" class="headerlink" title="性能参数"></a>性能参数</h3><ol>
<li><p>电压放大倍数</p>
<p> 总电压放大倍数等于各级电压放大倍数的乘积</p>
<p> $\beta_A=\beta_1\times\beta_2\times\cdots\times\beta_n$</p>
<p> 各级的放大倍数、静态值等可以独立计算</p>
</li>
<li><p>输入电阻、输出电阻等同于从输入端口、输出端口分别看入电路的总电阻</p>
</li>
</ol>
<h3 id="直接耦合放大电路的零点漂移问题"><a href="#直接耦合放大电路的零点漂移问题" class="headerlink" title="直接耦合放大电路的零点漂移问题"></a>直接耦合放大电路的零点漂移问题</h3><p><strong>零点漂移</strong>：直接耦合时，输入电压为0，但输出电压离开零点，并缓慢地发生不规则变化的现象</p>
<p>原因：放大器件的参数受温度影响而使Q点不稳定，所以零点漂移也称为温度漂移</p>
<p><em>多级放大器会使零点漂移更加严重</em></p>
<p>抑制零点漂移的方法：</p>
<ol>
<li>引入直流负反馈</li>
<li>利用热敏元件补偿放大器零漂</li>
<li>使用差分放大电路，放大差分信号（只有这种方法可以达到完美抑制零点漂移）</li>
</ol>
<h2 id="差分放大电路"><a href="#差分放大电路" class="headerlink" title="差分放大电路"></a>差分放大电路</h2><p>核心思想：构造电压源补偿由于零点漂移带来的电压不稳定</p>
<p>差分放大电路也称为差动放大电路，电路以两只并联的三极管集电极电位差为输出，以共模或差模信号为输入，其中共模信号会被直接忽略，由于零点漂移造成的信号也是一种共模信号，所以会被去除</p>
<p>差分放大电路中构造了两个“虚地”——负载电阻的中点电位在差模信号作用下不变，相当于“接地”；对管射极相连节点的电位由于差分信号而不变，构造了另一个“接地点”</p>
<p>差分放大器具有四种接法</p>
<ul>
<li>双入双出</li>
<li>双入单出</li>
<li>单入双出</li>
<li>单入单出</li>
</ul>
<p>单端情况下还是具有一定的共模抑制比，但是不如双端效果好</p>
<p>差模电压放大倍数、共模电压放大倍数与单端输入或双端输入无关，只与输出方式有关</p>
<p>双端输出时，共模电压放大倍数$A_{VC}=0$</p>
<p>差模输入电阻始终是基本放大电路的两倍</p>
<p>输出电阻双端输出时为$2R_C$，单端输出时为$R_C$</p>
<p>双端输出时共模抑制比K<del>CMR</del>可认为等于无穷大，单端输出时为有限值</p>
<p>可搭配恒流源电路构造改进的差分放大电路</p>
<h2 id="互补放大电路"><a href="#互补放大电路" class="headerlink" title="互补放大电路"></a>互补放大电路</h2><p>基本要求：输出电阻低、最大不失真输出电压尽可能大</p>
<p>使用NPN、PNP对管采用图腾柱连接，实现推挽输出，一个三极管放大正半周信号，另一个放大负半周信号；但这种方案存在<strong>交越失真</strong></p>
<p>解决方案如下：</p>
<ol>
<li>使用两个二极管钳位输入，并使用射极-基极并联电阻给三极管提供静态电压</li>
<li>使用压敏电阻、NPN-PNP对管、构建U<del>BE</del>倍增电路等方式为对管提供静态电压</li>
<li>使用复合管结构，增大对管电流放大倍数，减小前级驱动电流</li>
</ol>
]]></content>
      <tags>
        <tag>电路设计</tag>
      </tags>
  </entry>
  <entry>
    <title>我的新博客</title>
    <url>/2021/11/13/%E6%88%91%E7%9A%84%E6%96%B0%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="搬家了！"><a href="#搬家了！" class="headerlink" title="搬家了！"></a>搬家了！</h1><p>准备逐步把博客写作从CSDN换到基于Github Pages和Hexo的自建站上（笑）</p>
<p>CSDN😅</p>
<p>顺便以后推广公众号恰烂钱（？）</p>
<p>总之，不定期更新</p>
<p>保障一个月两次的保底更新（大概）</p>
<p><strong>Hexo还没用熟</strong></p>
<p>支持Markdown和$\LaTeX$公式，至少比b乎那个好多了</p>
<p>以后应该会再多整点活</p>
]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>数模转换原理</title>
    <url>/2021/11/14/%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="数模转换与模数转换"><a href="#数模转换与模数转换" class="headerlink" title="数模转换与模数转换"></a>数模转换与模数转换</h1><p>这里以STM32G474为例来介绍STM32中的ADC与DAC编程</p>
<p>主要作为电赛的笔记</p>
<h2 id="模数转换ADC"><a href="#模数转换ADC" class="headerlink" title="模数转换ADC"></a>模数转换ADC</h2><h3 id="四个基本部分"><a href="#四个基本部分" class="headerlink" title="四个基本部分"></a>四个基本部分</h3><ul>
<li>采样：定时对连续变化的模拟信号进行测量得到的瞬时值</li>
<li>保持：采样结束后将得到信号保持一段时间，使ADC有充分时间进行ADC转换。一般采样脉冲频率越高、采样越密，采样值就越多，采样保持电路的输出信号就越接近输入信号的波形。对采样频率要求（满足采样定理）：采样频率F<del>s</del> &gt;= 2*输入模拟信号频谱中最高频率F<del>max</del></li>
<li>量化：将采样电压转换为某个最小单位电压的整数倍</li>
<li>编码：用二进制代码表示量化后的量化电平</li>
</ul>
<p>量化级越细，量化误差就越小，所用二进制代码的位数就越多，电路也越复杂</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>常见的ADC主要分成三种：</p>
<ul>
<li><p>积分型：将输入电压转换成脉冲宽度信号或脉冲频率，使用定时器/计数器获取数字值</p>
<ul>
<li>优点：电路简单、分辨率高</li>
<li>缺点：转换精度依赖于积分时间，转换速率较低</li>
</ul>
</li>
<li><p>逐次比较型：由一个比较器和DAC转换器通过逐次比较逻辑构成，从最高位开始顺序地对每一位将输入电压与内置DAC转换器的输出进行比较，经过n次比较来输出数字值</p>
<p>  这个类型的ADC可以看作使用快速逼近-快速排序的方法来让DAC输出值靠近模拟值来实现ADC</p>
<ul>
<li>优点：速度高，功耗低，在低分辨率（12位）式具有性价比优势</li>
<li>缺点：转换速率一般，电路规模中等</li>
</ul>
</li>
<li><p>Σ-Δ调制型：使用积分器、比较器、1位DAC转换器和数字滤波器等构成，将输入电压转换成脉冲宽度信号，使用数字滤波器处理后得到数字值</p>
<ul>
<li>优点：可以容易地做到高分辨率测量</li>
<li>缺点：转换速率低、电路规模大</li>
</ul>
</li>
</ul>
<h3 id="主要参数"><a href="#主要参数" class="headerlink" title="主要参数"></a>主要参数</h3><ol>
<li>分辨率：输出数字量变化一个相邻数值所需输入模拟电压的变化量，一般用二进制的位数表示，分辨率为n表示是满刻度F<del>s</del>的2的n次方分之一</li>
<li>量化误差：ADC的有限位数对模拟量进行量化而引起的误差。要准确表示模拟量，ADC的位数需要很大甚至无穷大，所以ADC器件都有量化误差。一个分辨率有限的ADC的阶梯状转换特性曲线与具有无限分辨率的ADC转化特性曲线之间的最大偏差就是量化误差</li>
<li>转换速率：每秒进行转换的次数</li>
<li>转换量程：ADC所能测量的最大电压，一般等于参考电压，超过此电压有可能损毁ADC。当信号较小时可以考虑降低参考电压来提高分辨率，<strong>改变参考电压后，对应的转换值也会改变，计算实际电压时需要将参考电压考虑进去</strong>，所以说一般参考电压都要做到很稳定且不带有高次谐波</li>
<li>偏移误差：ADC输入信号为0时，但ADC转换输出信号不为0的值</li>
<li>满刻度误差：ADC满刻度输出时对应的输入信号与理想输入信号值之差</li>
<li>线性度：实际ADC的转移函数和理想直线的最大偏移</li>
</ol>
<h3 id="STM32G4中的ADC"><a href="#STM32G4中的ADC" class="headerlink" title="STM32G4中的ADC"></a>STM32G4中的ADC</h3><p>基本特性：</p>
<ul>
<li>五路12/10/8/6位可编程分辨率ADC，内置自动校准</li>
<li><strong>ADC转换时间与AHB总线时钟频率无关，只能通过降低分辨率加快转换时间</strong></li>
<li>4Msps最大转化率与全分辨率</li>
<li>每个ADC有多达19路通道，各通道AD转换可以以单一、连续、扫描或不连续方式进行，ADC结果存储在左对齐/右对齐的16位数据寄存器中</li>
<li>有外部参考引脚，允许输入电压范围独立于电源</li>
<li>可调的单端和差分模式输入</li>
<li>ADC1和ADC2紧密耦合，ADC3和ADC4紧密耦合，可以分别以ADC1、ADC3作master模式进行双模式运行；ADC5独立控制</li>
<li>允许DMA控制</li>
</ul>
<p>程序可以通过轮询、中断、定时器中断、同步、DMA等等方式来获取ADC值</p>
<p>使用函数<code>HAL_ADC_Start()</code>启动一次ADC转换，同理可使用<code>HAL_ADC_Start_IT()</code>和<code>HAL_ADC_Start_DMA()</code>来以中断或DMA的方式使用ADC</p>
<p>使用函数<code>HAL_ADC_GetValue()</code>在启动ADC转换一定延时时间后获取上次转换得到的ADC值</p>
<p>使用<code>HAL_ADC_Stop()</code>、<code>HAL_ADC_Stop_IT()</code>、<code>HAL_ADC_Stop_DMA()</code>停止使用ADC</p>
<h2 id="数模转换DAC"><a href="#数模转换DAC" class="headerlink" title="数模转换DAC"></a>数模转换DAC</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>数字寄存器：寄存输入的数字量和控制信号</p>
<p>模拟开关和转换网络：转换网络一般由一列电阻构成，模拟开关和对应的电阻按位加权</p>
<p>参考电压源：用于确定转换系数</p>
<p>求和放大器：对来自转换网络的模拟量进行相加</p>
<p>DAC的操作过程类似积分</p>
<h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><ul>
<li><p>电压输出型：从电阻网络直接输出电压，通常会在输出端加放大器来降低输出阻抗。</p>
</li>
<li><p>在输出端不加放大器的电压输出型：减少了输出端部分的延迟，常用于高速场合</p>
</li>
<li><p>电流输出型：一般很少直接利用电流输出，大多数会外接电流-电压转换电路得到电压输出。根据如何进行电流-电压转换又分成两类：</p>
<ul>
<li>在输出引脚上接负载电阻<ul>
<li>缺点：输出阻抗高、必须在规定的输出电流范围内使用，否则可能损坏DAC</li>
</ul>
</li>
<li>外接运算放大器<ul>
<li>缺点：加入了外接运放和导线的延迟，响应变慢</li>
</ul>
</li>
</ul>
<p>  电流输出型很少用，一般使用电压输出型</p>
</li>
</ul>
<h3 id="主要参数-1"><a href="#主要参数-1" class="headerlink" title="主要参数"></a>主要参数</h3><ol>
<li>分辨率：最小输出电压（也就是输入数字量为1时的电压）与最大输出电压（也就是输入数字量为最大（每一位都是1）时的电压）之比。一般通过输入数字量的位数来表示</li>
<li>转换量程：DAC能输出的最大电压，一般的关于参考电压或其倍数</li>
<li>建立时间：从输入数字量到输出模拟量之间的延时时间</li>
<li>转换精度：与ADC的转换精度类似</li>
</ol>
<h3 id="STM32G4中的DAC"><a href="#STM32G4中的DAC" class="headerlink" title="STM32G4中的DAC"></a>STM32G4中的DAC</h3><p>基本特性：</p>
<ul>
<li>4路配置为8位/12位的电压输出DAC，3个1MHz速率的DAC外部输出通道；4个15MHz速率的DAC内部输出通道</li>
<li>可生成噪声、三角波、锯齿波</li>
<li>可实现双DAC通道，两个通道组合在一起进行同步更新操作，转换可以独立或同步地完成</li>
<li>可通过设置独立的输入参考电压VREF+来获得更好的分辨率（注意该引脚和其他模拟外设如ADC、OPAMP等共用）</li>
<li>DAC1、DAC2引脚由GPIO复用；DAC3、DAC4仅用于内部输出</li>
<li>可开启输出缓冲</li>
<li>可单独启用的DAC输出缓冲器来输出高电流</li>
<li>支持低功耗模式、采样模式、保持模式，支持独立校准</li>
</ul>
<p>可直接使用<code>HAL_DAC_SetValue()</code>来设置DAC输出值</p>
<p>一般将某个波形的所有输出值保存在一个数组中并传给函数来输出特定波形；可以配合定时器来输出方波、三角波等</p>
]]></content>
      <tags>
        <tag>电赛笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>电机控制简介</title>
    <url>/2021/11/14/%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>本篇博文主要使用HAL库和CubeMX进行代码示例，毕竟电赛时间那么紧张，写STP库的时间都够CubeMX重开一局了</p>
<h1 id="直流电机控制"><a href="#直流电机控制" class="headerlink" title="直流电机控制"></a>直流电机控制</h1><p>根据电机学，直流电机转速<br>$$<br>n=\frac{U-IR}{K\phi}<br>$$<br>其中U为电枢端电压，I为电枢电流，R为电枢电路总电阻，Φ为每极磁通量，K为电机结构参数</p>
<p>直流电动机的转速控制方法有两种</p>
<ul>
<li>励磁控制法：对励磁磁通进行控制</li>
<li>电枢控制法：对电枢电压进行控制</li>
</ul>
<p>励磁控制阀在低速状态下收到磁极饱和限制，在高速时受换向火花和换向器结构强度的限制，动态响应较差，因此很少使用；大多数应用场合都使用电枢电压控制法，在保证励磁恒定的情况下使用单片机或相关电子器件输出<strong>PWM</strong>来直接实现直流电动机调速</p>
<h2 id="直流电机调速"><a href="#直流电机调速" class="headerlink" title="直流电机调速"></a>直流电机调速</h2><p>直流电机的调速思路就是“力大砖飞”，在电机控制线两端加适当电压，电压越高转速越快。可以通过功率半导体器件产生恒定的电压供给电机；对于数字器件而言很难控制电压精准保持在某一模拟值，因此使用PWM进行调速。</p>
<p>无论是模拟方法还是数字方法，都需要使用功率半导体器件，只不过使用方式有所不同。模拟电路通过线性放大的驱动方式，输出波动小、线性好，对临近电路干扰小，但存在效率低和散热问题；而数字电路通过耦合器件发出PWM使功率器件输出方波加在电机两端，通过改变方波的占空比来实现调节电机转速，往往对临近电路存在干扰，但是更易于实现。</p>
<p>基于PWM调速的电路往往包含三个部分</p>
<h3 id="驱动电路"><a href="#驱动电路" class="headerlink" title="驱动电路"></a>驱动电路</h3><p>一般使用晶体管或场效应管构成的半桥、全桥、三相桥电路，或直接使用护照那用的电机驱动功率IC。</p>
<p>常见的电机驱动芯片有L298N、ULN2003等</p>
<p>半桥拓扑采用推挽输出，<strong>需要保证两晶体管不同时开合</strong></p>
<p>全桥拓扑又称H桥，需要确定一个死区时间，在同一时间只有两个对称的桥臂晶体管导通，<strong>绝对不能让四路晶体管同时导通</strong></p>
<p>三相桥需要更严谨的时间控制，如果出现桥臂同时导通的情况很可能导致炸管</p>
<p>三者适用的功率逐次增大</p>
<p>还要注意电机两端应跨接续流二极管</p>
<h3 id="隔离电路"><a href="#隔离电路" class="headerlink" title="隔离电路"></a>隔离电路</h3><p>一般来说直流电机的驱动电压都在6V及以上，而常见的MCU供电、输出电压都在3.3V-5V，因此二者之间通常需要隔离</p>
<p>隔离器件可以是光耦、数字隔离器等</p>
<p>通常由于隔离设备的驱动能力不足，还需要在输出端加入三极管、场效应管放大电路或图腾柱推挽输出电路。比较方便的解决方案是直接使用达林顿管对电机进行控制，但是需要考虑达林顿管的耐压和发热</p>
<h3 id="控制电路"><a href="#控制电路" class="headerlink" title="控制电路"></a>控制电路</h3><p>大多数MCU都具有PWM输出功能，高性能的MCU往往还会配备控制死区时间、可以快速调节占空比、实现多路PWM同步/反相的高级控制功能；低端MCU也往往可以通过延时程序配合GPIO输出实现不精确的PWM功能</p>
<p>改变占空比的基本控制方法有：</p>
<ul>
<li>定宽调频法：保持PWM占空比不变，改变输出频率</li>
<li>定频调宽法：保持PWM频率不变，改变占空比</li>
<li>调频调宽法：不常用，同时改变频率和占空比</li>
</ul>
<h3 id="基于stm32f407的HAL库实现"><a href="#基于stm32f407的HAL库实现" class="headerlink" title="基于stm32f407的HAL库实现"></a>基于stm32f407的HAL库实现</h3><p>首先需要设置CubeMX或自己编写的外设初始化代码，配置好PSC寄存器和ARR寄存器，保证恒定的PWM频率</p>
<p>如果使用CubeMX只要可视化地调节选项即可；如果自己编写可以参考如下代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">htim1.Instance = TIM1; <span class="comment">//选择定时器实例</span></span><br><span class="line">htim1.Init.Prescaler = <span class="number">0</span>; <span class="comment">//这里设置PSC寄存器值</span></span><br><span class="line">htim1.Init.CounterMode = TIM_COUNTERMODE_UP; <span class="comment">//这里设置定时器模式</span></span><br><span class="line">htim1.Init.Period = <span class="number">65535</span>; <span class="comment">//这里设置ARR寄存器值</span></span><br><span class="line">htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1; <span class="comment">//这里设置分频值</span></span><br><span class="line">htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE; <span class="comment">//这里设置是否使能自动重装计数器</span></span><br></pre></td></tr></table></figure>

<p>使用定时器前需要先开启PWM通道</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_TIM_PWM_Start(&amp;htimx, TIM_CHANNEL_x);</span><br><span class="line"><span class="comment">//函数原型如下</span></span><br><span class="line"><span class="function">HAL_StatusTypeDef <span class="title">HAL_TIM_PWM_Start</span><span class="params">(TIM_HandleTypeDef *htim, <span class="keyword">uint32_t</span> Channel)</span></span></span><br></pre></td></tr></table></figure>

<p>然后通过在应用程序内修改比较值来实现定频调宽法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__HAL_TIM_SetCompare(&amp;htimx, TIM_CHANNEL_x, PWM_CompareValue);</span><br><span class="line"><span class="comment">//宏函数原型如下</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAL_TIM_SetCompare            __HAL_TIM_SET_COMPARE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAL_TIM_SET_COMPARE(__HANDLE__, __CHANNEL__, __COMPARE__) \</span></span><br><span class="line"><span class="meta">  (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)-&gt;Instance-&gt;CCR1 = (__COMPARE__)) :\</span></span><br><span class="line"><span class="meta">   ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)-&gt;Instance-&gt;CCR2 = (__COMPARE__)) :\</span></span><br><span class="line"><span class="meta">   ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)-&gt;Instance-&gt;CCR3 = (__COMPARE__)) :\</span></span><br><span class="line"><span class="meta">   ((__HANDLE__)-&gt;Instance-&gt;CCR4 = (__COMPARE__)))</span></span><br><span class="line"><span class="comment">//__HAL_TIM_SetCompare是老版本HAL库用法，新版本里为了统一宏函数，使用了lagency.h文件来对__HAL_TIM_SetCompare进行重定向，它和新版本的函数__HAL_TIM_SET_COMPARE等效</span></span><br></pre></td></tr></table></figure>

<p>特别地，HAL库允许直接修改CCR来改变定时器比较值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">htimx.Instance-&gt;CCRn = PWM_CompareValue;</span><br></pre></td></tr></table></figure>

<h1 id="步进电机控制"><a href="#步进电机控制" class="headerlink" title="步进电机控制"></a>步进电机控制</h1><p>步进电机是一种将电脉冲转化为角位移的电机机构。当它收到一个脉冲信号，就会按照设定的方向转动一个固定的角度，该角度称为电机的<strong>步距角</strong>。可以通过控制脉冲个数来控制角位移量；可以通过控制脉冲频率实现步进电机的调速</p>
<p>步进电机的转子一般为多极分布，定子上嵌有多相星形连接的控制绕组，每输入一次电脉冲信号，转子就旋转一步。步进电机的种类很多，可大致分成：</p>
<ul>
<li>反应式</li>
<li>永磁式</li>
<li>混合式</li>
</ul>
<p>还可以按相数分为单相、两相、三相三种</p>
<p><strong>如果给处于错齿状态的相通电</strong>，则转子会向磁导率最大、磁阻最小的位置转动，也就是<strong>趋于齿运动</strong></p>
<p>一个步进电机中往往还会加入减速装置来让其达到更高的精度，获得更高的转动力矩。</p>
<h3 id="基于stm32f407的HAL库实现-1"><a href="#基于stm32f407的HAL库实现-1" class="headerlink" title="基于stm32f407的HAL库实现"></a>基于stm32f407的HAL库实现</h3><p>首先使用CubeMX或自行编写初始化代码对外设进行配置 ，主要配置的参数如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">htim8.Instance = TIM8; <span class="comment">//选择合适的定时器</span></span><br><span class="line">htim8.Init.Prescaler = <span class="number">500</span>; <span class="comment">//配置预分频器</span></span><br><span class="line">htim8.Init.CounterMode = TIM_COUNTERMODE_UP; <span class="comment">//设置计数模式</span></span><br><span class="line">htim8.Init.Period = <span class="number">2000</span>; <span class="comment">//配置重装载值</span></span><br><span class="line">htim8.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;</span><br><span class="line">htim8.Init.RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">htim8.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;</span><br><span class="line"></span><br><span class="line">sConfigOC.Pulse = <span class="number">1000</span>; <span class="comment">//设置预定频数</span></span><br></pre></td></tr></table></figure>

<p>使用以下函数开启PWM输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_TIM_PWM_Start(&amp;htimx, TIM_CHANNEL_x);</span><br></pre></td></tr></table></figure>

<p>一般来说使用步进电机的基本方式是精准控制其行进步数，可以通过中断回调函数实现功能</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_TIM_PWM_Start_IT(&amp;htim8, TIM_CHANNEL_1); <span class="comment">//初始化时开启中断</span></span><br><span class="line"></span><br><span class="line">HAL_TIM_PWM_Stop_IT(&amp;htim8, TIM_CHANNEL_1); <span class="comment">//要设置频率参数前必须关闭中断</span></span><br><span class="line">TIM8-&gt;PSC = <span class="number">71</span>; <span class="comment">//将目标定时器8修改为72分频</span></span><br><span class="line"><span class="comment">//在之后的回调函数里再次打开中断</span></span><br></pre></td></tr></table></figure>

<p>通过定义中断回调函数即可实现步数控制功能</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_TIM_PWM_PulseFinishedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(htim-&gt;Instance == TIM8)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(count &lt; <span class="number">100</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			count++; <span class="comment">//计算步数</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">			HAL_TIM_PWM_Stop_IT(&amp;htim8, TIM_CHANNEL_1); <span class="comment">//再次打开中断</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过输出不同引脚的信号到电机控制器来控制步进电机的正反转</p>
<h3 id="基于步进电机专用控制IC的实现"><a href="#基于步进电机专用控制IC的实现" class="headerlink" title="基于步进电机专用控制IC的实现"></a>基于步进电机专用控制IC的实现</h3><p>为了更简便、精准地控制步进电机，常使用MCU搭配专用的电机控制IC来驱动电机——TI生产的DRV8824/8825以及更为常见的A4988都可以用来驱动常见的两相步进电机。一般根据datasheet中的典型应用设计出专用于控制步进电机的模块电路来实现控制功能。除了一般的正反转外，模块还提供了步进细分功能。下面分别以<strong>DRV8825</strong>和<strong>A4988</strong>步进电机驱动模块为例说明</p>
<p>步进电机的<strong>步进细分</strong>控制是由驱动器精确控制步进电机的相电流来实现的，细分会让电机运转更加平滑；换句话说，细分控制就是让驱动电路在输出脉冲的同时控制输出电压来实现电机的平滑启动和步进停止</p>
<ul>
<li><p>DRV8825模块</p>
<p>  DRV8825是TI的集成步进电机驱动芯片。芯片内部集成了2个H桥和1/32微步进分度器，可以驱动一个双极型电机或两个直流有刷电机。输入电压范围8.2~45V，可以提供1.75A的驱动电流， 芯片在24V、25°C的工作状态下可提供2.5A的峰值电流。芯片还集成了短路、过热、欠压及交叉传导保护电路，能够检测故障状况并迅速切断H桥，从而保护电机</p>
<p>  适用的电机类型：DRV8825驱动电机的类型主要与电机工作电流有关，理论上工作电流小于2A的步进电机都可以驱动。基于安全考虑，芯片上不加散热片，电流最好控制在1.5A以下；如果加散热片，电流峰值可到2.5A。</p>
<p>  模块接线如下：</p>
<p>  <img src="/2021/11/14/%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E7%AE%80%E4%BB%8B/DRV8824_DRV8825_pinout.png" alt="DRV8825引脚连线图"></p>
<p>  其中需要<strong>数字、模拟部分分别接地</strong>，一般来说VMOT旁边的GND是功率地，另一个GND则是数字地。同时<strong>功率电源需要接入100uF的旁路电容</strong>来减轻对数字部分的影响</p>
<p>  <strong>ENABLE引脚用于控制该模块是否启用，默认该引脚拉低，模块始终启用；RESET负责复位模块；SLEEP用于控制进入低功耗睡眠模式，当不使用电机时可以下拉该引脚来将功耗降到最低；三个引脚都是低电平有效，所以正常使用时都应接VCC（数字电源）</strong></p>
<p>  <strong>FAULT引脚（FLT）用于指示故障，一旦由于过电流保护或热关断，IC内部禁用H桥FET时，该引脚就会输出低电平，一般来说该引脚会在模块内部与SLEEP引脚短路，起到自动故障复位的效果</strong></p>
<p>  <strong>STEP引脚用于驱动电机转动，需要输入PWM波，频率越高，电机转动越快</strong></p>
<p>  <strong>DIR引脚用于控制电机转动方向，高电平正转，低电平反转</strong></p>
<p>  步进电机可以对应连接1B-1A-2A-2B、2B-2A-1A-1B、1A-1B-2B-2A、2A-2B-1B-1A，主要取决于需要的转动方向，总之只要<strong>同一相的两根线接到对应相的驱动引脚</strong>即可；特别地，如果电机不能正常运行，抖动严重，有可能是驱动板没有焊接好或某一相断开或两相接错导致缺相、错相；如果步进电机没有按照正确的顺序进行连接，可能导致无法工作或转动方向异常；如果步进电机扭力不足乃至丢步，可以尝试加大DRV8825的输出电流。驱动板上一般会搭配一个精密电位器用于调节输出电流，尝试调节该电位器来获取更好的输出效果，精密电位器与输出电流限制的计算公式为：<em>限制电流 = 电位器电压 * 2</em>，单位A</p>
<p>  <strong>通过控制M0、M1、M2的接地和接VCC（数字电源），可以根据下表来实现不同精密度的步进细分控制</strong></p>
<table>
<thead>
<tr>
<th>M0</th>
<th>M1</th>
<th>M2</th>
<th>细分类型</th>
</tr>
</thead>
<tbody><tr>
<td>Low</td>
<td>Low</td>
<td>Low</td>
<td>Full step</td>
</tr>
<tr>
<td>High</td>
<td>Low</td>
<td>Low</td>
<td>1/2 step</td>
</tr>
<tr>
<td>Low</td>
<td>High</td>
<td>Low</td>
<td>1/4 step</td>
</tr>
<tr>
<td>High</td>
<td>High</td>
<td>Low</td>
<td>1/8 step</td>
</tr>
<tr>
<td>Low</td>
<td>Low</td>
<td>High</td>
<td>1/16 step</td>
</tr>
<tr>
<td>High</td>
<td>Low</td>
<td>High</td>
<td>1/32 step</td>
</tr>
<tr>
<td>Low</td>
<td>High</td>
<td>High</td>
<td>1/32 step</td>
</tr>
<tr>
<td>High</td>
<td>High</td>
<td>High</td>
<td>1/32 step</td>
</tr>
</tbody></table>
</li>
<li><p>A4988模块</p>
<p>  相关控制方法与DRV8825基本一致，引脚也同理，两者最大的差别在于驱动电流和价格</p>
<p>  A4988价格更低，但是峰值驱动电流只有2A，内阻典型值为320Ω，最大耐压35V，所以DRV8825可以用来取代A4988，但是A4988不能取代DRV8825</p>
</li>
</ul>
<h1 id="舵机控制"><a href="#舵机控制" class="headerlink" title="舵机控制"></a>舵机控制</h1><p>舵机也称伺服电机、伺服驱动器，它接受一定的控制信号，输出一定的角度，适用于需要角度不断变化并可以保持的控制系统</p>
<p>舵机实际上是一个独立的闭环控制系统，通过其内部的机械或电路反馈控制其角度</p>
<p>工作过程如下：</p>
<ol>
<li>控制器向舵机发出控制信号</li>
<li>内部电路判断转动方向</li>
<li>驱动电路控制无核心马达转动</li>
<li>动力通过减速齿轮传送到摆臂</li>
<li>位置检测器回传摆臂数据</li>
<li>如果未达到指定位置则继续运动，否则停止</li>
</ol>
<p>其中位置检测器一般使用可变电阻，当舵机转动时电阻值会跟着改变，由此可以判断舵机是否达到指定位置</p>
<h2 id="舵机控制方法"><a href="#舵机控制方法" class="headerlink" title="舵机控制方法"></a>舵机控制方法</h2><p>标准舵机由电源、地线、控制线三条连接线，电源电压通常为4-6V，一般使用5V供电即可，但是需要电源带载能力够强。控制线一般输入方波信号，周期一般为20ms（频率50Hz）即可，具体情况应查看舵机生产商的说明。<strong>通过改变方波的占空比来改变舵机的角度</strong>，舵机角度和脉冲宽度成正比</p>
<p>舵机一般可以提供相当强的扭力，所以可以选择大扭力舵机用在机械臂等需要高强度的地方</p>
<h3 id="基于stm32f407的HAL库实现-2"><a href="#基于stm32f407的HAL库实现-2" class="headerlink" title="基于stm32f407的HAL库实现"></a>基于stm32f407的HAL库实现</h3><p>数字舵机依靠PWM进行控制。<strong>对于180°的舵机，一般周期为20ms（频率为50Hz）</strong>，脉宽为500–2500us。其中为1500us使得舵机转轮处于中间位置，即90°位置，如果在500-1500us和1500–2500us之间则分别会朝着0–90°和90–180°的方向旋转。给定固定占空比，舵机则会转到相应的角度，计算公式如下：</p>
<p>$$<br>占空比D =\frac{1}{90} *角度\theta + 0.5<br>$$<br>对应HAL库实现如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Servo_Control</span><span class="params">(<span class="keyword">uint16_t</span> angle)</span> <span class="comment">//angle为角度值，0~180</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> temp;</span><br><span class="line">	temp = (<span class="number">1.0</span> / <span class="number">90.0</span>) * angle + <span class="number">0.5</span>;<span class="comment">//占空比值 = 1/9 * 角度 + 5</span></span><br><span class="line">	__HAL_TIM_SET_COMPARE(&amp;htimx, TIM_CHANNEL_n, (<span class="keyword">uint16_t</span>)temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用下面的代码使能定时器时基单元和PWM输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_TIM_Base_Start(&amp;htimx);</span><br><span class="line">HAL_TIM_PWM_Start(&amp;htimx, TIM_CHANNEL_n);</span><br></pre></td></tr></table></figure>

<p>使用下面的代码关闭定时器时基单元和PWM输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_TIM_Base_Stop(&amp;htimx);</span><br><span class="line">HAL_TIM_PWM_Stop(&amp;htimx, TIM_CHANNEL_n);</span><br></pre></td></tr></table></figure>

<p>还可以直接通过改变CCR寄存器的值来控制舵机</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIMx-&gt;CCRn = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>电赛笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>电路设计从入门到弃坑0【电路概论】</title>
    <url>/2021/11/13/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E7%94%B5%E8%B7%AF%E6%A6%82%E8%AE%BA%E3%80%91/</url>
    <content><![CDATA[<h1 id="电路设计从入门到弃坑0【电路概论】"><a href="#电路设计从入门到弃坑0【电路概论】" class="headerlink" title="电路设计从入门到弃坑0【电路概论】"></a>电路设计从入门到弃坑0【电路概论】</h1><p>在本系列博客中，将遵循以下缩写/简写</p>
<ul>
<li>电路原理：电子线路、电子线路分析基础等基础电路课</li>
<li>模电：模拟电子电路、模拟电路、模拟电子技术、模拟电子线路等模拟电路课</li>
<li>数电：数字电子电路、数字电路、数字电子技术、数字电子线路等数字电路课</li>
<li>通信原理：通信原理、通信电子线路、通信电子电路、高频电子电路、高频电子线路等高频电路及通信理论课</li>
<li>强电：功率电子电路、功率电子线路、电力电子电路、电力电路等电力电子系统及理论课</li>
</ul>
<p>电路原理阐述了电路运行的基本规律：使用抽象电路模型、电磁学、图论、高等数学、线性代数、拉普拉斯变换等基础学科知识描述电路，提供一般的电路分析方法</p>
<p>模电则是从半导体器件的性质介绍如何使用这些器件构建能够对电信号或功率电压电流进行处理的电路</p>
<p>数电针对逻辑电路进行分析，结合布尔代数引入了晶体管在导通、截至两状态下的应用，并提炼出使用硬件描述语言对数字电路进行设计、分析、仿真的基本方法</p>
<p>通信原理则从分布参数电路与谐振、傅里叶分析角度解释模拟电路工作在高频情况下的状态与应用，并根据电磁场与电磁波理论介绍如何对通信信号进行调制-解调，以实现远距离电通信</p>
<p>强电则结合电机学、电工学相关知识，阐明功率半导体器件的工作原理和应用，主要关注功率、效率、质量三个要素</p>
<span id="more"></span>

<h3 id="专有名词解释"><a href="#专有名词解释" class="headerlink" title="专有名词解释"></a>专有名词解释</h3><p>本教程中使用的专有名词是更贴近直观的解释，和专业参考书籍存在一定差异，请以专业参考书为准</p>
<ul>
<li>电路拓扑：就是电路图的“形式”——把具体元件抽离出电路图，把实际电路图变换成理想电路模型，抽象出节点、支路后剩下的一个图就称为电路拓扑。可以形象理解成电路的套路或者说格式</li>
<li>系统：电路实现其功能过程的抽象。可以形象理解成电路功能框图</li>
<li>信息：就是信息论里面的信息</li>
<li>信号：从系统角度看，每个支路量都承载了信息，因此支路量可以称为信号</li>
<li>激励-响应：从系统的角度看电路时，系统中某个功能框的输入称为激励，系统某个功能框的输出称为响应</li>
<li>反馈：把某个响应引入到激励部分或功能框内部的过程称为反馈，对应的信号称为反馈信号</li>
</ul>
<h2 id="模电"><a href="#模电" class="headerlink" title="模电"></a>模电</h2><p>模电的知识结构是自下而上的</p>
<h3 id="半导体物理与半导体器件"><a href="#半导体物理与半导体器件" class="headerlink" title="半导体物理与半导体器件"></a>半导体物理与半导体器件</h3><p>讲述掺杂与导电性、PN结、双结型晶体管、场效应管等的基本物理原理和制造工艺对器件性能的影响</p>
<p>这一部分内容更偏重理论，和电路原理一样属于帮助理解模电、数电等工程应用的理论基础</p>
<h3 id="常见的半导体器件"><a href="#常见的半导体器件" class="headerlink" title="常见的半导体器件"></a>常见的半导体器件</h3><p>二极管、三极管、场效应管等基本的半导体器件，连同它们的变种器件，共同组成了模拟电子电路，经由开关频率特殊优化的开关管器件则构成了数字电路的基础——逻辑门和触发器</p>
<h4 id="二极管"><a href="#二极管" class="headerlink" title="二极管"></a>二极管</h4><p>由一个PN结封装成器件，就得到了具有单向导电性的二极管</p>
<p>生产中用到的不仅有二极管的单向导电性，还有击穿电压、漏电流等等一系列特性</p>
<h4 id="三极管和场效应管"><a href="#三极管和场效应管" class="headerlink" title="三极管和场效应管"></a>三极管和场效应管</h4><p>两个PN结封装成一个器件，就得到了三极管；而利用金属-氧化物绝缘层-半导体形式封装产生的电场效应，可以生产出场效应管。</p>
<p>三极管一般是电流控制电流型器件；而场效应管一般是电压控制电压型器件，二者可以互补——于是出现了结合二者，能够实现高功率输出的晶闸管（可控硅）和IGBT（绝缘栅双极型晶体管），以及复合单一器件的达林顿管</p>
<p>早期设备中使用真空管（电子管），正是因为半导体技术的发展才让三极管取代了真空管，但是二者的功能是一致的：<strong>对电信号加以控制</strong></p>
<h3 id="晶体管信号放大电路"><a href="#晶体管信号放大电路" class="headerlink" title="晶体管信号放大电路"></a>晶体管信号放大电路</h3><p>这里的晶体管是BJT（双结型晶体管，也就是三极管）和FET（场效应管）的统称</p>
<p>晶体管通过某些组合，可以最大限度发挥其控制信号的作用，而这种电路一般用于放大某些小信号，所以被称为晶体管信号放大电路。</p>
<p>放大电路并不是指输入1V，凭空就能输出3V，而是指<em>输入信号1V，通过外加2V的供电，能输出为2V的信号</em></p>
<p>信号放大电路往往看重信号的保真程度和信号的放大倍数，然而晶体管往往很容易受到门限电压、温度升高、电源变化等影响造成信号失真，为了避免这些问题，人们就对普通放大电路进行改进；同时为了获取更高的放大倍数，常常采用前级-输入级-驱动级-输出级这样的多级放大模式，从而提高信号放大倍数</p>
<p>主要参考的性能参数就是电压增益和电流增益：$A_v=\frac{v_o}{v_i}$ $A_i=\frac{i_o}{i_i}$</p>
<h3 id="晶体管功率放大电路"><a href="#晶体管功率放大电路" class="headerlink" title="晶体管功率放大电路"></a>晶体管功率放大电路</h3><p>对于一些特殊的应用（比如音响），信号放大电路无法驱动后级输出设备（扬声器）</p>
<p>于是出现了晶体管功率放大电路</p>
<p>这类电路一般使用特殊设计的能经受大电流、高电压的晶体管作为放大器件，于是可以在电源部分加大功率</p>
<p>通常需要注意功率放大电路的效率：$\eta=\frac{P_L}{P_S}$</p>
<h3 id="晶体管振荡电路"><a href="#晶体管振荡电路" class="headerlink" title="晶体管振荡电路"></a>晶体管振荡电路</h3><p>为了控制或产生周期性的激励，人们还设计出了能够产生振荡信号的晶体管电路</p>
<p>这种电路建立在放大电路和闭环控制理论的基础上，利用反馈进行工作</p>
<p>一般分立式元件难以产生高精度的信号输出，现在一般使用单片机（微控制器）或专用的集成电路生成振荡信号</p>
<h3 id="集成运算放大器"><a href="#集成运算放大器" class="headerlink" title="集成运算放大器"></a>集成运算放大器</h3><p>随着集成电路技术的发展，可以将多个二极管和晶体管集成在单个芯片中，内部大多为模拟电路的芯片被称为模拟集成电路，内部结构中多数字电路的芯片则是数字集成电路。其中通过将晶体管信号放大电路集成在一个芯片上，可以实现良好的放大性能，这种模拟集成电路就是集成运算放大器</p>
<p>集成运算放大器具有虚短、虚短、高输入阻抗、低输出阻抗等特征，利用这些特征可以组合出模拟运算电路和其他特殊的放大电路</p>
<p>集成运放工作在晶体管的基础上</p>
<h3 id="集成功率放大器"><a href="#集成功率放大器" class="headerlink" title="集成功率放大器"></a>集成功率放大器</h3><p>集成功率放大器即集成功放，是分立式晶体管功率放大器在功率半导体器件发展的基础上形成的一套新型集成电路</p>
<p>现代模拟电路具有集成化、小型化的趋势，集成功率电路正是舍弃了一部分高功率特性换来了更高的转换效率和更小的体积</p>
<h3 id="电源管理芯片和功率电源电路"><a href="#电源管理芯片和功率电源电路" class="headerlink" title="电源管理芯片和功率电源电路"></a>电源管理芯片和功率电源电路</h3><p>模拟电路的另一作用就是基于变压器、二极管、晶体管、基本电抗元件等构建稳压或恒流电源</p>
<p>在此基础上伴随半导体技术的发展，氮化镓、氮化砷等新型功率半导体器件为实现小型化、大功率、高效率的电源电路提供了可能</p>
<h2 id="数电"><a href="#数电" class="headerlink" title="数电"></a>数电</h2><p>数电的知识结构是从抽象到具体的</p>
<h3 id="布尔代数"><a href="#布尔代数" class="headerlink" title="布尔代数"></a>布尔代数</h3><p>布尔代数就是逻辑代数，使用布尔代数可以化简很多代数运算，并让电路得以实现</p>
<p>数电的基础是数学，数电的所有器件都是为了解决数学计算问题而设计</p>
<p>所以布尔代数是数字电路的基础</p>
<h3 id="开关管与逻辑门"><a href="#开关管与逻辑门" class="headerlink" title="开关管与逻辑门"></a>开关管与逻辑门</h3><p>电路可以使用高电平或低电平表示布尔代数中的0和1，进而实现数学计算</p>
<p>为了对数字信号进行处理，前人设计出了三种基本的逻辑门——与门、或门、非门</p>
<p>使用MOSFET（金属氧化物半导体场效应管）可以实现这三种逻辑门，进而实现更多复杂功能</p>
<p>在现代集成电路技术中，多采用CMOS工艺，将两个MOSFET制造在一起，并通过两个成对的MOSFET实现基础的逻辑门</p>
<p>只使用逻辑门构成的数字电路称为<strong>组合逻辑电路</strong></p>
<p>组合逻辑电路只能“瞬时”（由于寄生电容的存在，实际的组合逻辑电路存在延迟）地反映当前输入对应的输出，换句话说，它可以描述函数关系，但不能描述状态关系</p>
<h3 id="触发器与锁存器"><a href="#触发器与锁存器" class="headerlink" title="触发器与锁存器"></a>触发器与锁存器</h3><p>使用CMOS器件还可以制造具有“记忆”功能的器件——锁存器</p>
<p>锁存器可以暂时地保存输入的电平，通过再次加入一对MOSFET便可以让锁存器“滴答”（Tik-Tok）起来，这就是所谓的触发器</p>
<p>触发器是一种在外部信号输入后输出之前保存过电平的器件</p>
<p>使用触发器就可以实现随状态变化的数字电路，我们一般将其称为<strong>状态机</strong></p>
<h2 id="数电模电混合电路"><a href="#数电模电混合电路" class="headerlink" title="数电模电混合电路"></a>数电模电混合电路</h2><p>在生活中的任何一个角落，都有数模混合电路的存在——模拟电路负责供能、处理信号；数字电路负责对电信号进行计算、控制。</p>
<p>本系列博客将结合个人所学，以模电-数电-数模混合电路的逻辑讲述电路设计中的一些基础知识与技巧，同步进行开关电源、MCU板级外设电路等成体系电路的设计方法说明</p>
<p><strong>长期维护更新</strong></p>
<p>作者水平有限，如有错误疏漏，敬请谅解。</p>
]]></content>
      <tags>
        <tag>电路设计</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔</title>
    <url>/2021/11/13/%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<h1 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h1><p>所有的随笔都会放在这里OvO</p>
<p>可能还会扔些沙雕图……</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>集成运放简介</title>
    <url>/2021/11/14/%E9%9B%86%E6%88%90%E8%BF%90%E6%94%BE%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="集成运放概述"><a href="#集成运放概述" class="headerlink" title="集成运放概述"></a>集成运放概述</h1><p>常见的模拟集成电路类型</p>
<ul>
<li>集成运算放大器OP</li>
<li>集成功率放大器</li>
<li>集成高频放大器</li>
<li>集成中频放大器</li>
<li>集成比较器</li>
<li>集成乘法器</li>
<li>集成稳压器</li>
<li>集成数模/模数转换器ADC/DAC</li>
</ul>
<h3 id="模拟集成电路的特性"><a href="#模拟集成电路的特性" class="headerlink" title="模拟集成电路的特性"></a>模拟集成电路的特性</h3><p>集成电路中一般使用三极管组成恒流源电路来部分替代电阻</p>
<p>硅片上难以制作大电容、大电感，因此电路常常使用直接耦合的方式</p>
<p>常采用复合管的方式制作较大放大倍数的三极管</p>
<h2 id="集成运放的基本组成"><a href="#集成运放的基本组成" class="headerlink" title="集成运放的基本组成"></a>集成运放的基本组成</h2><h3 id="输入级"><a href="#输入级" class="headerlink" title="输入级"></a>输入级</h3><p>输入级要求高阻抗，常使用射随器与差分放大器减少温漂和增大输入电阻</p>
<p>一般使用复合管构成差分放大器，配合共集-共基放大器，用额外三极管的基极输出信号，可以实现很大的输入电阻和很大的共模抑制比</p>
<p>将复合管共基接法可以改善频率响应</p>
<p>使用<strong>共模负反馈</strong>减小温漂、提高共模抑制比</p>
<h3 id="中间级"><a href="#中间级" class="headerlink" title="中间级"></a>中间级</h3><p>常采用共射放大器配合复合管获得高增益</p>
<p>使用互补放大电路实现高放大倍数并提高带载能力</p>
<p>也存在放大器两端外接矫正电容来提高电路容性，防止自激振荡的措施（抑制过高的放大倍数、抑制正反馈）</p>
<h3 id="输出级"><a href="#输出级" class="headerlink" title="输出级"></a>输出级</h3><p>要求低阻抗，常使用射随器减小输出电阻</p>
<p>可以使用准互补OCD电路来提高带载能力，并引入电阻-二极管<strong>过载保护电路</strong></p>
<h3 id="偏置电路"><a href="#偏置电路" class="headerlink" title="偏置电路"></a>偏置电路</h3><p>使用恒流源电路给予三极管合适的偏置电压电流</p>
<p>多使用<strong>镜像恒流源</strong>配合跨接在VCC、VEE之间的电阻来提供标准偏置电流</p>
<h2 id="集成运放的特性"><a href="#集成运放的特性" class="headerlink" title="集成运放的特性"></a>集成运放的特性</h2><p>集成运放的开环放大倍数$A_{od}$非常大，一般使用负反馈的方式构造可控倍数的放大器或使用深度正反馈构造自激振荡电路</p>
<h3 id="开环差模电压增益"><a href="#开环差模电压增益" class="headerlink" title="开环差模电压增益"></a>开环差模电压增益</h3><p>直观上的运放开环情况下对差模信号的电压增益</p>
<p>用$A_{od}$表示，一般用对数表示，单位分贝</p>
<p>实际情况下运放A<del>od</del>在100到140之间</p>
<h3 id="输入失调电压、电流"><a href="#输入失调电压、电流" class="headerlink" title="输入失调电压、电流"></a>输入失调电压、电流</h3><p>为了使输出电压为0，在输入端需要加的补偿电压</p>
<p>一般运放在1-10mV</p>
<p>高端运放要保证在1mV以下</p>
<h3 id="输入失调电压、电流温漂"><a href="#输入失调电压、电流温漂" class="headerlink" title="输入失调电压、电流温漂"></a>输入失调电压、电流温漂</h3><p>由于温漂导致的输入失调电压增高情况</p>
<h3 id="输入偏置电流"><a href="#输入偏置电流" class="headerlink" title="输入偏置电流"></a>输入偏置电流</h3><p>输出电压为0时，两个输入端偏置电流的平均值</p>
<h3 id="差模输入电阻"><a href="#差模输入电阻" class="headerlink" title="差模输入电阻"></a>差模输入电阻</h3><p>一般要求很大，在几十MΩ</p>
<h3 id="共模抑制比"><a href="#共模抑制比" class="headerlink" title="共模抑制比"></a>共模抑制比</h3><p>多数运放在80-160dB之间</p>
<h3 id="最大共模、差模输入电压"><a href="#最大共模、差模输入电压" class="headerlink" title="最大共模、差模输入电压"></a>最大共模、差模输入电压</h3><p>直观上就是集成运放的耐压</p>
<p>一定程度上表征运放的耐静电程度</p>
<h3 id="3dB带宽fH"><a href="#3dB带宽fH" class="headerlink" title="-3dB带宽fH"></a>-3dB带宽f<del>H</del></h3><p>表示A<del>od</del>下降3dB时的频率。一般集成运放的f<del>H</del>在几H到几千Hz</p>
<h3 id="单位增益带宽"><a href="#单位增益带宽" class="headerlink" title="单位增益带宽"></a>单位增益带宽</h3><p>A<del>od</del>降低到0时的频率，此时运放开环差模电压放大倍数=1</p>
<h3 id="转换速率"><a href="#转换速率" class="headerlink" title="转换速率"></a>转换速率</h3><p>集成运放对输入-输入信号的转换速率</p>
<h2 id="单极型集成运放"><a href="#单极型集成运放" class="headerlink" title="单极型集成运放"></a>单极型集成运放</h2><p>三极管又称为BJT（双结型晶体管），组成双极型集成运放；也可以使用MOSFET组成单极型集成运放</p>
<p>采用耗尽型NMOS组成双入双出差分放大电路、使用增强型NMOS组成有源负载，并使用电流源组成偏置电路</p>
]]></content>
      <tags>
        <tag>电赛笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>常用控制算法</title>
    <url>/2021/11/14/%E5%B8%B8%E7%94%A8%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="硬件控制算法"><a href="#硬件控制算法" class="headerlink" title="硬件控制算法"></a>硬件控制算法</h1><p>可应用的电路系统一般由模拟电路和数字电路组成。模拟电路用于电信号的处理和提供电源；数字电路则用于采集非电信号数据和控制系统。一般来说系统控制使用MCU、DSP或FPGA通过软件编程实现，在其中常使用用于控制系统的各种算法。</p>
<h2 id="PID算法"><a href="#PID算法" class="headerlink" title="PID算法"></a>PID算法</h2><h3 id="PID算法简介"><a href="#PID算法简介" class="headerlink" title="PID算法简介"></a>PID算法简介</h3><p>PID算法是一种很成熟、应用广泛的连续时间控制系统算法，最突出优点在于：</p>
<ul>
<li>结构典型</li>
<li>方便参数整定</li>
<li>可以灵活更改结构</li>
</ul>
<p>除了数字PID，还存在使用电阻、电容反馈与集成运放配合实现的模拟PID，但是因为其不便于修改和调参，适用范围不广</p>
<p>PID是一种典型的闭环控制算法，使用PID控制器<em>D(s)<em>来完成控制，该控制器读取输出量</em>y(t)<em>和给定量</em>r(t)<em>，计算得到二者之间的误差</em>e(t)=r(t)-t(t)<em>，并获取其比例、积分、微分的线性组合来构成控制量</em>u(t)<em>，通过改变调节器参数</em>K<del>p</del>，K<del>i</del>，K<del>d</del><em>来实现控制，计算公式如下<br>$$<br>u(t)=K_P[e(t)+\frac{1}{T_I} \int_0^t e(t)dt+T_D \frac{de(t)}{dt}]<br>$$<br>或者可以采用变形公式<br>$$<br>u(t)=K_P\ e(t)+K_I \int_0^t e(t)dt+K_D \frac{de(t)}{dt}<br>$$<br>其中**三个参数P、I、D分别表示比例、积分、微分</em></em></p>
<p>实际应用中最常使用PI甚至只使用P参数来进行控制。因为D参数常常会引入不确定性，增大调参的难度。</p>
<p>三个参数的特性如下：</p>
<ul>
<li><p>比例调节参数K<del>P</del></p>
<p>  按比例反映系统的误差，一旦系统出现偏差比例调节就会进行，<strong>比例调节是主要的控制部分</strong>。但是过大的比例会使系统稳定性下降，系统反应更灵敏、速度加快、稳态误差更小，但是震荡次数会显著增多，调节时间也会加长；过小的比例则会导致系统很难回到稳态</p>
</li>
<li><p>积分调节参数K<del>I</del></p>
<p>  这个参数本质上是通过给定量和输出量之间稳态值的差来消除系统稳态误差，<strong>用于提高系统的控制精度</strong>。但过高的调节参数会导致系统稳定性下降，动态响应变慢，超调增大，该参数一般不单独作用，至少需要和P参数共用</p>
</li>
<li><p>微分调节参数K<del>D</del></p>
<p>  用于反映系统偏差信号的变化率，可以一定程度上预测偏差的变化趋势，<strong>起到超前控制作用</strong>。但是该参数难以整定，且过强的微分调节会使系统剧烈震荡，且对噪声干扰有放大作用，对抗干扰不利</p>
</li>
</ul>
<h3 id="数字PID控制"><a href="#数字PID控制" class="headerlink" title="数字PID控制"></a>数字PID控制</h3><p>数字控制系统大多数是采样数据控制系统，进入系统的连续时间信号必须经过采样和量化后转换为数字量才能进行相应的计算和处理，所以其中的参数需要使用数字计算去逼近，当采样周期短时可以使用求和代替积分，使用差商代替微商，<strong>将描述连续时间的PID算法微分方程变成描述离散时间的差分方程</strong></p>
<p>实际使用时有两种思路：</p>
<ol>
<li><p>位置式PID</p>
<p> 差分方程为<br> $$<br> u_n=K_P+[e_n+\frac{T_S}{T_I} \sum_{i=0}^n e_i+\frac{T_D}{T_S} (e_n - e_{n-1})]+u_0=K_P e_n +K_I \sum_{i=0}^n e_i+K_D(e_n - e_{n-1})+u_0<br> $$<br> 此式即数字PID算法的非递推形式——全量算法，$u_0$为控制量基准值，n=0时将会采用该值；$u_n$是第n个采样时刻的控制量；$T_S$为采样周期，在算法中为了实现求和，必须存储系统偏差的全部值$e_i$，该式求得全量输出$u_n$是控制量的绝对数值，决定了执行机构在控制系统中的位置</p>
<p> 因此称这种算法为位置算法</p>
</li>
<li><p>增量式PID</p>
<p> 当驱动步进电机这样需要控制量的增量的执行机构时，需要用增量算法，差分方程为<br> $$<br> \Delta u_n=u_n-u_{n-1}=K_P[e_n - e_{n-1}+\frac{T_S}{T_I}e_n +\frac{T_D}{T_S}(e_n -2e_{n-1}+e_{n-2})]<br> $$<br> 这时的输出值能体现各次误差量对控制作用的影响，计算时只需要存储最近的三个误差采样值$e_n,e_{n-1},e_{n-2}$</p>
</li>
</ol>
<h3 id="PID算法的饱和特性"><a href="#PID算法的饱和特性" class="headerlink" title="PID算法的饱和特性"></a>PID算法的饱和特性</h3><p>实际的控制系统存在这样的特性：当控制变量达到一定值后，系统的输出变量便不再增长，系统进入饱和区，称为<strong>饱和特性</strong>，这就要求系统的控制变量必须限制在某个范围之内$u_{min}\le u\le u_{max}$。有时对于控制量的变化率也有限制$|\frac{du}{dt}|\le|\frac{du_{max}}{dt}| $，为了能让控制系统更加稳定，需要对位置算法进行改进；虽然增量算法中没有累加和项，不会出现积分饱和，但是可能出现比例和微分饱和，需要使用积累补偿法，将因为饱和而未能执行的控制增量信息累积起来，一旦可能时再补充执行</p>
<p>位置算法的饱和主要由积分项引起，称为<strong>积分饱和</strong>，可以使用三种方法必免积分积累过大</p>
<ol>
<li><p>积分分离法</p>
<p> 在误差量较大时不进行积分，直到误差在一定值之内时才在控制量的计算中加入积分累积，差分方程为<br> $$<br> u_n=K_P e_n + K_I \sum_{i=0}^n K_i e_i +K_D(e_n -e_{n-1})<br> $$<br> 其中K<del>i</del>在$e_x\le \epsilon$时为1，在$e_x\ge \epsilon$时为0，以$\epsilon$作为门限值可以有效削减积分饱和</p>
</li>
<li><p>遇限削弱积分法</p>
<p> 当<strong>控制进入饱和区后便不再进行积分项的累加</strong>，只执行削弱积分的运算，使用该算法可以避免控制量长时间停留在饱和区</p>
</li>
<li><p>有效偏差法</p>
<p> 将<strong>实际执行的控制量对应的误差值</strong>作为有效误差值进行积分累加，而不是使用实际的误差值进行积分累加</p>
</li>
</ol>
<h3 id="PID调参（参数整定）"><a href="#PID调参（参数整定）" class="headerlink" title="PID调参（参数整定）"></a>PID调参（参数整定）</h3><ol>
<li><p>确定PID控制器结构</p>
<ul>
<li>控制结果比较宽松且要求稳定性的控制系统：P或PD控制器</li>
<li>必须消除稳态误差且要求精度的控制系统：PI或PID控制器</li>
<li>存在滞后的对象：PI控制器或PID控制器</li>
</ul>
<p> 一般情况下，P、PI、PID控制器应用较多，ID控制器可以说根本不用</p>
</li>
<li><p>调参</p>
<p> 参数选择要根据受控对象的具体特性和对控制系统的性能要求进行，工程上一般要求整个闭环系统是稳定的，对给定量的变化能迅速响应并平滑跟踪，超调量小；要求抗干扰性较高；总体上遵循解决主要问题，统筹兼顾其他方面，适量折中的思路</p>
<p> PID三个参数一般通过玄学调参或者经验公式确定</p>
<p> 采样周期选择可以通过以下方面进行确定：</p>
<ol>
<li>香农采样定理：$T_S \le \frac{\pi}{\omega_{max}}$（ω为被采样信号的上限角频率），用于确定采样周期的上限</li>
<li>有跟踪要求的闭环系统要适量减小采样周期</li>
<li>要求采样周期有一定宽度来确定计算精度，减少系统算力成本</li>
<li>通过经验公式和玄学调参来确定</li>
</ol>
<p> PID参数的基本调整方法如下：</p>
<ol>
<li>比例项逐次独立实验，取其中反应最快、超调最小的曲线</li>
<li>加入积分项，将之前选择的比例系数减小为50%到80%，再将积分时间置为较大值，观测响应曲线，再逐次减小积分时间，选择其中响应震荡次数较少、能快速趋近结果的参数</li>
<li>加入微分项减小超调和震荡，先设置T<del>D</del>=0，再逐渐加大微分项，在此基础上维持比例项80%到120%调节范围，积分项50%到150%调节范围</li>
<li>如果出现玄学问题可以直接随机调参，运气是实力的一部分</li>
</ol>
</li>
<li><p>特殊调参方法</p>
<ol>
<li><p>选足够短的采样周期，先使用P控制器，逐渐加大比例放大系数逐次实验直到系统对输入的阶跃信号响应出现稳定边缘的临界震荡，将此时的比例放大系数记为$K_r$，临界震荡周期记为$T_r$</p>
</li>
<li><p>以连续时间PID控制器为基准，使用误差平方积分作为评价函数，控制度<br> $$<br> \frac{min \int_0^{\inf} e^2(t)dt（数字控制）}{min\int_0^\inf e^2(t)dt（模拟控制）}<br> $$<br> 保证其必定大于1的前提下，选定一个合适的控制度</p>
</li>
<li><p>查经验公式表获取对应参数</p>
</li>
<li><p>实际检验参数并进行微调</p>
</li>
</ol>
</li>
</ol>
<h2 id="运动调节算法"><a href="#运动调节算法" class="headerlink" title="运动调节算法"></a>运动调节算法</h2><h3 id="大林算法"><a href="#大林算法" class="headerlink" title="大林算法"></a>大林算法</h3><p>许多工程中会遇到纯滞后调节系统，要求系统具有以下特征：</p>
<ul>
<li>滞后时间长</li>
<li>系统动态特性和稳定性高</li>
<li>没有或很少超调量</li>
</ul>
<p>一般使用大林算法处理这类问题。该算法由IBM的大林（Dahlin）设计，专用于处理带有纯滞后的一阶或二阶惯性环节，其传递函数分别为<br>$$<br>G_c(s)=\frac{Ke^{-\theta s}}{\tau_1 s +1}<br>$$<br>或<br>$$<br>G_c(s)=\frac{Ke^{-\theta s}}{(\tau_1 s+1)(\tau_2 s +1)}<br>$$<br>其中τ1和2都是对象的时间常数，θ=Nτ是对象的纯滞后时间，N为正整数，K为对象的放大倍数</p>
<p>该算法适合对ADC、DAC等需要一定时间的转换器或带有硬件运算电路的设备进行控制，使得整个闭环系统的传递参数为带有纯滞后时间的一阶惯性环节，即<br>$$<br>\Phi(s)=\frac{e^{-\theta s}}{\tau_1 s +1}<br>$$<br>算法数字控制器的最终表达式：<br>$$<br>U(k)=a_1 E(k)-a_2E(k-1)+b_1 U(k-1) +(1-b_1)U(k-N-1)<br>$$<br>U(k)为k时刻的输出值，E(k)是k时刻的误差值，E(k-1)是k-1时刻的误差值，U(k-N-1)是k-N-1时刻的输出值</p>
<p>该算法调参依旧很玄学，但是没有PID那么玄学，只要根据系统飞升曲线确定对象的纯滞后时间θ和系统时间常数τ，微调选取采样周期再不断调整τ值一般就能获得理想效果</p>
<p>该算法最大的优势就是消除了由于超调引起的系统不稳定因素</p>
<h3 id="模糊控制算法"><a href="#模糊控制算法" class="headerlink" title="模糊控制算法"></a>模糊控制算法</h3><p>当系统影响因素极度复杂，难以建立数学模型时，需要使用模糊控制算法。这是一种鲁棒性强、抗干扰、抗参数变化的非线性控制算法，适用于非线性、动态特征不易掌握及纯滞后系统的控制。模糊控制不受数学模型的束缚，采用模糊控制表，在调试过程中反复经过人工修正，建立模糊控制算法、确立模糊规则是设计模糊控制系统中最重要的环节。模糊控制算法的问题在于稳态精度低、易饱和、适应能力有限、没有形成完整的理论体系。</p>
<p>这一算法需要以下步骤实现建模：</p>
<ol>
<li><p>归纳实验经验：将经验公式归结为一组条件语句，称为<strong>模糊控制规则</strong>或模糊控制模型</p>
</li>
<li><p>将误差e和误差变化率de/dt进行模糊化处理：将输入变量映射到一个合适的响应领域或模糊集合的标识符</p>
<p> 本人接盘的一个项目代码里存在以下代码（关键数据已经模糊替换处理）</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	u8 AFlag = (RotateNum &gt; StraightNum);</span><br><span class="line">	u8 BFlag = ((RotateNum + StraightNum) &gt; Magicnumber);</span><br><span class="line">	u8 CFlag = (RotateNum &gt; Magicnumber);</span><br><span class="line">	u8 DFlag = (StraightNum &gt; Magicnumber);</span><br><span class="line">	u8 SFlag = AFlag * Magicnumber + BFlag * Magicnumber + CFlag * Magicnumber + DFlag;</span><br><span class="line">	<span class="keyword">switch</span> (condition)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> Magicnumber:</span><br><span class="line">	<span class="keyword">case</span> Magicnumber:</span><br><span class="line">		*MoveThruster[<span class="number">0</span>] = (u32) (RotateNum);</span><br><span class="line">		*MoveThruster[<span class="number">1</span>] = (u32) (RotateNum);</span><br><span class="line">		*MoveThruster[<span class="number">2</span>] = (u32) ((Magicnumber - RotateNum + StraightNum));</span><br><span class="line">		*MoveThruster[<span class="number">3</span>] = (u32) ((Magicnumber - RotateNum + StraightNum));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> Magicnumber:</span><br><span class="line">	<span class="keyword">case</span> Magicnumber:</span><br><span class="line">		*MoveThruster[<span class="number">0</span>] = (u32) (StraightNum);</span><br><span class="line">		*MoveThruster[<span class="number">1</span>] = (u32) (StraightNum);</span><br><span class="line">		*MoveThruster[<span class="number">2</span>] = (u32) ((Magicnumber - RotateNum + StraightNum));</span><br><span class="line">		*MoveThruster[<span class="number">3</span>] = (u32) ((Magicnumber - RotateNum + StraightNum));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> Magicnumber:</span><br><span class="line">	<span class="keyword">case</span> Magicnumber:</span><br><span class="line">		*MoveThruster[<span class="number">0</span>] = (u32) ((RotateNum + StraightNum - Magicnumber));</span><br><span class="line">		*MoveThruster[<span class="number">1</span>] = (u32) ((RotateNum + StraightNum - Magicnumber));</span><br><span class="line">		*MoveThruster[<span class="number">2</span>] = (u32) (StraightNum);</span><br><span class="line">		*MoveThruster[<span class="number">3</span>] = (u32) (StraightNum);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> Magicnumber:</span><br><span class="line">	<span class="keyword">case</span> Magicnumber:</span><br><span class="line">		*MoveThruster[<span class="number">0</span>] = (u32) ((RotateNum + StraightNum - Magicnumber));</span><br><span class="line">		*MoveThruster[<span class="number">1</span>] = (u32) ((RotateNum + StraightNum - Magicnumber));</span><br><span class="line">		*MoveThruster[<span class="number">2</span>] = (u32) ((Magicnumber - RotateNum));</span><br><span class="line">		*MoveThruster[<span class="number">3</span>] = (u32) ((Magicnumber - RotateNum));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*MoveThruster[<span class="number">4</span>] = (u32) (VerticalNum);</span><br><span class="line">	*MoveThruster[<span class="number">5</span>] = (u32) (VerticalNum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (condition == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	*MoveThruster[<span class="number">0</span>] = (u32) (*PDRotate);</span><br><span class="line">	*MoveThruster[<span class="number">1</span>] = (u32) ((Magicnumber - *PDRotate));</span><br><span class="line">	*MoveThruster[<span class="number">2</span>] = (u32) (*PDRotate);</span><br><span class="line">	*MoveThruster[<span class="number">3</span>] = (u32) (Magicnumber - *PDRotate);</span><br><span class="line">	*MoveThruster[<span class="number">4</span>] = (u32) (VerticalNum);</span><br><span class="line">	*MoveThruster[<span class="number">5</span>] = (u32) (VerticalNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 就是一个模糊控制算法的例子，其中的Magicnumber都是经过大量实验确定的控制数据。使用python自带的map函数可以很好地对数据进行映射。</p>
</li>
<li><p>应用模糊算法：根据控制规则计算出模糊控制量C，之后通过多次实验校准模糊控制规则</p>
</li>
<li><p>构造基本模糊控制器查询表：将之前的一整套控制方法写成库或表</p>
</li>
</ol>
<p>其中确定控制数据的步骤最为关键，称为<strong>解模糊化</strong></p>
<h3 id="神经网络算法"><a href="#神经网络算法" class="headerlink" title="神经网络算法"></a>神经网络算法</h3><p>自动调准控制模型，适应性极强，但算法较复杂，需求算力高，一般的MCU难以实现，一般使用专门的硬件加速单元配合高性能嵌入式处理器实现</p>
<p>算法原理比较复杂，我一个辣鸡电工的也不是很懂（悲）</p>
<h2 id="运动姿态控制算法"><a href="#运动姿态控制算法" class="headerlink" title="运动姿态控制算法"></a>运动姿态控制算法</h2><p>Bresenhan算法是常用的图形扫描算法，只使用整数加法和乘2运算即可实现，可以在低算力水平的MCU中搭载，实现控制物体按规律运动的效果</p>
<h3 id="产生线段的整数Bresenham算法"><a href="#产生线段的整数Bresenham算法" class="headerlink" title="产生线段的整数Bresenham算法"></a>产生线段的整数Bresenham算法</h3><p>直线方程$y=mx+b$，在现实中位于(x0,y0)的物体运动可能有多种趋势，但总体上可以分为以下两种：</p>
<ul>
<li>靠近(x0+1,y0)</li>
<li>靠近(x0+1,y0+1)</li>
</ul>
<p>根据这两种趋势分别计算他们到直线$y=mx+b$的距离d1、d2，在求出两距离之差$\Delta d=d_1-d_2=2m(x_i +1)-2y_i +2b-1$</p>
<p>根据Δd&gt;0，直线上点离(x0+1,y0+1)较近；Δd&lt;0，直线上点离(x0+1,y0)较近，再用该式乘Δx即可得到一般的判别式<br>$$<br>p_1=2\Delta y-\Delta x，x_{i+1}=x_i+1 \<br>y_{i+1}=y_i +1,p_{i+1}=p_i +2(\Delta y-\Delta x)，当p_i\ge 0 \<br>y_{i+1}=y_i,p_{i+1}=p_i +2\Delta y，当p_i&lt; 0<br>$$<br>只需将原公式适当修正，用$|\Delta y|$、$|\Delta x|$替换$\Delta y$、$\Delta x$就能轻易得到向后方运动的线段</p>
<h3 id="产生圆的整数Bresenham算法"><a href="#产生圆的整数Bresenham算法" class="headerlink" title="产生圆的整数Bresenham算法"></a>产生圆的整数Bresenham算法</h3><p>对于圆来说需要用尽可能多的点表示出控制对象需要经过的轨迹点，Bresenham算法也有与上面求直线类似的公式<br>$$<br>p_i=2(x_i+1)^2 +2y_i^2 -2y_i -2R^2 +1 \<br>x_{i+1}=x_i +1 \<br>y_{i+1}=y_i,p_{i+1}=p_i+4x_i+6，若p_i&lt;0 \<br>y_{i+1}=y_i-1,p_{i+1}=p_i +4(x_i-y_i)+10 ，若p_i\ge 0<br>$$<br>将圆分成八个方位，将上式镜像对称即可获得其他七个方位的公式，显而易见计算它需要消耗大量算力资源有两种解决方案：</p>
<ol>
<li>使用RAM存储前1/8的坐标数据，然后通过镜像对称求出剩下的1/8坐标，然后调整顺序输出。这种方法可以节省算力，但是需要耗费大量RAM空间，可能还需要扩展片外RAM</li>
<li>按顺时针求出8组1/8圆的Bresenham算法表达式，在接下来的控制过程中依次切换使用。这种方法不需要额外扩充RAM，但是需要花费经历处理控制-运算衔接问题。在一些性能足够的MCU上可以使用RTOS来减少需要的处理精力，因此这种方法可以有效平衡硬件和需求</li>
</ol>
<h2 id="数字滤波"><a href="#数字滤波" class="headerlink" title="数字滤波"></a>数字滤波</h2><p>数字滤波指使用数值运算达到改变输入信号中所含频率分量的相对比例，或滤除某些频率分量的目的。常用于处理坏点数据、对信号进行平滑处理、消除毛刺等用途</p>
<p>最简单的滤波其实就是按钮软件消抖</p>
<h3 id="限幅滤波"><a href="#限幅滤波" class="headerlink" title="限幅滤波"></a>限幅滤波</h3><p>又叫程序判断滤波，根据多次采集到的数据，如果当前采集值和前一次采集值维持在一定偏差ΔD之内，则将每次采集到的数据和前一次数据进行比较，如果它们差的绝对值小于ΔD，则本次采集到的数据有效，否则舍弃</p>
<p>这种滤波器可以克服偶然因素引入的脉冲干扰和波形上的尖峰毛刺，但是难以抑制周期性干扰且对于波形处理的平滑度较差，只能算作一种最简单的基本滤波</p>
<h3 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h3><p>将原来的采样间隔进行细分，在原有基础上采样N次，然后把N次采样值按照大小排序，取中位数为本次采样值。</p>
<p>能够有效克服偶然因素带来的干扰，对于变化缓慢的被测参数有良好的滤波效果，但对于快速变化的信号则不太适用。算法实现方面，一般采用冒泡排序、选择排序、快速排序等算法，由于引入了排序算法，该方法不能处理速度要求很高的信号，算法的运算速度和占用RAM直接受所选择的N值决定</p>
<h3 id="算术平均滤波"><a href="#算术平均滤波" class="headerlink" title="算术平均滤波"></a>算术平均滤波</h3><p>和中值滤波的实现思路类似，但是需要取N次采样的算术平均值。</p>
<p>该算法难以对高速信号使用（除非搭配死贵的高速FPGA和烦到爆炸的等长走线进行硬件级别的算法滤波）</p>
<h3 id="递推平均滤波"><a href="#递推平均滤波" class="headerlink" title="递推平均滤波"></a>递推平均滤波</h3><p>又称为滑动平均滤波，将连续的N个采样值设为一个FIFO（先入先出队列），队长就为N，将队列中的N个数据进行算术平均滤波</p>
<p>这种方法对于周期性干扰具有非常好的抑制作用，具有很高的平滑度，但是灵敏度较低，对于偶然出现的脉冲干扰抑制作用较差，不适用于脉冲干扰较严重的场合。</p>
<p>该算法原理也可以应用在<strong>软件陷波器</strong>上。取N=S/f。其中S是美妙的采样次数，即采样率；f是要消除的谐波的频率，S、N都要取整数，这样最终就能实现对于f频率谐波的定向消除（采样平均值Y=Σ1/N，最终获得Y-C）</p>
<h3 id="中值平均滤波"><a href="#中值平均滤波" class="headerlink" title="中值平均滤波"></a>中值平均滤波</h3><p>选取N个采样，去掉其中最大值和最小值，再进行算术平均滤波，融合了中值滤波和平均滤波的特点，但也继承了二者的缺点</p>
<h3 id="限幅平均滤波"><a href="#限幅平均滤波" class="headerlink" title="限幅平均滤波"></a>限幅平均滤波</h3><p>先限幅滤波，再进行算术平均滤波</p>
<p>可以有效抑制偶然出现的脉冲干扰并消除采样偏差，但仍旧不适合高速信号处理</p>
<h3 id="一阶滞后滤波"><a href="#一阶滞后滤波" class="headerlink" title="一阶滞后滤波"></a>一阶滞后滤波</h3><p>取用一个比例常数0&lt;k&lt;1，使用以下公式计算本次输出结果：<br>$$<br>Output=k*T_n +(1-k)*T_{n-1}<br>$$<br>其中T<del>n</del>为本次采样值，T<del>n-1</del>为上次输出值</p>
<p>该方法类似PID，但是会造成相位滞后，灵敏度较低，难以消除频率高于采样频率一半的干扰信号</p>
<p>不过对于周期性干扰具有良好的抑制作用且运算量不大，适用于频率较高、相位要求不高的场合</p>
<h3 id="加权递推平均滤波"><a href="#加权递推平均滤波" class="headerlink" title="加权递推平均滤波"></a>加权递推平均滤波</h3><p>赋予不同时刻的FIFO采样值不同的权重，在对其进行递推平均滤波</p>
<p>适合在有较大纯滞后时间常数的对象和采样周期短的情况；难以反映变化较慢、采样周期长的情况，且占用RAM较多</p>
<h3 id="消抖滤波"><a href="#消抖滤波" class="headerlink" title="消抖滤波"></a>消抖滤波</h3><p>又称为数字消抖，通过设置一个滤波计数器，将每次采样值与当前有效值比较，如果采样值和有效值相等则清零，否则计数器+1并判断计数器是否达到上限，如果计数器溢出则将本次值替换为当前有效值，再清零计数器</p>
<p>常用于对变化缓慢的被测参数进行滤波，可避免系统在临界值附近时的波动跳变，但并不适用于快速变化的参数测量控制</p>
<h3 id="限幅消抖滤波"><a href="#限幅消抖滤波" class="headerlink" title="限幅消抖滤波"></a>限幅消抖滤波</h3><p>先使用限幅滤波，再进行消抖滤波</p>
<p>避免将干扰值导入系统，但不适用于快速变化的参数</p>
<h3 id="复杂数字滤波"><a href="#复杂数字滤波" class="headerlink" title="复杂数字滤波"></a>复杂数字滤波</h3><p>卡尔曼滤波、IIR滤波、高阶滤波等都需要复杂的运算过程，经常需要使用浮点运算，因此需要搭载的MCU具有一定的算力才能使用</p>
]]></content>
      <tags>
        <tag>电赛笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>MSP430简介</title>
    <url>/2021/11/13/msp430%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="MSP430"><a href="#MSP430" class="headerlink" title="MSP430"></a>MSP430</h1><p>该MCU是由德州仪器TI生产的16位低功耗单片机</p>
<span id="more"></span>

<p>主要分以下型号：</p>
<ul>
<li>专注低功耗的<strong>1xx</strong>通用型，配备1KB-60KB FLASH、512B-10KB RAM，工作时耗电仅达200uA/MIPS，RAM保持模式耗电0.1uA，RTC模式耗电0.7uA；可在6us之内快速唤醒。搭载10/12位斜率SAR ADC，集成模拟比较器、DMA、硬件乘法器、BOR、SVS、12位DAC</li>
<li>能耗比高的<strong>F2xx</strong>通用型，性能<a href="mailto:&#49;&#54;&#77;&#73;&#80;&#x53;&#x40;&#51;&#46;&#51;&#86;">&#49;&#54;&#77;&#73;&#80;&#x53;&#x40;&#51;&#46;&#51;&#86;</a>，配备1-120KB FLASH，8-128KB RAM，工作耗电220uA，配备10/12位斜率SAR ADC，集成16位Σ-ΔADC，基本上等于1xx的升级版</li>
<li><strong>性价比</strong>高的<strong>G2xx</strong>经济型，性能<a href="mailto:&#49;&#x36;&#x4d;&#73;&#x50;&#x53;&#x40;&#51;&#46;&#51;&#86;">&#49;&#x36;&#x4d;&#73;&#x50;&#x53;&#x40;&#51;&#46;&#51;&#86;</a>，对标友商stm32l，主打模拟外设和低功耗</li>
<li>面向计量和智能电网的AFE2xx专用型：性能略低于以上两个2xx系列，但是集成了1-3个独立的24位Σ-ΔADC，一个16位定时器、一个16位硬件乘法器、USART控制器、看门狗和GPIO</li>
<li>停产的老型号3xx</li>
<li>面向低功耗<strong>多媒体</strong>的<strong>4xx</strong>控制型，8-16MIPS处理性能，<strong>配备LCD控制器</strong>、<strong>FLL、SVS</strong>，针对低功耗测量和医疗应用，功耗和1xx相近，4-120KB FLASH、8-256KB RAM，引脚丰富最多可达80Pin，配备10/12位斜率SAR、16位Σ-ΔADC，同样集成了12位ADC、DMA、硬件乘法器、运放、USCI模块等</li>
<li><strong>超高能耗比的5xx超低功耗型</strong>，能达到<a href="mailto:&#x32;&#53;&#x4d;&#73;&#x50;&#83;&#64;&#x33;&#x2e;&#x33;&#86;">&#x32;&#53;&#x4d;&#73;&#x50;&#83;&#64;&#x33;&#x2e;&#x33;&#86;</a>，工作模式功耗165uA/MIPS，RTC模式2.5uA，RAM保持模式可达1uA，待机唤醒时间极短，小于5ms，配备256KB FLASH、18KB RAM，额外集成了USB、模拟比较器</li>
<li>高性能、低功耗的6xx系列旗舰型，达到<a href="mailto:&#x32;&#53;&#77;&#73;&#80;&#x53;&#x40;&#51;&#x2e;&#51;&#86;">&#x32;&#53;&#77;&#73;&#80;&#x53;&#x40;&#51;&#x2e;&#51;&#86;</a>，配备功耗优化的创新电源管理模块和USB控制器，配备LCD控制器，有256KB FLASH、18KB RAM，74Pin引脚，功耗与5xx系列相同，还额外集成了电压管理模块</li>
<li>基于<strong>FRAM</strong>技术的<strong>FRxx</strong>系列，和主要的F系列差别在于使用了FRAM存储技术，能够达到更快的FLASH访问速度并在所有功率模式下实现零功率状态保持，即使发生功率损耗的情况也可以保证写入操作，写入寿命能达到100M个周期，不再需要EEPROM</li>
<li>低电压C、L系列，两个谢列都可以在0.9-1.65V电压范围内工作并提供4MIPS的性能</li>
<li>集成射频基带的CC无线系列，具有低于1GHz的片上射频收发器，工作电压为1.8-3.3V，处理性能20MIPS</li>
<li>特殊系列：面对车规应用、电容触摸、超声波测量、DSP等等特殊用途的系列设备</li>
</ul>
<p>综合来看MSP430具有以下特点：</p>
<ol>
<li><p>超低功耗</p>
<p>使用1.8-3.6V低电压供电，RAM数据保持方式下耗电仅为0.1μA/MIPS，活动模式下耗电也仅仅为250μA/MIPS，IO输入端口漏电流仅为50mA，相比之下只有stm8和stm32l0系列能够达到同等级的低功耗水准。普通的8051则远远落后</p>
</li>
<li><p>能效比高，针对算法加速</p>
<p>MSP430基于RISC架构，采用了一般DSP才有的16位多功能硬件乘法器、硬件乘-加功能、DMA等架构，可以高效实现如FFT、DFT、FIR滤波等数字信号处理算法</p>
</li>
<li><p>模拟外设技术高</p>
<p>MSP430片内集成多种模拟外设，包括液晶驱动器和ADC、DAC等，具体外设由型号决定</p>
</li>
<li><p>外设寄存器直接按位寻址</p>
<p>外设寄存器可以直接进行赋值、按位操作</p>
</li>
</ol>
<p>msp430系列使用了冯诺依曼架构，并构建了MAB（存储器地址总线）、MDB（存储器数据总线）两个总线协议，其中RAM、FLASH共用同一个地址空间，程序被下载到FLASH，设备复位后自动读取并执行程序指令，局部变量存储在RAM，BSS段变量存储在FLASH，FLASH掉电不丢失</p>
<p>设备内部时钟至少具有3套时钟源：</p>
<ol>
<li>LFXT1CLK：低频时钟，32.768kHz</li>
<li>XT2CLK：高频时钟，8MHz</li>
<li>DCOCLK：片内数字控制RC振荡器，经常用作系统和外设时钟信号，其稳定性由FLL与硬件控制</li>
</ol>
<p>三套时钟源可以被设备单独选用，时钟通过片内总线提供给设备；有些型号还具有更多类型的时钟源</p>
<p>DMA可以直接接管总线以提高传输效率（不同于AMBA总线的仲裁，MAB、MDB总线只采用主控设备-从设备的方式）</p>
<p>CPU则采用了双总线位宽的灵活处理方式，分为<strong>16位寻址的CPU</strong>和<strong>20位寻址的CPUX</strong>。CPU采用RISC架构，配备27条指令和7种统一的寻址模式，寻址空间64KB；CPUX寻址空间为1MB，采用面向控制的结构和指令系统，集成了计算分支、表处理等特性，可以在不分页的情况下处理1MB的地址范围，属于RISC正交指令集（正交：指令集的绝大多数指令格式相同、长度相同，所有寄存器的寻址可以替换；而指令的操作码、寻址方式、操作数寄存器字段的取值相互独立），可以实现MTM（内存到内存）传输，不需要经过中间寄存器，一并对16位CPU实现了兼容</p>
<p>在电赛中最常用的就是==<strong>MSP430F5529</strong>==，下面均以F5529为例说明</p>
<h2 id="外围电路设计"><a href="#外围电路设计" class="headerlink" title="外围电路设计"></a>外围电路设计</h2><h3 id="供电"><a href="#供电" class="headerlink" title="供电"></a>供电</h3><p>MCU部分模拟外设和FLASH、RAM对于电源要求较高，但是MCU数字部分对于电源要求较低，因此采用双电源——模拟/数字的方式为MCU供电。模拟-数字电源之间采用磁珠跨接3.3V和地除杂波，同时需要使用10uF、100nF电容并联进行滤波，10uF用于滤除低频杂波，100nF则用于旁路</p>
<h3 id="复位"><a href="#复位" class="headerlink" title="复位"></a>复位</h3><p>RST引脚低电平有效，因此和一般单片机的复位电路一样即可</p>
<h3 id="晶振"><a href="#晶振" class="headerlink" title="晶振"></a>晶振</h3><p>需要使用两个晶振接入来保证电源稳定，<strong>XT1接低频32.768kHz</strong>，<strong>XT2接高频晶振，一般为4MHz</strong>，因为内部电容不足以起振，所以同时需要单独配备20-30pF的匹配电容，一般使用22pF电容</p>
<h3 id="USB"><a href="#USB" class="headerlink" title="USB"></a>USB</h3><p>f5529具有USB控制器，能够使用4芯电缆：5V、D+、D-、GND，并可以兼容USB OTG的ID线。</p>
<h2 id="编译烧录"><a href="#编译烧录" class="headerlink" title="编译烧录"></a>编译烧录</h2><p>MSP430支持JTAG和SBW（Spy-Bi-Wire，TI指定的两线调试接口，信号叫为SBWTCK和SBWTDIO）</p>
<p>同时也支持BSL（BootStrap Loader），或者说BootLoader加载程序烧录可以通过USB、UART等对单片机进行ISP烧录，在PUR引脚和USB D+之间跨接1.4k电阻，下连1M电阻到地，并通过一个加了限流电阻（一般为100Ω）的微动开关连接到VCC即可实现USB的BSL烧录</p>
<p>MSP430的开发环境是TI基于eclipse开发的Code Composer Studio，简称<strong>CCS</strong>，在其中使用专用的MSP430 Compile与Linker即可实现C程序编译链接</p>
<h3 id="关键字和内联函数"><a href="#关键字和内联函数" class="headerlink" title="关键字和内联函数"></a>关键字和内联函数</h3><p>同时CCS支持了一些扩展关键字，列举如下：</p>
<ul>
<li><p><code>__asm</code>用于C语言内嵌汇编，这个和keil一样</p>
</li>
<li><p><code>__interrupt</code>放在函数前指示中断函数，一般和#pragma指令共用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=UART0RX_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">UART_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>上例指示了一个串口0接收中断，#pragma指令让中断向量表中的地址位重定向了</p>
</li>
<li><p><code>__monitor</code>放在函数前，在执行到函数时自动关闭全局中断，类似__atom指令</p>
</li>
<li><p><code>__no_init</code>放在全局变量钱让程序启动时不被变量赋初值</p>
</li>
<li><p><code>__raw</code>关闭中断服务函数的恢复现场能力，这会导致中断服务函数无法返回</p>
</li>
<li><p><code>__regvar</code>声明变量为寄存器变量，注意不能使用指针指向寄存器变量，并且必须搭配使用__no_init禁止初始化</p>
</li>
<li><p><code>sfrb</code>用于声明单字节IO数据类型对象，和51一样用于定义寄存器地址</p>
</li>
</ul>
<p>除了关键字外，CCS还包含了许多内联函数，常见的几个摘录如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__no_operation();<span class="comment">//空指令，相当于NOP</span></span><br><span class="line">__enable_interrupt();<span class="comment">//打开全局中断</span></span><br><span class="line">__disable_interrupt();<span class="comment">//关闭全局中断</span></span><br><span class="line">__delay_cycles(<span class="keyword">unsigned</span> <span class="keyword">long</span> __cycles);<span class="comment">//延时__cycles个主时钟（MCLK）周期</span></span><br><span class="line">__set_SP_register(<span class="keyword">unsigned</span> <span class="keyword">short</span>);<span class="comment">//为堆栈指针寄存器SP赋值</span></span><br></pre></td></tr></table></figure>

<h3 id="预定义寄存器"><a href="#预定义寄存器" class="headerlink" title="预定义寄存器"></a>预定义寄存器</h3><p>CCS中还预置了一些单片机常用的寄存器和配置，如下所示</p>
<ol>
<li><p>端口定义，其中x表示端口号</p>
<p>PxIN：端口输入寄存器</p>
<p>PxOUT：端口输出寄存器</p>
<p>PxDIR：端口方向控制寄存器</p>
<p>PxSEL：端口复用寄存器</p>
<p>注意：<strong>MSP430不支持位操作，一般通过屏蔽位的方法实现位操作，这是它和51开发方面最大的不同</strong>，如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT0 00000001b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT1 00000010b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT2 00000100b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT3 00001000b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT4 00010000b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT5 00100000b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT6 01000000b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT7 10000000b</span></span><br><span class="line"></span><br><span class="line">P1OUT |= BIT0;</span><br><span class="line"><span class="comment">//这样可以实现P1.0输出</span></span><br><span class="line"></span><br><span class="line">P1OUT |= BIT4;</span><br><span class="line"><span class="comment">//这样可以实现P1.0和P1.3同时输出</span></span><br><span class="line"></span><br><span class="line">P1OUT &amp;= ~BIT1;</span><br><span class="line"><span class="comment">//这样可以取消P1.0的输出</span></span><br></pre></td></tr></table></figure></li>
<li><p>低功耗模式的进入和退出</p>
<p>CCS预定义了一些宏指令用来实现低功耗模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LPM3;<span class="comment">//进入低功耗模式</span></span><br><span class="line">LPM3_EXIT;<span class="comment">//退出低功耗模式</span></span><br></pre></td></tr></table></figure>

<p>其中数字可以写0-4，分别对应四种低功耗模式</p>
</li>
<li><p>外设寄存器</p>
<p>各种片上外设的寄存器都被定义为了宏，可以通过<code>|=</code>与<code>&amp;=~</code>的方式进行按位控制</p>
</li>
<li><p>部分常用代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_dint(); <span class="comment">//等效于__disable_interrupt</span></span><br><span class="line">_EINT(); <span class="comment">//等效于__enable_interrupt</span></span><br><span class="line">_NOP(); <span class="comment">//空指令</span></span><br><span class="line">_OPC(x); <span class="comment">//在指令流中插入一个常熟，对与参数对应的任何指令进行编码</span></span><br><span class="line">_SWAP_BYTES(x); <span class="comment">//将无符号16位整数的高8位和低8位交换</span></span><br><span class="line">monitor <span class="comment">//关键字__monitor的宏定义</span></span><br><span class="line">no_init <span class="comment">//关键字__no_init的宏定义</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>综上所述，MSP430的开发和8051的开发非常类似，并没有stm32的库封装，而是直接操作寄存器。这不仅仅是由于MSP430的性能较低，也是由于这样的编程方式写出的代码更加简洁、指令量更少，能突出体现MSP430低功耗的优势</p>
<h2 id="片上外设开发"><a href="#片上外设开发" class="headerlink" title="片上外设开发"></a>片上外设开发</h2><p>MSP430的片上外设寄存器具体配置和51单片机的很像，但是有一些功能更加复杂，和stm32的寄存器接近，同时也提供了简化操作的库函数</p>
<h3 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h3><p>f5529一共有80个引脚，和stm32的<strong>gpio</strong>结构类似，并且也具有<strong>复用功能</strong>。除此之外某些引脚具备基本的<strong>电源功能</strong>，分别能够为MCU的片上数字电路和模拟电路供电，一般情况下可以共用一个电源，但在某些高精度测量场合需要双电源隔离供电。msp430还具有一个USB电源，可以直接输出5V供电，经过片上LDO后能在端口VBUS处输出稳定的3.3V电压供单片机和外设使用，最大驱动电流60mA</p>
<p>其中P1、P2端口IO都具有外部中断能力，分别对应P1IV中断向量和P2IV中断向量。端口可单独配置强驱动和弱驱动模式，<strong>强驱动模式下全片最大输出电流100mA，单端口最大电流15mA；弱驱动模式下全片最大输出电流48mA，单端口最大电流6mA</strong></p>
<p>寄存器操作可以通过上面介绍过的屏蔽位法，也可以通过分别操作寄存器高8位和低8位的方法实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用三种方法将P1.1和P2.2配置为输出功能</span></span><br><span class="line">P1DIR |= <span class="number">0x02</span>; <span class="comment">//0x02 == 00000010b</span></span><br><span class="line">P2DIR |= <span class="number">0x04</span>; <span class="comment">//0x04 == 00000100b</span></span><br><span class="line"></span><br><span class="line">PADIR_L |= <span class="number">0x02</span>; <span class="comment">//DIR寄存器低8位，代表P1</span></span><br><span class="line">PADIR_H |= <span class="number">0x04</span>; <span class="comment">//DIR寄存器高8位，代表P2</span></span><br><span class="line"></span><br><span class="line">PADIR |= <span class="number">0x0402</span>; <span class="comment">//直接操作DIR寄存器，将其视作uint16_t</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>端口配置</p>
<p>如下配置端口为输入状态并配置内部上拉</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P1DIR &amp;= ~BIT1; <span class="comment">//BIT1 == 0x00000010b，设置P1.1为输入模式</span></span><br><span class="line">P1REN |= BIT1; <span class="comment">//使能上下拉电阻</span></span><br><span class="line">P1OUT |= BIT1; <span class="comment">//P1.1配置上拉电阻</span></span><br></pre></td></tr></table></figure>

<p>通过配置PxDIR.n |= 1可以将相应的IO口配置为输出状态，在输出状态下，PxREN、PxIN无效。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P1OUT |= BIT1; <span class="comment">//P1.1输出高电平</span></span><br><span class="line">P1OUT &amp;= ~BIT1; <span class="comment">//P1.1输出低电平</span></span><br><span class="line"></span><br><span class="line">P1DS<span class="number">.1</span> &amp;= ~BIT1; <span class="comment">//配置P1.1为弱驱动输出</span></span><br><span class="line">P1DS<span class="number">.1</span> |= BIT1; <span class="comment">//配置P1.1为强驱动输出</span></span><br></pre></td></tr></table></figure></li>
<li><p>端口复用配置</p>
<p>基本每个IO都有端口复用功能，通过配置PxSEL.n把对应的IO口配置为复用功能</p>
<p>使用以下代码配置P1.0为定时器A0时钟输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P1DIR &amp;= ~BIT0; <span class="comment">//设置P1.0为输入状态</span></span><br><span class="line">P1SEL |= BIT0; <span class="comment">//将P1.0复用为定时器A0时钟输入</span></span><br></pre></td></tr></table></figure>

<p>相关配置需要按照datasheet中的端口复用表选择</p>
</li>
</ol>
<h3 id="时钟系统与低功耗"><a href="#时钟系统与低功耗" class="headerlink" title="时钟系统与低功耗"></a>时钟系统与低功耗</h3><p>msp430f5529具有<strong>5种时钟源</strong>（XT1CLK、XT2CLK、VLOCLK、REFOCLK、DCOCLK）和<strong>3种时钟信号</strong>（MCLK、SMCLK、ACLK）</p>
<p>时钟系统可以软件配置成不需要外部晶振、需要一个外部晶振、需要两个外部晶振、外部时钟输入等方式，最极端的情况下单片机内部具有自身振荡器可以为CPU及片上外设提供系统时钟</p>
<p>时钟系统的安全性比较重要，msp430配备了紧急保护系统，在外部时钟故障时会自动选择内部时钟源REFOCLK或VLOCLK作为时钟信号，并产生响应故障信号（可选中断）</p>
<p>系统时钟大致分为两级，<em>信号生成级</em>和<em>信号分配级</em>，中间通过MUX连接。信号生成级别分为三个模块基本的OSC模块可以通过晶振旁路、内部REFO或VLO直接输出XT1CLK、VLOCLK、REFOCLK三种信号；可选的XT2模块直接输出XT2晶振的4MHz时钟作为XT2CLK；可以通过晶振旁路和FLL（Frequency Locked Loop锁频环）进行晶振时钟倍频和分频，信号源（即FLLREFCLK反馈时钟）通过MUX直接引用XT1CLK、REFOCLK、XT2CLK之一，经过多个倍频分频器后输出为DCOCLK和DCOCLKDIV。所有信号分别输出到信号分配级，通过MUX分配给ACLK、MCLK、SMCLK</p>
<p><strong>XT1CLK</strong>：<strong>外部低频或高频时钟源</strong>，默认关闭，需要接入外部晶振并通过软件使晶振起振后再使用，一般使用32.768kHz的低频晶振，但是也可以使用4-32MHz的外部高频时钟源，<strong>端口P5.4、P5.5</strong></p>
<p>使用下面的代码对时钟源进行配置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P5SEL |= BIT4 | BIT5; <span class="comment">//配置P5.4、P5.5为XT1复用功能</span></span><br><span class="line">UCSCTL6 |= XCAP_3; <span class="comment">//配置匹配电容为12pF</span></span><br><span class="line">UCSCTL6 &amp;= ~XT1OFF; <span class="comment">//使能XT1，使外部晶振起振</span></span><br><span class="line"><span class="keyword">while</span>(SFRIFG1 &amp; OFIFG)</span><br><span class="line">&#123;</span><br><span class="line">    UCSCTL7 &amp;= ~(XT2OFFG + XT1LFOFFG + DCOFFG); <span class="comment">//清除三类时钟故障标志位，等待起振</span></span><br><span class="line">    SFRIFG1 &amp;= ~OFIFG; <span class="comment">//清除震荡器故障标志位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>XT2CLK</strong>：和XT1CLK类似，但只能接4-32MHz的<strong>高频晶振</strong>，一般接入4MHz晶振，需要额外加匹配电容方便起振。<strong>端口P5.2、P5.3</strong></p>
<p>需要注意的是在配置SMCLK和MCLK为XT2CLK时钟源之前需要先修改ACLK和REFCLK的时钟源，因为它们的时钟源默认为XT1CLK，但这里并没有启动，所以会导致没有必要的XT1CLK始终故障，会影响判断XT2是否起振，实现代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P5SEL |= BIT2 | BIT3; <span class="comment">//配置P5.2、P5.3为XT2复用功能</span></span><br><span class="line">UCSCTL6 &amp;= ~XT2OFF; <span class="comment">//使能XT2</span></span><br><span class="line">UCSCTL4 = UCSCTL4 &amp; (~(SELA_7)) | SELA_1; <span class="comment">//将ACLK配置为VLOCLK</span></span><br><span class="line">UCSCTL3 |= SELREF_2; <span class="comment">//将REFCLK配置为REFOCLK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(SFRIFG1 &amp; OFIFG)</span><br><span class="line">&#123;</span><br><span class="line">    UCSCTL7 &amp;= ~(XT2OFFG + XT1LFOFFG + DCOFFG); <span class="comment">//清除三类时钟故障标志位，等待起振</span></span><br><span class="line">    SFRIFG1 &amp;= ~OFIFG; <span class="comment">//清除震荡器故障标志位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>VLOCLK</strong>：<strong>内部低功耗、低频时钟源</strong>，<strong>频率10kHz</strong>，精度较低，会随电源电压和温度产生较大漂移，用于不需要精准时钟基准的系统控制，被使用时自动开启、不使用时自动关闭，低功耗唤醒模式下回优先使用该时钟源作为系统和看门狗时钟</p>
<p>配置UCSCTL4选择</p>
<p><strong>REFOCLK</strong>：<strong>内部修整低频参考时钟源，精度较高，32.768kHz</strong>，和VLOCLK一样不需要配置寄存器进行起振，若未使用外部晶振，系统会自动选择该时钟源作为ACLK和DCOCLK锁频环参考时钟源</p>
<p>通过UCSCTL4选择</p>
<p><strong>DCOCLK</strong>：内部数字控制时钟源，具有宽工作频率，<strong>最高可产生25MHz时钟频率</strong>，可以和FLL配合控制参考时钟，也可以引入其他时钟源反馈进行时钟分频/倍频，但是需要额外配置</p>
<p>这是f5xx中<strong>最常用的时钟源</strong>，类似于stm32的PLL时钟（它的内部也是类似的PLL）</p>
<p>其频率计算公式如下<br>$$<br>DCOCLK = D \times (N+1) \times \frac{REFCLK}{n} \<br>DCOCLKDIV = (N+1) \times \frac{REFCLK}{n}<br>$$<br>REFCLK来源见上文</p>
<p>n为输入时钟分频，通过UCSCTL3中的FLLCLKDIV设定，查找该寄存器介绍可知其取值0-7，对应n取值2^p^，默认为0，不分频</p>
<p>D通过UCSCTL2中的FLLD设对，可取值0-7，对应D取值2^p^，默认为1，即D=2，二分频</p>
<p>N可以通过UCSCTL2中的FLLN设定，取值0-1023，当FLLN=0时，N=1，除此之外N=FLLN，默认为31，即N=31</p>
<p>如果系统复位后不进行任何设置，DCOCLK=2097152Hz，DCOCLKDIV=1048576Hz</p>
<p><strong>MCLK和SMCLK都默认选择DCOCLKDIV作为时钟源</strong>。</p>
<p>通过配置DCORSEL、DCOx、MOD来选择DCO的频率设置范围（最小值和最大值）</p>
<p>详细内容参考datasheet</p>
<p><strong>MODOSC</strong>：内部模块振荡器，是<strong>UCS时钟模块下属的振荡器</strong>，能产生<strong>4.8MHz的MODCLK时钟</strong>，用于FLASH、ADC等片上外设</p>
<p><strong>MCLK</strong>：为CPU和片上外设提供<strong>主时钟</strong>，默认使用DCOCLKDIV</p>
<p>通过配置DIVM选择MCLK分频系数为1、2、4、8、16、32</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UCSCTL4 = UCSCTL4 &amp; (~SELM_7) | SELM_0; <span class="comment">//XT1CLK时钟源</span></span><br><span class="line">UCSCTL4 = UCSCTL4 &amp; (~SELM_7) | SELM_1; <span class="comment">//VLOCLK时钟源</span></span><br><span class="line">UCSCTL4 = UCSCTL4 &amp; (~SELM_7) | SELM_2; <span class="comment">//REFOCLK时钟源</span></span><br><span class="line">UCSCTL4 = UCSCTL4 &amp; (~SELM_7) | SELM_3; <span class="comment">//DCOCLK时钟源</span></span><br><span class="line">UCSCTL4 = UCSCTL4 &amp; (~SELM_7) | SELM_4; <span class="comment">//DCOCLKDIV时钟源</span></span><br><span class="line">UCSCTL4 = UCSCTL4 &amp; (~SELM_7) | SELM_5; <span class="comment">//XT2CLK时钟源</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UCSCTL5 = UCSCTL5 &amp; (~DIVM_7) | DIVM_0; <span class="comment">//MCLK不分频</span></span><br><span class="line">UCSCTL5 = UCSCTL5 &amp; (~DIVM_7) | DIVM_1; <span class="comment">//MCLK 2分频</span></span><br><span class="line">UCSCTL5 = UCSCTL5 &amp; (~DIVM_7) | DIVM_2; <span class="comment">//MCLK 4分频</span></span><br><span class="line">UCSCTL5 = UCSCTL5 &amp; (~DIVM_7) | DIVM_3; <span class="comment">//MCLK 8分频</span></span><br><span class="line">UCSCTL5 = UCSCTL5 &amp; (~DIVM_7) | DIVM_4; <span class="comment">//MCLK 16分频</span></span><br><span class="line">UCSCTL5 = UCSCTL5 &amp; (~DIVM_7) | DIVM_5; <span class="comment">//MCLK 32分频</span></span><br></pre></td></tr></table></figure>

<p><strong>ACLK</strong>：<strong>辅助时钟</strong>，专用来为外围模块提供信号。默认使用XT1CLK时钟源，如果未起振，则使用REFOCLK。配置方法和MCLK完全一致</p>
<p><strong>SMCLK</strong>：<strong>子系统主时钟</strong>，和MCLK基本一致，只是不为CPU提供时钟</p>
<p>上电复位后，UCS默认配置如下：</p>
<ul>
<li>ACLK选择XT1为时钟源，如果未起振则使用REFOCLK并生成时钟故障标志</li>
<li>MCLK选择DCOCLKDIV</li>
<li>SMCLK选择DCOCLKDIV</li>
</ul>
<p>需要注意：msp430f5529的XTIN和XTOUT引脚默认为GPIO功能，并在上电情况下不会启动，需要额外进行软件设置</p>
<p>同时P7.7、P2.2、P1.0分别能够对外输出MCLK、SMCLK、ACLK时钟</p>
<p>这里用最为复杂的DCO配置说明整个时钟系统的配置流程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430f5529.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetVcoreUp</span><span class="params">(<span class="keyword">uint_32_t</span> level)</span></span>; <span class="comment">//提升核心电压以提升工作频率</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">XT1_ON</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//启动XT1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DCO__16MHz</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//使用DCO将XT1倍频到16MHz</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW + WDTHOLD;</span><br><span class="line">    P1SEL |= BIT0; <span class="comment">//P1.0 ACLK输出</span></span><br><span class="line">    P1DIR |= BIT0;</span><br><span class="line">    P2SEL |= BIT2; <span class="comment">//SMCLK输出</span></span><br><span class="line">    P2DIR |= BIT2;</span><br><span class="line">    P7SEL |= BIT7; <span class="comment">//MCLK输出</span></span><br><span class="line">    P7DIR |= BIT7;</span><br><span class="line">    P7DIR |= BIT0; <span class="comment">//P7.0 LED驱动输出</span></span><br><span class="line">    P1OUT |= BIT0;</span><br><span class="line">    </span><br><span class="line">    XT1_ON();</span><br><span class="line">    DCO__16MHz();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        __delay_cycles(<span class="number">8000000</span>); <span class="comment">//每0.5s</span></span><br><span class="line">        P7OUT ^= BIT0 ;<span class="comment">//LED状态翻转一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetVcoreUp</span><span class="params">(<span class="keyword">uint_32_t</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PMMCTL0_H = PMMPW_H; <span class="comment">//解锁PMM寄存器，允许写入</span></span><br><span class="line">    SVSMHCTL = SVSHE + SVSHRVL0 * level + SVMHE + SVSMHRRL0 * level; <span class="comment">//设置SVS/SVM高侧到新的等级</span></span><br><span class="line">    SVSMLCTL = SVSLE + SVMLE + SVSMLRRL0 * level; <span class="comment">//设置SVS低侧到新的等级</span></span><br><span class="line">    <span class="keyword">while</span>((PMMIFG &amp; SVSMLDLYIFG) == <span class="number">0</span>); <span class="comment">//等待SVM稳定</span></span><br><span class="line">    PMMIFG &amp;= ~(SVMLVLRIFG + SVMLIFG); <span class="comment">//清除已经置位的标志</span></span><br><span class="line">    PMMCTL0_L = PMMCOREV0 * level; <span class="comment">//设置VCORE到新的等级</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span>((PMMIFG &amp; SVMLIFG)) <span class="comment">//等待达到新的电压等级</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>((PMMIFG &amp; SVMLVLRIFG) == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置SVS/SVM低侧到新的水平</span></span><br><span class="line">    SVSMLCTL = SVSLE + SVSLRVL0 * level + SVMLE + SVSMLRRL0 * level;</span><br><span class="line">    PMMCTL0_H = <span class="number">0x00</span>; <span class="comment">//锁住PMM的写入路径</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">XT1_ON</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    P5SEL |= BIT4 |BIT5; <span class="comment">//配置XT1引脚</span></span><br><span class="line">    UCSCTL6 |= XCAP_3; <span class="comment">//配置电容为12pF</span></span><br><span class="line">    UCSCTL6 &amp;= ~XT1OFF; <span class="comment">//使能XT1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(SFRIFG1 &amp; OFIFG)</span><br><span class="line">    &#123;</span><br><span class="line">        UCSCTL7 &amp;= ~(XT2OFFG + XT1LFOFFG + DCOFFG); <span class="comment">//清除三类时钟错误标志位</span></span><br><span class="line">        SFRIFG1 &amp;= ~OFIFG; <span class="comment">//清除时钟错误标志位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DCO__16MHz</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SetVcoreUp(<span class="number">1</span>); <span class="comment">//一级一级提升核心电压，不能跨级</span></span><br><span class="line">    SetVcoreUp(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置寄存器使DCOCLK=4.9MHz,DCOCLKDIV=2.45MHz */</span></span><br><span class="line">    __bis_SR_register(SCG0); <span class="comment">//关闭FLL库函数</span></span><br><span class="line">    UCSCTL0 = <span class="number">0x0000</span>; <span class="comment">//清零寄存器值，FLL运行时系统会自动配置该寄存器</span></span><br><span class="line">    UCSCTL1 = DCORSEL_5; <span class="comment">//选择DCOCLK频率范围 6-23.7MHz</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//FLLD=0，则D=1；FLLN=487，则N=487；N在UCSCTL3寄存器，默认值为1，则DCOCLK=1*(487+1)*32768=15.990784MHz</span></span><br><span class="line">    <span class="comment">//DCODIVCLK=(487+1)*32768=15.990784MHz</span></span><br><span class="line">    UCSCTL2 = FLLD_0 + <span class="number">487</span>; </span><br><span class="line">    </span><br><span class="line">    __bic_SR_register(SCG0); <span class="comment">//开启FLL控制回路</span></span><br><span class="line">    __delay_cycles(<span class="number">76563</span>); <span class="comment">//延时等待时钟稳定</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(SFRIFG1 &amp; OFIFG) <span class="comment">//检测时钟错误并等待时钟稳定</span></span><br><span class="line">    &#123;</span><br><span class="line">        UCSCTL7 &amp;= ~(XT2OFFG + XT1LFOFFG + DCOFFG);</span><br><span class="line">        SFRIFG1 &amp;= ~OFIFG;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>低功耗配置</strong></em></p>
<p>msp430一共有8种工作模式</p>
<ul>
<li>活跃模式（AM）</li>
<li>低功耗模式（LPM）0</li>
<li>低功耗模式1</li>
<li>低功耗模式2</li>
<li>低功耗模式3</li>
<li>低功耗模式3.5</li>
<li>低功耗模式4</li>
<li>低功耗模式4.5</li>
</ul>
<p>但是并不是所有系列都支持这些工作模式，对于f5529来说，不支持LPM3.5</p>
<p>使用以下指令来进入和退出低功耗模式0-4</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 开总中断并进入低功耗模式 */</span></span><br><span class="line">__bis_SR_register(LPMn_bits + GIE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 退出低功耗模式 */</span></span><br><span class="line">LPMn_EXIT; <span class="comment">//其中n可以换成数字0-4</span></span><br></pre></td></tr></table></figure>

<p>需要注意：<strong>低功耗模式唤醒都需要使用外部中断</strong>，所以需要在进入低功耗模式同时开启总中断</p>
<p>在最高级别LPM4.5低功耗模式下，RAM中内容会直接丢失，所以在从LPM4.5唤醒后需要重新配置寄存器和相关设置</p>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>低功耗模式唤醒使用的指令实际上是通过直接修改SR寄存器的值，清除休眠标志，它内联到以下函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_bic_SR_register_on_exit(LPM3_bits);<span class="comment">//退出LPM3</span></span><br></pre></td></tr></table></figure>

<p>MSP430和arm一样都具有<em>系统中断</em>、<em>不可屏蔽中断</em>和<em>可屏蔽中断</em>三种，其中系统中断和不可屏蔽中断优先级最高；可屏蔽中断可以通过<strong>状态寄存器SR</strong>中的GIE位来屏蔽和开启</p>
<p>大致的中断作用与arm类似，而使用方式与51类似</p>
<p>下面主要介绍外部中断</p>
<ol>
<li><p>初始化端口时要清空中断标志位</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P1IFG &amp;= ~(BIT0); <span class="comment">//清空中断标志位</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>PIES</code>寄存器选择触发边沿（0为上升沿，1为下降沿）并使用<code>PxIE</code>寄存器使能中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P1IES &amp;= ~BIT0; <span class="comment">//P1.0上升沿触发</span></span><br><span class="line">P1IES |= BIT1; <span class="comment">//P1.1下降沿触发</span></span><br><span class="line">P1IES |= BIT2; <span class="comment">//P1.2下降沿触发</span></span><br><span class="line">    </span><br><span class="line">P1IE |= BIT0; <span class="comment">//使能P1.0中断</span></span><br><span class="line">P1IE |= BIT1; <span class="comment">//使能P1.1中断</span></span><br><span class="line">P1IE |= BIT2; <span class="comment">//使能P1.2中断</span></span><br></pre></td></tr></table></figure></li>
<li><p>开总中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__bis_SR_register(GIE);</span><br></pre></td></tr></table></figure></li>
<li><p>编写中断服务函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector = 中断向量地址</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">ISR_function</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//中断服务函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在中断函数内部清零中断标志位</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__even_in_range(P1IV, <span class="number">16</span>); <span class="comment">//用于查询P1的所有中断标志位并自动清零，使用该函数可以实现将所有P1的外部中断放在同一个函数内解决的功能,如下所示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(__even_in_range(P1IV, <span class="number">16</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//无中断</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//P1IFG.0</span></span><br><span class="line">        <span class="comment">/* 中断处理函数 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">//P1IFG.1</span></span><br><span class="line">        <span class="comment">/* 中断处理函数 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: <span class="comment">//P1IFG.2</span></span><br><span class="line">        <span class="comment">/* 中断处理函数 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>: <span class="comment">//P1IFG.3</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>: <span class="comment">//P1IFG.4</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>: <span class="comment">//P1IFG.5</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">14</span>: <span class="comment">//P1IFG.6</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">16</span>: <span class="comment">//P1IFG.7</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">//出错情况</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>此外，msp430还支持<em>手动的</em>嵌套中断</p>
<p>示例程序如下所示（TI的七段数码管驱动示例程序）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> SEVENSEG_OUTPUT[<span class="number">10</span>] = &#123;<span class="number">0x3f</span>, <span class="number">0x06</span>, <span class="number">0x5b</span>, <span class="number">0x4f</span>, <span class="number">0x66</span>, <span class="number">0x6d</span>, <span class="number">0x7d</span>, <span class="number">0x07</span>, <span class="number">0x7f</span>, <span class="number">0x6f</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> loopCounter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> timeCounter1; </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> timeCounter2;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> timeCounter3;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW | WDTHOLD; <span class="comment">//关闭看门狗</span></span><br><span class="line"></span><br><span class="line">    PADIR = <span class="number">0x03ff</span>; <span class="comment">// P1, P2.0 and P2.1 output, P2.6 and P2.7 input</span></span><br><span class="line">    PAOUT = <span class="number">0xc03f</span>;</span><br><span class="line"></span><br><span class="line">    P2REN = <span class="number">0xc0</span>; <span class="comment">// P2.6 P2.7 上拉电阻使能</span></span><br><span class="line">    P2IES = <span class="number">0x3f</span>; <span class="comment">// P2.6 P2.7 配置中断为上升沿</span></span><br><span class="line">    P2IE = <span class="number">0xc0</span>; <span class="comment">// P2.6 P2.7 interrupt enabled</span></span><br><span class="line"></span><br><span class="line">    PM5CTL0 &amp;= ~LOCKLPM5; <span class="comment">// 关闭GPIO高阻抗模式</span></span><br><span class="line"></span><br><span class="line">    RTCMOD = <span class="number">50</span>; <span class="comment">// 设置RTC重装计数值为50</span></span><br><span class="line">                 <span class="comment">// 64/32768 * 51 = ~0.1 sec.</span></span><br><span class="line">    SYSCFG2 |= RTCCKSEL; <span class="comment">// Source = ACLK = REFO，64分频，选择ACLK作为RTC时钟</span></span><br><span class="line">    RTCCTL = RTCSS_1 | RTCSR | RTCPS__64;</span><br><span class="line"></span><br><span class="line">    P2IFG = <span class="number">0</span>; <span class="comment">// 清除P1.3中断标志位</span></span><br><span class="line">    __bis_SR_register(GIE); <span class="comment">//开全局中断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PAOUT |= (BIT9 | SEVENSEG_OUTPUT[timeCounter3]);  <span class="comment">// 按顺序显示七段数码管数字</span></span><br><span class="line">        __delay_cycles(<span class="number">100</span>);</span><br><span class="line">        PAOUT = <span class="number">0xc000</span>; <span class="comment">// 清除引脚</span></span><br><span class="line"></span><br><span class="line">        PAOUT |= (BIT8 | SEVENSEG_OUTPUT[timeCounter2]);</span><br><span class="line">        __delay_cycles(<span class="number">100</span>);</span><br><span class="line">        PAOUT = <span class="number">0xc000</span>;</span><br><span class="line"></span><br><span class="line">        P1OUT |= (BIT7 | SEVENSEG_OUTPUT[timeCounter1]);</span><br><span class="line">        __delay_cycles(<span class="number">100</span>);</span><br><span class="line">        P1OUT = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RTC中断服务函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=RTC_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">RTC_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __bis_SR_register(GIE); <span class="comment">// 允许嵌套中断</span></span><br><span class="line">    RTCIV = <span class="number">0</span>;</span><br><span class="line">    timeCounter1++; <span class="comment">// timeCounter1代表0.1s, timeCounter2代表1s,timeCounter3代表10s，经典延时操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(timeCounter1 &gt; <span class="number">9</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        timeCounter1 = <span class="number">0</span>;</span><br><span class="line">        timeCounter2++;</span><br><span class="line">        <span class="keyword">if</span>(timeCounter2 &gt; <span class="number">9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            timeCounter3++;</span><br><span class="line">            timeCounter2 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(timeCounter3 &gt; <span class="number">9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            timeCounter3 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P2中断服务函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=PORT2_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">Port_2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __bis_SR_register(GIE); <span class="comment">// 允许嵌套中断</span></span><br><span class="line">    <span class="keyword">if</span>(P2IFG &amp; BIT6)</span><br><span class="line">    &#123;</span><br><span class="line">        P2IFG &amp;= ~BIT6; <span class="comment">// 清除P2.6中断标志位</span></span><br><span class="line">        <span class="comment">// 第一次按下按钮时开启定时器；第二次按下时停止定时器</span></span><br><span class="line">        <span class="keyword">if</span>(loopCounter == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          	loopCounter++; <span class="comment">//开启一轮循环</span></span><br><span class="line">            RTCCTL |= RTCIE; <span class="comment">//开启定时器</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            RTCCTL &amp;= ~RTCIE; <span class="comment">//关闭定时器</span></span><br><span class="line">            loopCounter = <span class="number">0</span>; <span class="comment">//循环清零</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(P2IFG &amp; BIT7)</span><br><span class="line">    &#123;</span><br><span class="line">        P2IFG &amp;= ~BIT7; <span class="comment">// 清除P2.7中断标志位并复位秒表</span></span><br><span class="line">        RTCCTL &amp;= ~RTCIE; <span class="comment">//关闭定时器</span></span><br><span class="line">        </span><br><span class="line">        loopCounter = <span class="number">0</span>; <span class="comment">//复位所有变量</span></span><br><span class="line">        timeCounter3 = <span class="number">0</span>;</span><br><span class="line">        timeCounter2 = <span class="number">0</span>;</span><br><span class="line">        timeCounter1 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现中断嵌套需要注意以下几点：</p>
<p>msp430默认关闭中断嵌套，一定要中断嵌套的话，就必须在中断服务程序中打开总中断</p>
<p>msp430的指令中，_DINT()和_EINT()分别指关和开总中断</p>
<p>当进入中断服务程序时，只要不在中断服务程序中再次开中断，则总中断是关闭的，此时来中断不管是比当前中断的优先级高还是低都不执行</p>
<p><strong>若在中断服务程序A中开了总中断，则可以响应后来的中断B（不管B的优先级比A高还是低），B执行完再继续执行A</strong></p>
<p>注意：进入中断服务程序B后总中断同样也会关闭，如果B中断程序执行时需响应中断C，则此时也要开总中断，若不需响应中断，则不用开中断，B执行完后跳出中断程序进入A程序时，总中断会自动打开</p>
<p><strong>若在中断服务程序中开了总中断，后来的中断同时有多个，则会按优先级来执行，即中断优先级只有在多个中断同时到来时才起作用，中断服务不执行抢先原则</strong></p>
<p>对于单源中断，只要响应中断，系统硬件会自动清除中断标志位。对于TA/TB定时器的比较/捕获中断，只要访问TAIV/TBIV，标志位就会被自动清除；对于多源中断要手动清标志位，比如P1/P2口中断，要手工清除相应的标志。如果在这种中断里用<code>_EINT();</code>开中断,而在打开中断前没有清标志，就会有相同的中断不断嵌入，导致堆栈溢出引起复位，所以在<strong>这类中断中必须先清标志再打开中断开关</strong></p>
<p><strong>常用中断向量表</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASICTIMER_VECTOR   (0 * 2u) <span class="comment">/* 0xFFE0 Basic Timer */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT2_VECTOR        (1 * 2u)  <span class="comment">/* 0xFFE2 Port 2 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USART1TX_VECTOR     (2 * 2u) <span class="comment">/* 0xFFE4 USART 1 Transmit */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USART1RX_VECTOR     (3 * 2u) <span class="comment">/* 0xFFE6 USART 1 Receive */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT1_VECTOR        (4 * 2u)  <span class="comment">/* 0xFFE8 Port 1 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMERA1_VECTOR      (5 * 2u) <span class="comment">/* 0xFFEA Timer A CC1-2, TA */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMERA0_VECTOR      (6 * 2u) <span class="comment">/* 0xFFEC Timer A CC0 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADC12_VECTOR          (7 * 2u)  <span class="comment">/* 0xFFEE ADC */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USART0TX_VECTOR     (8 * 2u) <span class="comment">/* 0xFFF0 USART 0 Transmit */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USART0RX_VECTOR     (9 * 2u) <span class="comment">/* 0xFFF2 USART 0 Receive */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WDT_VECTOR          (10 * 2u) <span class="comment">/* 0xFFF4 Watchdog Timer */</span></span></span><br><span class="line"></span><br><span class="line">#defineCOMPARATORA_VECTOR  (<span class="number">11</span> * <span class="number">2u</span>) <span class="comment">/* 0xFFF6Comparator A */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMERB1_VECTOR      (12 * 2u) <span class="comment">/* 0xFFF8 Timer B CC1-6, TB */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMERB0_VECTOR      (13 * 2u) <span class="comment">/* 0xFFFA Timer B CC0 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NMI_VECTOR          (14 * 2u) <span class="comment">/* 0xFFFC Non-maskable */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RESET_VECTOR        (15 * 2u) <span class="comment">/* 0xFFFE Reset [HighestPriority] */</span></span></span><br></pre></td></tr></table></figure>

<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>msp430有四个基本定时器，外加一个RTC定时器，部分定时器具有PWM输出功能</p>
<p>计数器核心是一个计数寄存器，对输入的时钟信号进行计数，可以配置其捕获跳变沿种类和分频系数，使用寄存器TAxR获取当前计数值。定时器主要分成两部分：主计数器和捕获比较器模块。捕获比较器模块与主计数器模块通过TAxR连通，主计数器会根据输入的信号跳变沿递增/递减寄存器TAxR/TBxR的值，捕获比较器会根据收到的比较值对寄存器的值进行检查，根据当前模式不同做出不同反应，因为计数寄存器被共用，所以可以将其分成多个通道。一般当捕获比较器满足设置的条件时就会产生中断，存储计数值或输出相应的信号。<em>只需要主计数器即可完成定时工作，捕获比较器的作用则在于配合主计数器完成更多扩展功能</em></p>
<ul>
<li><p><strong>Timer_A</strong>：<strong>16位定时器</strong>（最大值65535），具有7个捕获比较器，支持<em>多路捕获比较</em>、<em>PWM输出</em>、<em>间隔定时</em>功能</p>
<p>F5529中包含两个Timer_A模块，记作Timer_A0、Timer_A1、Timer_A2，三个模块的主计数器在结构上完全相同，单捕获比较器的数量不相同：Timer_A0有7个，Timer_A1和Timer_A2各有3个。</p>
</li>
<li><p><strong>Timer_B</strong>：<strong>16位定时器</strong>（最大值65535），具备Timer_A的所有功能，但它还具备<em>双缓冲比较锁存</em>与<em>同步加载</em>功能</p>
</li>
</ul>
<p>定时器的基本模式如下：</p>
<ul>
<li><p>捕获器模式</p>
<p>触发信号到来时捕获器将计数寄存器的值复制到捕获比较器的计数值寄存器TAxCCRn/TBxCCRn，并产生中断请求</p>
</li>
<li><p>比较器模式</p>
<p>需要程序向计数值寄存器TAxCCRn/TBxCCRn中写入初值，当主计数器的计数寄存器TAxR/TBxR计数值达到寄存器中存储的初值后定时器模块就会向CPU请求中断 </p>
</li>
</ul>
<p>通过配置TASSEL可以选择时钟来自ACLK、SMCLK、TAxCLK（外部输入）或INCLK（定时器级联）</p>
<h4 id="定时器A"><a href="#定时器A" class="headerlink" title="定时器A"></a>定时器A</h4><p>msp430的定时器A的主计数器具有以下几个工作模式</p>
<ul>
<li><p>增模式</p>
<p>设备会重复<strong>从0自增到TAxCCRn的值</strong>，溢出时触发中断</p>
<p>最基础的功能</p>
</li>
<li><p>连续模式</p>
<p>设备会重复<strong>从0自增到0FFFFh</strong>，然后从0重新开始计数</p>
<p>一般用于生成独立的时间间隔和输出频率，时间间隔完成时会生成中断</p>
<p>起始设置TAxCCRn的初值，并在中断服务函数中重新设置TAxCCRn的值，使其与初值的计数个数相同即可产生固定的时间间隔，这种操作还可以应用多个通道，因为多通道之间相互独立</p>
<p>最基础的功能</p>
</li>
<li><p>增减模式</p>
<p>定时器从0自增到TAxCCR0，再自减到0，也就是说其定时周期为两倍的TAxCCR0</p>
</li>
</ul>
<p>捕获比较器工作模式如下：</p>
<p>通过设置捕获比较器中的CAP位可以选择捕获比较器的工作模式为比较模式（0）或捕获模式（1），</p>
<ul>
<li><p>捕获模式</p>
<p>当CAP=1时选择捕获模式，用于记录时间时间。</p>
<p>触发信号输入CCIxA/CCIxB连接外部的引脚或内部的信号，通过CCIS位来选择；通过CM位选择触发捕获事件的输入信号触发沿</p>
<p>每当触发信号到来时，捕获比较器会1. 将TAxR的值复制到TAxCCRn寄存器中；2. 将捕获器中断标志CCIFG置位触发中断</p>
</li>
<li><p>比较模式</p>
<p>如果计数器TAxR的值和某个TAxCCRn的值相等时，相应的中断标志位会被置位，产生一个比较中断。一般该模式用于产生PWM信号</p>
</li>
<li><p>输出模式</p>
<p>传统的定时器通过标志位判断来触发事件，但msp430配备了专用的输出模块，使用输出模块寄存器OUTMODEx可以快速输出PWM信号或其他控制信号</p>
</li>
</ul>
<h4 id="定时器中断"><a href="#定时器中断" class="headerlink" title="定时器中断"></a>定时器中断</h4><p>定时器A具有两个中断源，捕获比较器0中断独立，其他所有中断（定时器溢出中断、捕获比较器1中断、捕获比较器2中断等等）共用中断源，通过TAxIV来确定具体触发中断的中断源</p>
<p>使用步骤如下：</p>
<ol>
<li><p>设置主计数器时钟</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TA0CTL = TASSEL_1;</span><br></pre></td></tr></table></figure></li>
<li><p>设置分频</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TA0EX0 = TAIDEX_7 <span class="comment">//8分频</span></span><br></pre></td></tr></table></figure></li>
<li><p>初始化CCR寄存器（设置初值）并使能中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TA0CCR0 = <span class="number">9000</span>; <span class="comment">//设置初值</span></span><br><span class="line">TA0CCTL0 = CCIE; <span class="comment">//使能TA0CCR0中断</span></span><br></pre></td></tr></table></figure></li>
<li><p>设置捕获比较器模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TA0CTL |= MC_2 + TACLR; <span class="comment">//清除TA0R，启动定时器，选择连续计数模式</span></span><br></pre></td></tr></table></figure>

<p>也可以使用下面的代码启用其他模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MC_1 增模式</span><br><span class="line">MC_3 减增模式</span><br></pre></td></tr></table></figure></li>
<li><p>开总中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__bis_SR_register(GIE);</span><br></pre></td></tr></table></figure></li>
<li><p>配置中断服务函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector = TIMER0_A0_VECTOR <span class="comment">//TA0CCR0中断</span></span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">TA0CCR0_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TA0CCR0 += <span class="number">16384</span>; <span class="comment">//添加偏置</span></span><br><span class="line">    <span class="comment">/* 中断处理函数 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="定时器B"><a href="#定时器B" class="headerlink" title="定时器B"></a>定时器B</h4><p>在捕获比较器和比较器之间加入的比较锁存器可以分组控制比较值载入的时刻，实现同步更新数据</p>
<p>在Timer_B中可以通过配置寄存器TBxCCTLn来选择TBxCCRn载入TBxCLn的时刻，在Timer_B中起到比较作用的是比较锁存器TBxCLn而不是CCR寄存器，当TBxR的值达到TBxCLn时，相应的中断标志位置位，产生比较器中断请求，TBxCCRn的值会在寄存器设置的时间点载入TBxCLn，从而实现比较延时更新</p>
<h4 id="输入捕获"><a href="#输入捕获" class="headerlink" title="输入捕获"></a>输入捕获</h4><p>使用定时器的外部计数功能来测量脉冲个数，可用于测速、编码器驱动等场合</p>
<p>基本使用方式和上面的定时器中断类似，但是需要以下额外语句</p>
<ol>
<li><p>配置外部时钟源，使能溢出中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TA0CTL = TASSEL_0 + TAIE;</span><br></pre></td></tr></table></figure></li>
<li><p>清除TAxR、启动定时器并工作于连续模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TA0CTL |= TACLR + MC_2;</span><br></pre></td></tr></table></figure></li>
<li><p>在定时器中断服务函数内递增全局计数变量用于获取输入捕获的脉冲数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> counter;</span><br><span class="line"><span class="keyword">uint8_t</span> loop;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector = TIMER0_A1_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">TA0_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    counter++;</span><br><span class="line">    <span class="keyword">if</span>(counter&gt;<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        loop++;</span><br><span class="line">        counter=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="PWM输出"><a href="#PWM输出" class="headerlink" title="PWM输出"></a>PWM输出</h4><p>msp430可以实现在不占用CPU资源的情况下输出PWM信号，程序如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430f5529.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW | WDTHOLD; <span class="comment">//关闭看门狗</span></span><br><span class="line">    P1DIR |= BIT2 | BIT3;</span><br><span class="line">    P1SEL |= BIT2 | BIT3; <span class="comment">//设置为定时器复用</span></span><br><span class="line">    TA0CCR0 = <span class="number">512</span><span class="number">-1</span>; <span class="comment">//PWM周期，频率=32768/512=64</span></span><br><span class="line">    TA0CCTL1 = OUTMODE_7; <span class="comment">//CCR1输出模式7</span></span><br><span class="line">    TA0CCR1 = <span class="number">384</span>; <span class="comment">//CCR1 PWM占空比设置为384/512=75%</span></span><br><span class="line">    TA0CCTL2 = OUTMODE_7; <span class="comment">//CCR2输出模式7</span></span><br><span class="line">    TA0CCR2 = <span class="number">128</span>; <span class="comment">//CCR2 PWM占空比设置为128/512=25%</span></span><br><span class="line">    <span class="comment">//开启定时器</span></span><br><span class="line">    TA0CTL = TASSEL_1 + MC_1 + TACLR; <span class="comment">//定时器时钟设置为32768Hz的ACLK，配置为增模式，清空TA0R</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 可实现在P1.2上输出75%占空比，在P1.3上输出25%占空比，频率都是64Hz的PWM信号 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总线协议"><a href="#总线协议" class="headerlink" title="总线协议"></a>总线协议</h3><p>msp430f5529中配备了<strong>通用串行通信接口模块USCI</strong>，它支持了多种通信模式，UART、SPI、IIC都可以使用该外设进行处理</p>
<p>使用方法很类似，仅给出示例代码</p>
<h4 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h4><p>串口接收并复读数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430f5529.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW + WDTHOLD;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 初始化UART */</span></span><br><span class="line">    P4SEL |= BIT4 + BIT5; <span class="comment">//配置P4.4、P4.5为USCI_A1 Tx、Rx</span></span><br><span class="line">    UCA1CTL1 |= UCSWRST; <span class="comment">//复位USCI_A1</span></span><br><span class="line">    UCA1CTL1 |= UCSSEL_2; <span class="comment">//SMCLK 无校验位 8字符长度 1个停止位</span></span><br><span class="line">    UCA1BR0 = <span class="number">9</span>; <span class="comment">//低8位=9</span></span><br><span class="line">    UCA1BR1 = <span class="number">0</span>; <span class="comment">//高8位=0，调制后波特率约为115200bps</span></span><br><span class="line">    UCA1MCTL |= UCBRS_1 + UCBRF_0; <span class="comment">//调制器UCBRSx=1,UCBRFx=0</span></span><br><span class="line">    UCA1CTL1 &amp;= ~UCSWRST; <span class="comment">//启动USCI_A1</span></span><br><span class="line">    UCA1IE |= UCRXIE; <span class="comment">//使能USCI_A1接收中断</span></span><br><span class="line">    __bis_SR_register(LPM0_bits + GIE); <span class="comment">//使能全局中断</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=USCI_A1_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">USCI_A1_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(__even_in_range(UCA1IV, <span class="number">4</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//无中断</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//接收中断RXIFG</span></span><br><span class="line">            UCA1TXBUF = UCA1RXBUF; <span class="comment">//复读</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">//发送中断TXIFG</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UCA1TXBUF：串口发送寄存器</p>
<p>UCA1RXBUF：串口接收寄存器</p>
<p>UCA1IE：串口中断控制寄存器，可以选择接收中断、发送中断</p>
<h4 id="IIC"><a href="#IIC" class="headerlink" title="IIC"></a>IIC</h4><p>需要注意，msp430的IIC无法内部上拉，所以必须在外部接入4.7k的上拉电阻到VCC（3.3V）</p>
<p>下面的代码仅说明如何将USCI配置成IIC驱动模式</p>
<ol>
<li><p>包含头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>初始化引脚复用功能</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P4SEL |= BIT1 + BIT2;</span><br></pre></td></tr></table></figure></li>
<li><p>初始化USCI，并配置传输速率</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UCB1CTL1 |= UCSWRST; <span class="comment">//复位USCI_B1</span></span><br><span class="line">UCB1CTL0 |= UCMST + UCMODE_3 + UCSYNC; <span class="comment">//配置为IIC主机，同步模式</span></span><br><span class="line">UCB1CTL1 = UCSSEL_2 + UCSWRST; <span class="comment">//SMCLK，保持UCSWRST置位</span></span><br><span class="line"></span><br><span class="line">UCB1BR0 = <span class="number">12</span>; <span class="comment">//fscl=SMCLK/12=100kHz</span></span><br><span class="line">UCB1BR1 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>设置从机地址</p>
<p>这里假设从机地址是0x48</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UCB1I2CSA = <span class="number">0x48</span>; <span class="comment">//从机地址0x48</span></span><br></pre></td></tr></table></figure></li>
<li><p>启动外设</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UCB1CTL1 &amp;= ~UCSWRST; <span class="comment">//清除复位标志，外设开始运行</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写中断控制函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> IIC_RXByte;</span><br><span class="line"><span class="keyword">uint8_t</span> IIC_TXByte;</span><br><span class="line"><span class="keyword">uint8_t</span> *PRxData; <span class="comment">//接收缓存</span></span><br><span class="line"><span class="keyword">uint8_t</span> *PTxData; <span class="comment">//发送缓存</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=USCI_B1_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">USCI_B1_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(__even_in_range(UCB1IV, <span class="number">12</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//无中断</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//ALIFG</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">//无响应中断NACKIFG</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: <span class="comment">//STTIFG</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>: <span class="comment">//停止位中断STPIFG</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>: <span class="comment">//接收中断RXIFG</span></span><br><span class="line">            IIC_RXByte--; <span class="comment">//递减字节计数变量</span></span><br><span class="line">            <span class="keyword">if</span>(IIC_RXByte) <span class="comment">//如果没有接收完毕</span></span><br><span class="line">            &#123;</span><br><span class="line">                *PRxData++ = UCB1RXBUF; <span class="comment">//接收剩下的数据到缓存区</span></span><br><span class="line">                <span class="keyword">if</span>(IIC_RXByte == <span class="number">1</span>) <span class="comment">//检查是否只剩一个字节未接收</span></span><br><span class="line">                &#123;</span><br><span class="line">                    UCB1CTL1 |= UCTXSTP; <span class="comment">//发送停止条件</span></span><br><span class="line">				&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//已经接收完毕</span></span><br><span class="line">            &#123;</span><br><span class="line">                *PRxData = UCB1RXBUF; <span class="comment">//将最后一字节数据存储到缓存区</span></span><br><span class="line">                UCB1IE &amp;= ~UCRXIE; <span class="comment">//禁用接收中断</span></span><br><span class="line">                __bic_SR_registe_on_exit(LPM0_bits); <span class="comment">//退出LPM0，进入活跃模式</span></span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">12</span>: <span class="comment">//发送中断TXIFG</span></span><br><span class="line">            <span class="keyword">if</span>(IIC_TXByte) <span class="comment">//如果没有发送完毕</span></span><br><span class="line">            &#123;</span><br><span class="line">                UCB1TXBUF = *PTxData; <span class="comment">//IIC发送数据</span></span><br><span class="line">                IIC_TXByte--; <span class="comment">//递减字节计数变量</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//已经接收完毕</span></span><br><span class="line">            &#123;</span><br><span class="line">                UCB1CTL1 |= UCTXSTP; <span class="comment">//置位发送停止条件位</span></span><br><span class="line">                UCB1IFG &amp;= ~UCTTXIFG; <span class="comment">//清除发送中断标志位TXIFG</span></span><br><span class="line">                UCB1IE &amp;= ~UCTXIE; <span class="comment">//禁用发送中断</span></span><br><span class="line">                __bic_SR_registe_on_exit(LPM0_bits); <span class="comment">//退出LPM0，进入活跃模式</span></span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写相关驱动</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TxData[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//发送缓存区</span></span><br><span class="line">RxData[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//接收缓存区</span></span><br><span class="line"><span class="keyword">uint8_t</span> IIC_RXByte;</span><br><span class="line"><span class="keyword">uint8_t</span> IIC_TXByte;</span><br><span class="line"><span class="keyword">uint8_t</span> *PRxData; <span class="comment">//接收缓存</span></span><br><span class="line"><span class="keyword">uint8_t</span> *PTxData; <span class="comment">//发送缓存</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 这里省略初始化部分 */</span></span><br><span class="line">    disable_WDG();</span><br><span class="line">    init_iic();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 发送设置 */</span></span><br><span class="line">        PTxData = TxData;</span><br><span class="line">        IIC_TXByte = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">while</span>(UCB1CTL1 &amp; UCTXSTP); <span class="comment">//确保停止条件已发送，总线空闲</span></span><br><span class="line">        </span><br><span class="line">        UCBCTL1 |= UCTR; <span class="comment">//设置主机工作在发送机模式</span></span><br><span class="line">        UCBCTL1 |= UCTXSTT; <span class="comment">//发送开始条件并发送有“写标志位”的地址</span></span><br><span class="line">        UCB1IE |= UCTXIE; <span class="comment">//使能发送中断</span></span><br><span class="line">        __bis_SR_register(LPM0_bits + GIE); <span class="comment">//进入LPM0，使能全局中断</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 接收设置 */</span></span><br><span class="line">        PRxData = RxData;</span><br><span class="line">        IIC_RXByte = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">while</span>(UCB1CTL1 &amp; UCTXSTP); <span class="comment">//确保停止条件已发送，总线空闲</span></span><br><span class="line">        UCBCTL1 &amp;= ~UCTR;<span class="comment">//设置主机工作在接收机模式</span></span><br><span class="line">        UCBCTL1 |= UCTXSTT; <span class="comment">//发送开始条件并发送有“读标志位”的地址</span></span><br><span class="line">        UCB1IE |= UCRXIE; <span class="comment">//使能接收中断</span></span><br><span class="line">        __bis_SR_register(LPM0_bits + GIE); <span class="comment">//进入LPM0，使能全局中断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h4><p>使用以下代码设置SPI</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这里省略端口复用设置 */</span></span><br><span class="line">UCB0CTL1 |= UCSWrST;</span><br><span class="line">UCB0CTL0 |= UCMST + UCSYNC; <span class="comment">//设置为三线SPI主机模式，8位数据位</span></span><br><span class="line">UCB1CTL1 = UCSSEL_2; <span class="comment">//时钟设置为SMCLK</span></span><br><span class="line">UCB1BR0 = <span class="number">0xFF</span>; <span class="comment">//UCB0CLK = SMCLK / 0xFFF</span></span><br><span class="line">UCB1BR1 = <span class="number">0x0F</span>; <span class="comment">//一般来说可以选择100kHz以上的频率，通常使用4MHz频率</span></span><br><span class="line"></span><br><span class="line">UCB1CTL1 &amp;= ~UCSWRST; <span class="comment">//清除复位标志，外设开始运行</span></span><br></pre></td></tr></table></figure>

<p>中断和驱动编写部分和IIC基本一致，不再赘述</p>
<h3 id="片上模拟外设"><a href="#片上模拟外设" class="headerlink" title="片上模拟外设"></a>片上模拟外设</h3><p>msp430集成了12位ADC/DAC和模拟比较器外设</p>
<h4 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h4><p>f5529配备了SAR架构的ADC12_A模块，支持12位ADC，具有16个模拟输入通道、16个独立的转换和存储单元，可在脱离CPU情况下完成ADC转换，最高200ksp（千次采样/每秒）</p>
<p>基本配置流程如下：</p>
<ol>
<li><p>配置核心控制寄存器，选择时钟、转换模式、启动参考电压生成器</p>
<p>ADC12_A内部具有独立的REF模块，可以提供1.5V、2V、2.5V参考电压。通过REF模块的REFMSTR位选择参考电压：置1时（默认状态）使用REF模块控制参考电压；置0时使用ADC12_A的参考电压模块控制参考电压</p>
<p>使用ADC12REF2_5V控制参考电压大小，ADC12REFON控制是否开启电压生成器，ADC12REFOUT控制是否输出参考电压</p>
<p>ADC使用ADC12CLK时钟用来控制采样和转换的时间和周期，时钟源可选择SMCLK、MCLK、ACLK和ADC12OSC（UCS模块的MODCLK的5MHz内部振荡器），时钟源使用ADC12DIV控制的预分频器和ADC12SSELx控制的分频器进行分频，可选择1-32分频</p>
<p>基本配置程序如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADC12CTL0 = ADC12ON+ADC12SHT0_8+ADC12MSC; <span class="comment">//开启ADC12,设置采样时间,设置采样模式（这里使用了多采样转换）</span></span><br></pre></td></tr></table></figure>

<p>ADC具有4种模式，通过CONSEQx位选择</p>
<ul>
<li><strong>单通道模式</strong>：单通道只采样和转换一次，当ADC12SC置位时触发一次采样转换操作，持续一段时间后自动复位</li>
<li>序列通道（<strong>自动扫描</strong>）<strong>模式</strong>：使用CSTARTADDx位选择开始转换的第一个ADC1MCTLx，指定后序列启动指针会自动递增，被它指向的通道会自动开始转换，转换完成后自动复位，操作一直继续直到处理到ADC12EOS=1的ADC12MCTLx才会停止，ADC12EOS作为序列结束的标志，只在序列转换模式下使用</li>
<li><strong>重复单通道模式</strong>：一个单独的通道会被不断采样转换，可以设置完成中断来读取转换结果</li>
<li><strong>重复序列通道</strong>（自动重复）<strong>模式</strong>：一序列通道会被重复采样和转换，使用CSTARTADDx定义第一个ADC12McTLx，序列再检测到ADC12EOS（序列结束标志）置位后会自动结束，下一个触发信号将重新开始序列</li>
</ul>
</li>
<li><p>保持其处于禁用状态，ADC12ENC=0</p>
</li>
<li><p>配置引脚复用</p>
<p>将GPIO复用为ADC输入引脚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PxSEL |= <span class="number">0x0</span>n; <span class="comment">//选择Px.n引脚复用为ADC输入</span></span><br></pre></td></tr></table></figure>

<p>注意：<strong>只有能接入ADC的对应IO口才能复用</strong></p>
</li>
<li><p>配置采样定时器</p>
<p>一次转换由一个采样信号SHI的上升沿引起，可通过SHSx位来选择，可以选为直接由ADC12SC位控制或使用定时器来控制</p>
<ul>
<li>ADC12SHP=0，使用<strong>扩展采样模式</strong>，SHI信号直接控制SAMPCON并定义采样周期长度；SAMPCON=1时采样活跃，SAMPCON的下降沿会在同步ADC12CLK信号后启动转换</li>
<li>ADC12SHP=1，使用<strong>脉冲采样模式</strong>，SHI信号用于触发采样定时器，采样定时器在同步AD12CLK后将SAMPCON保持在高电平并持续一个可编程的间隔$t_{sample}$，整个采样时间就是$t_{sample}+t_{sync}$</li>
</ul>
</li>
<li><p>可单独配置每个通道的参考电压和输入源</p>
<p>使用ADC12MCTLx（x为0-15）控制转换存储单元，通过ADC12SREF和ADC12INCH分别选择参考电压和模拟信号的输入通道</p>
<p>在单通道单转换模式中，复位ADC12ENC<strong>立刻</strong>停止一个转换且会导致转换结果不可预知，一般来说需要使用以下语句停止单通道转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(ADC12BUSY != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    delay();</span><br><span class="line">&#125;</span><br><span class="line">ADC12ENC = <span class="number">0</span>; <span class="comment">//等待ADC12BUSY = 0后才能停止单通道转换</span></span><br></pre></td></tr></table></figure>

<p>重复单通道模式下，复位ADC12ENC会在<strong>当前转换结束</strong>时停止转换器</p>
<p>序列通道或重复序列通道中，复位ADC12ENC会在<strong>序列结束</strong>时停止转换器</p>
<p><em>任何模式中都可以通过清零ADC12CONSEQ并复位ADC12ENC位来立刻停止，但这样会导致转换结果不可预知</em></p>
</li>
<li><p>可以使能集成温度传感器或配置转换完成中断</p>
<p>ADC可以直接连接内部的温度传感器（这是参考电压生成器的一部分）来获取内部温度，计算公式如下<br>$$<br>T=(ADC_{raw} - CAL_ADC_T30) \times (\frac{85-30}{CAL_ADC_T85 - CAL_ADC_T30}) + 30<br>$$<br>其中T是精确温度值，$ADC_{raw}$是数模转换结果，两个$CAL_ADC_T$为温度矫正参数，需要通过地址进行访问调用，每个设备的矫正参数都不同，该参数会被使用TLV（Tag-Length-Value）的方式写入单片机，地址调用形式如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*((<span class="keyword">unsigned</span> <span class="keyword">int</span>*)<span class="number">0x1A1A</span>) <span class="comment">//具体地址需要根据电压和设备的不同来确定，详细内容参考datasheet即可</span></span><br></pre></td></tr></table></figure>

<p><strong>ADC12_A具有18个中断，共用一个中断源</strong></p>
<p>可单独配置某通道完成中断、ADC12MEMx溢出中断、ADC12_A计时溢出中断，所有中断通过唯一的中断向量寄存器来配置，也就是说只使用一个中断服务函数</p>
<p>注意：任何对于ADC12IV的读写操作都会自动复位ADC12OV或ADC12TOV，如果中断服务函数在访问ADC12IV寄存器时有ADC12OV和ADC12IFGx中断生成，那么ADC12OV中断条件会自动复位，在中断服务函数返回后紧接着处理其他中断，因此应避免中断执行时间过长导致ADC中断占用前台应用</p>
<p>使用下面的程序来开启ADC中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADC12IE = <span class="number">0x01</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>将ADC12ENC=1来使能设备</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADC12CTL0 |= ADC12ENC;</span><br><span class="line">ADC12CTL0 |= ADC12SC;</span><br></pre></td></tr></table></figure></li>
<li><p>通过读取ADC12MCTLx对应的ADC12MEMx来获取转换结果</p>
</li>
</ol>
<p>单通道单次转换示例如下（测量引脚电压高于参考电压则指示灯亮）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	WDTCTL = WDTPW + WDTHOLD;  <span class="comment">//停止WDG</span></span><br><span class="line">  	ADC12CTL0 = ADC12SHT02 + ADC12ON; <span class="comment">//设置采样时间并开启ADC12_A</span></span><br><span class="line"> 	ADC12CTL1 = ADC12SHP; <span class="comment">//使用采样定时器</span></span><br><span class="line">  	ADC12IE = <span class="number">0x01</span>; <span class="comment">//使能中断</span></span><br><span class="line">  	ADC12CTL0 |= ADC12ENC; <span class="comment">//使能转换通道</span></span><br><span class="line">  	P6SEL |= <span class="number">0x01</span>; <span class="comment">//配置P6.1复用为ADC输入</span></span><br><span class="line">  	P1DIR |= <span class="number">0x01</span>; <span class="comment">//配置P1.0信号指示输出</span></span><br><span class="line"></span><br><span class="line">  	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  	&#123;</span><br><span class="line">    	ADC12CTL0 |= ADC12SC; <span class="comment">//开始依次采样</span></span><br><span class="line"></span><br><span class="line">    	__bis_SR_register(LPM0_bits + GIE); <span class="comment">//进入LPM0,开启全局中断</span></span><br><span class="line">    	__no_operation(); <span class="comment">//用于调试器打断点的空指令</span></span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADC中断服务函数 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector = ADC12_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">ADC12_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="keyword">switch</span>(__even_in_range(ADC12IV,<span class="number">34</span>))</span><br><span class="line">  	&#123;</span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">0</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  0:  No interrupt</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">2</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  2:  ADC溢出中断</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">4</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  4:  ADC超时中断</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">6</span>:                                  <span class="comment">// Vector  6:  ADC12IFG0</span></span><br><span class="line">		<span class="comment">/* 测量P1引脚 */</span></span><br><span class="line">    	<span class="keyword">if</span> (ADC12MEM0 &gt;= <span class="number">0x7ff</span>)               <span class="comment">// ADC12MEM = A0 &gt; 0.5AVcc?</span></span><br><span class="line">      		P1OUT |= BIT0;                    <span class="comment">// P1.0 = 1</span></span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">      		P1OUT &amp;= ~BIT0;                   <span class="comment">// P1.0 = 0</span></span><br><span class="line"></span><br><span class="line">    	__bic_SR_register_on_exit(LPM0_bits); <span class="comment">//退出LPM0模式</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">8</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  8:  ADC12IFG1</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">10</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 10:  ADC12IFG2</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">12</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 12:  ADC12IFG3</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">14</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 14:  ADC12IFG4</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">16</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 16:  ADC12IFG5</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">18</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 18:  ADC12IFG6</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">20</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 20:  ADC12IFG7</span></span><br><span class="line"> 	<span class="keyword">case</span> <span class="number">22</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 22:  ADC12IFG8</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">24</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 24:  ADC12IFG9</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">26</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 26:  ADC12IFG10</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">28</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 28:  ADC12IFG11</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">30</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 30:  ADC12IFG12</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">32</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 32:  ADC12IFG13</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">34</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 34:  ADC12IFG14</span></span><br><span class="line">  	<span class="keyword">default</span>: <span class="keyword">break</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>多通道重复转换示例如下（连续读取P6.0、P6.1、P6.2、P6.3的ADC值）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Num_of_Results 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> A0results[Num_of_Results];</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> A1results[Num_of_Results];</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> A2results[Num_of_Results];</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> A3results[Num_of_Results];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	WDTCTL = WDTPW+WDTHOLD;                   <span class="comment">//关闭WDG</span></span><br><span class="line">    </span><br><span class="line">  	P6SEL = <span class="number">0x0F</span>;                             <span class="comment">//使能ADC复用引脚（P6的低四位0、1、2、3进行复用）</span></span><br><span class="line">  	ADC12CTL0 = ADC12ON+ADC12MSC+ADC12SHT0_8; <span class="comment">//开启ADC、扩展采样时间避免结果溢出</span></span><br><span class="line">  	ADC12CTL1 = ADC12SHP+ADC12CONSEQ_3;       <span class="comment">//使用采样定时器，设置为多通道重复采样模式</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置0、1、2、3通道的参数 */</span></span><br><span class="line">  	ADC12MCTL0 = ADC12INCH_0;                 <span class="comment">// ref+=AVcc, channel = A0</span></span><br><span class="line">  	ADC12MCTL1 = ADC12INCH_1;                 <span class="comment">// ref+=AVcc, channel = A1</span></span><br><span class="line">  	ADC12MCTL2 = ADC12INCH_2;                 <span class="comment">// ref+=AVcc, channel = A2</span></span><br><span class="line">  	ADC12MCTL3 = ADC12INCH_3+ADC12EOS;        <span class="comment">// ref+=AVcc, channel = A3 ，设置ADC结束标志</span></span><br><span class="line">    </span><br><span class="line">  	ADC12IE = <span class="number">0x08</span>;                           <span class="comment">//使能ADC12IFG.3中断</span></span><br><span class="line">  	ADC12CTL0 |= ADC12ENC;                    <span class="comment">//使能转换通道</span></span><br><span class="line">  	ADC12CTL0 |= ADC12SC;                     <span class="comment">//开始转换-软件触发</span></span><br><span class="line">  </span><br><span class="line">  	__bis_SR_register(LPM0_bits + GIE);       <span class="comment">//进入LPM0并开启全局中断</span></span><br><span class="line">  	__no_operation();                         <span class="comment">//用于调试器打断点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=ADC12_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">ADC12ISR</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">switch</span>(__even_in_range(ADC12IV,<span class="number">34</span>))</span><br><span class="line">  	&#123;</span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">0</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  0:  No interrupt</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">2</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  2:  ADC overflow</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">4</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  4:  ADC timing overflow</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">6</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  6:  ADC12IFG0</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">8</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  8:  ADC12IFG1</span></span><br><span class="line"> 	<span class="keyword">case</span> <span class="number">10</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 10:  ADC12IFG2</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">12</span>:                                  <span class="comment">// Vector 12:  ADC12IFG3</span></span><br><span class="line">    	A0results[index] = ADC12MEM0;         <span class="comment">// Move A0 results, IFG is cleared</span></span><br><span class="line">    	A1results[index] = ADC12MEM1;         <span class="comment">// Move A1 results, IFG is cleared</span></span><br><span class="line">    	A2results[index] = ADC12MEM2;         <span class="comment">// Move A2 results, IFG is cleared</span></span><br><span class="line">    	A3results[index] = ADC12MEM3;         <span class="comment">// Move A3 results, IFG is cleared</span></span><br><span class="line">    	index++;                              <span class="comment">// 保存到结果缓存区</span></span><br><span class="line">    </span><br><span class="line">    	<span class="keyword">if</span> (index == <span class="number">8</span>)</span><br><span class="line">    	&#123;</span><br><span class="line">      		(index = <span class="number">0</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">  	<span class="keyword">case</span> <span class="number">14</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 14:  ADC12IFG4</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">16</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 16:  ADC12IFG5</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">18</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 18:  ADC12IFG6</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">20</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 20:  ADC12IFG7</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">22</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 22:  ADC12IFG8</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">24</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 24:  ADC12IFG9</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">26</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 26:  ADC12IFG10</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">28</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 28:  ADC12IFG11</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">30</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 30:  ADC12IFG12</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">32</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 32:  ADC12IFG13</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">34</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 34:  ADC12IFG14</span></span><br><span class="line">  	<span class="keyword">default</span>: <span class="keyword">break</span>; </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DAC"><a href="#DAC" class="headerlink" title="DAC"></a>DAC</h4><p>msp430f5529配备了DAC12_A模块，模块组成结构如下：</p>
<ul>
<li><p>核心</p>
<p>可以通过修改DAC12RES的值将DAC12_A配置为8位或12位模式；配置DAC12IR和DAC12OG位可以将满标度输出配置为所选参考电压的1倍、2倍或3倍；配置DAC12DF位选择输入的数据格式是原码还是补码。</p>
</li>
<li><p>端口</p>
<p>大多数DAC复用的端口都有其他复用功能，但是当DAC12AMPx&gt;0时，DAC12_A会忽略PxSEL.y和PxSEL.x的值，自动配置端口为DAC12_A输出复用功能</p>
<p>每个DAC通道都能输出到两个不同的端口，通过DAC122OPS选择，详细参数需要查阅datasheet</p>
</li>
<li><p>参考电压</p>
<p>使用DAC12SREFx选择DAC12_A参考电压，该值从AVCC、外部电压输入、内部1.16V参考电压、内部REF模块提供1.5V、2V、2.5V参考电压之一选择</p>
</li>
<li><p>参考输入和电压输出缓冲区</p>
<p>参考输入和电压输出缓冲区通过寄存器配置来平衡建立时间和功耗，通过配置DAC12AMPx来选择组合，其值越小、建立时间越长、缓冲区上的电流消耗越小</p>
</li>
<li><p>数据格式</p>
<p>使用原码或补码形式都可以设置DAC，使用DAC12_xDAT（取值范围0800h（输出0V）-07ffh（输出标度），另外取值0000h时输出标度的一半）控制</p>
</li>
</ul>
<p>相关示例程序如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 输出固定电压 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW+WDTHOLD; <span class="comment">//关闭WDG</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置无增益，参考电压AVCC，启动DAC校准</span></span><br><span class="line">    DAC12_0CTL0 = DAC12IR + DAC12SREF_1 + DAC12AMP_5 + DAC12CALON;</span><br><span class="line">	DAC12_0CTL0 |= DAC12ENC; <span class="comment">//使能DAC12_A</span></span><br><span class="line">    <span class="comment">//需要注意这里的输出值是12位</span></span><br><span class="line">    DAC12_0DAT = <span class="number">0x000</span>; <span class="comment">//DAC输出0V</span></span><br><span class="line">    <span class="comment">//和上面一样的流程</span></span><br><span class="line">    DAC12_1CTL0 = DAC12IR + DAC12SREF_1 + DAC12AMP_5 + DAC12CALON;</span><br><span class="line">    DAC12_0CTL0 |= DAC12ENC; <span class="comment">//使能DAC12_A</span></span><br><span class="line">    DAC12_0DAT = <span class="number">0x700</span>; <span class="comment">//输出1.4V</span></span><br><span class="line">    __bis_SR_register(LPM4_bits); <span class="comment">//进入LPM4，DAC会自动输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出波形 */</span></span><br><span class="line"><span class="comment">//以FLASH换内存</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> Sin_tab[<span class="number">100</span>] = &#123; </span><br><span class="line"><span class="number">1638</span>,<span class="number">1740</span>,<span class="number">1843</span>,<span class="number">1944</span>,<span class="number">2045</span>,<span class="number">2143</span>,<span class="number">2240</span>,<span class="number">2335</span>,<span class="number">2426</span>,<span class="number">2515</span>,</span><br><span class="line"><span class="number">2600</span>,<span class="number">2681</span>,<span class="number">2758</span>,<span class="number">2831</span>, <span class="number">2899</span>,<span class="number">2962</span>,<span class="number">3020</span>,<span class="number">3072</span>,<span class="number">3119</span>,<span class="number">3160</span>,</span><br><span class="line"><span class="number">3195</span>,<span class="number">3224</span>,<span class="number">3246</span>,<span class="number">3262</span>,<span class="number">3272</span>,<span class="number">3272</span>,<span class="number">3263</span>,<span class="number">3247</span>,<span class="number">3224</span>,<span class="number">3196</span>,</span><br><span class="line"><span class="number">3161</span>,<span class="number">3120</span>,<span class="number">3074</span>,<span class="number">3021</span>,<span class="number">2964</span>,<span class="number">2901</span>,<span class="number">2833</span>,<span class="number">2760</span>,<span class="number">2683</span>,<span class="number">2602</span>,</span><br><span class="line"><span class="number">2517</span>,<span class="number">2429</span>,<span class="number">2337</span>,<span class="number">2243</span>,<span class="number">2146</span>,<span class="number">2047</span>,<span class="number">1947</span>,<span class="number">1845</span>,<span class="number">1743</span>,<span class="number">1640</span>,</span><br><span class="line"><span class="number">1537</span>,<span class="number">1435</span>,<span class="number">1333</span>,<span class="number">1233</span>,<span class="number">1134</span>,<span class="number">1037</span>,<span class="number">943</span>,<span class="number">851</span>,<span class="number">762</span>,<span class="number">677</span>,<span class="number">596</span>,</span><br><span class="line"><span class="number">519</span>,<span class="number">446</span>,<span class="number">378</span>,<span class="number">314</span>,<span class="number">256</span>,<span class="number">204</span>,<span class="number">157</span>,<span class="number">116</span>,<span class="number">81</span>,<span class="number">52</span>,<span class="number">29</span>,<span class="number">13</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>,</span><br><span class="line"><span class="number">12</span>,<span class="number">28</span>,<span class="number">50</span>,<span class="number">78</span>,<span class="number">113</span>,<span class="number">154</span>,<span class="number">200</span>,<span class="number">252</span>,<span class="number">310</span>,<span class="number">373</span>,<span class="number">440</span>,<span class="number">513</span>,<span class="number">590</span>,</span><br><span class="line"><span class="number">671</span>,<span class="number">756</span>,<span class="number">756</span>,<span class="number">844</span>,<span class="number">936</span>,<span class="number">1030</span>,<span class="number">1127</span>,<span class="number">1225</span>,<span class="number">1326</span>,<span class="number">1427</span>,<span class="number">1529</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW + WDTHOLD; <span class="comment">//停看门狗</span></span><br><span class="line"> 	INIT_XT2(); <span class="comment">//开启时钟   </span></span><br><span class="line"></span><br><span class="line"> 	P5SEL = <span class="number">0XFF</span>;</span><br><span class="line"> 	ADC12CTL0 = REFON; <span class="comment">//参考电压为内部2.5v  </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置DMA，直接将Sin_tab数据传输到DAC */</span></span><br><span class="line"> 	DMA0SA = (<span class="keyword">int</span>) Sin_tab; <span class="comment">//源地址寄存器</span></span><br><span class="line"> 	DMA0DA = DAC12_0DAT_; <span class="comment">//目的地址寄存器</span></span><br><span class="line">	DMA0SZ = <span class="number">100</span>; <span class="comment">//传输基本单元的个数</span></span><br><span class="line"> 	DMACTL0 = DMA0TSEL_5; <span class="comment">// DAC12_0CTL的DAC12IFG标志</span></span><br><span class="line"> 	DMA0CTL = DMADT_4 + DMASRCINCR_3 + DMAEN; <span class="comment">//DMADT_4：重复的块传输方式</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使用内部1.5V参考电压，无增益，使能DAC12_A校准并使能DAC12_A */</span></span><br><span class="line">	DAC12_0CTL = DAC12LSEL_2 + DAC12IR + DAC12AMP_5 + DAC12IFG + DAC12ENC; <span class="comment">//配置DAC</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 强制输出第一个中断 */</span></span><br><span class="line"> 	CCTL1 = OUTMOD_3; <span class="comment">//设置并复位</span></span><br><span class="line">	CCR1 = <span class="number">1</span>; <span class="comment">// PWM Duty Cycle   </span></span><br><span class="line">	CCR0 = <span class="number">8</span><span class="number">-1</span>; <span class="comment">//1kHz频率</span></span><br><span class="line">	TACTL = TASSEL_2 + MC_1; <span class="comment">//使用SMCLK时钟源,向上计数模式  </span></span><br><span class="line">	__bis_SR_register(LPM0_bits); <span class="comment">//进入LPM0，DMA和DAC都在工作，会自动输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可编程比较器"><a href="#可编程比较器" class="headerlink" title="可编程比较器"></a>可编程比较器</h4><p>f5529配备了Comp_B模块，支持精密线性数模转换、电源电压监控、外部模拟信号电压监测功能</p>
<p>其中核心是一个精密电压比较器，同相端比反相端电压高，则输出高电平，否则输出低电平，使用CBON位打开/关闭比较器</p>
<p>使用CBCTL0寄存器控制外部输入端口，CBIPEN和CBIMEN分别控制同相端和反相端；使用CBIMSEL和CBIPSEL控制端子连接的GPIO，应选择P6的端口，以这两个寄存器控制端口号</p>
<p>可以使用CBSHORT短路正反相输入，可用来建立简单的采样-保持机制，一般来说设置采样时间为3-10τ，3τ可以将采样电容充电到95%的输入信号电压值，5τ可以将采样电容充电到99%，10τ可以满足12位的精度</p>
<p>使用CBF控制位控制输出信号的输出滤波器</p>
<p>使用参考电压生成器来生成VREF，可以应用于比较器输入端，使用CBREF0x和CBREF1xl来控制</p>
<p>使用CBPWRMD来选择比较器功耗模式，默认为00——最大功耗、最快速度；可以调节到11来使用最低功耗、最低速度</p>
<p>使用CBCTL3来控制比较器的端口是否禁用；使用CBIPSEL或CBIMSEL来控制对应端口的输入缓冲区</p>
<p><strong>比较器也可以开启中断</strong></p>
<p>对于可编程电压比较器而言，一般使用滞后比较来让参考电压根据输出值变化，可以让比较器输出更加稳定，降低噪声</p>
<p>代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW + WDTHOLD; <span class="comment">//停看门狗</span></span><br><span class="line">    P1DIR |= BIT6; <span class="comment">//P1.6作输出</span></span><br><span class="line">    P1SEL |= BIT6; <span class="comment">//复用为比较器输出CBOUT</span></span><br><span class="line">    </span><br><span class="line">    P7DIR |= <span class="number">0xFF</span>; <span class="comment">//P7设置为输出，用来驱动LED显示当前比较器结果</span></span><br><span class="line">    </span><br><span class="line">    CBCTL0 |= CBIPEN + CBIPSEL_0; <span class="comment">//比较器施恩那个，设置输入通道CB0为P6.0</span></span><br><span class="line">    CBCTL1 |= CBPWRMD_0; <span class="comment">//设置为高速模数</span></span><br><span class="line">    CBCTL2 |= CBRSEL; <span class="comment">//使用VREF作为反相端的参考电压</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置高低两个阈值电压 */</span></span><br><span class="line">    CBCTL2 |= CBRS_1 + CBREF13; <span class="comment">//以VCC为参考电压，CBREF1=8，VREF=VCC/4</span></span><br><span class="line">    CBCTL2 |= CBREF04 + CBREF03; <span class="comment">//VREF0=VCC * 3/4</span></span><br><span class="line">    </span><br><span class="line">    CBCTL3 |= BIT0; <span class="comment">//打开Comp_B</span></span><br><span class="line">    CBCTL1 |= CBON; <span class="comment">//使能比较器</span></span><br><span class="line">    __delay_cycles(<span class="number">75</span>); <span class="comment">//等待比较器内部参考电压达到稳定</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(CBCTL1 &amp; CBOUT) <span class="comment">//如果CBOUT为高电平</span></span><br><span class="line">        &#123;</span><br><span class="line">            P7OUT = <span class="number">0x00</span>; <span class="comment">//LED点亮</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            P7OUT = <span class="number">0xFF</span>; <span class="comment">//LED熄灭</span></span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码在输入电压大于VREF0=3/4 VCC时CBOUT输出高电平，LED点亮；输入电压小于VREF0=1/4 VCC时CBOUT输出低电平，LED熄灭；当电压在二者之间时，CBOUT状态不变，起到了稳定输出的作用</p>
<p>同样的比较器也可以产生中断信号，在检测到设定的跳变沿（上升沿或下降沿）后触发中断，进入对应的中断服务函数，可以在其中判断比较器输出的电平，避免了轮询</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CBCTL1 |= CBPWRMD_1 + CBF + CBFDLY_3; <span class="comment">//普通模式，选择中断边压，使用输出滤波</span></span><br><span class="line"><span class="comment">/* 在中间设置其他比较器参数 */</span></span><br><span class="line"><span class="comment">/* 等待一定时间来让参考电压稳定 */</span></span><br><span class="line">CBINT &amp;= ~(CBIFG + CCBIIFG); <span class="comment">//清除错误中断标志</span></span><br><span class="line">CBINT |= CBIE + CBIIE; <span class="comment">//使能比较器输出中断和输出反相中断</span></span><br><span class="line">__bis_SR_register(LPM0_bits + GIE); <span class="comment">//开启全局中断</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=COMP_B_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">Comp_B_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(__even_in_range(CBIV, <span class="number">4</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//无中断</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//中断CBIFG</span></span><br><span class="line">            <span class="keyword">if</span>(CBCTL1 &amp; CBOUT) <span class="comment">//判断是否输出高电平</span></span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">//反相中断CBIIFG</span></span><br><span class="line">            <span class="keyword">if</span>(!(CBCTL1 &amp; CBOUT)) <span class="comment">//反相端需要相反的判断</span></span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里仅列出中断服务函数和其开启方式</p>
<h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><p>msp430的DMA最多有8个通道，但是msp430f5529只有3个通道</p>
<p>基本使用方法和stm32的DMA完全一样，四种模式、单传输、块传输、连续传输都和stm32的传输方法类似，但设置更为简单</p>
<p>一个使用DMA进行UART传输的例子如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> String1[] = &#123;<span class="string">&quot;Hello World\r\n&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW + WDTHOLD; <span class="comment">//停看门狗</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 端口配置 */</span></span><br><span class="line">    P4SEL = BIT4 + BIT5; <span class="comment">//配置P4.4、P4.5为Tx、Rx端口</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* 配置USCI_A1为UART模式 */</span></span><br><span class="line">    UCA1CTL1 = UCSSEL_1; <span class="comment">//使用ACLK为时钟源</span></span><br><span class="line">    <span class="comment">//控制分频器设置波特率为9600</span></span><br><span class="line">	UCA1BR0 = <span class="number">0x03</span>; <span class="comment">//分频器高八位</span></span><br><span class="line">    UCA1BR1 = <span class="number">0x0</span>; <span class="comment">//分频器低八位</span></span><br><span class="line">    UCA1MCTL = UCBRS_3 + UCBRF_0; <span class="comment">//调制器UCBRSx = 3</span></span><br><span class="line">    UCA1CTL1 &amp;= ~UCSWRST; <span class="comment">//启动设备</span></span><br><span class="line">    <span class="comment">/* 配置DMA */</span></span><br><span class="line">    DMACTL0 = DMA0TSEL_1; <span class="comment">//以定时器TA0CCR0 CCIFG为触发源</span></span><br><span class="line">    </span><br><span class="line">    __data16_write_addr((<span class="keyword">uint16_t</span>)&amp;DMA0SA, (<span class="keyword">uint32_t</span>)String1); <span class="comment">//源地址：String1字符串</span></span><br><span class="line">    __data16_write_addr((<span class="keyword">uint16_t</span>)&amp;DMA0DA), (<span class="keyword">uint32_t</span>)&amp;UCA1TXBUF); <span class="comment">//目标地址：UART发送缓存区域</span></span><br><span class="line">	</span><br><span class="line">	DMA0CTL = DMADT_4 + DMASRCINCR_3 + DMASBDB +DMAEN; <span class="comment">//重复单传输，递增模式，字节到字节，并使能DMA</span></span><br><span class="line">    <span class="comment">/* 配置定时器 */</span></span><br><span class="line">    TA0CCR0 = <span class="number">8192</span>; <span class="comment">//字符传输频率=32768/8192=4 字节/s</span></span><br><span class="line">	TA0CTL = TASSEL_1 + MC_1; <span class="comment">//使用ACLK作为时钟源，采用增模式</span></span><br><span class="line">    __bis_SR_register(LPM0_bits); <span class="comment">//进入LPM3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序会连续向外以9600波特率发送串口数据</p>
<h3 id="电源管理"><a href="#电源管理" class="headerlink" title="电源管理"></a>电源管理</h3><p>msp430f5529的电源管理模块PMM由监督器SVS和监视器SVM组成</p>
<p>SVS是强制要求的，用于保障设备稳定运行</p>
<p>SVM是宽松可编程的，用于进行一些低功耗控制和安全保障</p>
<p>可以通过对SVM编程提高VCORE来支持更高的MCLK，也就是所谓的<strong>超频</strong></p>
]]></content>
      <tags>
        <tag>电赛笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>电路设计从入门到弃坑1【基础晶体管】</title>
    <url>/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/</url>
    <content><![CDATA[<h1 id="电路设计从入门到弃坑1【基础晶体管】"><a href="#电路设计从入门到弃坑1【基础晶体管】" class="headerlink" title="电路设计从入门到弃坑1【基础晶体管】"></a>电路设计从入门到弃坑1【基础晶体管】</h1><p>最基础的电路是由无源元件，即电阻、电容、电感三者构成的电路，两端通电后可以产生一个暂时稳定的电信号。不论是机缘巧合还是为了验证实验，曾经的物理学家开始注意到电的特殊性质，并加以研究，他们最先对电的性质进行探寻，从风筝实验到电磁感应定律一点点理解了电磁运作的原理，于是电气工程就出现了。然而到19世纪末为止，一直都只有无源电路的存在，电路的分析理论也仅有基础的电磁感应定律和由麦克斯韦方程组衍生出的基尔霍夫定律——直到20世纪的工程师发明出真空管，开启电子电路的时代。电路从最初使用电能和磁场能来控制、转化其他能量这个单一用途，进一步拓展出使用电信号来描述、控制其他信号，乃至使用电信号进行计算的用途。实现这些功能的基础就是具有控制功能的有源器件，也就是常说的二极管、三极管等元件。现代的半导体晶体管在20世纪中期才被发明出来，在此之前承担电子信号变换作用的元件一直是真空管。</p>
<h2 id="真空管"><a href="#真空管" class="headerlink" title="真空管"></a>真空管</h2><p>在半导体材料被发明之前，人们都使用电子管或者说真空管对电路进行操控，现代的半导体技术实质上还是在使用半导体达到真空管的用途，只不过因为半导体材料可以在硅片上进行制造，大大缩小了电路体积——但是它们的用途是相似的</p>
<p>现在真空管已经被市场淘汰，剩下的也不过成了爱好者们的玩具，不过理解真空管有助于了解二极管、三极管等基本的晶体管在电路中起到的作用</p>
<p>电子管主要分为：二极管、三极管、五极管、束射管、复合管等，听上去和半导体器件很相似</p>
<p>二极管是其中最简单的，它中间装有两个电极，一个是由金属丝制成用于发射电子的阴极，另一个是接收电子的屏极。给阴极通电，电流会将金属加热，管内已经被抽成了真空，因此金属丝就能发射电子，屏极则负责将这些电子接收。</p>
<p>在屏极接高电势，阴极接低电势时，屏极会主动吸引阴极发出的电子。一般来说二极管的加热部件是独立的，围绕在阴极周围，如下图所示（图b为电路符号，K为阴极，a为屏极，两个f表示加热部件）</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210814022541069.png" alt="image-20210814022541069"></p>
<p>因此实际上会有很多（效率懂得都懂，但是当时能用就行）电子从阴极到达屏极；反之在屏极接低电势，阴极接高电势时，电子的发射会被抑制——这就造成了二极管具有<strong>单向导电性</strong></p>
<p>基于PN结的二极管实际上也是起到单向导电性的作用，只不过由于引入了半导体技术，它的功能更加丰富、复杂了（实际上前人们也使用了很多方法改进真空管让它们做到现在半导体二极管的功能——毕竟第一台电子计算机都是用真空管制造的）</p>
<p>容易看出，这个大二极管具有一个致命的问题：功耗大得离谱，这玩意实际上就是个电灯泡——工作时常常能达到外壳100多度，用手摸一下就能烫熟的那种……这就是真空管的通病了：它们都需要使用额外的电热丝来让金属发出电子，而半导体管则不需要这些</p>
<p>再来看三极管：<img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210814023224226.png" alt="image-20210814023224226"></p>
<p>它中间多了一个栅极g——这个称呼也被保留到了后来的场效应管中——可以通过控制栅极来实现控制阴极-屏极电流，这也是双极结型晶体管和场效应管的共同原理和要达到的目的：<strong>用一个电流/电压控制另一个电流/电压</strong></p>
<p>值得指出的是：真空三极管的很多特性与专有名词被移植到了晶体三级管上，如果学完了三极管/晶体管再来学另一个，会感到很熟悉</p>
<p>真空管中还有一个较三极管更复杂的分支——五极管。他在三极管的栅极和屏极之间插入另外两个电极，于是栅极被分成了<em>控制栅极</em>、<em>帘栅极</em>和<em>抑制栅极</em>，这个器件主要用于减少的真空三极管中超大寄生电容和超量漂移电流的影响，从而能够实现“<strong>高频开关和放大</strong>”（在当时确实是高频）的开关，第一台电子计算机中也大多用了五极管配合继电器进行开关</p>
<p>最后需要提的就是束射管（至于复合管嘛，管如其名），它就是高中物理里面大名鼎鼎示波管的父类——通过将高速电子流打在荧光屏上实现显示功能，使用周边的电磁铁来控制显示的位置</p>
<p>不过束射管还有很多其他变种，辉光管、荧光管等上世纪苏联时代的遗产都是束射管的成员，它们大都利用加热器-金属灯丝-荧光材料/电子射线的原理进行发光显示信息，可以说是现代发光二极管的鼻祖了</p>
<p>利用这些真空管，前人们也制造出了放大器、振荡器、线性电源乃至开关电源等设备，其耐用性甚至能把一部分使用现代技术的设备打趴下。比起教科书中从半导体物理直接讲起，个人认为晶体管这种”朴素“的老古董更能体现模拟电路的本质——<strong>通过支路量操控支路量，从而实现模拟电信号的变换</strong></p>
<p>而真空管中的几个基本元件的性质也会在晶体管元件上得到体现</p>
<ul>
<li>二极管——单向导电与反向击穿</li>
<li>三极管——电流放大与开关控制</li>
</ul>
<h2 id="二极管"><a href="#二极管" class="headerlink" title="二极管"></a>二极管</h2><blockquote>
<p>我再用真空管，诺伊斯就是个伞兵！——肖克利（他没说过）</p>
</blockquote>
<p>简单了解过真空管，我们再来看看现代半导体科技的结晶，<strong>晶体管</strong></p>
<p>首先要谈的就是二极管了。不过要看懂现代半导体科技，就要从它们的基础——半导体材料开始。由于本篇的重点在于半导体器件，所以这里仅进行笼统的概括。我们先从二极管的物理基础<strong>PN结</strong>看起。</p>
<h3 id="二极管就是PN结"><a href="#二极管就是PN结" class="headerlink" title="二极管就是PN结"></a>二极管就是PN结</h3><p>半导体材料（硅/锗）的单质都是很难导电的，因为其中的电子和空穴浓度相等，即使外加电压，也会很快形成电流的动态平衡；然而这种平衡容易随着外界环境改变而改变，通过向纯净的半导体材料中掺入受控量的N型杂质和P型杂质，可以分别得到<strong>N型半导体</strong>和<strong>P型半导体</strong>，这种技术称为<strong>掺杂</strong></p>
<blockquote>
<p>N型杂质就是氮族元素（IVA族），它们的最外层电子数为5；P型杂质则是硼族元素（IIIA族），它们的最外层电子数为3</p>
<p>显而易见，N型杂质的掺杂会导致自由电子数量增多，半导体的载流子为多子，即自由电子，这就是为什么它被称为<strong>N</strong>egative；相反地，P型杂质的掺杂会导致空穴数量增多，半导体的载流子为多子，即空穴，这也是为什么它被称为<strong>P</strong>ositive</p>
<p>使用能带理论可以解释多子导电：导带中的电子就是载流子，能够导电；而空穴作为电子反向移动（跃迁）的等效，也可以等效地导电。相关内容可以参考《半导体物理》教材或本博文的参考书《模拟电子系统设计指南（基础篇）：从半导体、分立元件到TI集成电路》</p>
</blockquote>
<p>幼儿园的小朋友都知道，半导体材料的导电性容易受到外界温度、光照等因素影响。这是因为在特定温度热平衡的条件下，对特定的半导体材料，电子浓度$n_o$和空穴浓度$p_o$的乘积始终为常数，公式如下：$n_o * p_o = n_i^2$</p>
<blockquote>
<p>电子在核外的量子分布状态成为<strong>状态密度</strong>；电子的能量分布称为<strong>费米函数</strong></p>
<p>费米函数可以表明电子占据特定允态能级的概率，而它的值是由当前温度T和<strong>费米能级</strong>$E_F$决定的，表达式如下：<br>$$<br>f(E)=\frac{1}{1+e^{(E-E_F)/kT}}<br>$$<br>当T=0K时，可以发现所有低于费米能级的允态能级会被填充；高于费米能级的允态能级则会空出</p>
<p>当T有一个大于0K的确定值时，上式就存在一个极限值，并且填充态和空态之间出现了过渡，随着温度升高，这个极限值会逐渐降低，这就导致<strong>导带中热平衡的电子浓度会随着导带能级与温度变化而变化</strong>，表达式如下<br>$$<br>n_0=N_Ce^{-(E_C-E_F)/kT}<br>$$<br>参数$N_C$表示导带中的有效态密度函数，它的值仅由半导体材料的有效质量和温度确定</p>
</blockquote>
<p>根据上式不难得出：在温度稳定的条件下，半导体材料的本征浓度为常数</p>
<p>一般地，把两种不同的体系合二为一时，载流子可以互相流动；但是热平衡的时候一定会形成统一的费米能级，这是因为出现了载流子浓度交换，因此可以<strong>把掺杂的过程看作使费米能级变化进而改变导带宽度的过程</strong>；由此也可以推断出光照和温度也会让导带宽度变化，进而影响半导体材料导电性</p>
<p>说完了P型和N型半导体，终于能谈到PN结了——二极管归根结底就是一个封装起来的PN结，通过控制PN结的物理性质就可以制造出不同种类的二极管</p>
<p>PN结的物理性质十分复杂，这里我们只讲<em>简化的PN结模型</em></p>
<p>在一个晶格内，将P型和N型半导体连接在一起就形成了PN结，电子会从N区扩散到P区，空穴会从P区扩散到N区，因此在二者的接触区附近，电子和空穴会复合抵消，将其称为<strong>耗尽区</strong>或<strong>空间电荷区</strong>——在特定温度的热平衡条件下，不施加额外能量，电子或空穴是不能通过PN节的；同时由于在结的两侧存在相反的电荷，这就建立了一个穿越PN结的电场</p>
<p>当没有给PN结施加额外能量时，耗尽区会阻挡电流形成，不过仍然会存在微弱的电流穿过耗尽区，根据方向分为<strong>正向扩散电流</strong>和<strong>反向漂移电流</strong>；如果在外部对PN结两端施加正向电场，使得耗尽区内电场被抵消，空穴和电子就能够自由流动，在此过程中耗尽区越厚，所需要施加的外部能量就越大</p>
<blockquote>
<p>想象一种极端情况，将P型半导体的掺杂浓度提升到极限，甚至将其换成金属，那么电子便会自由地从P区向N区扩散，但是随着扩散，P区的电子浓度会逐渐变低，反而会形成一个从N区到P区的势垒，这一过程是动态平衡，这个势垒就是大名鼎鼎的肖特基势垒，利用贵金属和N型半导体就可以制成<em>肖特基二极管</em>，它的原理和结型二极管十分相似，但是最后的产物完全不一样：加正向电压时肖特基势垒会变窄而导致其内阻减小，这一性质导致它具有正向压降低的优点</p>
</blockquote>
<p>虽然二极管耗尽区的这个电场（一般称为内建势垒或内电场）很强，能抑制多子的运动，但是P区的少子电子会因此漂移到N区；N区的少子空穴也会穿过PN结到达P区，二者引起的电流分别称为正向扩散电流和反向漂移电流，二者大小相等、方向相反</p>
<p>因此，PN结也就是二极管的最根本、最基础特性就是<strong>单向导电性</strong></p>
<h3 id="从伏安特性出发"><a href="#从伏安特性出发" class="headerlink" title="从伏安特性出发"></a>从伏安特性出发</h3><p>回想一下真空管时代我们都用真空二极管干了什么？拿它单向导电和反向稳压！当年肖克利老爷子准备了一份真空管的伏安特性，然后对着面前的硅片就开始研究：怎么让这破玩意弄得像真空管一样？我们也先从伏安特性出发，理解二极管的性质</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210828014723118.png" alt="image-20210828014723118"></p>
<ul>
<li><p>正偏曲线</p>
<p>  二极管的P极接高电势、N极接低电势，即<strong>正偏</strong>，在这个情况下二极管的伏安特性曲线近似于指数函数</p>
<p>  二极管正偏伏安特性曲线如下所示：</p>
<p>  <img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210828014716192.png" alt="image-20210828014716192"></p>
<p>  U<del>ON</del>为<strong>二极管导通电压，硅管约为0.7V，锗管约为0.3V</strong>。因为二极管导通电压相对较低，而导通后电流升高速度很快，在$2 * U_{ON}$后就可以看作是短路状态，因此也常使用二极管的简化模型：当电压&lt;0V（或导通电压）时二极管关断，当电压&gt;0V（或导通电压）时二极管导通且为短路</p>
<blockquote>
<p>顺带一提，锗二极管虽然导通电压更低，但是已经基本被市场淘汰了，因为</p>
<ol>
<li>锗稳定性不好、提炼加工困难导致其一致性难以保证</li>
<li>价格更高</li>
<li>难以在硅片上集成</li>
</ol>
<p>同样遭遇的还有锗三极管，它的结压降也是约为0.3V（甚至视型号不同会更低一些），但是因为制造工艺和品控问题早早停产，只有一些HiFi发烧友在使用锗器件来达到更好的放大性能</p>
<p>特别地，<strong>锗管反向饱和电流为μA级，硅管则为nA级</strong>，显然硅管的截止更彻底</p>
</blockquote>
</li>
<li><p>反偏曲线</p>
<p>  之前没有说二极管PN结<strong>反偏</strong>（P极接低电势，N极接高电势）的结果：当阴极电压比阳极电压高时，会形成一个由阴极到阳极的外电场，电流根本不会产生，但是如果这个电压逐渐增高，甚至能够抵消耗尽区的内电场时，二极管就会被<strong>击穿</strong>，击穿时，整个晶体管内会产生大量电子-空穴对，电流会达到最大，换句话说此时二极管近似于短路，在这个过程中二极管会因为电流而剧烈发热，但是<strong>这并不意味着二极管损坏</strong>，如果再撤销这个反向电压，二极管还是会因为内电场重新建立而恢复原状。</p>
<blockquote>
<p><strong>材料掺杂浓度较低的PN结中</strong>，当PN结反向电压增加时，空间电荷区中的电场随之增强。这样通过空间电荷区的电子和空穴就会在电场作用下，使获得的能量增大。在晶体中运行的电子和空穴将不断与晶体原子发生碰撞，通过这样的碰撞可使被束缚在共价键中的键电子碰撞出来，产生自由电子-空穴对。紧接着新产生的载流子会在电场作用下撞出其他价电子，又产生新的自由电子-空穴对。如此连锁反应，使得空间电荷区中的载流子的数量雪崩式（也可以理解为链式反应）增加，流过PN结的电流就急剧增大击穿PN结，这种碰撞电离导致击穿称为<strong>雪崩击穿</strong></p>
<p>而在<strong>材料掺杂浓度较高的PN结中</strong>，耗尽区本来就比较薄，而在此时反偏一个强电场，这就是的耗尽层内中性原子的价电子会被快速拉出，成为自由电子，同时产生空穴，这个过程被称为<strong>场致激发</strong>。在场致激发的影响下二极管内会产生大量载流子，因此出现反向击穿的现象，这种击穿一般需要的外部能量较雪崩击穿更少，被称为<strong>齐纳击穿</strong></p>
</blockquote>
<p>  事实上能够损坏二极管的只有高温和外部破坏。因为<strong>导带中热平衡的电子浓度会随着导带能级与温度变化而变化</strong>，温度越高，热平衡电子浓度越高，越难以导电，而当反向击穿积聚的热量无法被释放时，二极管会被烧毁。二极管的反偏伏安特性如下所示：</p>
<p>  <img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210828013041349.png" alt="image-20210828013041349"></p>
<p>  U<del>BR</del>表示<strong>击穿电压</strong>（分为<strong>雪崩电压</strong>和<strong>齐纳电压</strong>），I<del>S</del>为漏电流（反向饱和电流），可见当二极管反偏时，在击穿电压范围内电流会达到很小，而超过击穿电压后，通过二极管的电流就会迅速增大（一般雪崩击穿电流增大速率比齐纳击穿更快）</p>
</li>
<li><p>特别的，可以使用公式<br>  $$<br>  i=I_s(e^{\frac{u}{U_T}}-1)<br>  $$<br>  近似表示二极管的伏安特性</p>
</li>
</ul>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol>
<li><p>单向导电性</p>
<p> 二极管的单向导电性应该不用多介绍，大家品鉴的足够多了。一般利用这个性质，可以实现二极管的半桥整流或<strong>全桥整流</strong>（对于三相电可以使用三相桥整流），用于将交流信号变成脉动的直流信号。对于单相交流信号，可以直接在变压器中间抽头，用两个背对背的二极管就可以实现全桥整流</p>
<p> 还可以利用这个性质实现<strong>boost电路</strong>（倍压整流）来进行DC-DC升压；对于高频信号则可以使用类似的电路（二极管后接电阻和并联的电容，前接激励源）实现<strong>包络检测</strong>，从高频调制的信号中提取低频信号</p>
<p> 在一般电路中应用比较多的就是<strong>钳位电路</strong>和<strong>削波电路</strong>，可以通过两个二极管分别连到VCC和GND端防止某个节点的电压偏高/过低，但是应该注意要在二极管同一支路串接保护电阻防止泄放电流过大</p>
<p> 因为二极管可以起到改变高频信号偏置电流的作用（因为它的正向电容可以在一定程度上滤除高频信号），所以可以使用它和分压电阻、电容实现压控衰减器，示例电路如下</p>
<p> <img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210828023423864.png" alt="image-20210828023423864"></p>
</li>
<li><p>反偏稳压性</p>
<p> 如果二极管反向电压超过击穿电压时，它会工作在击穿去，反向电流迅速增加，但电压基本不变，因此可以在保证二极管不过热的情况下让二极管在击穿区实现稳压功能，通过专门设计的，在击穿区内有着陡峭特性曲线（利用齐纳击穿特性）的二极管成为齐纳二极管，也就是俗称的稳压二极管</p>
<blockquote>
<p>一般来说稳压二极管都会有很高的掺杂浓度，这是因为稳压管利用了齐纳击穿而不是雪崩击穿：雪崩击穿所需的外部电压一般相当高，击穿时会很快产生巨大的电流，在这种情况下二极管的结温非常难以控制，因此一般的二极管一旦出现雪崩击穿基本就意味着烧毁；但是齐纳击穿的击穿电压相对较低，而且它的击穿伏安特性更平滑，只要在外接一个电阻用于控制击穿电流就可以相对容易地实现稳压</p>
</blockquote>
</li>
<li><p>反偏变容性</p>
<p> 耗尽层相当于PN两块半导体之间的绝缘体，因此二极管存在寄生电容（<em>结电容</em>）；又因为外加电压时耗尽层厚度会发生变化，因此二极管的寄生电容就会发生变化——通过在某一侧只掺入微量杂质，可以实现一个相当厚的耗尽区，如果此时对二极管反偏，这个耗尽区厚度会很容易变化，由此达到<strong>变容二极管</strong>的作用</p>
</li>
<li><p>温度敏感性</p>
<p> 因为导带中热平衡的电子浓度会随着导带能级与温度变化而变化，所以<strong>反向饱和电流</strong>会对温度敏感——会<strong>随温度增加而快速增加</strong>。其次，<strong>温度升高，二极管正向压降减小，正向工作电流增大，</strong>这是因为温度升高会导致耗尽区的原子共价键不稳定，更容易被外加电场激发出自由电子-空穴对</p>
</li>
<li><p>耗尽电容与扩散电容</p>
<p> 高频交流信号下，二极管中的耗尽层会演变成一个以硅为电介质的平行板电容器，对应的电容被称为<strong>耗尽电容</strong>。它会随二极管反向偏压而变化。</p>
<p> 当二极管正片时，由于耗尽层附近区域会有过量少子电荷聚集，出现电荷存储效应，局部的电荷浓度出现了不平衡，这就相当于又引入了一个电容，被称为<strong>扩散电容</strong>，它的大小与PN结点的横截面积成正比，一般为10-100pF</p>
<p> 利用这两个电容可以推导出二极管的高频小信号模型：正偏时一个小电阻并两个电容；反偏时一个大电阻并一个电容（耗尽电容）</p>
</li>
</ol>
<p>其实还有发光二极管、肖特基二极管等多种结构的二极管，它们都有自己的特点，但是暂且不作介绍</p>
<h3 id="电路应用"><a href="#电路应用" class="headerlink" title="电路应用"></a>电路应用</h3><p>下面给出1n4148二极管（来自安森美）的datasheet</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210828021027904.png" alt="image-20210828021027904"></p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210828021038170.png" alt="image-20210828021038170"></p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210828021047611.png" alt="image-20210828021047611"></p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210828021054300.png" alt="image-20210828021054300"></p>
<p>常见的参数都已给出，1n4148是通用性的开关二极管，电路设计中主要需要参考其击穿电压（100V）、最大正向电流（200mA）、峰值电流（400mA）、工作温度（-55到175）、功率（500mW）、漏电流（0.025uA-5uA）、开关频率（或者说恢复时间）（4ns）</p>
<p>可见它的开关频率比较高，但耐压相对一般，也缺少反向击穿稳压的能力，因此适合用作开关二极管或检波二极管的替代品</p>
<h2 id="三极管"><a href="#三极管" class="headerlink" title="三极管"></a>三极管</h2><blockquote>
<p>一个有源器件可以通过一个电信号控制其他电信号——真空三极管告诉电气工程师的遗言</p>
</blockquote>
<p>三极管又称<strong>双极结型晶体管</strong>，也就是所谓的<strong>BJT</strong>（Bipolar Junction Transistor）</p>
<p>特别地，“晶体管”——Transistor实际上是贝尔实验室对跨导变阻器（Transconductance Varistor）的简称</p>
<h3 id="三极管与二极管"><a href="#三极管与二极管" class="headerlink" title="三极管与二极管"></a>三极管与二极管</h3><p>为了实现电信号的相互控制，三端器件是必须的。对于一个三端器件，我们一般通过双端口网络模型进行分析。对于三极管，更适合使用双端口网络的T参数和H参数矩阵进行描述——但这太学术了！从直观上理解<strong>三极管就是一个水龙头</strong></p>
<p>我们先来看需要三端元件做什么：首先它要使用一端的电压/电流进行控制，就假设这个三端元件有ABC三个端口，要想在A端口产生这个电压/电流，就要找到一个地，因此三端元件一定需要一个接地点，让另外两端到这一端产生电流。暂且假设这个接地点是B——既然有电流产生，根据基尔霍夫电流定律，A端流入和C端流入电流之和就是B端流出的电流。一切都解释的通了：A端通过AC之间的电流/电压控制BC之间的电流/电压，这不就是一个受控源吗！我们将AC之间的电流/电压与BC之间电流/电压的比值记作<strong>增益β</strong>，不难看出<strong>β&lt;1</strong>恒成立，换个角度，这其实就是T参数矩阵中的一个参数</p>
<p>这就能解释三极管是水龙头这个比喻了：通过扭动水龙头把手可以可以控制水流的大小</p>
<p>对于三极管来说，他正是使用电流控制电流，A端被称为<strong>基极</strong>，记为<strong>b</strong>（<strong>B</strong>ase），B端称为<strong>发射极e</strong>极（<strong>E</strong>mitter），C端称为<strong>集电极c</strong>极（<strong>C</strong>ollector）。<strong>be电流控制ce电流</strong>。以下部分都会使用e、b、c三个极的简写形式</p>
<h3 id="一点简单的原理"><a href="#一点简单的原理" class="headerlink" title="一点简单的原理"></a>一点简单的原理</h3><p>三极管有两种大类型：<strong>NPN</strong>和<strong>PNP</strong>。它们的名字来源于其中“结”的排列顺序。它们的大致结构和电路符号如下所示：</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210831003431811.png" alt="image-20210831003431811"></p>
<p>BJT使用c和e极作为电流源端，b作为电流控制端，<strong>电路符号中的箭头表示器件处于正向有源状态时的电流方向</strong></p>
<p>目前PNP和NPN两种晶体管都被大量生产，但是相对而言NPN型生产效果更好——半导体中电子的流动性比空穴流动性更强，NPN的内部具有两个N型半导体区，所以它内部的电子浓度更高，可以达到更高的工作速度和承载更大电流。对于NPN管而言，共e极模式下，c极将基极注入的小电流放大输出；其他条件下，<strong>当E<del>b</del>&gt;E<del>e</del>时，晶体管c、e导通</strong>；PNP管与其相反，共射模式下，c极将离开b极的小电流放大输出，而<strong>当E<del>b</del>&lt;E<del>e</del>时，晶体管c、e导通</strong></p>
<p>实际上三极管的原理比较复杂，但在这里我们主要讨论的是其电气性质，所以只用NPN举例简单解释一下。正如其命名，BJT是由两个PN结构成的，其中电荷载流子穿过两个不同电荷浓度区域PN结时会发生双向扩散，这就导致了BJT的内电流。一个BJT的剖面图如下所示</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210831004908286.png" alt="image-20210831004908286"></p>
<blockquote>
<p>原谅我的灵魂画作</p>
</blockquote>
<p>可以发现<strong>BJT成型于c极底座，面积很大，b极被做得很薄且具有极低的掺杂浓度，e极则被控制在较高的掺杂浓度</strong>。这么做主要有以下几个原因：</p>
<ol>
<li>让e极可以很容易地被be电压激发出电子</li>
<li>让b极容易被穿过</li>
<li>c极可以完整接住来源于e极的电子</li>
</ol>
<p>可以发现整个流程和真空三极管的发射电子-控制电子-接收电子有异曲同工之妙。特别地，e极电子作为多子向b极扩散后，本来是少子的b极电子浓度大增，会自发向电子浓度相对较低的c极扩散，因此BJT被划分为少子载流元件</p>
<blockquote>
<p>顺便一提场效应管FET是多子载流元件，这就是为什么FET能承受相对更大的电流，这个话题按下不表</p>
</blockquote>
<p>当b极和e极加正向电压时，e极高浓度电子被快速激发，直接在电场作用下达到e极，而如果没有其他电源，这些电子会自行穿过b极进入外电路；但是一旦施加了更高（大于E<del>ce</del>）的电压，这些电子中的绝大多数就会进入c极（因为c极的面积比b极大得多），随后进入外电路。生产中为了降低在到达c极之前被空穴中和掉电子的百分比和被b极电压“吸引走”电子的百分比，b区就被做得很薄了</p>
<blockquote>
<p>有些人在学习模电不久后觉得三极管就是两个二极管的简单串联，只不过多加了一个控制功能，这种想法是完全<strong>错误</strong>的！</p>
</blockquote>
<p>一般在模拟电路设计中，认为c极电流是b极电流的线性函数，也就是大名鼎鼎的<strong>β</strong>；但是对于更精确的BJT电路，需要使用电压控制模型，或者说<strong>EM（Ebers-Moll）模型</strong>，需要考虑一个指数函数<br>$$<br>I_C=I_S(e^{\frac{qV_{BE}}{kT}-1})<br>$$<br>这个模型基于三极管的物理模型建立，相对精确。V<del>BE</del>可以被描述为$V_{BE}=\frac{kT}{q} ln \frac{I_C}{I_S}$</p>
<p>使用这个模型的一个优点在于可以将三极管建模成跨导：电压控制，跨导和集电极电流成比例关系，常用于SPICE模型仿真和高频电路的理论计算中</p>
<p>上面提到了<strong>β值</strong>，这可以说是三极管最重要的性能指标了，它的正式名称为<strong>共射极电流增益</strong>，<strong>在正向有源区近似于c极直流电流和b极直流电流的比值</strong>；另一个重要参数是<strong>共基极电流增益α</strong>，<strong>在正向有源区近似于从发射极到集电极的电流增益</strong>，其值一般接近于1。相关公式如下<br>$$<br>\alpha=\frac{I_C}{I_E} \<br>\beta=\frac{I_C}{I_B} \<br>I_E=I_B+I_C \<br>\beta=\frac{\alpha}{1-\alpha} \<br>\alpha=\frac{\beta}{1-\beta}<br>$$</p>
<blockquote>
<p>BJT是非对称器件，因此当把c、e极互换后BJT会工作在反向有源模式，一般不会这样使用BJT，它的内部结构也为正向有源模式进行了优化。在CMOS制造工艺中，常常使用低性能的“横向”对称BJT，这是为了平衡成本（硅片面积）和性能</p>
</blockquote>
<p>在应用方面，可以直接通过三极管的工作电流电压测出其β值：$\beta=\frac{\Delta i_c}{\Delta i_b}$</p>
<p><strong>三极管的be结电阻</strong>也是一个重要参数，它需要使用半导体物理的公式得出：<br>$$<br>R_{BE}=r_{bb’}+\frac{26mV}{I_{BQ}}<br>$$<br>其中r<del>bb’</del>是三极管的基区电阻，这是一个大致在100~200Ω之间的常数，只与三极管的制造工艺有关，它加上PN结电阻，也就是后面那部分就可以得到be结总电阻了</p>
<h3 id="很多复杂的性质"><a href="#很多复杂的性质" class="headerlink" title="很多复杂的性质"></a>很多复杂的性质</h3><p>因为很复杂，所以跳过！</p>
<p>三极管的性质太多了，而这些性质造就了它的多种用途。可以说现代中小功率模拟电路就是建立在三极管之上的；而大功率模拟电路则被场效应管所掌控</p>
<p>下一部分会详细讲述三极管的基本应用。这里先了解一下三极管的基本工作区域和输入输出性质（以NPN为例）</p>
<p>BJT有5个不同的工作区，列举如下：</p>
<ol>
<li><strong>正向有源（正偏）</strong>：V<del>c</del>&gt;V<del>b</del>&gt;V<del>e</del>，$I_C=\beta I_B$，水龙头把手在开合范围内，可以控制水流大小。be结正偏，bc结反偏</li>
<li><strong>饱和（完全导通）</strong>：V<del>b</del>&gt;V<del>e</del>，V<del>c</del>&lt;V<del>b</del>，b极电压超过了c极电压，就像是手把水龙头开到最大，水龙头把手都扭歪了，自然水会喷涌而出，这时三极管c极电流会达到最大。所有PN结正偏，常用于实现逻辑电路中的开关闭合</li>
<li><strong>截止</strong>：V<del>b</del>&lt;V<del>e</del>，水龙头被关上，BJT的c极电流近似于0，属于漏电流；e极电流则近似等于b极电流。所有PN结反偏，可以实现逻辑电路中的开关断开</li>
<li><strong>反向有源（反偏）</strong>：V<del>c</del>&lt;V<del>b</del>&lt;V<del>e</del>，反向电流通过三极管，相当于把c、e极对调。实际中很少使用该模式，因为β值会小得多，相当于三极管内阻被放大了。集成电路中可能会在某些地方用到（大概）</li>
<li><strong>雪崩击穿</strong>：俗称炸管，一般来说三极管被击穿会直接烧毁，因为两个PN结的性质不可能完全一致，这就导致但凡电流过大一点，一个PN结不会被烧毁，另一个一定会被烧掉！三极管的耐压规定了ce、be电压的最大值，选型前一定要注意</li>
</ol>
<p>PNP型三极管的性质和NPN型的性质正好对偶，有兴趣的读者可以自行证明PNP三极管的相关性质</p>
<blockquote>
<p>自证不难</p>
</blockquote>
<p>下面是经典的小信号通用三极管S8050的datasheet</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210831013945373.png" alt="image-20210831013945373"></p>
<p>它使用了经典的TO-92封装，在很多收音机里都能见到这个NPN开关管的身影。</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210831014034027.png" alt="image-20210831014034027"></p>
<p>耐压be 5V；ce 20V；cb 30V。也就是说最好驱动电压不要超过5V，如果使用独立电源为三极管供电，电源也不能超过20V</p>
<p>c极电流700mA，算是开关管里面比较大的，能够驱动一些小型的功率设备了</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210831014222806.png" alt="image-20210831014222806"></p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210831014318634.png" alt="image-20210831014318634"></p>
<p><strong>开关管是指用于充当开关元件的三极管</strong>，也就是说它会工作在截止-导通两个状态下，因此其最重要属性就是开关频率，其次才是增益</p>
<p>而<strong>功率管是指专门用于功率放大的三极管</strong>，它会一直工作在正偏状态下，其最重要属性是增益</p>
<p><strong>通用管是指介于二者之间，能够在一定范围内通用使用的三极管</strong>，在各种各样的电路里都能见到这种三极管，它们的性能指标比较均衡，一般来说两个不同型号的通用管是很有可能相互取代的</p>
<p>可以从output capacitance输出电容看出s8050的开关频率：1MHz下为9pF，一般来说工作在几十kHz可以达到更低的电容量，属于工作在中频的三极管。它的增益在120到400之间，取200的中间值，属于放大性能一般的三极管。s8050就是这样一个中庸的三极管，各种地方都能使用，因此它的出货量很大，价格便宜。生产商也很多。</p>
<p>**DC Current Gain指的就是β值了，在大多数数据手册里面，这个参数被称为$h_{FE}$或$HFE$**，可以看出这个管子的β在120~400，算是性能中庸的</p>
<p>特别提一下current gain bandwidth product电流增益带宽积：放大器带宽和带宽的增益的乘积，在频率足够大时是一个常数，三极管的CGBP其实没有什么用，<em>在高频运算放大器中可以指示放大器的性能</em></p>
<h2 id="场效应管"><a href="#场效应管" class="headerlink" title="场效应管"></a>场效应管</h2><p>场效应管（FET，Field Effet Transistor）和三极管一样，同属于晶体管大家族，其中比较常用的就是MOSFET金属氧化物半导体场效应管（Metal Oxide Semiconductor Field Effect Transistor），它常常以互补金属氧化物半导体（CMOS，Complementary Metal Oxide Semiconductor）的形式出现在数字集成电路中，抑或是以直插功率元件的形式出现在开关电源里。下面对它进行简单的介绍（<em>下面全部使用简称</em>MOSFET或JFET）</p>
<p>由于MOSFET涉及的知识点较多，在这里只进行总体介绍，在后面的博文里会详细谈到MOSFET相关内容</p>
<h3 id="电场效应"><a href="#电场效应" class="headerlink" title="电场效应"></a>电场效应</h3><p>就像四大天王有五个一样，三端元件MOSFET有四个端子，除了<strong>源极s</strong>（<strong>S</strong>ource）、<strong>栅极g</strong>（<strong>G</strong>ate）、<strong>漏极d</strong>（<strong>D</strong>rain）外，还有一个俗称<em>衬底</em>的<strong>体极b</strong>（<strong>B</strong>ody）。一般来说衬底是连接到源极的，因此它表面上和其他三端元件一样。</p>
<p>MOSFET与BJT不同，是电压控制电流器件，它通过施加在栅极上的电压来控制从源极到漏极的电流；同时MOSFET是多子载流器件。BJT需要的开启电流大，开启电压小，能提供给负载的驱动电流也较小；但是MOSFET开启电压大，开启电流小（漏电流也相当小），可以给负载提供很大的电流</p>
<blockquote>
<p>你知道吗？高铁、电磁炮、<del>御坂美琴</del>常用于控制电流的绝缘栅双极型晶体管IGBT就是用三极管和MOSFET复合而成的，其中三极管负责对信号进行放大，通过特制的续流二极管芯片进行隔离，驱动负责导通/关断大电流的MOSFET，兼顾了MOSFET的高输入阻抗和BJT的低导通压降，同时由于是复合管，增益直接爆炸。将其与外围电路封装成模块，常用于控制400V、100A及以上的强电系统！</p>
</blockquote>
<p>MOSFET分为四种：N沟道-P沟道、增强型-耗尽型。这里先不解释它们的含义，我们先来看它的结构：</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901010858481.png" alt="image-20210901010858481"></p>
<p>MOSFET就是一个沿用了真空管三极称呼的器件：因为它本质上就是一个使用电场效应替代电子射线的真空管。解释一下它的名称由来：</p>
<ul>
<li>M代表Metal金属，曾经MOSFET使用金属材料制作栅极，但是现在处于生产便利考虑使用<strong>多晶硅</strong>，因为它能生成自对齐的栅极。现在只有高频MOSFET才会使用金属栅极来提高工作速度（事实上当前速度最快的FINFET工艺采用的仍是硅晶体，在某种程度上说金属应该是个“误解”）</li>
<li>O代表氧化物，目前这也变成了一个“误区”，因为现代的MOSFET会使用各种不同的绝缘材料，目前比较常用的其实是高k绝缘体。这样做的原因只有一个：降低MOSFET的开启电压，提高s-d电流，尽可能降低g极漏电流。<strong>使用xx nm衡量半导体工艺，一般来说这个长度是指MOSFET的沟道宽度</strong>，因为<em>沟道宽度</em>（在之后会解释沟道）减少时，漏电流就会增加；反之，漏电流减少、供电电压降低，意味着MOSFET的性能得到提高</li>
<li>S代表半导体，现代MOSFET的制作工艺就基于半导体材料：在硅衬底顶部生长一层硅氧化物（或其他什么绝缘/半导材料），再沉淀一层金属或多晶硅，就能获得传统的MOSFET了。现在一些厂商开始在MOSFET的沟道中使用硅和锗的化合物，也有一些科研人员在探索新的半导体材料（石墨烯、氮化镓等等），并将其应用在MOSFET上。</li>
<li>FET：场效应，就是所谓的“电场效应”。传统MOSFET等效于一个电容器，一个电极是半导体硅衬底，一个电极是多晶硅。这里先考虑使用的衬底是P型半导体（作为b极），当给金属/多晶硅（作为g极）施加外电压（正电压）时，带有正电荷的空穴就会远离g极和氧化物的中间区域，但是因为整体是个电容，电荷并不会从g极流出。这就创造了一个<strong>耗尽层</strong>，在这个区域里自由载流子无法移动。当g-b电压足够大时，会在靠近半导体和绝缘体之间薄薄一层形成高浓度的负电荷载流子区域，称为<strong>反转层</strong>。将反转层内电子体积密度和体内空穴密度相等的电压称为<strong>阈值电压</strong>。当g-b电压超过阈值电压时，就会形成反转层，此使MOSFET开启，对应的电压称为<strong>开启电压</strong>。而通过外加g-b电压形成反转层导致MOSFET开启的这个过程就称为<strong>电场效应</strong>。</li>
</ul>
<p>真空三极管使用通电的灯丝放出电子流；MOSFET使用场效应开启反转层，在氧化物绝缘层下方生成一个载流子浓度极高可以导电的区域</p>
<p>真空三极管使用栅极（实质上是通过栅极外加电压）控制到达屏极的电子数量，从而控制电流；MOSFET使用栅极电压控制场效应的强度，进而控制反转层的载流子浓度，从而控制s-d电流。</p>
<p>真空三极管的阴极和阳极具有单向导电性；MOSFET的d极和b极（衬底）之间存在一个寄生二极管，某种程度上也存在单向导电性</p>
<p>从上面可以看到MOSFET的性质和真空管的性质十分接近，这也是它沿用了栅极名称的原因之一。</p>
<p>MOSFET的原理就是利用g极的电场效应在绝缘层下方开启一个导电沟道，从而让s-d极能够导电。<strong>增强型MOSFET</strong>就是指随着g极电场增强，进入沟道的载流子增多，导电性增加；<strong>耗尽型MOSFET</strong>则是利用一个<em>表面掺杂层</em>中的载流子构成导电沟道，随着g极电场增强，外电场会抵消掉来自表面掺杂层的载流子，导电性减弱。在g极和衬底之间施加电压时，电场会先导致半导体层中出现电荷分离的情况，根据<strong>衬底中半导体掺杂</strong>的不同，可将MOSFET分为PMOS和NMOS。<strong>NMOS</strong>结构就是上述过程所形容的；而<strong>NMOS</strong>在被施以外部电场时，电子作为少子会被聚集在氧化物底层，但是因为密度太小并不能形成反转层，因此NMOS必须施加<em>b正g负</em>的反向电场，这样多子空穴会聚集并形成反转层。上面的四个MOSFET结构可以组合起来，成为四种基本的MOSFET</p>
<ul>
<li>增强型NMOS</li>
<li>耗尽型NMOS</li>
<li>增强型PMOS</li>
<li>耗尽型PMOS</li>
</ul>
<p>它们的电路符号如下所示：</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901020726001.png" alt="image-20210901020726001"></p>
<p>用一条竖线表示导电沟道，另一条短竖线表示g极的半导体</p>
<p>需要注意的是g极呈现“L”型，它的输入引脚更靠近s极，用来显著地指示方向——如果使用简化的图标，也要用箭头标明s极</p>
<p><strong>b极（s极）上会注明一个箭头，它永远指向从P到N的方向</strong>，因此它用来指示PMOS/NMOS（<strong>PMOS向外指；NMOS向内指</strong>，具体原因留给读者自行考虑）</p>
<blockquote>
<p>思考题答案：因为箭头永远指向N，只要沟道是N，那箭头就会指向沟道，也就是向内指了；P沟道则相反</p>
</blockquote>
<p>一般来说MOSFET会通过一个竖线将衬底和s极连在一起，如下图所示</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901021103401.png" alt="image-20210901021103401"></p>
<p>这就表示衬底和源极连在一起引出。</p>
<p>有的时候MOSFET会在d极和s极之间跨接一个二极管标识，这常用于开关电路或者高频电路中的MOSFET表示</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901021550063.png" alt="image-20210901021550063"></p>
<p>实际上这个二极管指的是MOSFET的<strong>寄生二极管</strong>，正是因为这个二极管，导致大功率下MOSFET具有一定的单向导电性和复杂电气特性</p>
<blockquote>
<p>大功率MOS管d极从硅片衬底底部引出，而s极被放在衬底底部的另一半，d极和s极都由不同种类的半导体材料制成，如下图所示</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901022016180.png" alt="image-20210901022016180"></p>
<p>这就导致了N-P-N之间出现了PN结，上图中左侧的PN结由于b-s短接而无效，右侧的b-&gt;d的PN结则相当于一个从b极接到d极的二极管，对于NMOS来说也是如此，<strong>总会存在一个与箭头方向（箭头指示P-&gt;N）相同的寄生二极管</strong></p>
</blockquote>
<p>寄生二极管并不是大功率MOSFET独有的，只要是NPN或PNP型的MOSFET都会存在PN结，只要有PN结就会或多或少存在寄生二极管。上图中s、d区是由不同于衬底的掺杂半导体制成的，这个工艺的原理在下面讲述</p>
<h3 id="增强型MOSFET"><a href="#增强型MOSFET" class="headerlink" title="增强型MOSFET"></a>增强型MOSFET</h3><p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901231358388.png" alt="image-20210901231358388"></p>
<p>上图是增强型N沟道MOS的结构，将N和P型半导体调换，即可得到增强型P沟道MOS的结构</p>
<p>一般使用W表示栅极宽度，使用L表示栅极长度，因为绝缘层非常薄，所以栅极长度和沟道长度近似相等，它也称为沟道宽度。<strong>栅极、源极、漏极之间的重叠区域要求保证反转层可以在源极和漏极之间形成连续的导电通道，为了减少寄生电容，这个重叠区域要尽量小</strong>。现代的NMOS与传统MOSFET的最大不同就是通过引入两个P型半导体电极降低了沟道开启所需电压。</p>
<p>需要注意：一般N型半导体上方引出电极使用金属铝</p>
<p>PMOS和NMOS结构大同小异，二者最大的不同在于形成的导电沟道方向和寄生二极管方向——由于MOSFET内部N-P型半导体交界耗尽区而形成的沟道外延被称为<strong>诱生沟道</strong></p>
<p>增强型MOSFET的工作模式有以下几种：</p>
<ol>
<li><p><strong>截止模式</strong></p>
<p> V<del>GS</del>&lt;V<del>th</del>（阈值电压）。此时不会形成s-d之间的导电通路，也就是<strong>导电沟道无法开启</strong>。但是由于电子能量的玻尔兹曼分布，s极的一些高能量电子可以进入沟道并扩散到d极。同样的，理想情况下d-s电流应为0，但是存在<strong>弱反转电流</strong>，它与V<del>GS</del>-V<del>th</del>成正指数关系，与斜率因子n=1+耗尽层电容/氧化物层电容成负指数关系。在集成电路中，还需要考虑短沟道的<strong>漏极势垒降低</strong>（Drain Induced Barrier Lowering，<strong>DIBL</strong>）效应，这个效应的强弱和器件的几何形状、PN结掺杂等有关，这个效应既有利也有弊：微功耗模拟电路利用低于阈值条件的优势，使得MOSFET可以尽可能提供较高的跨导-电流比值，甚至能和BJT一较高下。但是一般情况下，低于阈值的伏安特性会导致产品一致性难以保证</p>
</li>
<li><p><strong>欧姆模式</strong>（线性模式、线性区）</p>
<p> 当$V_{GS}&gt;V_{th}$且$V_{DS}&lt;(V_{GS}-V_{th})$时，MOS闭合，<strong>导电沟道开启，但是没有完全开启</strong>。<em><strong>此时MOSFET就像一个电阻</strong></em>：s-d电流可以使用以下公式表述<br> $$<br> I_D=\mu_n C_{ox} \frac{W}{L} [(V_{GS}-V_{th})V_{DS} - \frac{V^2_{DS}}{2}]<br> $$<br> μ<del>n</del>表示电荷载流子有效迁移率，其他参数就是字面意思（请读者翻看上文并理解各个符号的含义）</p>
<p> 可以看出s-d电流和ds电压具有相关性，进一步推到可以发现这个曲线相当接近直线，也就是说在欧姆模式，MOSFET可以起到类似电阻的作用，从而实现电流-电压控制</p>
</li>
<li><p><strong>饱和模式</strong></p>
<p> 当$V_{GS}&gt;V_{th}$且$V_DS&gt;(V_{GS}-V_{th})$，生成一条沟道以允许在d极和s极之间流过电流，也就是<strong>导电沟道完全开启</strong>。由于d极电压大于g极电压，电子会顺势扩散，<em>在该工作模式下，MOSFET的d-s极近乎短路</em></p>
</li>
</ol>
<p>增强型MOSFET还有几个性质：</p>
<ol>
<li><p>转移特性    </p>
<p> s-d电压恒定时，测量g-s两端电压和d极电流之间的关系</p>
<p> 实际上就是二端口网络的转移特性矩阵实例</p>
<p> <img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901235023213.png" alt="image-20210901235023213"></p>
</li>
<li><p>输出特性</p>
<p> g-s电压恒定时，s-d电压和d极电流之间的关系（输出特性矩阵实例）</p>
<p> <img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901235011715.png" alt="image-20210901235011715"></p>
</li>
<li><p>温度特性</p>
<p> 随温度升高，流经d极的电流会逐渐下降</p>
</li>
</ol>
<h3 id="耗尽型MOSFET"><a href="#耗尽型MOSFET" class="headerlink" title="耗尽型MOSFET"></a>耗尽型MOSFET</h3><p>耗尽型MOSFET与增强型MOSFET原理上最大的不同就是它使用了实实在在的“沟道”</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901235247565.png" alt="image-20210901235247565"></p>
<p>如上图，耗尽型PMOS的两个P型半导体之间额外沉积了一层薄薄的P半导体沟道，因此PN结的耗尽层在沟道下方出现，当V<del>GS</del>&lt;0时，沟道中的空穴会被排斥出沟道进入耗尽层，并与其中的电子中和，这样使得P型半导体沟道中的载流子浓度大减，沟道会变窄——如果更进一步，沟道附近的衬底会称为缺P型，导电能力增强，但<strong>沟道的导电能力会变得近乎没有</strong>。这就实现了“耗尽”的目的。沟道失去导电性的瞬间称为“<strong>沟道夹断</strong>”</p>
<p>从应用上看，耗尽型MOSFET相当于对增强型MOSFET进行了“非运算”，高V<del>GS</del>会开启增强型MOS，但是会夹断耗尽型MOSFET</p>
<blockquote>
<p>利用增强型-耗尽型MOSFET的互补性可以实现MOSFET图腾柱电路：两个MOSFET的d-s极首尾相连，最上面的MOSFET的s极引出到电源，下面的MOSFET则引到地，这样使用一个“不高不低”的电压就能够实现放大作用；使用高/低电平则会让二者之一导通，实现最大的开关性能。该电路也可以使用NPN-PNP三极管对管或者NMOS-PMOS对管实现</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210902000134796.png" alt="image-20210902000134796"></p>
<p>这个电路常常被用来作为电机、功率设备的驱动电路，三个相同的电路接到三相电上还可以实现H桥架构，进而驱动三相电机</p>
</blockquote>
<h3 id="小号继电器"><a href="#小号继电器" class="headerlink" title="小号继电器"></a>小号继电器</h3><p>MOSFET因为较低的启动电压和高输入阻抗，常常被用来<strong>作为继电器在非隔离情形下的替代品</strong></p>
<p>但是由于MOSFET的导通电压一般比数字IC能提供的更高，所以在使用之前也应该在IO处接入一个光耦-三极管放大电路或者直接接入一个三极管推完结构进行电流、电压放大，从而让弱输出能够驱动MOSFET</p>
<p>使用方法还挺像继电器的，但是二者的性能、功耗可不一样——MOSFET的开关频率比继电器高出两个数量级，功耗也比继电器低多了，同时还不会造成太大的电路噪声干扰，如果遇到需要隔离但是功率不大的情况，应该优先选择MOSFET而不是继电器</p>
<h3 id="功率半导体器件"><a href="#功率半导体器件" class="headerlink" title="功率半导体器件"></a>功率半导体器件</h3><p>简单说一下达林顿管和IGBT吧</p>
<p><strong>达林顿管=叠在一起的三极管</strong></p>
<p><strong>IGBT=叠在一起的三极管和MOSFET</strong></p>
<p>实际上的达林顿管是使用集成电路工艺制造的，将多个三极管制造在同一片晶圆上。但是还会针对PN结的性能进行优化。比较特殊的就是<strong>达林顿管的极性和前面三极管的极性保持一致</strong>，而不管后续接入的三极管是什么极性。因此前面的小管被称为达林顿<strong>基管</strong>；后面的小管被称为达林顿<strong>放大管</strong>。达林顿管以最前面小管的基极为整管基极，以最后接入的三极管发射极为整管发射极，<strong>最后的放大倍数是所有叠加的三极管放大倍数的乘积</strong><br>$$<br>\beta = \beta_1 \beta_2<br>$$<br>因此，达林顿管的功率、发热都会非常大，常用于驱动小型继电器、舵机、直流电机等等</p>
<p>IGBT则是典型的模拟集成电路结晶。博采众长，结合了三极管的低导通压降和MOS管的高输入阻抗，在不超过限制电压电流的情况下可以直接作为继电器使用——不过还是要注意，它的输出和输入之间还是存在耦合电阻的！</p>
<p>IGBT的结构就是一个三极管和一个MOSFET竖向叠起来，从MOSFET最上层两个隔开的栅极上引出IGBT的E极，MOSFET的P区同时作为三极管的B极P区，但是在三极管基础上多增加了一层B极N区和N缓冲区，主要用于存储电子，最下面一层是P+层，从它上面引出IGBT的C极</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210930000527652.png" alt="image-20210930000527652"></p>
<p>如上图所示（N沟道增强型IGBT），MOSFET部分的N+区称为<strong>源区</strong>，附于其上的电极称为源极，被引出作为IGBT的发射极E；N基极又称<strong>漏区</strong>D。为了区分IGBT和MOSFET，将同位置引出的G极翻译成<strong>门极</strong>，与MOSFET不同，IGBT的门极是悬浮在绝缘介质中的，并直接引出。沟道会在紧靠门极的边界形成。C、E两极之间的P型区（包括P+和P-区）被称为亚沟道区，事实上的沟道在这个区域形成。在漏区另一侧的P+区称为<strong>漏注入区</strong>，它是IGBT特有的功能区，与漏区和亚沟道区一起形成PNP双极型晶体管，起到其中发射极E的作用，向漏极注入空穴，进行导电调制，以降低器件的导通电压。最后，附于漏注入区上的电极称为漏极（也就是对应三极管的集电极C）。</p>
<p>IGBT的开关作用是通过<strong>加正向栅极电压形成沟道</strong>，<strong>给PNP</strong>（原来为NPN，但经过与IGBT耦合后，极性反转）<strong>晶体管提供基极电流，使IGBT导通</strong>。反之，可以加反向门极电压消除沟道，切断基极电流，使IGBT关断。IGBT的驱动方法和MOSFET基本相同，只需控制输入极N-沟道MOSFET即可，毕竟它控制的电流的第一步就是驱动一个栅极,所以IGBT具有高输入阻抗特性。当MOSFET的沟道形成后，从P+基极注入到N-层的空穴（少子）对N-层进行电导调制，减小N-层的电阻，使IGBT在高电压时也具有相对较低的导通电压</p>
]]></content>
      <tags>
        <tag>电路设计</tag>
      </tags>
  </entry>
</search>
