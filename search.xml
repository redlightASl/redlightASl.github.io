<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>我的新博客</title>
    <url>/2021/11/13/%E6%88%91%E7%9A%84%E6%96%B0%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="搬家了！"><a href="#搬家了！" class="headerlink" title="搬家了！"></a>搬家了！</h1><p>准备逐步把博客写作从CSDN换到基于Github Pages和Hexo的自建站上（笑）</p>
<p>CSDN😅</p>
<p>顺便以后推广公众号恰烂钱（？）</p>
<p>总之，不定期更新</p>
<p>保障一个月两次的保底更新（大概）</p>
<p><strong>Hexo还没用熟</strong></p>
<p>支持Markdown和$\LaTeX$公式，至少比b乎那个好多了</p>
<p>以后应该会再多整点活</p>
]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔</title>
    <url>/2021/11/13/%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<h1 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h1><p>所有的随笔都会放在这里OvO</p>
<p>可能还会扔些沙雕图……</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>电路设计从入门到弃坑0【电路概论】</title>
    <url>/2021/11/13/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E7%94%B5%E8%B7%AF%E6%A6%82%E8%AE%BA%E3%80%91/</url>
    <content><![CDATA[<h1 id="电路设计从入门到弃坑0【电路概论】"><a href="#电路设计从入门到弃坑0【电路概论】" class="headerlink" title="电路设计从入门到弃坑0【电路概论】"></a>电路设计从入门到弃坑0【电路概论】</h1><p>在本系列博客中，将遵循以下缩写/简写</p>
<ul>
<li>电路原理：电子线路、电子线路分析基础等基础电路课</li>
<li>模电：模拟电子电路、模拟电路、模拟电子技术、模拟电子线路等模拟电路课</li>
<li>数电：数字电子电路、数字电路、数字电子技术、数字电子线路等数字电路课</li>
<li>通信原理：通信原理、通信电子线路、通信电子电路、高频电子电路、高频电子线路等高频电路及通信理论课</li>
<li>强电：功率电子电路、功率电子线路、电力电子电路、电力电路等电力电子系统及理论课</li>
</ul>
<p>电路原理阐述了电路运行的基本规律：使用抽象电路模型、电磁学、图论、高等数学、线性代数、拉普拉斯变换等基础学科知识描述电路，提供一般的电路分析方法</p>
<p>模电则是从半导体器件的性质介绍如何使用这些器件构建能够对电信号或功率电压电流进行处理的电路</p>
<p>数电针对逻辑电路进行分析，结合布尔代数引入了晶体管在导通、截至两状态下的应用，并提炼出使用硬件描述语言对数字电路进行设计、分析、仿真的基本方法</p>
<p>通信原理则从分布参数电路与谐振、傅里叶分析角度解释模拟电路工作在高频情况下的状态与应用，并根据电磁场与电磁波理论介绍如何对通信信号进行调制-解调，以实现远距离电通信</p>
<p>强电则结合电机学、电工学相关知识，阐明功率半导体器件的工作原理和应用，主要关注功率、效率、质量三个要素</p>
<span id="more"></span>

<h3 id="专有名词解释"><a href="#专有名词解释" class="headerlink" title="专有名词解释"></a>专有名词解释</h3><p>本教程中使用的专有名词是更贴近直观的解释，和专业参考书籍存在一定差异，请以专业参考书为准</p>
<ul>
<li>电路拓扑：就是电路图的“形式”——把具体元件抽离出电路图，把实际电路图变换成理想电路模型，抽象出节点、支路后剩下的一个图就称为电路拓扑。可以形象理解成电路的套路或者说格式</li>
<li>系统：电路实现其功能过程的抽象。可以形象理解成电路功能框图</li>
<li>信息：就是信息论里面的信息</li>
<li>信号：从系统角度看，每个支路量都承载了信息，因此支路量可以称为信号</li>
<li>激励-响应：从系统的角度看电路时，系统中某个功能框的输入称为激励，系统某个功能框的输出称为响应</li>
<li>反馈：把某个响应引入到激励部分或功能框内部的过程称为反馈，对应的信号称为反馈信号</li>
</ul>
<h2 id="模电"><a href="#模电" class="headerlink" title="模电"></a>模电</h2><p>模电的知识结构是自下而上的</p>
<h3 id="半导体物理与半导体器件"><a href="#半导体物理与半导体器件" class="headerlink" title="半导体物理与半导体器件"></a>半导体物理与半导体器件</h3><p>讲述掺杂与导电性、PN结、双结型晶体管、场效应管等的基本物理原理和制造工艺对器件性能的影响</p>
<p>这一部分内容更偏重理论，和电路原理一样属于帮助理解模电、数电等工程应用的理论基础</p>
<h3 id="常见的半导体器件"><a href="#常见的半导体器件" class="headerlink" title="常见的半导体器件"></a>常见的半导体器件</h3><p>二极管、三极管、场效应管等基本的半导体器件，连同它们的变种器件，共同组成了模拟电子电路，经由开关频率特殊优化的开关管器件则构成了数字电路的基础——逻辑门和触发器</p>
<h4 id="二极管"><a href="#二极管" class="headerlink" title="二极管"></a>二极管</h4><p>由一个PN结封装成器件，就得到了具有单向导电性的二极管</p>
<p>生产中用到的不仅有二极管的单向导电性，还有击穿电压、漏电流等等一系列特性</p>
<h4 id="三极管和场效应管"><a href="#三极管和场效应管" class="headerlink" title="三极管和场效应管"></a>三极管和场效应管</h4><p>两个PN结封装成一个器件，就得到了三极管；而利用金属-氧化物绝缘层-半导体形式封装产生的电场效应，可以生产出场效应管。</p>
<p>三极管一般是电流控制电流型器件；而场效应管一般是电压控制电压型器件，二者可以互补——于是出现了结合二者，能够实现高功率输出的晶闸管（可控硅）和IGBT（绝缘栅双极型晶体管），以及复合单一器件的达林顿管</p>
<p>早期设备中使用真空管（电子管），正是因为半导体技术的发展才让三极管取代了真空管，但是二者的功能是一致的：<strong>对电信号加以控制</strong></p>
<h3 id="晶体管信号放大电路"><a href="#晶体管信号放大电路" class="headerlink" title="晶体管信号放大电路"></a>晶体管信号放大电路</h3><p>这里的晶体管是BJT（双结型晶体管，也就是三极管）和FET（场效应管）的统称</p>
<p>晶体管通过某些组合，可以最大限度发挥其控制信号的作用，而这种电路一般用于放大某些小信号，所以被称为晶体管信号放大电路。</p>
<p>放大电路并不是指输入1V，凭空就能输出3V，而是指<em>输入信号1V，通过外加2V的供电，能输出为2V的信号</em></p>
<p>信号放大电路往往看重信号的保真程度和信号的放大倍数，然而晶体管往往很容易受到门限电压、温度升高、电源变化等影响造成信号失真，为了避免这些问题，人们就对普通放大电路进行改进；同时为了获取更高的放大倍数，常常采用前级-输入级-驱动级-输出级这样的多级放大模式，从而提高信号放大倍数</p>
<p>主要参考的性能参数就是电压增益和电流增益：$A_v=\frac{v_o}{v_i}$ $A_i=\frac{i_o}{i_i}$</p>
<h3 id="晶体管功率放大电路"><a href="#晶体管功率放大电路" class="headerlink" title="晶体管功率放大电路"></a>晶体管功率放大电路</h3><p>对于一些特殊的应用（比如音响），信号放大电路无法驱动后级输出设备（扬声器）</p>
<p>于是出现了晶体管功率放大电路</p>
<p>这类电路一般使用特殊设计的能经受大电流、高电压的晶体管作为放大器件，于是可以在电源部分加大功率</p>
<p>通常需要注意功率放大电路的效率：$\eta=\frac{P_L}{P_S}$</p>
<h3 id="晶体管振荡电路"><a href="#晶体管振荡电路" class="headerlink" title="晶体管振荡电路"></a>晶体管振荡电路</h3><p>为了控制或产生周期性的激励，人们还设计出了能够产生振荡信号的晶体管电路</p>
<p>这种电路建立在放大电路和闭环控制理论的基础上，利用反馈进行工作</p>
<p>一般分立式元件难以产生高精度的信号输出，现在一般使用单片机（微控制器）或专用的集成电路生成振荡信号</p>
<h3 id="集成运算放大器"><a href="#集成运算放大器" class="headerlink" title="集成运算放大器"></a>集成运算放大器</h3><p>随着集成电路技术的发展，可以将多个二极管和晶体管集成在单个芯片中，内部大多为模拟电路的芯片被称为模拟集成电路，内部结构中多数字电路的芯片则是数字集成电路。其中通过将晶体管信号放大电路集成在一个芯片上，可以实现良好的放大性能，这种模拟集成电路就是集成运算放大器</p>
<p>集成运算放大器具有虚短、虚短、高输入阻抗、低输出阻抗等特征，利用这些特征可以组合出模拟运算电路和其他特殊的放大电路</p>
<p>集成运放工作在晶体管的基础上</p>
<h3 id="集成功率放大器"><a href="#集成功率放大器" class="headerlink" title="集成功率放大器"></a>集成功率放大器</h3><p>集成功率放大器即集成功放，是分立式晶体管功率放大器在功率半导体器件发展的基础上形成的一套新型集成电路</p>
<p>现代模拟电路具有集成化、小型化的趋势，集成功率电路正是舍弃了一部分高功率特性换来了更高的转换效率和更小的体积</p>
<h3 id="电源管理芯片和功率电源电路"><a href="#电源管理芯片和功率电源电路" class="headerlink" title="电源管理芯片和功率电源电路"></a>电源管理芯片和功率电源电路</h3><p>模拟电路的另一作用就是基于变压器、二极管、晶体管、基本电抗元件等构建稳压或恒流电源</p>
<p>在此基础上伴随半导体技术的发展，氮化镓、氮化砷等新型功率半导体器件为实现小型化、大功率、高效率的电源电路提供了可能</p>
<h2 id="数电"><a href="#数电" class="headerlink" title="数电"></a>数电</h2><p>数电的知识结构是从抽象到具体的</p>
<h3 id="布尔代数"><a href="#布尔代数" class="headerlink" title="布尔代数"></a>布尔代数</h3><p>布尔代数就是逻辑代数，使用布尔代数可以化简很多代数运算，并让电路得以实现</p>
<p>数电的基础是数学，数电的所有器件都是为了解决数学计算问题而设计</p>
<p>所以布尔代数是数字电路的基础</p>
<h3 id="开关管与逻辑门"><a href="#开关管与逻辑门" class="headerlink" title="开关管与逻辑门"></a>开关管与逻辑门</h3><p>电路可以使用高电平或低电平表示布尔代数中的0和1，进而实现数学计算</p>
<p>为了对数字信号进行处理，前人设计出了三种基本的逻辑门——与门、或门、非门</p>
<p>使用MOSFET（金属氧化物半导体场效应管）可以实现这三种逻辑门，进而实现更多复杂功能</p>
<p>在现代集成电路技术中，多采用CMOS工艺，将两个MOSFET制造在一起，并通过两个成对的MOSFET实现基础的逻辑门</p>
<p>只使用逻辑门构成的数字电路称为<strong>组合逻辑电路</strong></p>
<p>组合逻辑电路只能“瞬时”（由于寄生电容的存在，实际的组合逻辑电路存在延迟）地反映当前输入对应的输出，换句话说，它可以描述函数关系，但不能描述状态关系</p>
<h3 id="触发器与锁存器"><a href="#触发器与锁存器" class="headerlink" title="触发器与锁存器"></a>触发器与锁存器</h3><p>使用CMOS器件还可以制造具有“记忆”功能的器件——锁存器</p>
<p>锁存器可以暂时地保存输入的电平，通过再次加入一对MOSFET便可以让锁存器“滴答”（Tik-Tok）起来，这就是所谓的触发器</p>
<p>触发器是一种在外部信号输入后输出之前保存过电平的器件</p>
<p>使用触发器就可以实现随状态变化的数字电路，我们一般将其称为<strong>状态机</strong></p>
<h2 id="数电模电混合电路"><a href="#数电模电混合电路" class="headerlink" title="数电模电混合电路"></a>数电模电混合电路</h2><p>在生活中的任何一个角落，都有数模混合电路的存在——模拟电路负责供能、处理信号；数字电路负责对电信号进行计算、控制。</p>
<p>本系列博客将结合个人所学，以模电-数电-数模混合电路的逻辑讲述电路设计中的一些基础知识与技巧，同步进行开关电源、MCU板级外设电路等成体系电路的设计方法说明</p>
<p><strong>长期维护更新</strong></p>
<p>作者水平有限，如有错误疏漏，敬请谅解。</p>
]]></content>
      <tags>
        <tag>电路设计</tag>
      </tags>
  </entry>
  <entry>
    <title>MSP430简介</title>
    <url>/2021/11/13/msp430%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="MSP430"><a href="#MSP430" class="headerlink" title="MSP430"></a>MSP430</h1><p>该MCU是由德州仪器TI生产的16位低功耗单片机</p>
<span id="more"></span>

<p>主要分以下型号：</p>
<ul>
<li>专注低功耗的<strong>1xx</strong>通用型，配备1KB-60KB FLASH、512B-10KB RAM，工作时耗电仅达200uA/MIPS，RAM保持模式耗电0.1uA，RTC模式耗电0.7uA；可在6us之内快速唤醒。搭载10/12位斜率SAR ADC，集成模拟比较器、DMA、硬件乘法器、BOR、SVS、12位DAC</li>
<li>能耗比高的<strong>F2xx</strong>通用型，性能<a href="mailto:&#x31;&#54;&#x4d;&#73;&#x50;&#83;&#64;&#x33;&#x2e;&#51;&#86;">&#x31;&#54;&#x4d;&#73;&#x50;&#83;&#64;&#x33;&#x2e;&#51;&#86;</a>，配备1-120KB FLASH，8-128KB RAM，工作耗电220uA，配备10/12位斜率SAR ADC，集成16位Σ-ΔADC，基本上等于1xx的升级版</li>
<li><strong>性价比</strong>高的<strong>G2xx</strong>经济型，性能<a href="mailto:&#49;&#x36;&#x4d;&#73;&#80;&#83;&#64;&#51;&#46;&#51;&#86;">&#49;&#x36;&#x4d;&#73;&#80;&#83;&#64;&#51;&#46;&#51;&#86;</a>，对标友商stm32l，主打模拟外设和低功耗</li>
<li>面向计量和智能电网的AFE2xx专用型：性能略低于以上两个2xx系列，但是集成了1-3个独立的24位Σ-ΔADC，一个16位定时器、一个16位硬件乘法器、USART控制器、看门狗和GPIO</li>
<li>停产的老型号3xx</li>
<li>面向低功耗<strong>多媒体</strong>的<strong>4xx</strong>控制型，8-16MIPS处理性能，<strong>配备LCD控制器</strong>、<strong>FLL、SVS</strong>，针对低功耗测量和医疗应用，功耗和1xx相近，4-120KB FLASH、8-256KB RAM，引脚丰富最多可达80Pin，配备10/12位斜率SAR、16位Σ-ΔADC，同样集成了12位ADC、DMA、硬件乘法器、运放、USCI模块等</li>
<li><strong>超高能耗比的5xx超低功耗型</strong>，能达到<a href="mailto:&#50;&#x35;&#77;&#73;&#80;&#x53;&#x40;&#51;&#x2e;&#x33;&#86;">&#50;&#x35;&#77;&#73;&#80;&#x53;&#x40;&#51;&#x2e;&#x33;&#86;</a>，工作模式功耗165uA/MIPS，RTC模式2.5uA，RAM保持模式可达1uA，待机唤醒时间极短，小于5ms，配备256KB FLASH、18KB RAM，额外集成了USB、模拟比较器</li>
<li>高性能、低功耗的6xx系列旗舰型，达到<a href="mailto:&#50;&#x35;&#x4d;&#x49;&#80;&#x53;&#x40;&#x33;&#x2e;&#x33;&#86;">&#50;&#x35;&#x4d;&#x49;&#80;&#x53;&#x40;&#x33;&#x2e;&#x33;&#86;</a>，配备功耗优化的创新电源管理模块和USB控制器，配备LCD控制器，有256KB FLASH、18KB RAM，74Pin引脚，功耗与5xx系列相同，还额外集成了电压管理模块</li>
<li>基于<strong>FRAM</strong>技术的<strong>FRxx</strong>系列，和主要的F系列差别在于使用了FRAM存储技术，能够达到更快的FLASH访问速度并在所有功率模式下实现零功率状态保持，即使发生功率损耗的情况也可以保证写入操作，写入寿命能达到100M个周期，不再需要EEPROM</li>
<li>低电压C、L系列，两个谢列都可以在0.9-1.65V电压范围内工作并提供4MIPS的性能</li>
<li>集成射频基带的CC无线系列，具有低于1GHz的片上射频收发器，工作电压为1.8-3.3V，处理性能20MIPS</li>
<li>特殊系列：面对车规应用、电容触摸、超声波测量、DSP等等特殊用途的系列设备</li>
</ul>
<p>综合来看MSP430具有以下特点：</p>
<ol>
<li><p>超低功耗</p>
<p>使用1.8-3.6V低电压供电，RAM数据保持方式下耗电仅为0.1μA/MIPS，活动模式下耗电也仅仅为250μA/MIPS，IO输入端口漏电流仅为50mA，相比之下只有stm8和stm32l0系列能够达到同等级的低功耗水准。普通的8051则远远落后</p>
</li>
<li><p>能效比高，针对算法加速</p>
<p>MSP430基于RISC架构，采用了一般DSP才有的16位多功能硬件乘法器、硬件乘-加功能、DMA等架构，可以高效实现如FFT、DFT、FIR滤波等数字信号处理算法</p>
</li>
<li><p>模拟外设技术高</p>
<p>MSP430片内集成多种模拟外设，包括液晶驱动器和ADC、DAC等，具体外设由型号决定</p>
</li>
<li><p>外设寄存器直接按位寻址</p>
<p>外设寄存器可以直接进行赋值、按位操作</p>
</li>
</ol>
<p>msp430系列使用了冯诺依曼架构，并构建了MAB（存储器地址总线）、MDB（存储器数据总线）两个总线协议，其中RAM、FLASH共用同一个地址空间，程序被下载到FLASH，设备复位后自动读取并执行程序指令，局部变量存储在RAM，BSS段变量存储在FLASH，FLASH掉电不丢失</p>
<p>设备内部时钟至少具有3套时钟源：</p>
<ol>
<li>LFXT1CLK：低频时钟，32.768kHz</li>
<li>XT2CLK：高频时钟，8MHz</li>
<li>DCOCLK：片内数字控制RC振荡器，经常用作系统和外设时钟信号，其稳定性由FLL与硬件控制</li>
</ol>
<p>三套时钟源可以被设备单独选用，时钟通过片内总线提供给设备；有些型号还具有更多类型的时钟源</p>
<p>DMA可以直接接管总线以提高传输效率（不同于AMBA总线的仲裁，MAB、MDB总线只采用主控设备-从设备的方式）</p>
<p>CPU则采用了双总线位宽的灵活处理方式，分为<strong>16位寻址的CPU</strong>和<strong>20位寻址的CPUX</strong>。CPU采用RISC架构，配备27条指令和7种统一的寻址模式，寻址空间64KB；CPUX寻址空间为1MB，采用面向控制的结构和指令系统，集成了计算分支、表处理等特性，可以在不分页的情况下处理1MB的地址范围，属于RISC正交指令集（正交：指令集的绝大多数指令格式相同、长度相同，所有寄存器的寻址可以替换；而指令的操作码、寻址方式、操作数寄存器字段的取值相互独立），可以实现MTM（内存到内存）传输，不需要经过中间寄存器，一并对16位CPU实现了兼容</p>
<p>在电赛中最常用的就是==<strong>MSP430F5529</strong>==，下面均以F5529为例说明</p>
<h2 id="外围电路设计"><a href="#外围电路设计" class="headerlink" title="外围电路设计"></a>外围电路设计</h2><h3 id="供电"><a href="#供电" class="headerlink" title="供电"></a>供电</h3><p>MCU部分模拟外设和FLASH、RAM对于电源要求较高，但是MCU数字部分对于电源要求较低，因此采用双电源——模拟/数字的方式为MCU供电。模拟-数字电源之间采用磁珠跨接3.3V和地除杂波，同时需要使用10uF、100nF电容并联进行滤波，10uF用于滤除低频杂波，100nF则用于旁路</p>
<h3 id="复位"><a href="#复位" class="headerlink" title="复位"></a>复位</h3><p>RST引脚低电平有效，因此和一般单片机的复位电路一样即可</p>
<h3 id="晶振"><a href="#晶振" class="headerlink" title="晶振"></a>晶振</h3><p>需要使用两个晶振接入来保证电源稳定，<strong>XT1接低频32.768kHz</strong>，<strong>XT2接高频晶振，一般为4MHz</strong>，因为内部电容不足以起振，所以同时需要单独配备20-30pF的匹配电容，一般使用22pF电容</p>
<h3 id="USB"><a href="#USB" class="headerlink" title="USB"></a>USB</h3><p>f5529具有USB控制器，能够使用4芯电缆：5V、D+、D-、GND，并可以兼容USB OTG的ID线。</p>
<h2 id="编译烧录"><a href="#编译烧录" class="headerlink" title="编译烧录"></a>编译烧录</h2><p>MSP430支持JTAG和SBW（Spy-Bi-Wire，TI指定的两线调试接口，信号叫为SBWTCK和SBWTDIO）</p>
<p>同时也支持BSL（BootStrap Loader），或者说BootLoader加载程序烧录可以通过USB、UART等对单片机进行ISP烧录，在PUR引脚和USB D+之间跨接1.4k电阻，下连1M电阻到地，并通过一个加了限流电阻（一般为100Ω）的微动开关连接到VCC即可实现USB的BSL烧录</p>
<p>MSP430的开发环境是TI基于eclipse开发的Code Composer Studio，简称<strong>CCS</strong>，在其中使用专用的MSP430 Compile与Linker即可实现C程序编译链接</p>
<h3 id="关键字和内联函数"><a href="#关键字和内联函数" class="headerlink" title="关键字和内联函数"></a>关键字和内联函数</h3><p>同时CCS支持了一些扩展关键字，列举如下：</p>
<ul>
<li><p><code>__asm</code>用于C语言内嵌汇编，这个和keil一样</p>
</li>
<li><p><code>__interrupt</code>放在函数前指示中断函数，一般和#pragma指令共用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=UART0RX_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">UART_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>上例指示了一个串口0接收中断，#pragma指令让中断向量表中的地址位重定向了</p>
</li>
<li><p><code>__monitor</code>放在函数前，在执行到函数时自动关闭全局中断，类似__atom指令</p>
</li>
<li><p><code>__no_init</code>放在全局变量钱让程序启动时不被变量赋初值</p>
</li>
<li><p><code>__raw</code>关闭中断服务函数的恢复现场能力，这会导致中断服务函数无法返回</p>
</li>
<li><p><code>__regvar</code>声明变量为寄存器变量，注意不能使用指针指向寄存器变量，并且必须搭配使用__no_init禁止初始化</p>
</li>
<li><p><code>sfrb</code>用于声明单字节IO数据类型对象，和51一样用于定义寄存器地址</p>
</li>
</ul>
<p>除了关键字外，CCS还包含了许多内联函数，常见的几个摘录如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__no_operation();<span class="comment">//空指令，相当于NOP</span></span><br><span class="line">__enable_interrupt();<span class="comment">//打开全局中断</span></span><br><span class="line">__disable_interrupt();<span class="comment">//关闭全局中断</span></span><br><span class="line">__delay_cycles(<span class="keyword">unsigned</span> <span class="keyword">long</span> __cycles);<span class="comment">//延时__cycles个主时钟（MCLK）周期</span></span><br><span class="line">__set_SP_register(<span class="keyword">unsigned</span> <span class="keyword">short</span>);<span class="comment">//为堆栈指针寄存器SP赋值</span></span><br></pre></td></tr></table></figure>

<h3 id="预定义寄存器"><a href="#预定义寄存器" class="headerlink" title="预定义寄存器"></a>预定义寄存器</h3><p>CCS中还预置了一些单片机常用的寄存器和配置，如下所示</p>
<ol>
<li><p>端口定义，其中x表示端口号</p>
<p>PxIN：端口输入寄存器</p>
<p>PxOUT：端口输出寄存器</p>
<p>PxDIR：端口方向控制寄存器</p>
<p>PxSEL：端口复用寄存器</p>
<p>注意：<strong>MSP430不支持位操作，一般通过屏蔽位的方法实现位操作，这是它和51开发方面最大的不同</strong>，如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT0 00000001b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT1 00000010b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT2 00000100b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT3 00001000b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT4 00010000b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT5 00100000b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT6 01000000b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT7 10000000b</span></span><br><span class="line"></span><br><span class="line">P1OUT |= BIT0;</span><br><span class="line"><span class="comment">//这样可以实现P1.0输出</span></span><br><span class="line"></span><br><span class="line">P1OUT |= BIT4;</span><br><span class="line"><span class="comment">//这样可以实现P1.0和P1.3同时输出</span></span><br><span class="line"></span><br><span class="line">P1OUT &amp;= ~BIT1;</span><br><span class="line"><span class="comment">//这样可以取消P1.0的输出</span></span><br></pre></td></tr></table></figure></li>
<li><p>低功耗模式的进入和退出</p>
<p>CCS预定义了一些宏指令用来实现低功耗模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LPM3;<span class="comment">//进入低功耗模式</span></span><br><span class="line">LPM3_EXIT;<span class="comment">//退出低功耗模式</span></span><br></pre></td></tr></table></figure>

<p>其中数字可以写0-4，分别对应四种低功耗模式</p>
</li>
<li><p>外设寄存器</p>
<p>各种片上外设的寄存器都被定义为了宏，可以通过<code>|=</code>与<code>&amp;=~</code>的方式进行按位控制</p>
</li>
<li><p>部分常用代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_dint(); <span class="comment">//等效于__disable_interrupt</span></span><br><span class="line">_EINT(); <span class="comment">//等效于__enable_interrupt</span></span><br><span class="line">_NOP(); <span class="comment">//空指令</span></span><br><span class="line">_OPC(x); <span class="comment">//在指令流中插入一个常熟，对与参数对应的任何指令进行编码</span></span><br><span class="line">_SWAP_BYTES(x); <span class="comment">//将无符号16位整数的高8位和低8位交换</span></span><br><span class="line">monitor <span class="comment">//关键字__monitor的宏定义</span></span><br><span class="line">no_init <span class="comment">//关键字__no_init的宏定义</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>综上所述，MSP430的开发和8051的开发非常类似，并没有stm32的库封装，而是直接操作寄存器。这不仅仅是由于MSP430的性能较低，也是由于这样的编程方式写出的代码更加简洁、指令量更少，能突出体现MSP430低功耗的优势</p>
<h2 id="片上外设开发"><a href="#片上外设开发" class="headerlink" title="片上外设开发"></a>片上外设开发</h2><p>MSP430的片上外设寄存器具体配置和51单片机的很像，但是有一些功能更加复杂，和stm32的寄存器接近，同时也提供了简化操作的库函数</p>
<h3 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h3><p>f5529一共有80个引脚，和stm32的<strong>gpio</strong>结构类似，并且也具有<strong>复用功能</strong>。除此之外某些引脚具备基本的<strong>电源功能</strong>，分别能够为MCU的片上数字电路和模拟电路供电，一般情况下可以共用一个电源，但在某些高精度测量场合需要双电源隔离供电。msp430还具有一个USB电源，可以直接输出5V供电，经过片上LDO后能在端口VBUS处输出稳定的3.3V电压供单片机和外设使用，最大驱动电流60mA</p>
<p>其中P1、P2端口IO都具有外部中断能力，分别对应P1IV中断向量和P2IV中断向量。端口可单独配置强驱动和弱驱动模式，<strong>强驱动模式下全片最大输出电流100mA，单端口最大电流15mA；弱驱动模式下全片最大输出电流48mA，单端口最大电流6mA</strong></p>
<p>寄存器操作可以通过上面介绍过的屏蔽位法，也可以通过分别操作寄存器高8位和低8位的方法实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用三种方法将P1.1和P2.2配置为输出功能</span></span><br><span class="line">P1DIR |= <span class="number">0x02</span>; <span class="comment">//0x02 == 00000010b</span></span><br><span class="line">P2DIR |= <span class="number">0x04</span>; <span class="comment">//0x04 == 00000100b</span></span><br><span class="line"></span><br><span class="line">PADIR_L |= <span class="number">0x02</span>; <span class="comment">//DIR寄存器低8位，代表P1</span></span><br><span class="line">PADIR_H |= <span class="number">0x04</span>; <span class="comment">//DIR寄存器高8位，代表P2</span></span><br><span class="line"></span><br><span class="line">PADIR |= <span class="number">0x0402</span>; <span class="comment">//直接操作DIR寄存器，将其视作uint16_t</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>端口配置</p>
<p>如下配置端口为输入状态并配置内部上拉</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P1DIR &amp;= ~BIT1; <span class="comment">//BIT1 == 0x00000010b，设置P1.1为输入模式</span></span><br><span class="line">P1REN |= BIT1; <span class="comment">//使能上下拉电阻</span></span><br><span class="line">P1OUT |= BIT1; <span class="comment">//P1.1配置上拉电阻</span></span><br></pre></td></tr></table></figure>

<p>通过配置PxDIR.n |= 1可以将相应的IO口配置为输出状态，在输出状态下，PxREN、PxIN无效。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P1OUT |= BIT1; <span class="comment">//P1.1输出高电平</span></span><br><span class="line">P1OUT &amp;= ~BIT1; <span class="comment">//P1.1输出低电平</span></span><br><span class="line"></span><br><span class="line">P1DS<span class="number">.1</span> &amp;= ~BIT1; <span class="comment">//配置P1.1为弱驱动输出</span></span><br><span class="line">P1DS<span class="number">.1</span> |= BIT1; <span class="comment">//配置P1.1为强驱动输出</span></span><br></pre></td></tr></table></figure></li>
<li><p>端口复用配置</p>
<p>基本每个IO都有端口复用功能，通过配置PxSEL.n把对应的IO口配置为复用功能</p>
<p>使用以下代码配置P1.0为定时器A0时钟输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P1DIR &amp;= ~BIT0; <span class="comment">//设置P1.0为输入状态</span></span><br><span class="line">P1SEL |= BIT0; <span class="comment">//将P1.0复用为定时器A0时钟输入</span></span><br></pre></td></tr></table></figure>

<p>相关配置需要按照datasheet中的端口复用表选择</p>
</li>
</ol>
<h3 id="时钟系统与低功耗"><a href="#时钟系统与低功耗" class="headerlink" title="时钟系统与低功耗"></a>时钟系统与低功耗</h3><p>msp430f5529具有<strong>5种时钟源</strong>（XT1CLK、XT2CLK、VLOCLK、REFOCLK、DCOCLK）和<strong>3种时钟信号</strong>（MCLK、SMCLK、ACLK）</p>
<p>时钟系统可以软件配置成不需要外部晶振、需要一个外部晶振、需要两个外部晶振、外部时钟输入等方式，最极端的情况下单片机内部具有自身振荡器可以为CPU及片上外设提供系统时钟</p>
<p>时钟系统的安全性比较重要，msp430配备了紧急保护系统，在外部时钟故障时会自动选择内部时钟源REFOCLK或VLOCLK作为时钟信号，并产生响应故障信号（可选中断）</p>
<p>系统时钟大致分为两级，<em>信号生成级</em>和<em>信号分配级</em>，中间通过MUX连接。信号生成级别分为三个模块基本的OSC模块可以通过晶振旁路、内部REFO或VLO直接输出XT1CLK、VLOCLK、REFOCLK三种信号；可选的XT2模块直接输出XT2晶振的4MHz时钟作为XT2CLK；可以通过晶振旁路和FLL（Frequency Locked Loop锁频环）进行晶振时钟倍频和分频，信号源（即FLLREFCLK反馈时钟）通过MUX直接引用XT1CLK、REFOCLK、XT2CLK之一，经过多个倍频分频器后输出为DCOCLK和DCOCLKDIV。所有信号分别输出到信号分配级，通过MUX分配给ACLK、MCLK、SMCLK</p>
<p><strong>XT1CLK</strong>：<strong>外部低频或高频时钟源</strong>，默认关闭，需要接入外部晶振并通过软件使晶振起振后再使用，一般使用32.768kHz的低频晶振，但是也可以使用4-32MHz的外部高频时钟源，<strong>端口P5.4、P5.5</strong></p>
<p>使用下面的代码对时钟源进行配置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P5SEL |= BIT4 | BIT5; <span class="comment">//配置P5.4、P5.5为XT1复用功能</span></span><br><span class="line">UCSCTL6 |= XCAP_3; <span class="comment">//配置匹配电容为12pF</span></span><br><span class="line">UCSCTL6 &amp;= ~XT1OFF; <span class="comment">//使能XT1，使外部晶振起振</span></span><br><span class="line"><span class="keyword">while</span>(SFRIFG1 &amp; OFIFG)</span><br><span class="line">&#123;</span><br><span class="line">    UCSCTL7 &amp;= ~(XT2OFFG + XT1LFOFFG + DCOFFG); <span class="comment">//清除三类时钟故障标志位，等待起振</span></span><br><span class="line">    SFRIFG1 &amp;= ~OFIFG; <span class="comment">//清除震荡器故障标志位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>XT2CLK</strong>：和XT1CLK类似，但只能接4-32MHz的<strong>高频晶振</strong>，一般接入4MHz晶振，需要额外加匹配电容方便起振。<strong>端口P5.2、P5.3</strong></p>
<p>需要注意的是在配置SMCLK和MCLK为XT2CLK时钟源之前需要先修改ACLK和REFCLK的时钟源，因为它们的时钟源默认为XT1CLK，但这里并没有启动，所以会导致没有必要的XT1CLK始终故障，会影响判断XT2是否起振，实现代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P5SEL |= BIT2 | BIT3; <span class="comment">//配置P5.2、P5.3为XT2复用功能</span></span><br><span class="line">UCSCTL6 &amp;= ~XT2OFF; <span class="comment">//使能XT2</span></span><br><span class="line">UCSCTL4 = UCSCTL4 &amp; (~(SELA_7)) | SELA_1; <span class="comment">//将ACLK配置为VLOCLK</span></span><br><span class="line">UCSCTL3 |= SELREF_2; <span class="comment">//将REFCLK配置为REFOCLK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(SFRIFG1 &amp; OFIFG)</span><br><span class="line">&#123;</span><br><span class="line">    UCSCTL7 &amp;= ~(XT2OFFG + XT1LFOFFG + DCOFFG); <span class="comment">//清除三类时钟故障标志位，等待起振</span></span><br><span class="line">    SFRIFG1 &amp;= ~OFIFG; <span class="comment">//清除震荡器故障标志位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>VLOCLK</strong>：<strong>内部低功耗、低频时钟源</strong>，<strong>频率10kHz</strong>，精度较低，会随电源电压和温度产生较大漂移，用于不需要精准时钟基准的系统控制，被使用时自动开启、不使用时自动关闭，低功耗唤醒模式下回优先使用该时钟源作为系统和看门狗时钟</p>
<p>配置UCSCTL4选择</p>
<p><strong>REFOCLK</strong>：<strong>内部修整低频参考时钟源，精度较高，32.768kHz</strong>，和VLOCLK一样不需要配置寄存器进行起振，若未使用外部晶振，系统会自动选择该时钟源作为ACLK和DCOCLK锁频环参考时钟源</p>
<p>通过UCSCTL4选择</p>
<p><strong>DCOCLK</strong>：内部数字控制时钟源，具有宽工作频率，<strong>最高可产生25MHz时钟频率</strong>，可以和FLL配合控制参考时钟，也可以引入其他时钟源反馈进行时钟分频/倍频，但是需要额外配置</p>
<p>这是f5xx中<strong>最常用的时钟源</strong>，类似于stm32的PLL时钟（它的内部也是类似的PLL）</p>
<p>其频率计算公式如下<br>$$<br>DCOCLK = D \times (N+1) \times \frac{REFCLK}{n} \<br>DCOCLKDIV = (N+1) \times \frac{REFCLK}{n}<br>$$<br>REFCLK来源见上文</p>
<p>n为输入时钟分频，通过UCSCTL3中的FLLCLKDIV设定，查找该寄存器介绍可知其取值0-7，对应n取值2^p^，默认为0，不分频</p>
<p>D通过UCSCTL2中的FLLD设对，可取值0-7，对应D取值2^p^，默认为1，即D=2，二分频</p>
<p>N可以通过UCSCTL2中的FLLN设定，取值0-1023，当FLLN=0时，N=1，除此之外N=FLLN，默认为31，即N=31</p>
<p>如果系统复位后不进行任何设置，DCOCLK=2097152Hz，DCOCLKDIV=1048576Hz</p>
<p><strong>MCLK和SMCLK都默认选择DCOCLKDIV作为时钟源</strong>。</p>
<p>通过配置DCORSEL、DCOx、MOD来选择DCO的频率设置范围（最小值和最大值）</p>
<p>详细内容参考datasheet</p>
<p><strong>MODOSC</strong>：内部模块振荡器，是<strong>UCS时钟模块下属的振荡器</strong>，能产生<strong>4.8MHz的MODCLK时钟</strong>，用于FLASH、ADC等片上外设</p>
<p><strong>MCLK</strong>：为CPU和片上外设提供<strong>主时钟</strong>，默认使用DCOCLKDIV</p>
<p>通过配置DIVM选择MCLK分频系数为1、2、4、8、16、32</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UCSCTL4 = UCSCTL4 &amp; (~SELM_7) | SELM_0; <span class="comment">//XT1CLK时钟源</span></span><br><span class="line">UCSCTL4 = UCSCTL4 &amp; (~SELM_7) | SELM_1; <span class="comment">//VLOCLK时钟源</span></span><br><span class="line">UCSCTL4 = UCSCTL4 &amp; (~SELM_7) | SELM_2; <span class="comment">//REFOCLK时钟源</span></span><br><span class="line">UCSCTL4 = UCSCTL4 &amp; (~SELM_7) | SELM_3; <span class="comment">//DCOCLK时钟源</span></span><br><span class="line">UCSCTL4 = UCSCTL4 &amp; (~SELM_7) | SELM_4; <span class="comment">//DCOCLKDIV时钟源</span></span><br><span class="line">UCSCTL4 = UCSCTL4 &amp; (~SELM_7) | SELM_5; <span class="comment">//XT2CLK时钟源</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UCSCTL5 = UCSCTL5 &amp; (~DIVM_7) | DIVM_0; <span class="comment">//MCLK不分频</span></span><br><span class="line">UCSCTL5 = UCSCTL5 &amp; (~DIVM_7) | DIVM_1; <span class="comment">//MCLK 2分频</span></span><br><span class="line">UCSCTL5 = UCSCTL5 &amp; (~DIVM_7) | DIVM_2; <span class="comment">//MCLK 4分频</span></span><br><span class="line">UCSCTL5 = UCSCTL5 &amp; (~DIVM_7) | DIVM_3; <span class="comment">//MCLK 8分频</span></span><br><span class="line">UCSCTL5 = UCSCTL5 &amp; (~DIVM_7) | DIVM_4; <span class="comment">//MCLK 16分频</span></span><br><span class="line">UCSCTL5 = UCSCTL5 &amp; (~DIVM_7) | DIVM_5; <span class="comment">//MCLK 32分频</span></span><br></pre></td></tr></table></figure>

<p><strong>ACLK</strong>：<strong>辅助时钟</strong>，专用来为外围模块提供信号。默认使用XT1CLK时钟源，如果未起振，则使用REFOCLK。配置方法和MCLK完全一致</p>
<p><strong>SMCLK</strong>：<strong>子系统主时钟</strong>，和MCLK基本一致，只是不为CPU提供时钟</p>
<p>上电复位后，UCS默认配置如下：</p>
<ul>
<li>ACLK选择XT1为时钟源，如果未起振则使用REFOCLK并生成时钟故障标志</li>
<li>MCLK选择DCOCLKDIV</li>
<li>SMCLK选择DCOCLKDIV</li>
</ul>
<p>需要注意：msp430f5529的XTIN和XTOUT引脚默认为GPIO功能，并在上电情况下不会启动，需要额外进行软件设置</p>
<p>同时P7.7、P2.2、P1.0分别能够对外输出MCLK、SMCLK、ACLK时钟</p>
<p>这里用最为复杂的DCO配置说明整个时钟系统的配置流程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430f5529.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetVcoreUp</span><span class="params">(<span class="keyword">uint_32_t</span> level)</span></span>; <span class="comment">//提升核心电压以提升工作频率</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">XT1_ON</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//启动XT1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DCO__16MHz</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//使用DCO将XT1倍频到16MHz</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW + WDTHOLD;</span><br><span class="line">    P1SEL |= BIT0; <span class="comment">//P1.0 ACLK输出</span></span><br><span class="line">    P1DIR |= BIT0;</span><br><span class="line">    P2SEL |= BIT2; <span class="comment">//SMCLK输出</span></span><br><span class="line">    P2DIR |= BIT2;</span><br><span class="line">    P7SEL |= BIT7; <span class="comment">//MCLK输出</span></span><br><span class="line">    P7DIR |= BIT7;</span><br><span class="line">    P7DIR |= BIT0; <span class="comment">//P7.0 LED驱动输出</span></span><br><span class="line">    P1OUT |= BIT0;</span><br><span class="line">    </span><br><span class="line">    XT1_ON();</span><br><span class="line">    DCO__16MHz();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        __delay_cycles(<span class="number">8000000</span>); <span class="comment">//每0.5s</span></span><br><span class="line">        P7OUT ^= BIT0 ;<span class="comment">//LED状态翻转一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetVcoreUp</span><span class="params">(<span class="keyword">uint_32_t</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PMMCTL0_H = PMMPW_H; <span class="comment">//解锁PMM寄存器，允许写入</span></span><br><span class="line">    SVSMHCTL = SVSHE + SVSHRVL0 * level + SVMHE + SVSMHRRL0 * level; <span class="comment">//设置SVS/SVM高侧到新的等级</span></span><br><span class="line">    SVSMLCTL = SVSLE + SVMLE + SVSMLRRL0 * level; <span class="comment">//设置SVS低侧到新的等级</span></span><br><span class="line">    <span class="keyword">while</span>((PMMIFG &amp; SVSMLDLYIFG) == <span class="number">0</span>); <span class="comment">//等待SVM稳定</span></span><br><span class="line">    PMMIFG &amp;= ~(SVMLVLRIFG + SVMLIFG); <span class="comment">//清除已经置位的标志</span></span><br><span class="line">    PMMCTL0_L = PMMCOREV0 * level; <span class="comment">//设置VCORE到新的等级</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span>((PMMIFG &amp; SVMLIFG)) <span class="comment">//等待达到新的电压等级</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>((PMMIFG &amp; SVMLVLRIFG) == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置SVS/SVM低侧到新的水平</span></span><br><span class="line">    SVSMLCTL = SVSLE + SVSLRVL0 * level + SVMLE + SVSMLRRL0 * level;</span><br><span class="line">    PMMCTL0_H = <span class="number">0x00</span>; <span class="comment">//锁住PMM的写入路径</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">XT1_ON</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    P5SEL |= BIT4 |BIT5; <span class="comment">//配置XT1引脚</span></span><br><span class="line">    UCSCTL6 |= XCAP_3; <span class="comment">//配置电容为12pF</span></span><br><span class="line">    UCSCTL6 &amp;= ~XT1OFF; <span class="comment">//使能XT1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(SFRIFG1 &amp; OFIFG)</span><br><span class="line">    &#123;</span><br><span class="line">        UCSCTL7 &amp;= ~(XT2OFFG + XT1LFOFFG + DCOFFG); <span class="comment">//清除三类时钟错误标志位</span></span><br><span class="line">        SFRIFG1 &amp;= ~OFIFG; <span class="comment">//清除时钟错误标志位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DCO__16MHz</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SetVcoreUp(<span class="number">1</span>); <span class="comment">//一级一级提升核心电压，不能跨级</span></span><br><span class="line">    SetVcoreUp(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置寄存器使DCOCLK=4.9MHz,DCOCLKDIV=2.45MHz */</span></span><br><span class="line">    __bis_SR_register(SCG0); <span class="comment">//关闭FLL库函数</span></span><br><span class="line">    UCSCTL0 = <span class="number">0x0000</span>; <span class="comment">//清零寄存器值，FLL运行时系统会自动配置该寄存器</span></span><br><span class="line">    UCSCTL1 = DCORSEL_5; <span class="comment">//选择DCOCLK频率范围 6-23.7MHz</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//FLLD=0，则D=1；FLLN=487，则N=487；N在UCSCTL3寄存器，默认值为1，则DCOCLK=1*(487+1)*32768=15.990784MHz</span></span><br><span class="line">    <span class="comment">//DCODIVCLK=(487+1)*32768=15.990784MHz</span></span><br><span class="line">    UCSCTL2 = FLLD_0 + <span class="number">487</span>; </span><br><span class="line">    </span><br><span class="line">    __bic_SR_register(SCG0); <span class="comment">//开启FLL控制回路</span></span><br><span class="line">    __delay_cycles(<span class="number">76563</span>); <span class="comment">//延时等待时钟稳定</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(SFRIFG1 &amp; OFIFG) <span class="comment">//检测时钟错误并等待时钟稳定</span></span><br><span class="line">    &#123;</span><br><span class="line">        UCSCTL7 &amp;= ~(XT2OFFG + XT1LFOFFG + DCOFFG);</span><br><span class="line">        SFRIFG1 &amp;= ~OFIFG;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>低功耗配置</strong></em></p>
<p>msp430一共有8种工作模式</p>
<ul>
<li>活跃模式（AM）</li>
<li>低功耗模式（LPM）0</li>
<li>低功耗模式1</li>
<li>低功耗模式2</li>
<li>低功耗模式3</li>
<li>低功耗模式3.5</li>
<li>低功耗模式4</li>
<li>低功耗模式4.5</li>
</ul>
<p>但是并不是所有系列都支持这些工作模式，对于f5529来说，不支持LPM3.5</p>
<p>使用以下指令来进入和退出低功耗模式0-4</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 开总中断并进入低功耗模式 */</span></span><br><span class="line">__bis_SR_register(LPMn_bits + GIE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 退出低功耗模式 */</span></span><br><span class="line">LPMn_EXIT; <span class="comment">//其中n可以换成数字0-4</span></span><br></pre></td></tr></table></figure>

<p>需要注意：<strong>低功耗模式唤醒都需要使用外部中断</strong>，所以需要在进入低功耗模式同时开启总中断</p>
<p>在最高级别LPM4.5低功耗模式下，RAM中内容会直接丢失，所以在从LPM4.5唤醒后需要重新配置寄存器和相关设置</p>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>低功耗模式唤醒使用的指令实际上是通过直接修改SR寄存器的值，清除休眠标志，它内联到以下函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_bic_SR_register_on_exit(LPM3_bits);<span class="comment">//退出LPM3</span></span><br></pre></td></tr></table></figure>

<p>MSP430和arm一样都具有<em>系统中断</em>、<em>不可屏蔽中断</em>和<em>可屏蔽中断</em>三种，其中系统中断和不可屏蔽中断优先级最高；可屏蔽中断可以通过<strong>状态寄存器SR</strong>中的GIE位来屏蔽和开启</p>
<p>大致的中断作用与arm类似，而使用方式与51类似</p>
<p>下面主要介绍外部中断</p>
<ol>
<li><p>初始化端口时要清空中断标志位</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P1IFG &amp;= ~(BIT0); <span class="comment">//清空中断标志位</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>PIES</code>寄存器选择触发边沿（0为上升沿，1为下降沿）并使用<code>PxIE</code>寄存器使能中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P1IES &amp;= ~BIT0; <span class="comment">//P1.0上升沿触发</span></span><br><span class="line">P1IES |= BIT1; <span class="comment">//P1.1下降沿触发</span></span><br><span class="line">P1IES |= BIT2; <span class="comment">//P1.2下降沿触发</span></span><br><span class="line">    </span><br><span class="line">P1IE |= BIT0; <span class="comment">//使能P1.0中断</span></span><br><span class="line">P1IE |= BIT1; <span class="comment">//使能P1.1中断</span></span><br><span class="line">P1IE |= BIT2; <span class="comment">//使能P1.2中断</span></span><br></pre></td></tr></table></figure></li>
<li><p>开总中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__bis_SR_register(GIE);</span><br></pre></td></tr></table></figure></li>
<li><p>编写中断服务函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector = 中断向量地址</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">ISR_function</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//中断服务函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在中断函数内部清零中断标志位</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__even_in_range(P1IV, <span class="number">16</span>); <span class="comment">//用于查询P1的所有中断标志位并自动清零，使用该函数可以实现将所有P1的外部中断放在同一个函数内解决的功能,如下所示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(__even_in_range(P1IV, <span class="number">16</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//无中断</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//P1IFG.0</span></span><br><span class="line">        <span class="comment">/* 中断处理函数 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">//P1IFG.1</span></span><br><span class="line">        <span class="comment">/* 中断处理函数 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: <span class="comment">//P1IFG.2</span></span><br><span class="line">        <span class="comment">/* 中断处理函数 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>: <span class="comment">//P1IFG.3</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>: <span class="comment">//P1IFG.4</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>: <span class="comment">//P1IFG.5</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">14</span>: <span class="comment">//P1IFG.6</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">16</span>: <span class="comment">//P1IFG.7</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">//出错情况</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>此外，msp430还支持<em>手动的</em>嵌套中断</p>
<p>示例程序如下所示（TI的七段数码管驱动示例程序）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> SEVENSEG_OUTPUT[<span class="number">10</span>] = &#123;<span class="number">0x3f</span>, <span class="number">0x06</span>, <span class="number">0x5b</span>, <span class="number">0x4f</span>, <span class="number">0x66</span>, <span class="number">0x6d</span>, <span class="number">0x7d</span>, <span class="number">0x07</span>, <span class="number">0x7f</span>, <span class="number">0x6f</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> loopCounter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> timeCounter1; </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> timeCounter2;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> timeCounter3;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW | WDTHOLD; <span class="comment">//关闭看门狗</span></span><br><span class="line"></span><br><span class="line">    PADIR = <span class="number">0x03ff</span>; <span class="comment">// P1, P2.0 and P2.1 output, P2.6 and P2.7 input</span></span><br><span class="line">    PAOUT = <span class="number">0xc03f</span>;</span><br><span class="line"></span><br><span class="line">    P2REN = <span class="number">0xc0</span>; <span class="comment">// P2.6 P2.7 上拉电阻使能</span></span><br><span class="line">    P2IES = <span class="number">0x3f</span>; <span class="comment">// P2.6 P2.7 配置中断为上升沿</span></span><br><span class="line">    P2IE = <span class="number">0xc0</span>; <span class="comment">// P2.6 P2.7 interrupt enabled</span></span><br><span class="line"></span><br><span class="line">    PM5CTL0 &amp;= ~LOCKLPM5; <span class="comment">// 关闭GPIO高阻抗模式</span></span><br><span class="line"></span><br><span class="line">    RTCMOD = <span class="number">50</span>; <span class="comment">// 设置RTC重装计数值为50</span></span><br><span class="line">                 <span class="comment">// 64/32768 * 51 = ~0.1 sec.</span></span><br><span class="line">    SYSCFG2 |= RTCCKSEL; <span class="comment">// Source = ACLK = REFO，64分频，选择ACLK作为RTC时钟</span></span><br><span class="line">    RTCCTL = RTCSS_1 | RTCSR | RTCPS__64;</span><br><span class="line"></span><br><span class="line">    P2IFG = <span class="number">0</span>; <span class="comment">// 清除P1.3中断标志位</span></span><br><span class="line">    __bis_SR_register(GIE); <span class="comment">//开全局中断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PAOUT |= (BIT9 | SEVENSEG_OUTPUT[timeCounter3]);  <span class="comment">// 按顺序显示七段数码管数字</span></span><br><span class="line">        __delay_cycles(<span class="number">100</span>);</span><br><span class="line">        PAOUT = <span class="number">0xc000</span>; <span class="comment">// 清除引脚</span></span><br><span class="line"></span><br><span class="line">        PAOUT |= (BIT8 | SEVENSEG_OUTPUT[timeCounter2]);</span><br><span class="line">        __delay_cycles(<span class="number">100</span>);</span><br><span class="line">        PAOUT = <span class="number">0xc000</span>;</span><br><span class="line"></span><br><span class="line">        P1OUT |= (BIT7 | SEVENSEG_OUTPUT[timeCounter1]);</span><br><span class="line">        __delay_cycles(<span class="number">100</span>);</span><br><span class="line">        P1OUT = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RTC中断服务函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=RTC_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">RTC_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __bis_SR_register(GIE); <span class="comment">// 允许嵌套中断</span></span><br><span class="line">    RTCIV = <span class="number">0</span>;</span><br><span class="line">    timeCounter1++; <span class="comment">// timeCounter1代表0.1s, timeCounter2代表1s,timeCounter3代表10s，经典延时操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(timeCounter1 &gt; <span class="number">9</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        timeCounter1 = <span class="number">0</span>;</span><br><span class="line">        timeCounter2++;</span><br><span class="line">        <span class="keyword">if</span>(timeCounter2 &gt; <span class="number">9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            timeCounter3++;</span><br><span class="line">            timeCounter2 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(timeCounter3 &gt; <span class="number">9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            timeCounter3 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P2中断服务函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=PORT2_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">Port_2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __bis_SR_register(GIE); <span class="comment">// 允许嵌套中断</span></span><br><span class="line">    <span class="keyword">if</span>(P2IFG &amp; BIT6)</span><br><span class="line">    &#123;</span><br><span class="line">        P2IFG &amp;= ~BIT6; <span class="comment">// 清除P2.6中断标志位</span></span><br><span class="line">        <span class="comment">// 第一次按下按钮时开启定时器；第二次按下时停止定时器</span></span><br><span class="line">        <span class="keyword">if</span>(loopCounter == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          	loopCounter++; <span class="comment">//开启一轮循环</span></span><br><span class="line">            RTCCTL |= RTCIE; <span class="comment">//开启定时器</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            RTCCTL &amp;= ~RTCIE; <span class="comment">//关闭定时器</span></span><br><span class="line">            loopCounter = <span class="number">0</span>; <span class="comment">//循环清零</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(P2IFG &amp; BIT7)</span><br><span class="line">    &#123;</span><br><span class="line">        P2IFG &amp;= ~BIT7; <span class="comment">// 清除P2.7中断标志位并复位秒表</span></span><br><span class="line">        RTCCTL &amp;= ~RTCIE; <span class="comment">//关闭定时器</span></span><br><span class="line">        </span><br><span class="line">        loopCounter = <span class="number">0</span>; <span class="comment">//复位所有变量</span></span><br><span class="line">        timeCounter3 = <span class="number">0</span>;</span><br><span class="line">        timeCounter2 = <span class="number">0</span>;</span><br><span class="line">        timeCounter1 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现中断嵌套需要注意以下几点：</p>
<p>msp430默认关闭中断嵌套，一定要中断嵌套的话，就必须在中断服务程序中打开总中断</p>
<p>msp430的指令中，_DINT()和_EINT()分别指关和开总中断</p>
<p>当进入中断服务程序时，只要不在中断服务程序中再次开中断，则总中断是关闭的，此时来中断不管是比当前中断的优先级高还是低都不执行</p>
<p><strong>若在中断服务程序A中开了总中断，则可以响应后来的中断B（不管B的优先级比A高还是低），B执行完再继续执行A</strong></p>
<p>注意：进入中断服务程序B后总中断同样也会关闭，如果B中断程序执行时需响应中断C，则此时也要开总中断，若不需响应中断，则不用开中断，B执行完后跳出中断程序进入A程序时，总中断会自动打开</p>
<p><strong>若在中断服务程序中开了总中断，后来的中断同时有多个，则会按优先级来执行，即中断优先级只有在多个中断同时到来时才起作用，中断服务不执行抢先原则</strong></p>
<p>对于单源中断，只要响应中断，系统硬件会自动清除中断标志位。对于TA/TB定时器的比较/捕获中断，只要访问TAIV/TBIV，标志位就会被自动清除；对于多源中断要手动清标志位，比如P1/P2口中断，要手工清除相应的标志。如果在这种中断里用<code>_EINT();</code>开中断,而在打开中断前没有清标志，就会有相同的中断不断嵌入，导致堆栈溢出引起复位，所以在<strong>这类中断中必须先清标志再打开中断开关</strong></p>
<p><strong>常用中断向量表</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASICTIMER_VECTOR   (0 * 2u) <span class="comment">/* 0xFFE0 Basic Timer */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT2_VECTOR        (1 * 2u)  <span class="comment">/* 0xFFE2 Port 2 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USART1TX_VECTOR     (2 * 2u) <span class="comment">/* 0xFFE4 USART 1 Transmit */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USART1RX_VECTOR     (3 * 2u) <span class="comment">/* 0xFFE6 USART 1 Receive */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT1_VECTOR        (4 * 2u)  <span class="comment">/* 0xFFE8 Port 1 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMERA1_VECTOR      (5 * 2u) <span class="comment">/* 0xFFEA Timer A CC1-2, TA */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMERA0_VECTOR      (6 * 2u) <span class="comment">/* 0xFFEC Timer A CC0 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADC12_VECTOR          (7 * 2u)  <span class="comment">/* 0xFFEE ADC */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USART0TX_VECTOR     (8 * 2u) <span class="comment">/* 0xFFF0 USART 0 Transmit */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USART0RX_VECTOR     (9 * 2u) <span class="comment">/* 0xFFF2 USART 0 Receive */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WDT_VECTOR          (10 * 2u) <span class="comment">/* 0xFFF4 Watchdog Timer */</span></span></span><br><span class="line"></span><br><span class="line">#defineCOMPARATORA_VECTOR  (<span class="number">11</span> * <span class="number">2u</span>) <span class="comment">/* 0xFFF6Comparator A */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMERB1_VECTOR      (12 * 2u) <span class="comment">/* 0xFFF8 Timer B CC1-6, TB */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMERB0_VECTOR      (13 * 2u) <span class="comment">/* 0xFFFA Timer B CC0 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NMI_VECTOR          (14 * 2u) <span class="comment">/* 0xFFFC Non-maskable */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RESET_VECTOR        (15 * 2u) <span class="comment">/* 0xFFFE Reset [HighestPriority] */</span></span></span><br></pre></td></tr></table></figure>

<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>msp430有四个基本定时器，外加一个RTC定时器，部分定时器具有PWM输出功能</p>
<p>计数器核心是一个计数寄存器，对输入的时钟信号进行计数，可以配置其捕获跳变沿种类和分频系数，使用寄存器TAxR获取当前计数值。定时器主要分成两部分：主计数器和捕获比较器模块。捕获比较器模块与主计数器模块通过TAxR连通，主计数器会根据输入的信号跳变沿递增/递减寄存器TAxR/TBxR的值，捕获比较器会根据收到的比较值对寄存器的值进行检查，根据当前模式不同做出不同反应，因为计数寄存器被共用，所以可以将其分成多个通道。一般当捕获比较器满足设置的条件时就会产生中断，存储计数值或输出相应的信号。<em>只需要主计数器即可完成定时工作，捕获比较器的作用则在于配合主计数器完成更多扩展功能</em></p>
<ul>
<li><p><strong>Timer_A</strong>：<strong>16位定时器</strong>（最大值65535），具有7个捕获比较器，支持<em>多路捕获比较</em>、<em>PWM输出</em>、<em>间隔定时</em>功能</p>
<p>F5529中包含两个Timer_A模块，记作Timer_A0、Timer_A1、Timer_A2，三个模块的主计数器在结构上完全相同，单捕获比较器的数量不相同：Timer_A0有7个，Timer_A1和Timer_A2各有3个。</p>
</li>
<li><p><strong>Timer_B</strong>：<strong>16位定时器</strong>（最大值65535），具备Timer_A的所有功能，但它还具备<em>双缓冲比较锁存</em>与<em>同步加载</em>功能</p>
</li>
</ul>
<p>定时器的基本模式如下：</p>
<ul>
<li><p>捕获器模式</p>
<p>触发信号到来时捕获器将计数寄存器的值复制到捕获比较器的计数值寄存器TAxCCRn/TBxCCRn，并产生中断请求</p>
</li>
<li><p>比较器模式</p>
<p>需要程序向计数值寄存器TAxCCRn/TBxCCRn中写入初值，当主计数器的计数寄存器TAxR/TBxR计数值达到寄存器中存储的初值后定时器模块就会向CPU请求中断 </p>
</li>
</ul>
<p>通过配置TASSEL可以选择时钟来自ACLK、SMCLK、TAxCLK（外部输入）或INCLK（定时器级联）</p>
<h4 id="定时器A"><a href="#定时器A" class="headerlink" title="定时器A"></a>定时器A</h4><p>msp430的定时器A的主计数器具有以下几个工作模式</p>
<ul>
<li><p>增模式</p>
<p>设备会重复<strong>从0自增到TAxCCRn的值</strong>，溢出时触发中断</p>
<p>最基础的功能</p>
</li>
<li><p>连续模式</p>
<p>设备会重复<strong>从0自增到0FFFFh</strong>，然后从0重新开始计数</p>
<p>一般用于生成独立的时间间隔和输出频率，时间间隔完成时会生成中断</p>
<p>起始设置TAxCCRn的初值，并在中断服务函数中重新设置TAxCCRn的值，使其与初值的计数个数相同即可产生固定的时间间隔，这种操作还可以应用多个通道，因为多通道之间相互独立</p>
<p>最基础的功能</p>
</li>
<li><p>增减模式</p>
<p>定时器从0自增到TAxCCR0，再自减到0，也就是说其定时周期为两倍的TAxCCR0</p>
</li>
</ul>
<p>捕获比较器工作模式如下：</p>
<p>通过设置捕获比较器中的CAP位可以选择捕获比较器的工作模式为比较模式（0）或捕获模式（1），</p>
<ul>
<li><p>捕获模式</p>
<p>当CAP=1时选择捕获模式，用于记录时间时间。</p>
<p>触发信号输入CCIxA/CCIxB连接外部的引脚或内部的信号，通过CCIS位来选择；通过CM位选择触发捕获事件的输入信号触发沿</p>
<p>每当触发信号到来时，捕获比较器会1. 将TAxR的值复制到TAxCCRn寄存器中；2. 将捕获器中断标志CCIFG置位触发中断</p>
</li>
<li><p>比较模式</p>
<p>如果计数器TAxR的值和某个TAxCCRn的值相等时，相应的中断标志位会被置位，产生一个比较中断。一般该模式用于产生PWM信号</p>
</li>
<li><p>输出模式</p>
<p>传统的定时器通过标志位判断来触发事件，但msp430配备了专用的输出模块，使用输出模块寄存器OUTMODEx可以快速输出PWM信号或其他控制信号</p>
</li>
</ul>
<h4 id="定时器中断"><a href="#定时器中断" class="headerlink" title="定时器中断"></a>定时器中断</h4><p>定时器A具有两个中断源，捕获比较器0中断独立，其他所有中断（定时器溢出中断、捕获比较器1中断、捕获比较器2中断等等）共用中断源，通过TAxIV来确定具体触发中断的中断源</p>
<p>使用步骤如下：</p>
<ol>
<li><p>设置主计数器时钟</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TA0CTL = TASSEL_1;</span><br></pre></td></tr></table></figure></li>
<li><p>设置分频</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TA0EX0 = TAIDEX_7 <span class="comment">//8分频</span></span><br></pre></td></tr></table></figure></li>
<li><p>初始化CCR寄存器（设置初值）并使能中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TA0CCR0 = <span class="number">9000</span>; <span class="comment">//设置初值</span></span><br><span class="line">TA0CCTL0 = CCIE; <span class="comment">//使能TA0CCR0中断</span></span><br></pre></td></tr></table></figure></li>
<li><p>设置捕获比较器模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TA0CTL |= MC_2 + TACLR; <span class="comment">//清除TA0R，启动定时器，选择连续计数模式</span></span><br></pre></td></tr></table></figure>

<p>也可以使用下面的代码启用其他模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MC_1 增模式</span><br><span class="line">MC_3 减增模式</span><br></pre></td></tr></table></figure></li>
<li><p>开总中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__bis_SR_register(GIE);</span><br></pre></td></tr></table></figure></li>
<li><p>配置中断服务函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector = TIMER0_A0_VECTOR <span class="comment">//TA0CCR0中断</span></span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">TA0CCR0_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TA0CCR0 += <span class="number">16384</span>; <span class="comment">//添加偏置</span></span><br><span class="line">    <span class="comment">/* 中断处理函数 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="定时器B"><a href="#定时器B" class="headerlink" title="定时器B"></a>定时器B</h4><p>在捕获比较器和比较器之间加入的比较锁存器可以分组控制比较值载入的时刻，实现同步更新数据</p>
<p>在Timer_B中可以通过配置寄存器TBxCCTLn来选择TBxCCRn载入TBxCLn的时刻，在Timer_B中起到比较作用的是比较锁存器TBxCLn而不是CCR寄存器，当TBxR的值达到TBxCLn时，相应的中断标志位置位，产生比较器中断请求，TBxCCRn的值会在寄存器设置的时间点载入TBxCLn，从而实现比较延时更新</p>
<h4 id="输入捕获"><a href="#输入捕获" class="headerlink" title="输入捕获"></a>输入捕获</h4><p>使用定时器的外部计数功能来测量脉冲个数，可用于测速、编码器驱动等场合</p>
<p>基本使用方式和上面的定时器中断类似，但是需要以下额外语句</p>
<ol>
<li><p>配置外部时钟源，使能溢出中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TA0CTL = TASSEL_0 + TAIE;</span><br></pre></td></tr></table></figure></li>
<li><p>清除TAxR、启动定时器并工作于连续模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TA0CTL |= TACLR + MC_2;</span><br></pre></td></tr></table></figure></li>
<li><p>在定时器中断服务函数内递增全局计数变量用于获取输入捕获的脉冲数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> counter;</span><br><span class="line"><span class="keyword">uint8_t</span> loop;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector = TIMER0_A1_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">TA0_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    counter++;</span><br><span class="line">    <span class="keyword">if</span>(counter&gt;<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        loop++;</span><br><span class="line">        counter=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="PWM输出"><a href="#PWM输出" class="headerlink" title="PWM输出"></a>PWM输出</h4><p>msp430可以实现在不占用CPU资源的情况下输出PWM信号，程序如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430f5529.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW | WDTHOLD; <span class="comment">//关闭看门狗</span></span><br><span class="line">    P1DIR |= BIT2 | BIT3;</span><br><span class="line">    P1SEL |= BIT2 | BIT3; <span class="comment">//设置为定时器复用</span></span><br><span class="line">    TA0CCR0 = <span class="number">512</span><span class="number">-1</span>; <span class="comment">//PWM周期，频率=32768/512=64</span></span><br><span class="line">    TA0CCTL1 = OUTMODE_7; <span class="comment">//CCR1输出模式7</span></span><br><span class="line">    TA0CCR1 = <span class="number">384</span>; <span class="comment">//CCR1 PWM占空比设置为384/512=75%</span></span><br><span class="line">    TA0CCTL2 = OUTMODE_7; <span class="comment">//CCR2输出模式7</span></span><br><span class="line">    TA0CCR2 = <span class="number">128</span>; <span class="comment">//CCR2 PWM占空比设置为128/512=25%</span></span><br><span class="line">    <span class="comment">//开启定时器</span></span><br><span class="line">    TA0CTL = TASSEL_1 + MC_1 + TACLR; <span class="comment">//定时器时钟设置为32768Hz的ACLK，配置为增模式，清空TA0R</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 可实现在P1.2上输出75%占空比，在P1.3上输出25%占空比，频率都是64Hz的PWM信号 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总线协议"><a href="#总线协议" class="headerlink" title="总线协议"></a>总线协议</h3><p>msp430f5529中配备了<strong>通用串行通信接口模块USCI</strong>，它支持了多种通信模式，UART、SPI、IIC都可以使用该外设进行处理</p>
<p>使用方法很类似，仅给出示例代码</p>
<h4 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h4><p>串口接收并复读数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430f5529.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW + WDTHOLD;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 初始化UART */</span></span><br><span class="line">    P4SEL |= BIT4 + BIT5; <span class="comment">//配置P4.4、P4.5为USCI_A1 Tx、Rx</span></span><br><span class="line">    UCA1CTL1 |= UCSWRST; <span class="comment">//复位USCI_A1</span></span><br><span class="line">    UCA1CTL1 |= UCSSEL_2; <span class="comment">//SMCLK 无校验位 8字符长度 1个停止位</span></span><br><span class="line">    UCA1BR0 = <span class="number">9</span>; <span class="comment">//低8位=9</span></span><br><span class="line">    UCA1BR1 = <span class="number">0</span>; <span class="comment">//高8位=0，调制后波特率约为115200bps</span></span><br><span class="line">    UCA1MCTL |= UCBRS_1 + UCBRF_0; <span class="comment">//调制器UCBRSx=1,UCBRFx=0</span></span><br><span class="line">    UCA1CTL1 &amp;= ~UCSWRST; <span class="comment">//启动USCI_A1</span></span><br><span class="line">    UCA1IE |= UCRXIE; <span class="comment">//使能USCI_A1接收中断</span></span><br><span class="line">    __bis_SR_register(LPM0_bits + GIE); <span class="comment">//使能全局中断</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=USCI_A1_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">USCI_A1_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(__even_in_range(UCA1IV, <span class="number">4</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//无中断</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//接收中断RXIFG</span></span><br><span class="line">            UCA1TXBUF = UCA1RXBUF; <span class="comment">//复读</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">//发送中断TXIFG</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UCA1TXBUF：串口发送寄存器</p>
<p>UCA1RXBUF：串口接收寄存器</p>
<p>UCA1IE：串口中断控制寄存器，可以选择接收中断、发送中断</p>
<h4 id="IIC"><a href="#IIC" class="headerlink" title="IIC"></a>IIC</h4><p>需要注意，msp430的IIC无法内部上拉，所以必须在外部接入4.7k的上拉电阻到VCC（3.3V）</p>
<p>下面的代码仅说明如何将USCI配置成IIC驱动模式</p>
<ol>
<li><p>包含头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>初始化引脚复用功能</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P4SEL |= BIT1 + BIT2;</span><br></pre></td></tr></table></figure></li>
<li><p>初始化USCI，并配置传输速率</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UCB1CTL1 |= UCSWRST; <span class="comment">//复位USCI_B1</span></span><br><span class="line">UCB1CTL0 |= UCMST + UCMODE_3 + UCSYNC; <span class="comment">//配置为IIC主机，同步模式</span></span><br><span class="line">UCB1CTL1 = UCSSEL_2 + UCSWRST; <span class="comment">//SMCLK，保持UCSWRST置位</span></span><br><span class="line"></span><br><span class="line">UCB1BR0 = <span class="number">12</span>; <span class="comment">//fscl=SMCLK/12=100kHz</span></span><br><span class="line">UCB1BR1 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>设置从机地址</p>
<p>这里假设从机地址是0x48</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UCB1I2CSA = <span class="number">0x48</span>; <span class="comment">//从机地址0x48</span></span><br></pre></td></tr></table></figure></li>
<li><p>启动外设</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UCB1CTL1 &amp;= ~UCSWRST; <span class="comment">//清除复位标志，外设开始运行</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写中断控制函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> IIC_RXByte;</span><br><span class="line"><span class="keyword">uint8_t</span> IIC_TXByte;</span><br><span class="line"><span class="keyword">uint8_t</span> *PRxData; <span class="comment">//接收缓存</span></span><br><span class="line"><span class="keyword">uint8_t</span> *PTxData; <span class="comment">//发送缓存</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=USCI_B1_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">USCI_B1_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(__even_in_range(UCB1IV, <span class="number">12</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//无中断</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//ALIFG</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">//无响应中断NACKIFG</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: <span class="comment">//STTIFG</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>: <span class="comment">//停止位中断STPIFG</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>: <span class="comment">//接收中断RXIFG</span></span><br><span class="line">            IIC_RXByte--; <span class="comment">//递减字节计数变量</span></span><br><span class="line">            <span class="keyword">if</span>(IIC_RXByte) <span class="comment">//如果没有接收完毕</span></span><br><span class="line">            &#123;</span><br><span class="line">                *PRxData++ = UCB1RXBUF; <span class="comment">//接收剩下的数据到缓存区</span></span><br><span class="line">                <span class="keyword">if</span>(IIC_RXByte == <span class="number">1</span>) <span class="comment">//检查是否只剩一个字节未接收</span></span><br><span class="line">                &#123;</span><br><span class="line">                    UCB1CTL1 |= UCTXSTP; <span class="comment">//发送停止条件</span></span><br><span class="line">				&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//已经接收完毕</span></span><br><span class="line">            &#123;</span><br><span class="line">                *PRxData = UCB1RXBUF; <span class="comment">//将最后一字节数据存储到缓存区</span></span><br><span class="line">                UCB1IE &amp;= ~UCRXIE; <span class="comment">//禁用接收中断</span></span><br><span class="line">                __bic_SR_registe_on_exit(LPM0_bits); <span class="comment">//退出LPM0，进入活跃模式</span></span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">12</span>: <span class="comment">//发送中断TXIFG</span></span><br><span class="line">            <span class="keyword">if</span>(IIC_TXByte) <span class="comment">//如果没有发送完毕</span></span><br><span class="line">            &#123;</span><br><span class="line">                UCB1TXBUF = *PTxData; <span class="comment">//IIC发送数据</span></span><br><span class="line">                IIC_TXByte--; <span class="comment">//递减字节计数变量</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//已经接收完毕</span></span><br><span class="line">            &#123;</span><br><span class="line">                UCB1CTL1 |= UCTXSTP; <span class="comment">//置位发送停止条件位</span></span><br><span class="line">                UCB1IFG &amp;= ~UCTTXIFG; <span class="comment">//清除发送中断标志位TXIFG</span></span><br><span class="line">                UCB1IE &amp;= ~UCTXIE; <span class="comment">//禁用发送中断</span></span><br><span class="line">                __bic_SR_registe_on_exit(LPM0_bits); <span class="comment">//退出LPM0，进入活跃模式</span></span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写相关驱动</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TxData[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//发送缓存区</span></span><br><span class="line">RxData[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//接收缓存区</span></span><br><span class="line"><span class="keyword">uint8_t</span> IIC_RXByte;</span><br><span class="line"><span class="keyword">uint8_t</span> IIC_TXByte;</span><br><span class="line"><span class="keyword">uint8_t</span> *PRxData; <span class="comment">//接收缓存</span></span><br><span class="line"><span class="keyword">uint8_t</span> *PTxData; <span class="comment">//发送缓存</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 这里省略初始化部分 */</span></span><br><span class="line">    disable_WDG();</span><br><span class="line">    init_iic();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 发送设置 */</span></span><br><span class="line">        PTxData = TxData;</span><br><span class="line">        IIC_TXByte = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">while</span>(UCB1CTL1 &amp; UCTXSTP); <span class="comment">//确保停止条件已发送，总线空闲</span></span><br><span class="line">        </span><br><span class="line">        UCBCTL1 |= UCTR; <span class="comment">//设置主机工作在发送机模式</span></span><br><span class="line">        UCBCTL1 |= UCTXSTT; <span class="comment">//发送开始条件并发送有“写标志位”的地址</span></span><br><span class="line">        UCB1IE |= UCTXIE; <span class="comment">//使能发送中断</span></span><br><span class="line">        __bis_SR_register(LPM0_bits + GIE); <span class="comment">//进入LPM0，使能全局中断</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 接收设置 */</span></span><br><span class="line">        PRxData = RxData;</span><br><span class="line">        IIC_RXByte = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">while</span>(UCB1CTL1 &amp; UCTXSTP); <span class="comment">//确保停止条件已发送，总线空闲</span></span><br><span class="line">        UCBCTL1 &amp;= ~UCTR;<span class="comment">//设置主机工作在接收机模式</span></span><br><span class="line">        UCBCTL1 |= UCTXSTT; <span class="comment">//发送开始条件并发送有“读标志位”的地址</span></span><br><span class="line">        UCB1IE |= UCRXIE; <span class="comment">//使能接收中断</span></span><br><span class="line">        __bis_SR_register(LPM0_bits + GIE); <span class="comment">//进入LPM0，使能全局中断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h4><p>使用以下代码设置SPI</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这里省略端口复用设置 */</span></span><br><span class="line">UCB0CTL1 |= UCSWrST;</span><br><span class="line">UCB0CTL0 |= UCMST + UCSYNC; <span class="comment">//设置为三线SPI主机模式，8位数据位</span></span><br><span class="line">UCB1CTL1 = UCSSEL_2; <span class="comment">//时钟设置为SMCLK</span></span><br><span class="line">UCB1BR0 = <span class="number">0xFF</span>; <span class="comment">//UCB0CLK = SMCLK / 0xFFF</span></span><br><span class="line">UCB1BR1 = <span class="number">0x0F</span>; <span class="comment">//一般来说可以选择100kHz以上的频率，通常使用4MHz频率</span></span><br><span class="line"></span><br><span class="line">UCB1CTL1 &amp;= ~UCSWRST; <span class="comment">//清除复位标志，外设开始运行</span></span><br></pre></td></tr></table></figure>

<p>中断和驱动编写部分和IIC基本一致，不再赘述</p>
<h3 id="片上模拟外设"><a href="#片上模拟外设" class="headerlink" title="片上模拟外设"></a>片上模拟外设</h3><p>msp430集成了12位ADC/DAC和模拟比较器外设</p>
<h4 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h4><p>f5529配备了SAR架构的ADC12_A模块，支持12位ADC，具有16个模拟输入通道、16个独立的转换和存储单元，可在脱离CPU情况下完成ADC转换，最高200ksp（千次采样/每秒）</p>
<p>基本配置流程如下：</p>
<ol>
<li><p>配置核心控制寄存器，选择时钟、转换模式、启动参考电压生成器</p>
<p>ADC12_A内部具有独立的REF模块，可以提供1.5V、2V、2.5V参考电压。通过REF模块的REFMSTR位选择参考电压：置1时（默认状态）使用REF模块控制参考电压；置0时使用ADC12_A的参考电压模块控制参考电压</p>
<p>使用ADC12REF2_5V控制参考电压大小，ADC12REFON控制是否开启电压生成器，ADC12REFOUT控制是否输出参考电压</p>
<p>ADC使用ADC12CLK时钟用来控制采样和转换的时间和周期，时钟源可选择SMCLK、MCLK、ACLK和ADC12OSC（UCS模块的MODCLK的5MHz内部振荡器），时钟源使用ADC12DIV控制的预分频器和ADC12SSELx控制的分频器进行分频，可选择1-32分频</p>
<p>基本配置程序如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADC12CTL0 = ADC12ON+ADC12SHT0_8+ADC12MSC; <span class="comment">//开启ADC12,设置采样时间,设置采样模式（这里使用了多采样转换）</span></span><br></pre></td></tr></table></figure>

<p>ADC具有4种模式，通过CONSEQx位选择</p>
<ul>
<li><strong>单通道模式</strong>：单通道只采样和转换一次，当ADC12SC置位时触发一次采样转换操作，持续一段时间后自动复位</li>
<li>序列通道（<strong>自动扫描</strong>）<strong>模式</strong>：使用CSTARTADDx位选择开始转换的第一个ADC1MCTLx，指定后序列启动指针会自动递增，被它指向的通道会自动开始转换，转换完成后自动复位，操作一直继续直到处理到ADC12EOS=1的ADC12MCTLx才会停止，ADC12EOS作为序列结束的标志，只在序列转换模式下使用</li>
<li><strong>重复单通道模式</strong>：一个单独的通道会被不断采样转换，可以设置完成中断来读取转换结果</li>
<li><strong>重复序列通道</strong>（自动重复）<strong>模式</strong>：一序列通道会被重复采样和转换，使用CSTARTADDx定义第一个ADC12McTLx，序列再检测到ADC12EOS（序列结束标志）置位后会自动结束，下一个触发信号将重新开始序列</li>
</ul>
</li>
<li><p>保持其处于禁用状态，ADC12ENC=0</p>
</li>
<li><p>配置引脚复用</p>
<p>将GPIO复用为ADC输入引脚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PxSEL |= <span class="number">0x0</span>n; <span class="comment">//选择Px.n引脚复用为ADC输入</span></span><br></pre></td></tr></table></figure>

<p>注意：<strong>只有能接入ADC的对应IO口才能复用</strong></p>
</li>
<li><p>配置采样定时器</p>
<p>一次转换由一个采样信号SHI的上升沿引起，可通过SHSx位来选择，可以选为直接由ADC12SC位控制或使用定时器来控制</p>
<ul>
<li>ADC12SHP=0，使用<strong>扩展采样模式</strong>，SHI信号直接控制SAMPCON并定义采样周期长度；SAMPCON=1时采样活跃，SAMPCON的下降沿会在同步ADC12CLK信号后启动转换</li>
<li>ADC12SHP=1，使用<strong>脉冲采样模式</strong>，SHI信号用于触发采样定时器，采样定时器在同步AD12CLK后将SAMPCON保持在高电平并持续一个可编程的间隔$t_{sample}$，整个采样时间就是$t_{sample}+t_{sync}$</li>
</ul>
</li>
<li><p>可单独配置每个通道的参考电压和输入源</p>
<p>使用ADC12MCTLx（x为0-15）控制转换存储单元，通过ADC12SREF和ADC12INCH分别选择参考电压和模拟信号的输入通道</p>
<p>在单通道单转换模式中，复位ADC12ENC<strong>立刻</strong>停止一个转换且会导致转换结果不可预知，一般来说需要使用以下语句停止单通道转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(ADC12BUSY != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    delay();</span><br><span class="line">&#125;</span><br><span class="line">ADC12ENC = <span class="number">0</span>; <span class="comment">//等待ADC12BUSY = 0后才能停止单通道转换</span></span><br></pre></td></tr></table></figure>

<p>重复单通道模式下，复位ADC12ENC会在<strong>当前转换结束</strong>时停止转换器</p>
<p>序列通道或重复序列通道中，复位ADC12ENC会在<strong>序列结束</strong>时停止转换器</p>
<p><em>任何模式中都可以通过清零ADC12CONSEQ并复位ADC12ENC位来立刻停止，但这样会导致转换结果不可预知</em></p>
</li>
<li><p>可以使能集成温度传感器或配置转换完成中断</p>
<p>ADC可以直接连接内部的温度传感器（这是参考电压生成器的一部分）来获取内部温度，计算公式如下<br>$$<br>T=(ADC_{raw} - CAL_ADC_T30) \times (\frac{85-30}{CAL_ADC_T85 - CAL_ADC_T30}) + 30<br>$$<br>其中T是精确温度值，$ADC_{raw}$是数模转换结果，两个$CAL_ADC_T$为温度矫正参数，需要通过地址进行访问调用，每个设备的矫正参数都不同，该参数会被使用TLV（Tag-Length-Value）的方式写入单片机，地址调用形式如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*((<span class="keyword">unsigned</span> <span class="keyword">int</span>*)<span class="number">0x1A1A</span>) <span class="comment">//具体地址需要根据电压和设备的不同来确定，详细内容参考datasheet即可</span></span><br></pre></td></tr></table></figure>

<p><strong>ADC12_A具有18个中断，共用一个中断源</strong></p>
<p>可单独配置某通道完成中断、ADC12MEMx溢出中断、ADC12_A计时溢出中断，所有中断通过唯一的中断向量寄存器来配置，也就是说只使用一个中断服务函数</p>
<p>注意：任何对于ADC12IV的读写操作都会自动复位ADC12OV或ADC12TOV，如果中断服务函数在访问ADC12IV寄存器时有ADC12OV和ADC12IFGx中断生成，那么ADC12OV中断条件会自动复位，在中断服务函数返回后紧接着处理其他中断，因此应避免中断执行时间过长导致ADC中断占用前台应用</p>
<p>使用下面的程序来开启ADC中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADC12IE = <span class="number">0x01</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>将ADC12ENC=1来使能设备</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADC12CTL0 |= ADC12ENC;</span><br><span class="line">ADC12CTL0 |= ADC12SC;</span><br></pre></td></tr></table></figure></li>
<li><p>通过读取ADC12MCTLx对应的ADC12MEMx来获取转换结果</p>
</li>
</ol>
<p>单通道单次转换示例如下（测量引脚电压高于参考电压则指示灯亮）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	WDTCTL = WDTPW + WDTHOLD;  <span class="comment">//停止WDG</span></span><br><span class="line">  	ADC12CTL0 = ADC12SHT02 + ADC12ON; <span class="comment">//设置采样时间并开启ADC12_A</span></span><br><span class="line"> 	ADC12CTL1 = ADC12SHP; <span class="comment">//使用采样定时器</span></span><br><span class="line">  	ADC12IE = <span class="number">0x01</span>; <span class="comment">//使能中断</span></span><br><span class="line">  	ADC12CTL0 |= ADC12ENC; <span class="comment">//使能转换通道</span></span><br><span class="line">  	P6SEL |= <span class="number">0x01</span>; <span class="comment">//配置P6.1复用为ADC输入</span></span><br><span class="line">  	P1DIR |= <span class="number">0x01</span>; <span class="comment">//配置P1.0信号指示输出</span></span><br><span class="line"></span><br><span class="line">  	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  	&#123;</span><br><span class="line">    	ADC12CTL0 |= ADC12SC; <span class="comment">//开始依次采样</span></span><br><span class="line"></span><br><span class="line">    	__bis_SR_register(LPM0_bits + GIE); <span class="comment">//进入LPM0,开启全局中断</span></span><br><span class="line">    	__no_operation(); <span class="comment">//用于调试器打断点的空指令</span></span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADC中断服务函数 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector = ADC12_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">ADC12_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="keyword">switch</span>(__even_in_range(ADC12IV,<span class="number">34</span>))</span><br><span class="line">  	&#123;</span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">0</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  0:  No interrupt</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">2</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  2:  ADC溢出中断</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">4</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  4:  ADC超时中断</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">6</span>:                                  <span class="comment">// Vector  6:  ADC12IFG0</span></span><br><span class="line">		<span class="comment">/* 测量P1引脚 */</span></span><br><span class="line">    	<span class="keyword">if</span> (ADC12MEM0 &gt;= <span class="number">0x7ff</span>)               <span class="comment">// ADC12MEM = A0 &gt; 0.5AVcc?</span></span><br><span class="line">      		P1OUT |= BIT0;                    <span class="comment">// P1.0 = 1</span></span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">      		P1OUT &amp;= ~BIT0;                   <span class="comment">// P1.0 = 0</span></span><br><span class="line"></span><br><span class="line">    	__bic_SR_register_on_exit(LPM0_bits); <span class="comment">//退出LPM0模式</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">8</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  8:  ADC12IFG1</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">10</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 10:  ADC12IFG2</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">12</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 12:  ADC12IFG3</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">14</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 14:  ADC12IFG4</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">16</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 16:  ADC12IFG5</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">18</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 18:  ADC12IFG6</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">20</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 20:  ADC12IFG7</span></span><br><span class="line"> 	<span class="keyword">case</span> <span class="number">22</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 22:  ADC12IFG8</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">24</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 24:  ADC12IFG9</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">26</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 26:  ADC12IFG10</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">28</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 28:  ADC12IFG11</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">30</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 30:  ADC12IFG12</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">32</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 32:  ADC12IFG13</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">34</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 34:  ADC12IFG14</span></span><br><span class="line">  	<span class="keyword">default</span>: <span class="keyword">break</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>多通道重复转换示例如下（连续读取P6.0、P6.1、P6.2、P6.3的ADC值）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Num_of_Results 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> A0results[Num_of_Results];</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> A1results[Num_of_Results];</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> A2results[Num_of_Results];</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> A3results[Num_of_Results];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	WDTCTL = WDTPW+WDTHOLD;                   <span class="comment">//关闭WDG</span></span><br><span class="line">    </span><br><span class="line">  	P6SEL = <span class="number">0x0F</span>;                             <span class="comment">//使能ADC复用引脚（P6的低四位0、1、2、3进行复用）</span></span><br><span class="line">  	ADC12CTL0 = ADC12ON+ADC12MSC+ADC12SHT0_8; <span class="comment">//开启ADC、扩展采样时间避免结果溢出</span></span><br><span class="line">  	ADC12CTL1 = ADC12SHP+ADC12CONSEQ_3;       <span class="comment">//使用采样定时器，设置为多通道重复采样模式</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置0、1、2、3通道的参数 */</span></span><br><span class="line">  	ADC12MCTL0 = ADC12INCH_0;                 <span class="comment">// ref+=AVcc, channel = A0</span></span><br><span class="line">  	ADC12MCTL1 = ADC12INCH_1;                 <span class="comment">// ref+=AVcc, channel = A1</span></span><br><span class="line">  	ADC12MCTL2 = ADC12INCH_2;                 <span class="comment">// ref+=AVcc, channel = A2</span></span><br><span class="line">  	ADC12MCTL3 = ADC12INCH_3+ADC12EOS;        <span class="comment">// ref+=AVcc, channel = A3 ，设置ADC结束标志</span></span><br><span class="line">    </span><br><span class="line">  	ADC12IE = <span class="number">0x08</span>;                           <span class="comment">//使能ADC12IFG.3中断</span></span><br><span class="line">  	ADC12CTL0 |= ADC12ENC;                    <span class="comment">//使能转换通道</span></span><br><span class="line">  	ADC12CTL0 |= ADC12SC;                     <span class="comment">//开始转换-软件触发</span></span><br><span class="line">  </span><br><span class="line">  	__bis_SR_register(LPM0_bits + GIE);       <span class="comment">//进入LPM0并开启全局中断</span></span><br><span class="line">  	__no_operation();                         <span class="comment">//用于调试器打断点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=ADC12_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">ADC12ISR</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">switch</span>(__even_in_range(ADC12IV,<span class="number">34</span>))</span><br><span class="line">  	&#123;</span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">0</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  0:  No interrupt</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">2</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  2:  ADC overflow</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">4</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  4:  ADC timing overflow</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">6</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  6:  ADC12IFG0</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">8</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  8:  ADC12IFG1</span></span><br><span class="line"> 	<span class="keyword">case</span> <span class="number">10</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 10:  ADC12IFG2</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">12</span>:                                  <span class="comment">// Vector 12:  ADC12IFG3</span></span><br><span class="line">    	A0results[index] = ADC12MEM0;         <span class="comment">// Move A0 results, IFG is cleared</span></span><br><span class="line">    	A1results[index] = ADC12MEM1;         <span class="comment">// Move A1 results, IFG is cleared</span></span><br><span class="line">    	A2results[index] = ADC12MEM2;         <span class="comment">// Move A2 results, IFG is cleared</span></span><br><span class="line">    	A3results[index] = ADC12MEM3;         <span class="comment">// Move A3 results, IFG is cleared</span></span><br><span class="line">    	index++;                              <span class="comment">// 保存到结果缓存区</span></span><br><span class="line">    </span><br><span class="line">    	<span class="keyword">if</span> (index == <span class="number">8</span>)</span><br><span class="line">    	&#123;</span><br><span class="line">      		(index = <span class="number">0</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">  	<span class="keyword">case</span> <span class="number">14</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 14:  ADC12IFG4</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">16</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 16:  ADC12IFG5</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">18</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 18:  ADC12IFG6</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">20</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 20:  ADC12IFG7</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">22</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 22:  ADC12IFG8</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">24</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 24:  ADC12IFG9</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">26</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 26:  ADC12IFG10</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">28</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 28:  ADC12IFG11</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">30</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 30:  ADC12IFG12</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">32</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 32:  ADC12IFG13</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">34</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 34:  ADC12IFG14</span></span><br><span class="line">  	<span class="keyword">default</span>: <span class="keyword">break</span>; </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DAC"><a href="#DAC" class="headerlink" title="DAC"></a>DAC</h4><p>msp430f5529配备了DAC12_A模块，模块组成结构如下：</p>
<ul>
<li><p>核心</p>
<p>可以通过修改DAC12RES的值将DAC12_A配置为8位或12位模式；配置DAC12IR和DAC12OG位可以将满标度输出配置为所选参考电压的1倍、2倍或3倍；配置DAC12DF位选择输入的数据格式是原码还是补码。</p>
</li>
<li><p>端口</p>
<p>大多数DAC复用的端口都有其他复用功能，但是当DAC12AMPx&gt;0时，DAC12_A会忽略PxSEL.y和PxSEL.x的值，自动配置端口为DAC12_A输出复用功能</p>
<p>每个DAC通道都能输出到两个不同的端口，通过DAC122OPS选择，详细参数需要查阅datasheet</p>
</li>
<li><p>参考电压</p>
<p>使用DAC12SREFx选择DAC12_A参考电压，该值从AVCC、外部电压输入、内部1.16V参考电压、内部REF模块提供1.5V、2V、2.5V参考电压之一选择</p>
</li>
<li><p>参考输入和电压输出缓冲区</p>
<p>参考输入和电压输出缓冲区通过寄存器配置来平衡建立时间和功耗，通过配置DAC12AMPx来选择组合，其值越小、建立时间越长、缓冲区上的电流消耗越小</p>
</li>
<li><p>数据格式</p>
<p>使用原码或补码形式都可以设置DAC，使用DAC12_xDAT（取值范围0800h（输出0V）-07ffh（输出标度），另外取值0000h时输出标度的一半）控制</p>
</li>
</ul>
<p>相关示例程序如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 输出固定电压 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW+WDTHOLD; <span class="comment">//关闭WDG</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置无增益，参考电压AVCC，启动DAC校准</span></span><br><span class="line">    DAC12_0CTL0 = DAC12IR + DAC12SREF_1 + DAC12AMP_5 + DAC12CALON;</span><br><span class="line">	DAC12_0CTL0 |= DAC12ENC; <span class="comment">//使能DAC12_A</span></span><br><span class="line">    <span class="comment">//需要注意这里的输出值是12位</span></span><br><span class="line">    DAC12_0DAT = <span class="number">0x000</span>; <span class="comment">//DAC输出0V</span></span><br><span class="line">    <span class="comment">//和上面一样的流程</span></span><br><span class="line">    DAC12_1CTL0 = DAC12IR + DAC12SREF_1 + DAC12AMP_5 + DAC12CALON;</span><br><span class="line">    DAC12_0CTL0 |= DAC12ENC; <span class="comment">//使能DAC12_A</span></span><br><span class="line">    DAC12_0DAT = <span class="number">0x700</span>; <span class="comment">//输出1.4V</span></span><br><span class="line">    __bis_SR_register(LPM4_bits); <span class="comment">//进入LPM4，DAC会自动输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出波形 */</span></span><br><span class="line"><span class="comment">//以FLASH换内存</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> Sin_tab[<span class="number">100</span>] = &#123; </span><br><span class="line"><span class="number">1638</span>,<span class="number">1740</span>,<span class="number">1843</span>,<span class="number">1944</span>,<span class="number">2045</span>,<span class="number">2143</span>,<span class="number">2240</span>,<span class="number">2335</span>,<span class="number">2426</span>,<span class="number">2515</span>,</span><br><span class="line"><span class="number">2600</span>,<span class="number">2681</span>,<span class="number">2758</span>,<span class="number">2831</span>, <span class="number">2899</span>,<span class="number">2962</span>,<span class="number">3020</span>,<span class="number">3072</span>,<span class="number">3119</span>,<span class="number">3160</span>,</span><br><span class="line"><span class="number">3195</span>,<span class="number">3224</span>,<span class="number">3246</span>,<span class="number">3262</span>,<span class="number">3272</span>,<span class="number">3272</span>,<span class="number">3263</span>,<span class="number">3247</span>,<span class="number">3224</span>,<span class="number">3196</span>,</span><br><span class="line"><span class="number">3161</span>,<span class="number">3120</span>,<span class="number">3074</span>,<span class="number">3021</span>,<span class="number">2964</span>,<span class="number">2901</span>,<span class="number">2833</span>,<span class="number">2760</span>,<span class="number">2683</span>,<span class="number">2602</span>,</span><br><span class="line"><span class="number">2517</span>,<span class="number">2429</span>,<span class="number">2337</span>,<span class="number">2243</span>,<span class="number">2146</span>,<span class="number">2047</span>,<span class="number">1947</span>,<span class="number">1845</span>,<span class="number">1743</span>,<span class="number">1640</span>,</span><br><span class="line"><span class="number">1537</span>,<span class="number">1435</span>,<span class="number">1333</span>,<span class="number">1233</span>,<span class="number">1134</span>,<span class="number">1037</span>,<span class="number">943</span>,<span class="number">851</span>,<span class="number">762</span>,<span class="number">677</span>,<span class="number">596</span>,</span><br><span class="line"><span class="number">519</span>,<span class="number">446</span>,<span class="number">378</span>,<span class="number">314</span>,<span class="number">256</span>,<span class="number">204</span>,<span class="number">157</span>,<span class="number">116</span>,<span class="number">81</span>,<span class="number">52</span>,<span class="number">29</span>,<span class="number">13</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>,</span><br><span class="line"><span class="number">12</span>,<span class="number">28</span>,<span class="number">50</span>,<span class="number">78</span>,<span class="number">113</span>,<span class="number">154</span>,<span class="number">200</span>,<span class="number">252</span>,<span class="number">310</span>,<span class="number">373</span>,<span class="number">440</span>,<span class="number">513</span>,<span class="number">590</span>,</span><br><span class="line"><span class="number">671</span>,<span class="number">756</span>,<span class="number">756</span>,<span class="number">844</span>,<span class="number">936</span>,<span class="number">1030</span>,<span class="number">1127</span>,<span class="number">1225</span>,<span class="number">1326</span>,<span class="number">1427</span>,<span class="number">1529</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW + WDTHOLD; <span class="comment">//停看门狗</span></span><br><span class="line"> 	INIT_XT2(); <span class="comment">//开启时钟   </span></span><br><span class="line"></span><br><span class="line"> 	P5SEL = <span class="number">0XFF</span>;</span><br><span class="line"> 	ADC12CTL0 = REFON; <span class="comment">//参考电压为内部2.5v  </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置DMA，直接将Sin_tab数据传输到DAC */</span></span><br><span class="line"> 	DMA0SA = (<span class="keyword">int</span>) Sin_tab; <span class="comment">//源地址寄存器</span></span><br><span class="line"> 	DMA0DA = DAC12_0DAT_; <span class="comment">//目的地址寄存器</span></span><br><span class="line">	DMA0SZ = <span class="number">100</span>; <span class="comment">//传输基本单元的个数</span></span><br><span class="line"> 	DMACTL0 = DMA0TSEL_5; <span class="comment">// DAC12_0CTL的DAC12IFG标志</span></span><br><span class="line"> 	DMA0CTL = DMADT_4 + DMASRCINCR_3 + DMAEN; <span class="comment">//DMADT_4：重复的块传输方式</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使用内部1.5V参考电压，无增益，使能DAC12_A校准并使能DAC12_A */</span></span><br><span class="line">	DAC12_0CTL = DAC12LSEL_2 + DAC12IR + DAC12AMP_5 + DAC12IFG + DAC12ENC; <span class="comment">//配置DAC</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 强制输出第一个中断 */</span></span><br><span class="line"> 	CCTL1 = OUTMOD_3; <span class="comment">//设置并复位</span></span><br><span class="line">	CCR1 = <span class="number">1</span>; <span class="comment">// PWM Duty Cycle   </span></span><br><span class="line">	CCR0 = <span class="number">8</span><span class="number">-1</span>; <span class="comment">//1kHz频率</span></span><br><span class="line">	TACTL = TASSEL_2 + MC_1; <span class="comment">//使用SMCLK时钟源,向上计数模式  </span></span><br><span class="line">	__bis_SR_register(LPM0_bits); <span class="comment">//进入LPM0，DMA和DAC都在工作，会自动输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可编程比较器"><a href="#可编程比较器" class="headerlink" title="可编程比较器"></a>可编程比较器</h4><p>f5529配备了Comp_B模块，支持精密线性数模转换、电源电压监控、外部模拟信号电压监测功能</p>
<p>其中核心是一个精密电压比较器，同相端比反相端电压高，则输出高电平，否则输出低电平，使用CBON位打开/关闭比较器</p>
<p>使用CBCTL0寄存器控制外部输入端口，CBIPEN和CBIMEN分别控制同相端和反相端；使用CBIMSEL和CBIPSEL控制端子连接的GPIO，应选择P6的端口，以这两个寄存器控制端口号</p>
<p>可以使用CBSHORT短路正反相输入，可用来建立简单的采样-保持机制，一般来说设置采样时间为3-10τ，3τ可以将采样电容充电到95%的输入信号电压值，5τ可以将采样电容充电到99%，10τ可以满足12位的精度</p>
<p>使用CBF控制位控制输出信号的输出滤波器</p>
<p>使用参考电压生成器来生成VREF，可以应用于比较器输入端，使用CBREF0x和CBREF1xl来控制</p>
<p>使用CBPWRMD来选择比较器功耗模式，默认为00——最大功耗、最快速度；可以调节到11来使用最低功耗、最低速度</p>
<p>使用CBCTL3来控制比较器的端口是否禁用；使用CBIPSEL或CBIMSEL来控制对应端口的输入缓冲区</p>
<p><strong>比较器也可以开启中断</strong></p>
<p>对于可编程电压比较器而言，一般使用滞后比较来让参考电压根据输出值变化，可以让比较器输出更加稳定，降低噪声</p>
<p>代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW + WDTHOLD; <span class="comment">//停看门狗</span></span><br><span class="line">    P1DIR |= BIT6; <span class="comment">//P1.6作输出</span></span><br><span class="line">    P1SEL |= BIT6; <span class="comment">//复用为比较器输出CBOUT</span></span><br><span class="line">    </span><br><span class="line">    P7DIR |= <span class="number">0xFF</span>; <span class="comment">//P7设置为输出，用来驱动LED显示当前比较器结果</span></span><br><span class="line">    </span><br><span class="line">    CBCTL0 |= CBIPEN + CBIPSEL_0; <span class="comment">//比较器施恩那个，设置输入通道CB0为P6.0</span></span><br><span class="line">    CBCTL1 |= CBPWRMD_0; <span class="comment">//设置为高速模数</span></span><br><span class="line">    CBCTL2 |= CBRSEL; <span class="comment">//使用VREF作为反相端的参考电压</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置高低两个阈值电压 */</span></span><br><span class="line">    CBCTL2 |= CBRS_1 + CBREF13; <span class="comment">//以VCC为参考电压，CBREF1=8，VREF=VCC/4</span></span><br><span class="line">    CBCTL2 |= CBREF04 + CBREF03; <span class="comment">//VREF0=VCC * 3/4</span></span><br><span class="line">    </span><br><span class="line">    CBCTL3 |= BIT0; <span class="comment">//打开Comp_B</span></span><br><span class="line">    CBCTL1 |= CBON; <span class="comment">//使能比较器</span></span><br><span class="line">    __delay_cycles(<span class="number">75</span>); <span class="comment">//等待比较器内部参考电压达到稳定</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(CBCTL1 &amp; CBOUT) <span class="comment">//如果CBOUT为高电平</span></span><br><span class="line">        &#123;</span><br><span class="line">            P7OUT = <span class="number">0x00</span>; <span class="comment">//LED点亮</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            P7OUT = <span class="number">0xFF</span>; <span class="comment">//LED熄灭</span></span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码在输入电压大于VREF0=3/4 VCC时CBOUT输出高电平，LED点亮；输入电压小于VREF0=1/4 VCC时CBOUT输出低电平，LED熄灭；当电压在二者之间时，CBOUT状态不变，起到了稳定输出的作用</p>
<p>同样的比较器也可以产生中断信号，在检测到设定的跳变沿（上升沿或下降沿）后触发中断，进入对应的中断服务函数，可以在其中判断比较器输出的电平，避免了轮询</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CBCTL1 |= CBPWRMD_1 + CBF + CBFDLY_3; <span class="comment">//普通模式，选择中断边压，使用输出滤波</span></span><br><span class="line"><span class="comment">/* 在中间设置其他比较器参数 */</span></span><br><span class="line"><span class="comment">/* 等待一定时间来让参考电压稳定 */</span></span><br><span class="line">CBINT &amp;= ~(CBIFG + CCBIIFG); <span class="comment">//清除错误中断标志</span></span><br><span class="line">CBINT |= CBIE + CBIIE; <span class="comment">//使能比较器输出中断和输出反相中断</span></span><br><span class="line">__bis_SR_register(LPM0_bits + GIE); <span class="comment">//开启全局中断</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=COMP_B_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">Comp_B_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(__even_in_range(CBIV, <span class="number">4</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//无中断</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//中断CBIFG</span></span><br><span class="line">            <span class="keyword">if</span>(CBCTL1 &amp; CBOUT) <span class="comment">//判断是否输出高电平</span></span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">//反相中断CBIIFG</span></span><br><span class="line">            <span class="keyword">if</span>(!(CBCTL1 &amp; CBOUT)) <span class="comment">//反相端需要相反的判断</span></span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里仅列出中断服务函数和其开启方式</p>
<h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><p>msp430的DMA最多有8个通道，但是msp430f5529只有3个通道</p>
<p>基本使用方法和stm32的DMA完全一样，四种模式、单传输、块传输、连续传输都和stm32的传输方法类似，但设置更为简单</p>
<p>一个使用DMA进行UART传输的例子如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> String1[] = &#123;<span class="string">&quot;Hello World\r\n&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW + WDTHOLD; <span class="comment">//停看门狗</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 端口配置 */</span></span><br><span class="line">    P4SEL = BIT4 + BIT5; <span class="comment">//配置P4.4、P4.5为Tx、Rx端口</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* 配置USCI_A1为UART模式 */</span></span><br><span class="line">    UCA1CTL1 = UCSSEL_1; <span class="comment">//使用ACLK为时钟源</span></span><br><span class="line">    <span class="comment">//控制分频器设置波特率为9600</span></span><br><span class="line">	UCA1BR0 = <span class="number">0x03</span>; <span class="comment">//分频器高八位</span></span><br><span class="line">    UCA1BR1 = <span class="number">0x0</span>; <span class="comment">//分频器低八位</span></span><br><span class="line">    UCA1MCTL = UCBRS_3 + UCBRF_0; <span class="comment">//调制器UCBRSx = 3</span></span><br><span class="line">    UCA1CTL1 &amp;= ~UCSWRST; <span class="comment">//启动设备</span></span><br><span class="line">    <span class="comment">/* 配置DMA */</span></span><br><span class="line">    DMACTL0 = DMA0TSEL_1; <span class="comment">//以定时器TA0CCR0 CCIFG为触发源</span></span><br><span class="line">    </span><br><span class="line">    __data16_write_addr((<span class="keyword">uint16_t</span>)&amp;DMA0SA, (<span class="keyword">uint32_t</span>)String1); <span class="comment">//源地址：String1字符串</span></span><br><span class="line">    __data16_write_addr((<span class="keyword">uint16_t</span>)&amp;DMA0DA), (<span class="keyword">uint32_t</span>)&amp;UCA1TXBUF); <span class="comment">//目标地址：UART发送缓存区域</span></span><br><span class="line">	</span><br><span class="line">	DMA0CTL = DMADT_4 + DMASRCINCR_3 + DMASBDB +DMAEN; <span class="comment">//重复单传输，递增模式，字节到字节，并使能DMA</span></span><br><span class="line">    <span class="comment">/* 配置定时器 */</span></span><br><span class="line">    TA0CCR0 = <span class="number">8192</span>; <span class="comment">//字符传输频率=32768/8192=4 字节/s</span></span><br><span class="line">	TA0CTL = TASSEL_1 + MC_1; <span class="comment">//使用ACLK作为时钟源，采用增模式</span></span><br><span class="line">    __bis_SR_register(LPM0_bits); <span class="comment">//进入LPM3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序会连续向外以9600波特率发送串口数据</p>
<h3 id="电源管理"><a href="#电源管理" class="headerlink" title="电源管理"></a>电源管理</h3><p>msp430f5529的电源管理模块PMM由监督器SVS和监视器SVM组成</p>
<p>SVS是强制要求的，用于保障设备稳定运行</p>
<p>SVM是宽松可编程的，用于进行一些低功耗控制和安全保障</p>
<p>可以通过对SVM编程提高VCORE来支持更高的MCLK，也就是所谓的<strong>超频</strong></p>
]]></content>
      <tags>
        <tag>电赛笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>电路设计从入门到弃坑1【基础晶体管】</title>
    <url>/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/</url>
    <content><![CDATA[<h1 id="电路设计从入门到弃坑1【基础晶体管】"><a href="#电路设计从入门到弃坑1【基础晶体管】" class="headerlink" title="电路设计从入门到弃坑1【基础晶体管】"></a>电路设计从入门到弃坑1【基础晶体管】</h1><p>最基础的电路是由无源元件，即电阻、电容、电感三者构成的电路，两端通电后可以产生一个暂时稳定的电信号。不论是机缘巧合还是为了验证实验，曾经的物理学家开始注意到电的特殊性质，并加以研究，他们最先对电的性质进行探寻，从风筝实验到电磁感应定律一点点理解了电磁运作的原理，于是电气工程就出现了。然而到19世纪末为止，一直都只有无源电路的存在，电路的分析理论也仅有基础的电磁感应定律和由麦克斯韦方程组衍生出的基尔霍夫定律——直到20世纪的工程师发明出真空管，开启电子电路的时代。电路从最初使用电能和磁场能来控制、转化其他能量这个单一用途，进一步拓展出使用电信号来描述、控制其他信号，乃至使用电信号进行计算的用途。实现这些功能的基础就是具有控制功能的有源器件，也就是常说的二极管、三极管等元件。现代的半导体晶体管在20世纪中期才被发明出来，在此之前承担电子信号变换作用的元件一直是真空管。</p>
<h2 id="真空管"><a href="#真空管" class="headerlink" title="真空管"></a>真空管</h2><p>在半导体材料被发明之前，人们都使用电子管或者说真空管对电路进行操控，现代的半导体技术实质上还是在使用半导体达到真空管的用途，只不过因为半导体材料可以在硅片上进行制造，大大缩小了电路体积——但是它们的用途是相似的</p>
<p>现在真空管已经被市场淘汰，剩下的也不过成了爱好者们的玩具，不过理解真空管有助于了解二极管、三极管等基本的晶体管在电路中起到的作用</p>
<p>电子管主要分为：二极管、三极管、五极管、束射管、复合管等，听上去和半导体器件很相似</p>
<p>二极管是其中最简单的，它中间装有两个电极，一个是由金属丝制成用于发射电子的阴极，另一个是接收电子的屏极。给阴极通电，电流会将金属加热，管内已经被抽成了真空，因此金属丝就能发射电子，屏极则负责将这些电子接收。</p>
<p>在屏极接高电势，阴极接低电势时，屏极会主动吸引阴极发出的电子。一般来说二极管的加热部件是独立的，围绕在阴极周围，如下图所示（图b为电路符号，K为阴极，a为屏极，两个f表示加热部件）</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210814022541069.png" alt="image-20210814022541069"></p>
<p>因此实际上会有很多（效率懂得都懂，但是当时能用就行）电子从阴极到达屏极；反之在屏极接低电势，阴极接高电势时，电子的发射会被抑制——这就造成了二极管具有<strong>单向导电性</strong></p>
<p>基于PN结的二极管实际上也是起到单向导电性的作用，只不过由于引入了半导体技术，它的功能更加丰富、复杂了（实际上前人们也使用了很多方法改进真空管让它们做到现在半导体二极管的功能——毕竟第一台电子计算机都是用真空管制造的）</p>
<p>容易看出，这个大二极管具有一个致命的问题：功耗大得离谱，这玩意实际上就是个电灯泡——工作时常常能达到外壳100多度，用手摸一下就能烫熟的那种……这就是真空管的通病了：它们都需要使用额外的电热丝来让金属发出电子，而半导体管则不需要这些</p>
<p>再来看三极管：<img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210814023224226.png" alt="image-20210814023224226"></p>
<p>它中间多了一个栅极g——这个称呼也被保留到了后来的场效应管中——可以通过控制栅极来实现控制阴极-屏极电流，这也是双极结型晶体管和场效应管的共同原理和要达到的目的：<strong>用一个电流/电压控制另一个电流/电压</strong></p>
<p>值得指出的是：真空三极管的很多特性与专有名词被移植到了晶体三级管上，如果学完了三极管/晶体管再来学另一个，会感到很熟悉</p>
<p>真空管中还有一个较三极管更复杂的分支——五极管。他在三极管的栅极和屏极之间插入另外两个电极，于是栅极被分成了<em>控制栅极</em>、<em>帘栅极</em>和<em>抑制栅极</em>，这个器件主要用于减少的真空三极管中超大寄生电容和超量漂移电流的影响，从而能够实现“<strong>高频开关和放大</strong>”（在当时确实是高频）的开关，第一台电子计算机中也大多用了五极管配合继电器进行开关</p>
<p>最后需要提的就是束射管（至于复合管嘛，管如其名），它就是高中物理里面大名鼎鼎示波管的父类——通过将高速电子流打在荧光屏上实现显示功能，使用周边的电磁铁来控制显示的位置</p>
<p>不过束射管还有很多其他变种，辉光管、荧光管等上世纪苏联时代的遗产都是束射管的成员，它们大都利用加热器-金属灯丝-荧光材料/电子射线的原理进行发光显示信息，可以说是现代发光二极管的鼻祖了</p>
<p>利用这些真空管，前人们也制造出了放大器、振荡器、线性电源乃至开关电源等设备，其耐用性甚至能把一部分使用现代技术的设备打趴下。比起教科书中从半导体物理直接讲起，个人认为晶体管这种”朴素“的老古董更能体现模拟电路的本质——<strong>通过支路量操控支路量，从而实现模拟电信号的变换</strong></p>
<p>而真空管中的几个基本元件的性质也会在晶体管元件上得到体现</p>
<ul>
<li>二极管——单向导电与反向击穿</li>
<li>三极管——电流放大与开关控制</li>
</ul>
<h2 id="二极管"><a href="#二极管" class="headerlink" title="二极管"></a>二极管</h2><blockquote>
<p>我再用真空管，诺伊斯就是个伞兵！——肖克利（他没说过）</p>
</blockquote>
<p>简单了解过真空管，我们再来看看现代半导体科技的结晶，<strong>晶体管</strong></p>
<p>首先要谈的就是二极管了。不过要看懂现代半导体科技，就要从它们的基础——半导体材料开始。由于本篇的重点在于半导体器件，所以这里仅进行笼统的概括。我们先从二极管的物理基础<strong>PN结</strong>看起。</p>
<h3 id="二极管就是PN结"><a href="#二极管就是PN结" class="headerlink" title="二极管就是PN结"></a>二极管就是PN结</h3><p>半导体材料（硅/锗）的单质都是很难导电的，因为其中的电子和空穴浓度相等，即使外加电压，也会很快形成电流的动态平衡；然而这种平衡容易随着外界环境改变而改变，通过向纯净的半导体材料中掺入受控量的N型杂质和P型杂质，可以分别得到<strong>N型半导体</strong>和<strong>P型半导体</strong>，这种技术称为<strong>掺杂</strong></p>
<blockquote>
<p>N型杂质就是氮族元素（IVA族），它们的最外层电子数为5；P型杂质则是硼族元素（IIIA族），它们的最外层电子数为3</p>
<p>显而易见，N型杂质的掺杂会导致自由电子数量增多，半导体的载流子为多子，即自由电子，这就是为什么它被称为<strong>N</strong>egative；相反地，P型杂质的掺杂会导致空穴数量增多，半导体的载流子为多子，即空穴，这也是为什么它被称为<strong>P</strong>ositive</p>
<p>使用能带理论可以解释多子导电：导带中的电子就是载流子，能够导电；而空穴作为电子反向移动（跃迁）的等效，也可以等效地导电。相关内容可以参考《半导体物理》教材或本博文的参考书《模拟电子系统设计指南（基础篇）：从半导体、分立元件到TI集成电路》</p>
</blockquote>
<p>幼儿园的小朋友都知道，半导体材料的导电性容易受到外界温度、光照等因素影响。这是因为在特定温度热平衡的条件下，对特定的半导体材料，电子浓度$n_o$和空穴浓度$p_o$的乘积始终为常数，公式如下：$n_o * p_o = n_i^2$</p>
<blockquote>
<p>电子在核外的量子分布状态成为<strong>状态密度</strong>；电子的能量分布称为<strong>费米函数</strong></p>
<p>费米函数可以表明电子占据特定允态能级的概率，而它的值是由当前温度T和<strong>费米能级</strong>$E_F$决定的，表达式如下：<br>$$<br>f(E)=\frac{1}{1+e^{(E-E_F)/kT}}<br>$$<br>当T=0K时，可以发现所有低于费米能级的允态能级会被填充；高于费米能级的允态能级则会空出</p>
<p>当T有一个大于0K的确定值时，上式就存在一个极限值，并且填充态和空态之间出现了过渡，随着温度升高，这个极限值会逐渐降低，这就导致<strong>导带中热平衡的电子浓度会随着导带能级与温度变化而变化</strong>，表达式如下<br>$$<br>n_0=N_Ce^{-(E_C-E_F)/kT}<br>$$<br>参数$N_C$表示导带中的有效态密度函数，它的值仅由半导体材料的有效质量和温度确定</p>
</blockquote>
<p>根据上式不难得出：在温度稳定的条件下，半导体材料的本征浓度为常数</p>
<p>一般地，把两种不同的体系合二为一时，载流子可以互相流动；但是热平衡的时候一定会形成统一的费米能级，这是因为出现了载流子浓度交换，因此可以<strong>把掺杂的过程看作使费米能级变化进而改变导带宽度的过程</strong>；由此也可以推断出光照和温度也会让导带宽度变化，进而影响半导体材料导电性</p>
<p>说完了P型和N型半导体，终于能谈到PN结了——二极管归根结底就是一个封装起来的PN结，通过控制PN结的物理性质就可以制造出不同种类的二极管</p>
<p>PN结的物理性质十分复杂，这里我们只讲<em>简化的PN结模型</em></p>
<p>在一个晶格内，将P型和N型半导体连接在一起就形成了PN结，电子会从N区扩散到P区，空穴会从P区扩散到N区，因此在二者的接触区附近，电子和空穴会复合抵消，将其称为<strong>耗尽区</strong>或<strong>空间电荷区</strong>——在特定温度的热平衡条件下，不施加额外能量，电子或空穴是不能通过PN节的；同时由于在结的两侧存在相反的电荷，这就建立了一个穿越PN结的电场</p>
<p>当没有给PN结施加额外能量时，耗尽区会阻挡电流形成，不过仍然会存在微弱的电流穿过耗尽区，根据方向分为<strong>正向扩散电流</strong>和<strong>反向漂移电流</strong>；如果在外部对PN结两端施加正向电场，使得耗尽区内电场被抵消，空穴和电子就能够自由流动，在此过程中耗尽区越厚，所需要施加的外部能量就越大</p>
<blockquote>
<p>想象一种极端情况，将P型半导体的掺杂浓度提升到极限，甚至将其换成金属，那么电子便会自由地从P区向N区扩散，但是随着扩散，P区的电子浓度会逐渐变低，反而会形成一个从N区到P区的势垒，这一过程是动态平衡，这个势垒就是大名鼎鼎的肖特基势垒，利用贵金属和N型半导体就可以制成<em>肖特基二极管</em>，它的原理和结型二极管十分相似，但是最后的产物完全不一样：加正向电压时肖特基势垒会变窄而导致其内阻减小，这一性质导致它具有正向压降低的优点</p>
</blockquote>
<p>虽然二极管耗尽区的这个电场（一般称为内建势垒或内电场）很强，能抑制多子的运动，但是P区的少子电子会因此漂移到N区；N区的少子空穴也会穿过PN结到达P区，二者引起的电流分别称为正向扩散电流和反向漂移电流，二者大小相等、方向相反</p>
<p>因此，PN结也就是二极管的最根本、最基础特性就是<strong>单向导电性</strong></p>
<h3 id="从伏安特性出发"><a href="#从伏安特性出发" class="headerlink" title="从伏安特性出发"></a>从伏安特性出发</h3><p>回想一下真空管时代我们都用真空二极管干了什么？拿它单向导电和反向稳压！当年肖克利老爷子准备了一份真空管的伏安特性，然后对着面前的硅片就开始研究：怎么让这破玩意弄得像真空管一样？我们也先从伏安特性出发，理解二极管的性质</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210828014723118.png" alt="image-20210828014723118"></p>
<ul>
<li><p>正偏曲线</p>
<p>  二极管的P极接高电势、N极接低电势，即<strong>正偏</strong>，在这个情况下二极管的伏安特性曲线近似于指数函数</p>
<p>  二极管正偏伏安特性曲线如下所示：</p>
<p>  <img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210828014716192.png" alt="image-20210828014716192"></p>
<p>  U<del>ON</del>为<strong>二极管导通电压，硅管约为0.7V，锗管约为0.3V</strong>。因为二极管导通电压相对较低，而导通后电流升高速度很快，在$2 * U_{ON}$后就可以看作是短路状态，因此也常使用二极管的简化模型：当电压&lt;0V（或导通电压）时二极管关断，当电压&gt;0V（或导通电压）时二极管导通且为短路</p>
<blockquote>
<p>顺带一提，锗二极管虽然导通电压更低，但是已经基本被市场淘汰了，因为</p>
<ol>
<li>锗稳定性不好、提炼加工困难导致其一致性难以保证</li>
<li>价格更高</li>
<li>难以在硅片上集成</li>
</ol>
<p>同样遭遇的还有锗三极管，它的结压降也是约为0.3V（甚至视型号不同会更低一些），但是因为制造工艺和品控问题早早停产，只有一些HiFi发烧友在使用锗器件来达到更好的放大性能</p>
<p>特别地，<strong>锗管反向饱和电流为μA级，硅管则为nA级</strong>，显然硅管的截止更彻底</p>
</blockquote>
</li>
<li><p>反偏曲线</p>
<p>  之前没有说二极管PN结<strong>反偏</strong>（P极接低电势，N极接高电势）的结果：当阴极电压比阳极电压高时，会形成一个由阴极到阳极的外电场，电流根本不会产生，但是如果这个电压逐渐增高，甚至能够抵消耗尽区的内电场时，二极管就会被<strong>击穿</strong>，击穿时，整个晶体管内会产生大量电子-空穴对，电流会达到最大，换句话说此时二极管近似于短路，在这个过程中二极管会因为电流而剧烈发热，但是<strong>这并不意味着二极管损坏</strong>，如果再撤销这个反向电压，二极管还是会因为内电场重新建立而恢复原状。</p>
<blockquote>
<p><strong>材料掺杂浓度较低的PN结中</strong>，当PN结反向电压增加时，空间电荷区中的电场随之增强。这样通过空间电荷区的电子和空穴就会在电场作用下，使获得的能量增大。在晶体中运行的电子和空穴将不断与晶体原子发生碰撞，通过这样的碰撞可使被束缚在共价键中的键电子碰撞出来，产生自由电子-空穴对。紧接着新产生的载流子会在电场作用下撞出其他价电子，又产生新的自由电子-空穴对。如此连锁反应，使得空间电荷区中的载流子的数量雪崩式（也可以理解为链式反应）增加，流过PN结的电流就急剧增大击穿PN结，这种碰撞电离导致击穿称为<strong>雪崩击穿</strong></p>
<p>而在<strong>材料掺杂浓度较高的PN结中</strong>，耗尽区本来就比较薄，而在此时反偏一个强电场，这就是的耗尽层内中性原子的价电子会被快速拉出，成为自由电子，同时产生空穴，这个过程被称为<strong>场致激发</strong>。在场致激发的影响下二极管内会产生大量载流子，因此出现反向击穿的现象，这种击穿一般需要的外部能量较雪崩击穿更少，被称为<strong>齐纳击穿</strong></p>
</blockquote>
<p>  事实上能够损坏二极管的只有高温和外部破坏。因为<strong>导带中热平衡的电子浓度会随着导带能级与温度变化而变化</strong>，温度越高，热平衡电子浓度越高，越难以导电，而当反向击穿积聚的热量无法被释放时，二极管会被烧毁。二极管的反偏伏安特性如下所示：</p>
<p>  <img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210828013041349.png" alt="image-20210828013041349"></p>
<p>  U<del>BR</del>表示<strong>击穿电压</strong>（分为<strong>雪崩电压</strong>和<strong>齐纳电压</strong>），I<del>S</del>为漏电流（反向饱和电流），可见当二极管反偏时，在击穿电压范围内电流会达到很小，而超过击穿电压后，通过二极管的电流就会迅速增大（一般雪崩击穿电流增大速率比齐纳击穿更快）</p>
</li>
<li><p>特别的，可以使用公式<br>  $$<br>  i=I_s(e^{\frac{u}{U_T}}-1)<br>  $$<br>  近似表示二极管的伏安特性</p>
</li>
</ul>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol>
<li><p>单向导电性</p>
<p> 二极管的单向导电性应该不用多介绍，大家品鉴的足够多了。一般利用这个性质，可以实现二极管的半桥整流或<strong>全桥整流</strong>（对于三相电可以使用三相桥整流），用于将交流信号变成脉动的直流信号。对于单相交流信号，可以直接在变压器中间抽头，用两个背对背的二极管就可以实现全桥整流</p>
<p> 还可以利用这个性质实现<strong>boost电路</strong>（倍压整流）来进行DC-DC升压；对于高频信号则可以使用类似的电路（二极管后接电阻和并联的电容，前接激励源）实现<strong>包络检测</strong>，从高频调制的信号中提取低频信号</p>
<p> 在一般电路中应用比较多的就是<strong>钳位电路</strong>和<strong>削波电路</strong>，可以通过两个二极管分别连到VCC和GND端防止某个节点的电压偏高/过低，但是应该注意要在二极管同一支路串接保护电阻防止泄放电流过大</p>
<p> 因为二极管可以起到改变高频信号偏置电流的作用（因为它的正向电容可以在一定程度上滤除高频信号），所以可以使用它和分压电阻、电容实现压控衰减器，示例电路如下</p>
<p> <img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210828023423864.png" alt="image-20210828023423864"></p>
</li>
<li><p>反偏稳压性</p>
<p> 如果二极管反向电压超过击穿电压时，它会工作在击穿去，反向电流迅速增加，但电压基本不变，因此可以在保证二极管不过热的情况下让二极管在击穿区实现稳压功能，通过专门设计的，在击穿区内有着陡峭特性曲线（利用齐纳击穿特性）的二极管成为齐纳二极管，也就是俗称的稳压二极管</p>
<blockquote>
<p>一般来说稳压二极管都会有很高的掺杂浓度，这是因为稳压管利用了齐纳击穿而不是雪崩击穿：雪崩击穿所需的外部电压一般相当高，击穿时会很快产生巨大的电流，在这种情况下二极管的结温非常难以控制，因此一般的二极管一旦出现雪崩击穿基本就意味着烧毁；但是齐纳击穿的击穿电压相对较低，而且它的击穿伏安特性更平滑，只要在外接一个电阻用于控制击穿电流就可以相对容易地实现稳压</p>
</blockquote>
</li>
<li><p>反偏变容性</p>
<p> 耗尽层相当于PN两块半导体之间的绝缘体，因此二极管存在寄生电容（<em>结电容</em>）；又因为外加电压时耗尽层厚度会发生变化，因此二极管的寄生电容就会发生变化——通过在某一侧只掺入微量杂质，可以实现一个相当厚的耗尽区，如果此时对二极管反偏，这个耗尽区厚度会很容易变化，由此达到<strong>变容二极管</strong>的作用</p>
</li>
<li><p>温度敏感性</p>
<p> 因为导带中热平衡的电子浓度会随着导带能级与温度变化而变化，所以<strong>反向饱和电流</strong>会对温度敏感——会<strong>随温度增加而快速增加</strong>。其次，<strong>温度升高，二极管正向压降减小，正向工作电流增大，</strong>这是因为温度升高会导致耗尽区的原子共价键不稳定，更容易被外加电场激发出自由电子-空穴对</p>
</li>
<li><p>耗尽电容与扩散电容</p>
<p> 高频交流信号下，二极管中的耗尽层会演变成一个以硅为电介质的平行板电容器，对应的电容被称为<strong>耗尽电容</strong>。它会随二极管反向偏压而变化。</p>
<p> 当二极管正片时，由于耗尽层附近区域会有过量少子电荷聚集，出现电荷存储效应，局部的电荷浓度出现了不平衡，这就相当于又引入了一个电容，被称为<strong>扩散电容</strong>，它的大小与PN结点的横截面积成正比，一般为10-100pF</p>
<p> 利用这两个电容可以推导出二极管的高频小信号模型：正偏时一个小电阻并两个电容；反偏时一个大电阻并一个电容（耗尽电容）</p>
</li>
</ol>
<p>其实还有发光二极管、肖特基二极管等多种结构的二极管，它们都有自己的特点，但是暂且不作介绍</p>
<h3 id="电路应用"><a href="#电路应用" class="headerlink" title="电路应用"></a>电路应用</h3><p>下面给出1n4148二极管（来自安森美）的datasheet</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210828021027904.png" alt="image-20210828021027904"></p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210828021038170.png" alt="image-20210828021038170"></p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210828021047611.png" alt="image-20210828021047611"></p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210828021054300.png" alt="image-20210828021054300"></p>
<p>常见的参数都已给出，1n4148是通用性的开关二极管，电路设计中主要需要参考其击穿电压（100V）、最大正向电流（200mA）、峰值电流（400mA）、工作温度（-55到175）、功率（500mW）、漏电流（0.025uA-5uA）、开关频率（或者说恢复时间）（4ns）</p>
<p>可见它的开关频率比较高，但耐压相对一般，也缺少反向击穿稳压的能力，因此适合用作开关二极管或检波二极管的替代品</p>
<h2 id="三极管"><a href="#三极管" class="headerlink" title="三极管"></a>三极管</h2><blockquote>
<p>一个有源器件可以通过一个电信号控制其他电信号——真空三极管告诉电气工程师的遗言</p>
</blockquote>
<p>三极管又称<strong>双极结型晶体管</strong>，也就是所谓的<strong>BJT</strong>（Bipolar Junction Transistor）</p>
<p>特别地，“晶体管”——Transistor实际上是贝尔实验室对跨导变阻器（Transconductance Varistor）的简称</p>
<h3 id="三极管与二极管"><a href="#三极管与二极管" class="headerlink" title="三极管与二极管"></a>三极管与二极管</h3><p>为了实现电信号的相互控制，三端器件是必须的。对于一个三端器件，我们一般通过双端口网络模型进行分析。对于三极管，更适合使用双端口网络的T参数和H参数矩阵进行描述——但这太学术了！从直观上理解<strong>三极管就是一个水龙头</strong></p>
<p>我们先来看需要三端元件做什么：首先它要使用一端的电压/电流进行控制，就假设这个三端元件有ABC三个端口，要想在A端口产生这个电压/电流，就要找到一个地，因此三端元件一定需要一个接地点，让另外两端到这一端产生电流。暂且假设这个接地点是B——既然有电流产生，根据基尔霍夫电流定律，A端流入和C端流入电流之和就是B端流出的电流。一切都解释的通了：A端通过AC之间的电流/电压控制BC之间的电流/电压，这不就是一个受控源吗！我们将AC之间的电流/电压与BC之间电流/电压的比值记作<strong>增益β</strong>，不难看出<strong>β&lt;1</strong>恒成立，换个角度，这其实就是T参数矩阵中的一个参数</p>
<p>这就能解释三极管是水龙头这个比喻了：通过扭动水龙头把手可以可以控制水流的大小</p>
<p>对于三极管来说，他正是使用电流控制电流，A端被称为<strong>基极</strong>，记为<strong>b</strong>（<strong>B</strong>ase），B端称为<strong>发射极e</strong>极（<strong>E</strong>mitter），C端称为<strong>集电极c</strong>极（<strong>C</strong>ollector）。<strong>be电流控制ce电流</strong>。以下部分都会使用e、b、c三个极的简写形式</p>
<h3 id="一点简单的原理"><a href="#一点简单的原理" class="headerlink" title="一点简单的原理"></a>一点简单的原理</h3><p>三极管有两种大类型：<strong>NPN</strong>和<strong>PNP</strong>。它们的名字来源于其中“结”的排列顺序。它们的大致结构和电路符号如下所示：</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210831003431811.png" alt="image-20210831003431811"></p>
<p>BJT使用c和e极作为电流源端，b作为电流控制端，<strong>电路符号中的箭头表示器件处于正向有源状态时的电流方向</strong></p>
<p>目前PNP和NPN两种晶体管都被大量生产，但是相对而言NPN型生产效果更好——半导体中电子的流动性比空穴流动性更强，NPN的内部具有两个N型半导体区，所以它内部的电子浓度更高，可以达到更高的工作速度和承载更大电流。对于NPN管而言，共e极模式下，c极将基极注入的小电流放大输出；其他条件下，<strong>当E<del>b</del>&gt;E<del>e</del>时，晶体管c、e导通</strong>；PNP管与其相反，共射模式下，c极将离开b极的小电流放大输出，而<strong>当E<del>b</del>&lt;E<del>e</del>时，晶体管c、e导通</strong></p>
<p>实际上三极管的原理比较复杂，但在这里我们主要讨论的是其电气性质，所以只用NPN举例简单解释一下。正如其命名，BJT是由两个PN结构成的，其中电荷载流子穿过两个不同电荷浓度区域PN结时会发生双向扩散，这就导致了BJT的内电流。一个BJT的剖面图如下所示</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210831004908286.png" alt="image-20210831004908286"></p>
<blockquote>
<p>原谅我的灵魂画作</p>
</blockquote>
<p>可以发现<strong>BJT成型于c极底座，面积很大，b极被做得很薄且具有极低的掺杂浓度，e极则被控制在较高的掺杂浓度</strong>。这么做主要有以下几个原因：</p>
<ol>
<li>让e极可以很容易地被be电压激发出电子</li>
<li>让b极容易被穿过</li>
<li>c极可以完整接住来源于e极的电子</li>
</ol>
<p>可以发现整个流程和真空三极管的发射电子-控制电子-接收电子有异曲同工之妙。特别地，e极电子作为多子向b极扩散后，本来是少子的b极电子浓度大增，会自发向电子浓度相对较低的c极扩散，因此BJT被划分为少子载流元件</p>
<blockquote>
<p>顺便一提场效应管FET是多子载流元件，这就是为什么FET能承受相对更大的电流，这个话题按下不表</p>
</blockquote>
<p>当b极和e极加正向电压时，e极高浓度电子被快速激发，直接在电场作用下达到e极，而如果没有其他电源，这些电子会自行穿过b极进入外电路；但是一旦施加了更高（大于E<del>ce</del>）的电压，这些电子中的绝大多数就会进入c极（因为c极的面积比b极大得多），随后进入外电路。生产中为了降低在到达c极之前被空穴中和掉电子的百分比和被b极电压“吸引走”电子的百分比，b区就被做得很薄了</p>
<blockquote>
<p>有些人在学习模电不久后觉得三极管就是两个二极管的简单串联，只不过多加了一个控制功能，这种想法是完全<strong>错误</strong>的！</p>
</blockquote>
<p>一般在模拟电路设计中，认为c极电流是b极电流的线性函数，也就是大名鼎鼎的<strong>β</strong>；但是对于更精确的BJT电路，需要使用电压控制模型，或者说<strong>EM（Ebers-Moll）模型</strong>，需要考虑一个指数函数<br>$$<br>I_C=I_S(e^{\frac{qV_{BE}}{kT}-1})<br>$$<br>这个模型基于三极管的物理模型建立，相对精确。V<del>BE</del>可以被描述为$V_{BE}=\frac{kT}{q} ln \frac{I_C}{I_S}$</p>
<p>使用这个模型的一个优点在于可以将三极管建模成跨导：电压控制，跨导和集电极电流成比例关系，常用于SPICE模型仿真和高频电路的理论计算中</p>
<p>上面提到了<strong>β值</strong>，这可以说是三极管最重要的性能指标了，它的正式名称为<strong>共射极电流增益</strong>，<strong>在正向有源区近似于c极直流电流和b极直流电流的比值</strong>；另一个重要参数是<strong>共基极电流增益α</strong>，<strong>在正向有源区近似于从发射极到集电极的电流增益</strong>，其值一般接近于1。相关公式如下<br>$$<br>\alpha=\frac{I_C}{I_E} \<br>\beta=\frac{I_C}{I_B} \<br>I_E=I_B+I_C \<br>\beta=\frac{\alpha}{1-\alpha} \<br>\alpha=\frac{\beta}{1-\beta}<br>$$</p>
<blockquote>
<p>BJT是非对称器件，因此当把c、e极互换后BJT会工作在反向有源模式，一般不会这样使用BJT，它的内部结构也为正向有源模式进行了优化。在CMOS制造工艺中，常常使用低性能的“横向”对称BJT，这是为了平衡成本（硅片面积）和性能</p>
</blockquote>
<p>在应用方面，可以直接通过三极管的工作电流电压测出其β值：$\beta=\frac{\Delta i_c}{\Delta i_b}$</p>
<p><strong>三极管的be结电阻</strong>也是一个重要参数，它需要使用半导体物理的公式得出：<br>$$<br>R_{BE}=r_{bb’}+\frac{26mV}{I_{BQ}}<br>$$<br>其中r<del>bb’</del>是三极管的基区电阻，这是一个大致在100~200Ω之间的常数，只与三极管的制造工艺有关，它加上PN结电阻，也就是后面那部分就可以得到be结总电阻了</p>
<h3 id="很多复杂的性质"><a href="#很多复杂的性质" class="headerlink" title="很多复杂的性质"></a>很多复杂的性质</h3><p>因为很复杂，所以跳过！</p>
<p>三极管的性质太多了，而这些性质造就了它的多种用途。可以说现代中小功率模拟电路就是建立在三极管之上的；而大功率模拟电路则被场效应管所掌控</p>
<p>下一部分会详细讲述三极管的基本应用。这里先了解一下三极管的基本工作区域和输入输出性质（以NPN为例）</p>
<p>BJT有5个不同的工作区，列举如下：</p>
<ol>
<li><strong>正向有源（正偏）</strong>：V<del>c</del>&gt;V<del>b</del>&gt;V<del>e</del>，$I_C=\beta I_B$，水龙头把手在开合范围内，可以控制水流大小。be结正偏，bc结反偏</li>
<li><strong>饱和（完全导通）</strong>：V<del>b</del>&gt;V<del>e</del>，V<del>c</del>&lt;V<del>b</del>，b极电压超过了c极电压，就像是手把水龙头开到最大，水龙头把手都扭歪了，自然水会喷涌而出，这时三极管c极电流会达到最大。所有PN结正偏，常用于实现逻辑电路中的开关闭合</li>
<li><strong>截止</strong>：V<del>b</del>&lt;V<del>e</del>，水龙头被关上，BJT的c极电流近似于0，属于漏电流；e极电流则近似等于b极电流。所有PN结反偏，可以实现逻辑电路中的开关断开</li>
<li><strong>反向有源（反偏）</strong>：V<del>c</del>&lt;V<del>b</del>&lt;V<del>e</del>，反向电流通过三极管，相当于把c、e极对调。实际中很少使用该模式，因为β值会小得多，相当于三极管内阻被放大了。集成电路中可能会在某些地方用到（大概）</li>
<li><strong>雪崩击穿</strong>：俗称炸管，一般来说三极管被击穿会直接烧毁，因为两个PN结的性质不可能完全一致，这就导致但凡电流过大一点，一个PN结不会被烧毁，另一个一定会被烧掉！三极管的耐压规定了ce、be电压的最大值，选型前一定要注意</li>
</ol>
<p>PNP型三极管的性质和NPN型的性质正好对偶，有兴趣的读者可以自行证明PNP三极管的相关性质</p>
<blockquote>
<p>自证不难</p>
</blockquote>
<p>下面是经典的小信号通用三极管S8050的datasheet</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210831013945373.png" alt="image-20210831013945373"></p>
<p>它使用了经典的TO-92封装，在很多收音机里都能见到这个NPN开关管的身影。</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210831014034027.png" alt="image-20210831014034027"></p>
<p>耐压be 5V；ce 20V；cb 30V。也就是说最好驱动电压不要超过5V，如果使用独立电源为三极管供电，电源也不能超过20V</p>
<p>c极电流700mA，算是开关管里面比较大的，能够驱动一些小型的功率设备了</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210831014222806.png" alt="image-20210831014222806"></p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210831014318634.png" alt="image-20210831014318634"></p>
<p><strong>开关管是指用于充当开关元件的三极管</strong>，也就是说它会工作在截止-导通两个状态下，因此其最重要属性就是开关频率，其次才是增益</p>
<p>而<strong>功率管是指专门用于功率放大的三极管</strong>，它会一直工作在正偏状态下，其最重要属性是增益</p>
<p><strong>通用管是指介于二者之间，能够在一定范围内通用使用的三极管</strong>，在各种各样的电路里都能见到这种三极管，它们的性能指标比较均衡，一般来说两个不同型号的通用管是很有可能相互取代的</p>
<p>可以从output capacitance输出电容看出s8050的开关频率：1MHz下为9pF，一般来说工作在几十kHz可以达到更低的电容量，属于工作在中频的三极管。它的增益在120到400之间，取200的中间值，属于放大性能一般的三极管。s8050就是这样一个中庸的三极管，各种地方都能使用，因此它的出货量很大，价格便宜。生产商也很多。</p>
<p>**DC Current Gain指的就是β值了，在大多数数据手册里面，这个参数被称为$h_{FE}$或$HFE$**，可以看出这个管子的β在120~400，算是性能中庸的</p>
<p>特别提一下current gain bandwidth product电流增益带宽积：放大器带宽和带宽的增益的乘积，在频率足够大时是一个常数，三极管的CGBP其实没有什么用，<em>在高频运算放大器中可以指示放大器的性能</em></p>
<h2 id="场效应管"><a href="#场效应管" class="headerlink" title="场效应管"></a>场效应管</h2><p>场效应管（FET，Field Effet Transistor）和三极管一样，同属于晶体管大家族，其中比较常用的就是MOSFET金属氧化物半导体场效应管（Metal Oxide Semiconductor Field Effect Transistor），它常常以互补金属氧化物半导体（CMOS，Complementary Metal Oxide Semiconductor）的形式出现在数字集成电路中，抑或是以直插功率元件的形式出现在开关电源里。下面对它进行简单的介绍（<em>下面全部使用简称</em>MOSFET或JFET）</p>
<p>由于MOSFET涉及的知识点较多，在这里只进行总体介绍，在后面的博文里会详细谈到MOSFET相关内容</p>
<h3 id="电场效应"><a href="#电场效应" class="headerlink" title="电场效应"></a>电场效应</h3><p>就像四大天王有五个一样，三端元件MOSFET有四个端子，除了<strong>源极s</strong>（<strong>S</strong>ource）、<strong>栅极g</strong>（<strong>G</strong>ate）、<strong>漏极d</strong>（<strong>D</strong>rain）外，还有一个俗称<em>衬底</em>的<strong>体极b</strong>（<strong>B</strong>ody）。一般来说衬底是连接到源极的，因此它表面上和其他三端元件一样。</p>
<p>MOSFET与BJT不同，是电压控制电流器件，它通过施加在栅极上的电压来控制从源极到漏极的电流；同时MOSFET是多子载流器件。BJT需要的开启电流大，开启电压小，能提供给负载的驱动电流也较小；但是MOSFET开启电压大，开启电流小（漏电流也相当小），可以给负载提供很大的电流</p>
<blockquote>
<p>你知道吗？高铁、电磁炮、<del>御坂美琴</del>常用于控制电流的绝缘栅双极型晶体管IGBT就是用三极管和MOSFET复合而成的，其中三极管负责对信号进行放大，通过特制的续流二极管芯片进行隔离，驱动负责导通/关断大电流的MOSFET，兼顾了MOSFET的高输入阻抗和BJT的低导通压降，同时由于是复合管，增益直接爆炸。将其与外围电路封装成模块，常用于控制400V、100A及以上的强电系统！</p>
</blockquote>
<p>MOSFET分为四种：N沟道-P沟道、增强型-耗尽型。这里先不解释它们的含义，我们先来看它的结构：</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901010858481.png" alt="image-20210901010858481"></p>
<p>MOSFET就是一个沿用了真空管三极称呼的器件：因为它本质上就是一个使用电场效应替代电子射线的真空管。解释一下它的名称由来：</p>
<ul>
<li>M代表Metal金属，曾经MOSFET使用金属材料制作栅极，但是现在处于生产便利考虑使用<strong>多晶硅</strong>，因为它能生成自对齐的栅极。现在只有高频MOSFET才会使用金属栅极来提高工作速度（事实上当前速度最快的FINFET工艺采用的仍是硅晶体，在某种程度上说金属应该是个“误解”）</li>
<li>O代表氧化物，目前这也变成了一个“误区”，因为现代的MOSFET会使用各种不同的绝缘材料，目前比较常用的其实是高k绝缘体。这样做的原因只有一个：降低MOSFET的开启电压，提高s-d电流，尽可能降低g极漏电流。<strong>使用xx nm衡量半导体工艺，一般来说这个长度是指MOSFET的沟道宽度</strong>，因为<em>沟道宽度</em>（在之后会解释沟道）减少时，漏电流就会增加；反之，漏电流减少、供电电压降低，意味着MOSFET的性能得到提高</li>
<li>S代表半导体，现代MOSFET的制作工艺就基于半导体材料：在硅衬底顶部生长一层硅氧化物（或其他什么绝缘/半导材料），再沉淀一层金属或多晶硅，就能获得传统的MOSFET了。现在一些厂商开始在MOSFET的沟道中使用硅和锗的化合物，也有一些科研人员在探索新的半导体材料（石墨烯、氮化镓等等），并将其应用在MOSFET上。</li>
<li>FET：场效应，就是所谓的“电场效应”。传统MOSFET等效于一个电容器，一个电极是半导体硅衬底，一个电极是多晶硅。这里先考虑使用的衬底是P型半导体（作为b极），当给金属/多晶硅（作为g极）施加外电压（正电压）时，带有正电荷的空穴就会远离g极和氧化物的中间区域，但是因为整体是个电容，电荷并不会从g极流出。这就创造了一个<strong>耗尽层</strong>，在这个区域里自由载流子无法移动。当g-b电压足够大时，会在靠近半导体和绝缘体之间薄薄一层形成高浓度的负电荷载流子区域，称为<strong>反转层</strong>。将反转层内电子体积密度和体内空穴密度相等的电压称为<strong>阈值电压</strong>。当g-b电压超过阈值电压时，就会形成反转层，此使MOSFET开启，对应的电压称为<strong>开启电压</strong>。而通过外加g-b电压形成反转层导致MOSFET开启的这个过程就称为<strong>电场效应</strong>。</li>
</ul>
<p>真空三极管使用通电的灯丝放出电子流；MOSFET使用场效应开启反转层，在氧化物绝缘层下方生成一个载流子浓度极高可以导电的区域</p>
<p>真空三极管使用栅极（实质上是通过栅极外加电压）控制到达屏极的电子数量，从而控制电流；MOSFET使用栅极电压控制场效应的强度，进而控制反转层的载流子浓度，从而控制s-d电流。</p>
<p>真空三极管的阴极和阳极具有单向导电性；MOSFET的d极和b极（衬底）之间存在一个寄生二极管，某种程度上也存在单向导电性</p>
<p>从上面可以看到MOSFET的性质和真空管的性质十分接近，这也是它沿用了栅极名称的原因之一。</p>
<p>MOSFET的原理就是利用g极的电场效应在绝缘层下方开启一个导电沟道，从而让s-d极能够导电。<strong>增强型MOSFET</strong>就是指随着g极电场增强，进入沟道的载流子增多，导电性增加；<strong>耗尽型MOSFET</strong>则是利用一个<em>表面掺杂层</em>中的载流子构成导电沟道，随着g极电场增强，外电场会抵消掉来自表面掺杂层的载流子，导电性减弱。在g极和衬底之间施加电压时，电场会先导致半导体层中出现电荷分离的情况，根据<strong>衬底中半导体掺杂</strong>的不同，可将MOSFET分为PMOS和NMOS。<strong>NMOS</strong>结构就是上述过程所形容的；而<strong>NMOS</strong>在被施以外部电场时，电子作为少子会被聚集在氧化物底层，但是因为密度太小并不能形成反转层，因此NMOS必须施加<em>b正g负</em>的反向电场，这样多子空穴会聚集并形成反转层。上面的四个MOSFET结构可以组合起来，成为四种基本的MOSFET</p>
<ul>
<li>增强型NMOS</li>
<li>耗尽型NMOS</li>
<li>增强型PMOS</li>
<li>耗尽型PMOS</li>
</ul>
<p>它们的电路符号如下所示：</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901020726001.png" alt="image-20210901020726001"></p>
<p>用一条竖线表示导电沟道，另一条短竖线表示g极的半导体</p>
<p>需要注意的是g极呈现“L”型，它的输入引脚更靠近s极，用来显著地指示方向——如果使用简化的图标，也要用箭头标明s极</p>
<p><strong>b极（s极）上会注明一个箭头，它永远指向从P到N的方向</strong>，因此它用来指示PMOS/NMOS（<strong>PMOS向外指；NMOS向内指</strong>，具体原因留给读者自行考虑）</p>
<blockquote>
<p>思考题答案：因为箭头永远指向N，只要沟道是N，那箭头就会指向沟道，也就是向内指了；P沟道则相反</p>
</blockquote>
<p>一般来说MOSFET会通过一个竖线将衬底和s极连在一起，如下图所示</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901021103401.png" alt="image-20210901021103401"></p>
<p>这就表示衬底和源极连在一起引出。</p>
<p>有的时候MOSFET会在d极和s极之间跨接一个二极管标识，这常用于开关电路或者高频电路中的MOSFET表示</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901021550063.png" alt="image-20210901021550063"></p>
<p>实际上这个二极管指的是MOSFET的<strong>寄生二极管</strong>，正是因为这个二极管，导致大功率下MOSFET具有一定的单向导电性和复杂电气特性</p>
<blockquote>
<p>大功率MOS管d极从硅片衬底底部引出，而s极被放在衬底底部的另一半，d极和s极都由不同种类的半导体材料制成，如下图所示</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901022016180.png" alt="image-20210901022016180"></p>
<p>这就导致了N-P-N之间出现了PN结，上图中左侧的PN结由于b-s短接而无效，右侧的b-&gt;d的PN结则相当于一个从b极接到d极的二极管，对于NMOS来说也是如此，<strong>总会存在一个与箭头方向（箭头指示P-&gt;N）相同的寄生二极管</strong></p>
</blockquote>
<p>寄生二极管并不是大功率MOSFET独有的，只要是NPN或PNP型的MOSFET都会存在PN结，只要有PN结就会或多或少存在寄生二极管。上图中s、d区是由不同于衬底的掺杂半导体制成的，这个工艺的原理在下面讲述</p>
<h3 id="增强型MOSFET"><a href="#增强型MOSFET" class="headerlink" title="增强型MOSFET"></a>增强型MOSFET</h3><p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901231358388.png" alt="image-20210901231358388"></p>
<p>上图是增强型N沟道MOS的结构，将N和P型半导体调换，即可得到增强型P沟道MOS的结构</p>
<p>一般使用W表示栅极宽度，使用L表示栅极长度，因为绝缘层非常薄，所以栅极长度和沟道长度近似相等，它也称为沟道宽度。<strong>栅极、源极、漏极之间的重叠区域要求保证反转层可以在源极和漏极之间形成连续的导电通道，为了减少寄生电容，这个重叠区域要尽量小</strong>。现代的NMOS与传统MOSFET的最大不同就是通过引入两个P型半导体电极降低了沟道开启所需电压。</p>
<p>需要注意：一般N型半导体上方引出电极使用金属铝</p>
<p>PMOS和NMOS结构大同小异，二者最大的不同在于形成的导电沟道方向和寄生二极管方向——由于MOSFET内部N-P型半导体交界耗尽区而形成的沟道外延被称为<strong>诱生沟道</strong></p>
<p>增强型MOSFET的工作模式有以下几种：</p>
<ol>
<li><p><strong>截止模式</strong></p>
<p> V<del>GS</del>&lt;V<del>th</del>（阈值电压）。此时不会形成s-d之间的导电通路，也就是<strong>导电沟道无法开启</strong>。但是由于电子能量的玻尔兹曼分布，s极的一些高能量电子可以进入沟道并扩散到d极。同样的，理想情况下d-s电流应为0，但是存在<strong>弱反转电流</strong>，它与V<del>GS</del>-V<del>th</del>成正指数关系，与斜率因子n=1+耗尽层电容/氧化物层电容成负指数关系。在集成电路中，还需要考虑短沟道的<strong>漏极势垒降低</strong>（Drain Induced Barrier Lowering，<strong>DIBL</strong>）效应，这个效应的强弱和器件的几何形状、PN结掺杂等有关，这个效应既有利也有弊：微功耗模拟电路利用低于阈值条件的优势，使得MOSFET可以尽可能提供较高的跨导-电流比值，甚至能和BJT一较高下。但是一般情况下，低于阈值的伏安特性会导致产品一致性难以保证</p>
</li>
<li><p><strong>欧姆模式</strong>（线性模式、线性区）</p>
<p> 当$V_{GS}&gt;V_{th}$且$V_{DS}&lt;(V_{GS}-V_{th})$时，MOS闭合，<strong>导电沟道开启，但是没有完全开启</strong>。<em><strong>此时MOSFET就像一个电阻</strong></em>：s-d电流可以使用以下公式表述<br> $$<br> I_D=\mu_n C_{ox} \frac{W}{L} [(V_{GS}-V_{th})V_{DS} - \frac{V^2_{DS}}{2}]<br> $$<br> μ<del>n</del>表示电荷载流子有效迁移率，其他参数就是字面意思（请读者翻看上文并理解各个符号的含义）</p>
<p> 可以看出s-d电流和ds电压具有相关性，进一步推到可以发现这个曲线相当接近直线，也就是说在欧姆模式，MOSFET可以起到类似电阻的作用，从而实现电流-电压控制</p>
</li>
<li><p><strong>饱和模式</strong></p>
<p> 当$V_{GS}&gt;V_{th}$且$V_DS&gt;(V_{GS}-V_{th})$，生成一条沟道以允许在d极和s极之间流过电流，也就是<strong>导电沟道完全开启</strong>。由于d极电压大于g极电压，电子会顺势扩散，<em>在该工作模式下，MOSFET的d-s极近乎短路</em></p>
</li>
</ol>
<p>增强型MOSFET还有几个性质：</p>
<ol>
<li><p>转移特性    </p>
<p> s-d电压恒定时，测量g-s两端电压和d极电流之间的关系</p>
<p> 实际上就是二端口网络的转移特性矩阵实例</p>
<p> <img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901235023213.png" alt="image-20210901235023213"></p>
</li>
<li><p>输出特性</p>
<p> g-s电压恒定时，s-d电压和d极电流之间的关系（输出特性矩阵实例）</p>
<p> <img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901235011715.png" alt="image-20210901235011715"></p>
</li>
<li><p>温度特性</p>
<p> 随温度升高，流经d极的电流会逐渐下降</p>
</li>
</ol>
<h3 id="耗尽型MOSFET"><a href="#耗尽型MOSFET" class="headerlink" title="耗尽型MOSFET"></a>耗尽型MOSFET</h3><p>耗尽型MOSFET与增强型MOSFET原理上最大的不同就是它使用了实实在在的“沟道”</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901235247565.png" alt="image-20210901235247565"></p>
<p>如上图，耗尽型PMOS的两个P型半导体之间额外沉积了一层薄薄的P半导体沟道，因此PN结的耗尽层在沟道下方出现，当V<del>GS</del>&lt;0时，沟道中的空穴会被排斥出沟道进入耗尽层，并与其中的电子中和，这样使得P型半导体沟道中的载流子浓度大减，沟道会变窄——如果更进一步，沟道附近的衬底会称为缺P型，导电能力增强，但<strong>沟道的导电能力会变得近乎没有</strong>。这就实现了“耗尽”的目的。沟道失去导电性的瞬间称为“<strong>沟道夹断</strong>”</p>
<p>从应用上看，耗尽型MOSFET相当于对增强型MOSFET进行了“非运算”，高V<del>GS</del>会开启增强型MOS，但是会夹断耗尽型MOSFET</p>
<blockquote>
<p>利用增强型-耗尽型MOSFET的互补性可以实现MOSFET图腾柱电路：两个MOSFET的d-s极首尾相连，最上面的MOSFET的s极引出到电源，下面的MOSFET则引到地，这样使用一个“不高不低”的电压就能够实现放大作用；使用高/低电平则会让二者之一导通，实现最大的开关性能。该电路也可以使用NPN-PNP三极管对管或者NMOS-PMOS对管实现</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210902000134796.png" alt="image-20210902000134796"></p>
<p>这个电路常常被用来作为电机、功率设备的驱动电路，三个相同的电路接到三相电上还可以实现H桥架构，进而驱动三相电机</p>
</blockquote>
<h3 id="小号继电器"><a href="#小号继电器" class="headerlink" title="小号继电器"></a>小号继电器</h3><p>MOSFET因为较低的启动电压和高输入阻抗，常常被用来<strong>作为继电器在非隔离情形下的替代品</strong></p>
<p>但是由于MOSFET的导通电压一般比数字IC能提供的更高，所以在使用之前也应该在IO处接入一个光耦-三极管放大电路或者直接接入一个三极管推完结构进行电流、电压放大，从而让弱输出能够驱动MOSFET</p>
<p>使用方法还挺像继电器的，但是二者的性能、功耗可不一样——MOSFET的开关频率比继电器高出两个数量级，功耗也比继电器低多了，同时还不会造成太大的电路噪声干扰，如果遇到需要隔离但是功率不大的情况，应该优先选择MOSFET而不是继电器</p>
<h3 id="功率半导体器件"><a href="#功率半导体器件" class="headerlink" title="功率半导体器件"></a>功率半导体器件</h3><p>简单说一下达林顿管和IGBT吧</p>
<p><strong>达林顿管=叠在一起的三极管</strong></p>
<p><strong>IGBT=叠在一起的三极管和MOSFET</strong></p>
<p>实际上的达林顿管是使用集成电路工艺制造的，将多个三极管制造在同一片晶圆上。但是还会针对PN结的性能进行优化。比较特殊的就是<strong>达林顿管的极性和前面三极管的极性保持一致</strong>，而不管后续接入的三极管是什么极性。因此前面的小管被称为达林顿<strong>基管</strong>；后面的小管被称为达林顿<strong>放大管</strong>。达林顿管以最前面小管的基极为整管基极，以最后接入的三极管发射极为整管发射极，<strong>最后的放大倍数是所有叠加的三极管放大倍数的乘积</strong><br>$$<br>\beta = \beta_1 \beta_2<br>$$<br>因此，达林顿管的功率、发热都会非常大，常用于驱动小型继电器、舵机、直流电机等等</p>
<p>IGBT则是典型的模拟集成电路结晶。博采众长，结合了三极管的低导通压降和MOS管的高输入阻抗，在不超过限制电压电流的情况下可以直接作为继电器使用——不过还是要注意，它的输出和输入之间还是存在耦合电阻的！</p>
<p>IGBT的结构就是一个三极管和一个MOSFET竖向叠起来，从MOSFET最上层两个隔开的栅极上引出IGBT的E极，MOSFET的P区同时作为三极管的B极P区，但是在三极管基础上多增加了一层B极N区和N缓冲区，主要用于存储电子，最下面一层是P+层，从它上面引出IGBT的C极</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210930000527652.png" alt="image-20210930000527652"></p>
<p>如上图所示（N沟道增强型IGBT），MOSFET部分的N+区称为<strong>源区</strong>，附于其上的电极称为源极，被引出作为IGBT的发射极E；N基极又称<strong>漏区</strong>D。为了区分IGBT和MOSFET，将同位置引出的G极翻译成<strong>门极</strong>，与MOSFET不同，IGBT的门极是悬浮在绝缘介质中的，并直接引出。沟道会在紧靠门极的边界形成。C、E两极之间的P型区（包括P+和P-区）被称为亚沟道区，事实上的沟道在这个区域形成。在漏区另一侧的P+区称为<strong>漏注入区</strong>，它是IGBT特有的功能区，与漏区和亚沟道区一起形成PNP双极型晶体管，起到其中发射极E的作用，向漏极注入空穴，进行导电调制，以降低器件的导通电压。最后，附于漏注入区上的电极称为漏极（也就是对应三极管的集电极C）。</p>
<p>IGBT的开关作用是通过<strong>加正向栅极电压形成沟道</strong>，<strong>给PNP</strong>（原来为NPN，但经过与IGBT耦合后，极性反转）<strong>晶体管提供基极电流，使IGBT导通</strong>。反之，可以加反向门极电压消除沟道，切断基极电流，使IGBT关断。IGBT的驱动方法和MOSFET基本相同，只需控制输入极N-沟道MOSFET即可，毕竟它控制的电流的第一步就是驱动一个栅极,所以IGBT具有高输入阻抗特性。当MOSFET的沟道形成后，从P+基极注入到N-层的空穴（少子）对N-层进行电导调制，减小N-层的电阻，使IGBT在高电压时也具有相对较低的导通电压</p>
]]></content>
      <tags>
        <tag>电路设计</tag>
      </tags>
  </entry>
</search>
