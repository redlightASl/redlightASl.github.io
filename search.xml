<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Markdown基本语法</title>
    <url>/2021/11/14/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>

<p>例：</p>
<h1 id="你好"><a href="#你好" class="headerlink" title="你好"></a>你好</h1><h2 id="你好-1"><a href="#你好-1" class="headerlink" title="你好"></a>你好</h2><h3 id="你好-2"><a href="#你好-2" class="headerlink" title="你好"></a>你好</h3><h4 id="你好-3"><a href="#你好-3" class="headerlink" title="你好"></a>你好</h4><h5 id="你好-4"><a href="#你好-4" class="headerlink" title="你好"></a>你好</h5><h6 id="你不好"><a href="#你不好" class="headerlink" title="你不好"></a>你不好</h6><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>Markdown 可以使用以下几种字体：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*斜体*</span><br><span class="line">_斜体_</span><br><span class="line">**粗体**</span><br><span class="line">__粗体__</span><br><span class="line">***粗斜体***</span><br><span class="line">___粗斜体___</span><br></pre></td></tr></table></figure>

<p>为了方便可以统一记为*是强调符号，一对为斜体，两对为更加强调的粗体，三对是非常强调的粗斜体</p>
<p>例：<br><em>苍茫的天涯是我的爱</em><br><em>月亮之上</em><br><strong>无他，唯手熟耳</strong><br><strong>1d100=100【大失败】</strong><br><em><strong>提桶跑路</strong></em><br><em><strong>讲个笑话，钓鱼佬今天没空军</strong></em></p>
<h2 id="高亮强调"><a href="#高亮强调" class="headerlink" title="高亮强调"></a>高亮强调</h2><p>用四个等于号=包围需要强调的内容即可实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==独轮车 tskk 独轮车==</span><br></pre></td></tr></table></figure>

<p>例：</p>
<p>==独轮车 tskk 独轮车==</p>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>用三个或以上*号单独成行表示分割线</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">***</span><br></pre></td></tr></table></figure>
<p>例：</p>
<hr>
<p>下面是【数据删除】个星号*写的，猜猜有什么特殊的地方？</p>
<hr>
<p>显然 用很多*写出分割线可以在代码层面增加你文章的气势，具体原因留给读者自行证明</p>
<h2 id="上标与下标"><a href="#上标与下标" class="headerlink" title="上标与下标"></a>上标与下标</h2><p>用两个^表示上标<br>用两个~表示下标</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1919^114514^</span><br><span class="line"> 今天~也是好天气~</span><br></pre></td></tr></table></figure>
<p>例：<br>1919^114514^<br>今天<del>也是好天气</del></p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--注释内容--&gt;</span><br></pre></td></tr></table></figure>
<p>表示注释<br>例：</p>
<!--肖战必糊-->
<p>虽然什么也没有显示<br>但这里确实有注释，我也并没有在注释里骂人</p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>Markdown 支持有序列表和无序列表。</p>
<p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 第一项</span><br><span class="line">* 第二项</span><br><span class="line">* 第三项</span><br><span class="line"></span><br><span class="line">+ 第一项</span><br><span class="line">+ 第二项</span><br><span class="line">+ 第三项</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 第一项</span><br><span class="line">- 第二项</span><br><span class="line">- 第三项</span><br></pre></td></tr></table></figure>
<p>例：</p>
<ul>
<li>第一项</li>
</ul>
<ul>
<li>第二项</li>
</ul>
<ul>
<li>第三项</li>
</ul>
<p>为了记忆简单，可统一记为*后面接空格意味着一个无序列表项</p>
<hr>
<p>有序列表使用数字并加上 . 号来表示，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 第一项</span><br><span class="line">2. 第二项</span><br><span class="line">3. 第三项</span><br></pre></td></tr></table></figure>
<p>例：</p>
<ol>
<li>amdyes!</li>
<li>nvidia!fxxkyou!</li>
<li>intel还在做cpu？</li>
</ol>
<h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个<strong>空格</strong>符号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 区块引用</span><br><span class="line">&gt; 衬衫的价格是9镑15便士</span><br><span class="line">&gt; 下面你将听到</span><br></pre></td></tr></table></figure>

<p>另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 最外层</span><br><span class="line">&gt;&gt; 第一层嵌套</span><br><span class="line">&gt;&gt;&gt; 第二层嵌套</span><br></pre></td></tr></table></figure>

<h3 id="列表中使用区块"><a href="#列表中使用区块" class="headerlink" title="列表中使用区块"></a>列表中使用区块</h3><p>如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 第一项</span><br><span class="line">    &gt; 传统markdown要讲码德</span><br><span class="line">    &gt; 在这里劝这位年轻码农耗子尾汁</span><br><span class="line">* 第二项</span><br><span class="line">	&gt; 芜湖</span><br><span class="line">	&gt; &gt; 起飞 &lt;!--中间加不加空格都行--&gt;</span><br><span class="line">	&gt;&gt;&gt; 飞飞飞</span><br></pre></td></tr></table></figure>

<ul>
<li>第一项<blockquote>
<p>传统markdown要讲码德<br>在这里劝这位年轻码农耗子尾汁</p>
</blockquote>
</li>
<li>第二项<blockquote>
<p>芜湖</p>
<blockquote>
<p>起飞<!--中间加不加空格都行--><br>are u good 马来西亚</p>
<blockquote>
<p>飞飞飞</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`printf()` 函数</span><br></pre></td></tr></table></figure>

<h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><p>代码区块使用 <strong>4 个空格</strong>或者一个<strong>制表符（Tab 键）</strong>。</p>
<p>也可以用 ```包裹一段代码，并指定一种语言（也可以不指定）：</p>
<p>在大多数Markdown编辑器中，```旁边可以加语言名字添加对应的语法高亮</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```javascript</span><br><span class="line">$(document).ready(function () &#123;</span><br><span class="line">    alert(&#x27;RUNOOB&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 链接</span><br><span class="line"></span><br><span class="line">链接使用方法如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80">链接名称</a></p>
<p>或者</p>
<p>&lt;链接地址&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">例如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 哦我的老伙计，瞧瞧这条链接<br>  <a href="https://www.runoob.com/">感谢菜鸟教程提供部分资料（其实是大部分）</a><br> 或<a href="https://wosuibianzhaogewangzhan.com/">https://wosuibianzhaogewangzhan.com</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[感谢菜鸟教程提供部分资料（其实是大部分）](https://www.runoob.com)</span><br><span class="line"></span><br><span class="line">或&lt;https://wosuibianzhaogewangzhan.com&gt;</span><br><span class="line"></span><br><span class="line">### 高级链接</span><br><span class="line"></span><br><span class="line">可以通过变量来设置一个链接，变量赋值在文档末尾进行：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>用 1 作为网址变量 <a href="http://www.pornhub.com/">pxxnhub</a><br>用 rua 作为网址变量 <a href="https://space.bilibili.com/15810">Rua</a><br>然后在文档的结尾为变量赋值（网址）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[pxxnhub][1]</span><br><span class="line">[Rua][rua]</span><br><span class="line"></span><br><span class="line">[1]: http://www.pornhub.com/</span><br><span class="line">[rua]: https://space.bilibili.com/15810</span><br><span class="line">## 图片</span><br><span class="line"></span><br><span class="line">Markdown 图片语法格式如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/14/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/%E6%88%91%E4%B9%9F%E4%B8%8D%E7%9F%A5%E9%81%93%E8%AF%A5%E6%94%BE%E4%BB%80%E4%B9%88%EF%BC%8C%E7%9E%8E%E5%86%99%E5%90%A7" alt="介写了个嘛玩意"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 开头一个感叹号 !</span><br><span class="line">- 接着一个方括号，里面放上图片的替代文字</span><br><span class="line">- 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 &#x27;title&#x27; 属性的文字。</span><br><span class="line"></span><br><span class="line">//抱歉没有例子，奇怪的图片发出来的话，人生就要结束了（悲）</span><br><span class="line"></span><br><span class="line">Markdown 还没有办法指定图片的高度与宽度，如果需要的话，可以使用普通的 \&lt;img\&gt; 标签。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img src="/2021/11/14/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/原文这里是runoob的一张图" width="50%">
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 表格</span><br><span class="line"></span><br><span class="line">Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。</span><br><span class="line"></span><br><span class="line">语法格式如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
| 表头   | 表头   |
| ------ | ------ |
| 单元格 | 单元格 |
| 单元格 | 单元格 |
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 对齐方式</span><br><span class="line"></span><br><span class="line">**我们可以设置表格的对齐方式：**</span><br><span class="line"></span><br><span class="line">* -: 设置内容和标题栏居右对齐。</span><br><span class="line">* :- 设置内容和标题栏居左对齐。</span><br><span class="line">* :-: 设置内容和标题栏居中对齐。</span><br><span class="line">例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
| 左对齐 | 右对齐 | 居中对齐 |
| :----- | -----: | :------: |
| 单元格 | 单元格 |  单元格  |
| 单元格 | 单元格 |  单元格  |
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## HTML 元素</span><br><span class="line"></span><br><span class="line">不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</span><br><span class="line"></span><br><span class="line">目前支持的 HTML 元素有：`&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;`等 ，如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑</span><br><span class="line"></span><br><span class="line">## 转义</span><br><span class="line"></span><br><span class="line">Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
**文本加粗** 
\*\* 正常显示星号 \*\*
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
\   反斜线
`   反引号
*   星号
_   下划线
{}  花括号
[]  方括号
()  小括号
#   井字号
+   加号
-   减号
.   英文句点
!   感叹号
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 公式</span><br><span class="line"></span><br><span class="line">当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。</span><br><span class="line"></span><br><span class="line">不过这个东西和渲染器有关，对于不同编辑器可能会不支持某些latex特性</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
$$
思考题：\lim_{x\rarr 0}\frac{tanx}{x+sinx} =?
$$

<p>$$<br>\frac{dx}{dt}=v<br>\mathbf{V}_1 \times \mathbf{V}_2<br>$$</p>
<pre><code>
$$
思考题：\lim_&#123;x\rarr 0&#125;\frac&#123;tanx&#125;&#123;x+sinx&#125; =?
$$

$$
\frac&#123;dx&#125;&#123;dt&#125;=v
\mathbf&#123;V&#125;_1 \times \mathbf&#123;V&#125;_2
$$

## 非常感谢菜鸟教程runoob.com提供了好多代码，本人也是在这学的markdown
 链接如下：

[菜鸟教程](https://www.runoob.com)
 十分适合新手学习各种语言和开发技巧，虽然讲解思路比较跳跃，但胜在详细
</code></pre>
]]></content>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>Tcl脚本基础</title>
    <url>/2021/11/14/Tcl%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="Tcl脚本在IC领域的主要用途"><a href="#Tcl脚本在IC领域的主要用途" class="headerlink" title="Tcl脚本在IC领域的主要用途"></a>Tcl脚本在IC领域的主要用途</h1><h2 id="复杂文本处理"><a href="#复杂文本处理" class="headerlink" title="复杂文本处理"></a>复杂文本处理</h2><p>Tcl可以把文本中的每一行变为一个<strong>列表</strong>，最简单的列表就是包含由任意个空格、制表符、换行符分隔开的任意多个元素的字符串，可以直接根据元素编号来获取字符串内容</p>
<p>Tcl也支持正则表达式</p>
<h2 id="自动化执行flow"><a href="#自动化执行flow" class="headerlink" title="自动化执行flow"></a>自动化执行flow</h2><p>对于一些流程化的flow，可以编写Tcl脚本来自动执行，一键得到结果和report</p>
<h2 id="辅助EDA开发"><a href="#辅助EDA开发" class="headerlink" title="辅助EDA开发"></a>辅助EDA开发</h2><p>Tcl易上手、使用简便，可以简便地设计图形化界面；也可以针对大型项目设计EDA辅助工具</p>
<h1 id="Tcl脚本简介"><a href="#Tcl脚本简介" class="headerlink" title="Tcl脚本简介"></a>Tcl脚本简介</h1><p>Tcl即Tool command language工具控制语言，读作Tickle</p>
<p>Tcl包含了一个脚本语言和一个库包：Tcl脚本主要用于发布命令给交互程序，语法简单、扩展性强；Tcl库可以被嵌入应用程序，它包含了一个分析器、用于执行内建命令的例程和一个可以允许用户扩充的库函数。使用Tcl库，应用程序可以产生Tcl命令并执行，命令可以由用户产生，也可以从用户接口的输入中读取，Tcl库收到命令后将他分解并执行内建的命令。</p>
<p>目前大部分EDA工具都支持Tcl语言，如Design Complier、quartus、Synplify、modesim、finesim等，Tcl在IC设计中非常常用</p>
<p>Tcl程序有两种运行方式，一种是将程序写入脚本中，通常以.tcl命名；另一种是在tcl命令行中直接执行</p>
<h2 id="Tcl解释器"><a href="#Tcl解释器" class="headerlink" title="Tcl解释器"></a>Tcl解释器</h2><p>Tcl是解释型语言，与Python、Perl等类似，它依靠Tcl脚本语言解释器工作，逐行执行Tcl命令，遇到错误时它会停止运行</p>
<p>helloworld程序如下：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/tclsh</span></span><br><span class="line"><span class="keyword">puts</span> <span class="string">&quot;helloworld&quot;</span></span><br></pre></td></tr></table></figure>

<p>在shell中如下执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tclsh hello.tcl <span class="comment"># Unix</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> tclsh hello.tcl <span class="comment"># Windows</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Tcl数据类型"><a href="#Tcl数据类型" class="headerlink" title="Tcl数据类型"></a>Tcl数据类型</h2><p>Tcl只支持<strong>字符串</strong>数据类型：所有命令、参数、命令结果、变量等都是字符串</p>
<p>==字符串的实际解释依赖于上下文==</p>
<p>Tcl允许使用字符串组合出多种高级数据类型</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/tclsh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> a hello</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$a</span></span><br><span class="line"><span class="keyword">set</span> b <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="keyword">set</span> c &#123;hello world&#125;</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$b</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$c</span> # 这里b和c打印的值都是 hello world</span><br></pre></td></tr></table></figure>

<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p><strong>使用一组单词与双引号、中括号或者大括号的组合表示列表</strong>，如下所示：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/tclsh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> myVariable &#123;red green blue&#125; # <span class="keyword">set</span> listName [<span class="keyword">list</span> item1 item2 item3] 中括号、大括号都可以</span><br><span class="line"><span class="keyword">puts</span> [<span class="keyword">lindex</span> <span class="variable">$myVariable</span> <span class="number">2</span>]</span><br><span class="line"><span class="keyword">set</span> myVariable <span class="string">&quot;red green blue&quot;</span></span><br><span class="line"><span class="keyword">puts</span> [<span class="keyword">lindex</span> <span class="variable">$myVariable</span> <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>注意：==Tcl的列表以0为第一个元素的坐标==，所以以上输出为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> blue</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> green</span></span><br></pre></td></tr></table></figure>

<p>使用<code>append</code>或<code>lappend</code>命令追加项目到列表</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">append</span> 列表名 原来的项目 追加项目 # 或 <span class="keyword">lappend</span> 列表名 追加项目</span><br></pre></td></tr></table></figure>

<p>使用<code>llength</code>变量控制列表的长度</p>
<p>使用<code>lsort</code>命令排序列表</p>
<p>使用<code>lreplace</code>替换列表项，如下所示</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/tclsh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> var &#123;orange blue red green&#125;</span><br><span class="line"><span class="keyword">set</span> var [<span class="keyword">lreplace</span> <span class="variable">$var</span> <span class="number">2</span> <span class="number">3</span> black white]</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$var</span> # 输出 orange blue black white （第<span class="number">3</span>、<span class="number">4</span>个列表项被替换为了black、white）</span><br></pre></td></tr></table></figure>

<p>使用<code>lassign</code>将列表的值赋值给变量，如下所示</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/tclsh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> var &#123;orange blue red green&#125;</span><br><span class="line"><span class="keyword">lassign</span> <span class="variable">$var</span> colour1 colour2</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$colour1</span> # 输出 orange</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$colour2</span> # 输出 blue</span><br></pre></td></tr></table></figure>

<h3 id="关联数组（字典）"><a href="#关联数组（字典）" class="headerlink" title="关联数组（字典）"></a>关联数组（字典）</h3><p>可以使用以下形式创建关联数组，或者说<strong>键值对（字典）</strong></p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/tclsh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>  marks(english) <span class="number">80</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$marks</span>(english) # 输出 <span class="number">80</span></span><br><span class="line"><span class="keyword">set</span>  marks(mathematics) <span class="number">90</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$marks</span>(mathematics) # 输出 <span class="number">90</span></span><br></pre></td></tr></table></figure>

<p>特别地，==Tcl的键值对不要求索引（键）是整数==</p>
<p>使用<code>dict set 字典名 键 值</code>来格式化创建字典</p>
<p>使用<code>dict size</code>获取字典的大小</p>
<p>使用以下方法遍历字典</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/tclsh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> colours [<span class="keyword">dict</span> create colour1 <span class="string">&quot;black&quot;</span> colour2 <span class="string">&quot;white&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> item [<span class="keyword">dict</span> keys <span class="variable">$colours</span>] &#123;</span><br><span class="line">    <span class="keyword">set</span> value [<span class="keyword">dict</span> get <span class="variable">$colours</span> <span class="variable">$item</span>]</span><br><span class="line">    <span class="keyword">puts</span> <span class="variable">$value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或以下方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/tclsh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> colours [<span class="keyword">dict</span> create colour1 <span class="string">&quot;black&quot;</span> colour2 <span class="string">&quot;white&quot;</span>]</span><br><span class="line"><span class="keyword">set</span> values [<span class="keyword">dict</span> values <span class="variable">$colours</span>]</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$values</span></span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> black</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> white</span></span><br></pre></td></tr></table></figure>

<p>使用以下方法(<code>dict exists</code>)检索字典</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/tclsh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> colours [<span class="keyword">dict</span> create colour1 <span class="string">&quot;black&quot;</span> colour2 <span class="string">&quot;white&quot;</span>]</span><br><span class="line"><span class="keyword">set</span> result [<span class="keyword">dict</span> exists <span class="variable">$colours</span> colour1]</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$result</span> # 输出 <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h3><p>TCL句柄通常用于表示文件和图形对象，也可以包括句柄网络请求以及其它流设备，如串口、套接字或I/O设备</p>
<p>使用例如下</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> myfile [<span class="keyword">open</span> <span class="string">&quot;filename&quot;</span> r]</span><br></pre></td></tr></table></figure>

<h2 id="Tcl基本语法"><a href="#Tcl基本语法" class="headerlink" title="Tcl基本语法"></a>Tcl基本语法</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>使用<code>#</code>作为单行注释</p>
<p>如果第一个非空字符是<code>#</code>，这一行的所有东西都是注释</p>
<p>特别地，可以使用条件判断语句作为多行注释，不过这样会影响代码可读性</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下面是多行注释</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">0</span> &#123;</span><br><span class="line">这里是注释</span><br><span class="line">这里也是注释</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">puts</span> <span class="string">&quot;test&quot;</span> <span class="comment">;# 这里是行内注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是单行注释</span></span><br></pre></td></tr></table></figure>

<h3 id="标示符"><a href="#标示符" class="headerlink" title="标示符"></a>标示符</h3><p>Tcl标识符是用来标识变量，函数，或任何其它用户定义的项目的名称。标识符开始以字母A到Z或a〜z或后跟零个或多个字母下划线（_），下划线，美元（$）和数字（0〜9），Tcl不允许标点字符，如@和％标识符，但可以使用转义或<code>&#123;&#125;</code>括起来使用标点字符；<strong>Tcl大小写敏感</strong></p>
<p><strong>Tcl的保留字不能用做变量名</strong></p>
<h3 id="空格与分隔"><a href="#空格与分隔" class="headerlink" title="空格与分隔"></a>空格与分隔</h3><p>Tcl解释器会忽略多余的<strong>空白格</strong>与注释行</p>
<p>Tcl中将<strong>空格、制表符</strong>、换行符、注释统称为<strong>空白格</strong>。空格分开声明中的一个组成部分，使解释器来识别</p>
<p>总体与shell脚本类似，格式自由</p>
<p><strong>Tcl中句与句之间以换行或分号分隔。如果每行只有一个语句，则分号不是必须的；如果一行中只包含空白格、注释，解释器则会忽略该行；在一个语句中，通过空格来分隔语句的不同部分</strong></p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>Tcl命令实际上是词语的列表。使用要执行表示该命令的第一个字</p>
<p>Tcl命令有以下特点：</p>
<ul>
<li>一个命令就是一个字符串</li>
<li><strong>命令用换行符或分号来分隔</strong></li>
<li>一个命令由许多的<strong>域</strong>组成，第一个域是命令名，剩下的域作为参数</li>
<li><strong>域通常由空格或制表符分割</strong></li>
</ul>
<h3 id="引用与替换"><a href="#引用与替换" class="headerlink" title="引用与替换"></a>引用与替换</h3><p>如下方法引用变量：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">$变量名</span><br></pre></td></tr></table></figure>

<p>如下方法展开命令或调用过程的值</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">[命令或调用过程]</span><br></pre></td></tr></table></figure>

<p>使用<code>\</code>将特殊字符转义</p>
<p>使用如下方法展开<code>[]</code>、<code>$</code>、<code>\</code>语句的内容</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;要展开使用内容&quot;</span></span><br></pre></td></tr></table></figure>

<p>使用如下方法将内容作为一个整体使用（但内部的特殊字符不会被展开或转义）</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">&#123;作为整体使用的内容&#125;</span><br></pre></td></tr></table></figure>

<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>使用<code>expr</code>表示后面的式子是数学表达式</p>
<p><strong>Tcl默认精度是12位</strong>，可以使用<code>tcl_precision</code>改变精度</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/tclsh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> variableA <span class="string">&quot;10&quot;</span></span><br><span class="line"><span class="keyword">set</span> tcl_precision <span class="number">5</span></span><br><span class="line"><span class="keyword">set</span> result [<span class="keyword">expr</span> <span class="variable">$variableA</span> / <span class="number">9.0</span>];</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$result</span> # 输出 <span class="number">1.1111</span></span><br></pre></td></tr></table></figure>

<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>使用<code>set</code>对变量进行赋值，使用<code>$</code>引用变量</p>
<p>综合示例如下：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/tclsh</span></span><br><span class="line"><span class="keyword">set</span> a <span class="number">114514</span><span class="comment">; # 把114514赋值给a</span></span><br><span class="line"><span class="keyword">set</span> b &#123;<span class="variable">$a</span>&#125;<span class="comment">; # 把$a赋值给b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">puts</span> <span class="string">&quot;test!&quot;</span><span class="comment">; # 打印出test!</span></span><br><span class="line"><span class="keyword">puts</span> a<span class="comment">; # 打印出字符a</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$a</span><span class="comment">; # 打印出114514</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$b</span><span class="comment">; #打印出$a 注意并不是114514</span></span><br></pre></td></tr></table></figure>

<p>字符串赋值见Tcl数据类型</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ol>
<li>算术运算符</li>
</ol>
<p>支持+ - * / %</p>
<p>与c一样</p>
<ol start="2">
<li>关系运算符</li>
</ol>
<p>与c一样</p>
<ol start="3">
<li>逻辑运算符</li>
</ol>
<p>与c一样</p>
<ol start="4">
<li>位运算符</li>
</ol>
<p>与c一样</p>
<ol start="5">
<li>三元运算符</li>
</ol>
<p>与c一样</p>
<ol start="6">
<li>运算符优先级</li>
</ol>
<table>
<thead>
<tr>
<th>分类</th>
<th>运算符</th>
<th>结合性</th>
</tr>
</thead>
<tbody><tr>
<td>正负号</td>
<td>+ -</td>
<td>Right to left</td>
</tr>
<tr>
<td>乘除法</td>
<td>* / %</td>
<td>Left to right</td>
</tr>
<tr>
<td>加减法</td>
<td>+ -</td>
<td>Left to right</td>
</tr>
<tr>
<td>移位</td>
<td>&lt;&lt; &gt;&gt;</td>
<td>Left to right</td>
</tr>
<tr>
<td>关系</td>
<td>&lt; &lt;= &gt; &gt;=</td>
<td>Left to right</td>
</tr>
<tr>
<td>位与</td>
<td>&amp;</td>
<td>Left to right</td>
</tr>
<tr>
<td>位异或</td>
<td>^</td>
<td>Left to right</td>
</tr>
<tr>
<td>位或</td>
<td>|</td>
<td>Left to right</td>
</tr>
<tr>
<td>Logical AND</td>
<td>&amp;&amp;</td>
<td>Left to right</td>
</tr>
<tr>
<td>逻辑或</td>
<td>||</td>
<td>Left to right</td>
</tr>
<tr>
<td>三元</td>
<td>?:</td>
<td>Right to left</td>
</tr>
</tbody></table>
<p>总体上来说和c语言运算符一致</p>
<h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><p>Tcl的if语法如下：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> &#123;布尔表达式&#125; &#123;</span><br><span class="line"><span class="comment">	# 表达式</span></span><br><span class="line">&#125; else <span class="keyword">if</span> &#123;布尔表达式&#125; &#123;</span><br><span class="line"><span class="comment">	# 表达式</span></span><br><span class="line">&#125; else <span class="keyword">if</span> &#123;布尔表达式&#125; &#123;</span><br><span class="line"><span class="comment">	# 表达式</span></span><br><span class="line">&#125; else <span class="keyword">if</span> &#123;布尔表达式&#125; &#123;</span><br><span class="line"><span class="comment">	# 表达式</span></span><br><span class="line">&#125; else &#123;</span><br><span class="line"><span class="comment">	# 表达式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和c语言不能说差别不大，只能说完全一样</p>
<p>甚至也可以使用switch语句</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> switchingString &#123;</span><br><span class="line">   matchString1 &#123;</span><br><span class="line">      body1</span><br><span class="line">   &#125;</span><br><span class="line">   matchString2 &#123;</span><br><span class="line">      body2</span><br><span class="line">   &#125;</span><br><span class="line">...</span><br><span class="line">   matchStringn &#123;</span><br><span class="line">      bodyn</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch语句也可以嵌套</p>
<p>循环语句则分成2种，和c语言一样的for与while，但是没有do while</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> &#123;condition&#125; &#123;</span><br><span class="line">   statement(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;initialization&#125; &#123;condition&#125; &#123;increment&#125; &#123;</span><br><span class="line">   statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>Tcl支持自定义函数，称为<strong>过程</strong>，语法如下</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">proc</span> 过程名 &#123;参数<span class="number">1</span> 参数<span class="number">2</span> ...&#125;</span><br><span class="line">&#123;	过程体</span><br><span class="line"><span class="keyword">return</span> 返回值&#125;</span><br></pre></td></tr></table></figure>

<p>参数之间用空白格分开</p>
<p>函数支持递归调用</p>
<p>不支持在函数内部定义函数</p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>Tcl支持内嵌正则表达式，<strong>正则表达式以命令形式使用</strong></p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/tclsh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">regexp</span> &#123;([A-Z,a-z]*)&#125; <span class="string">&quot;Tcl Tutorial&quot;</span> a b </span><br><span class="line"><span class="keyword">puts</span> <span class="string">&quot;Full Match: $a&quot;</span></span><br><span class="line"><span class="keyword">puts</span> <span class="string">&quot;Sub Match1: $b&quot;</span></span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line">Full Match:Tcl</span><br><span class="line">Sub Match1:Tcl</span><br></pre></td></tr></table></figure>

<p>Tcl提供了一些参数用于简便使用正则表达式</p>
<ul>
<li>-nocase 忽略大小写</li>
<li>-indices 匹配子模式，而不是匹配字符存储的位置</li>
<li>-line 新行敏感匹配。换行后忽略字符</li>
<li>-start index 搜索模式开始设置偏移</li>
</ul>
]]></content>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>《可定制计算》阅读笔记</title>
    <url>/2021/11/14/%E3%80%8A%E5%8F%AF%E5%AE%9A%E5%88%B6%E8%AE%A1%E7%AE%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="《可定制计算》阅读笔记"><a href="#《可定制计算》阅读笔记" class="headerlink" title="《可定制计算》阅读笔记"></a>《可定制计算》阅读笔记</h1><p>本笔记以基础概念为线索编写，黑体部分是关键字</p>
<span id="more"></span>

<ul>
<li><p><strong>登纳德缩放定律</strong>：晶体管在满足内电场恒定（即每代芯片的供电电压降低30%）条件下，晶体管尺寸每代（约两年）减少30%。</p>
<p>  结合该定律和摩尔定律可得推论：晶体管密度每代翻倍，同时晶体管延时降低30%，功耗降低50%，能耗降低65%</p>
<p>  换句话说，同面积下能集成晶体管的数目翻倍，带来功耗和频率的翻倍，就好像同面积的电路被缩放到原来的1/4</p>
<p>  但是到21世纪早期，由于量子效应，晶体管漏电功耗显著增加，登纳德定律逐渐失效</p>
</li>
<li><p><strong>定制计算</strong>：调整处理器结构以使其适应于某种特定应用领域的技术</p>
<p>  面对登纳德缩放定律失效、摩尔定律放缓，定制计算技术成为提高计算效率的关键技术之一</p>
<p>  往往可重构的定制计算电路可以使得能效得到1~2个数量级提升；而专用于某个领域的定制计算电路有时能够实现数百万倍的能效提升；同时引入<em>可重构性</em>并利用<em>可整合</em>的硬件加速其可以解决适用范围过窄的问题，现在常见的DSA（异构计算）就是这个思路的延伸</p>
</li>
<li><p><strong>暗硅</strong>：在多核cpu中并不是所有核心都会被使用，往往同时工作的只有其中小部分核心，其他核心因为功耗、发热等问题往往得不到应用，这部分电路被称为暗硅</p>
</li>
<li><p><strong>通用片上多处理器</strong>（Chip MultProcessor，CMP）：具有通用性的计算处理器，常见的CPU，如i9 11900k、r5 5600x等具有多核心的桌面级cpu都属于这个类型</p>
</li>
<li><p><strong>可定制异构平台</strong>（Customizable Heterogeneous Platform，CHP）：用于提供定制化计算服务的可定制的SoC</p>
<p>  一般CHP中包含四个部件：</p>
<ul>
<li>用于通用计算和控制逻辑的<strong>处理器核</strong></li>
<li>用于定制计算的硬件<strong>加速器</strong></li>
<li>用于辅助计算和低功耗控制的<strong>协处理器</strong></li>
<li>存储数据和程序的<strong>片上存储部件</strong></li>
</ul>
</li>
<li><p><strong>可重构硬件</strong>：流片之后依然可以被灵活调整的硬件</p>
<p>  硬件可以被重构的程度取决于重构的粒度，越小的重构粒度灵活性越大，但一般会造成性能下降和能效降低等额外开销</p>
<p>  传统的可重构硬件只有FPGA一种，它算作可细粒度重构的硬件，因此会比同算法的ASIC实现有更低的速率和更高的开销</p>
</li>
<li><p><strong>专用加速器</strong>：针对特定领域内有限的一组应用或算法进行优化的硬件</p>
<p>  早期的GPU、图像数据编解码器、加解密加速器等都属于加速器</p>
</li>
<li><p><strong>动态处理器核缩放和去特征化</strong>：选择性停用处理器核中的部件来节省能耗</p>
<p>  通用的做法是在内核中引入特定机器的寄存器，用来指示特定部件是否激活</p>
<p>  stm32f4的dsp和fpu就使用了这样的技术</p>
</li>
<li><p><strong>处理器核融合</strong>：使一个大核能够像真正的许多小核叠加工作一样的体系结构，可以动态适应不同数量的线程级或指令级的并行处理</p>
<p>  通过将处理器核拆成两部分实现：一个是窄发射宽度的常规处理器核，但是它的取指模块（Fetch Module）会被舍弃；另一部分是充当模块化的取指/译码/派发模块的额外部件，负责为每个处理器核心执行取指指令，或统一为多个处理器核提供指令。取指模块会使用宽读取引擎读取整个指令块并将它们分发给各个核心，流水线结束后，通过一个排序流水线步骤来让指令顺序写回</p>
</li>
<li><p><strong>定制指令集扩展</strong>：用特定工作负载中的新指令来让处理器快速分派任务到计算模块</p>
<p>  intel的AVX-512指令集就是这样增强CPU性能的（可惜并不怎么实用）</p>
<p>  商用处理器常使用的就是像SSE和AVX这种专用<em>向量指令</em>形式，允许简单的指令操作大量数据。现代高性能处理器一般都采用超标量架构，它能够实现指令集层面的并行化处理，利用的是<strong>单指令多数据流</strong>（SIMD）指令，也就是所谓的向量指令。为了通过一个指令控制多个数据的处理，需要引入一组新的寄存器和一组用于执行向量并行计算的ALU。x86指令集中，向量指令在4~16个元素的小向量上运行，主要用于执行浮点运算。超标量处理器还引入了基于通道的设计：多个小型计算引擎和寄存器元素并行参与计算，发出一条向量指令，所有通道都会接收该指令，因此可以并行化地执行大量重复计算的任务</p>
<p>  定制扩展指令集还可以通过<em>定制计算引擎</em>实现——一般的ALU只有乘法、加法、移位等功能，但是可以通过改变流水线的方式塞进乘除法器乃至专用的矩阵点乘叉乘电路</p>
<p>  <em>可重构指令集</em>也是其中一个解决方案，它允许程序编写自己的指令，但是往往需要编译器对定制指令支持才可行</p>
</li>
<li><p><strong>松耦合加速器</strong>：独立于处理器内核运行的粗粒度加速器，是与核心交互但是不固定在核上的粗粒度计算引擎，简称LCA</p>
<p>  LCA可以部署在片上或片外，PC上的cpu+显卡组合就是一个广义上的LCA架构；片上LCA没有物理邻接某个特定核心，但是可以被系统中所有核心共享，LCA通过一个简单快速的控制逻辑电路（最常见的就是DMA）拉控制数据输入输出。但是LCA只能使用ASIC方式实现，这就导致LCA必须具有以下特性：1. 算法足够成熟；2. 算法需要算力较大或比较重要。DPU、APU等针对AIoT领域的SoC就可以理解成采用了LCA架构</p>
<p>  多核共享的LCA需要加入仲裁开销，一般存在软件和硬件两种仲裁方法。</p>
<p>  特别地，LCA不依赖编译器，而依赖开放给开发者的API，比如OpenCL就是一种面向通用计算的API架构；而Cuda-C++是NVidia开发的针对自家GPU的API接口；其他的硬件加速设备也会有针对性的接口，最大的阻碍就是它们往往不兼容</p>
<p>  LCA最大的缺点不在于因为不耦合于内核，往往存在较大延时；而在于只能使用ASIC形式实现，导致它的功能固定。</p>
<p>  IBM推出的线速处理器（WSP）就是一种含有LCA的处理器</p>
</li>
<li><p><strong>现场可编程硬件</strong>：为通用性牺牲一些效率和性能的超细粒度可重构电路</p>
<p>  使用FPGA可以实现类似LCA的功能，但它们往往更加灵活，但相对应的性能和效率有所损失。因为HLS技术的成熟，现在FPGA硬件加速的开发变得相对快捷不少。Zynq平台上的高带宽硬件加速也是当前发展方向之一</p>
</li>
<li><p><strong>粗粒度可重构阵列</strong>：具有接近ASIC性能和具有一定可重构性的组合加速器，也就是CGRA组合加速器</p>
<p>  它试图中和LCA和FPGA，通过一组粗粒度部件及其互联机制，能够使得CGRA在可编程的基础上实现接近LCA的效率和开销。从概念上说，CGRA是含有小型加速器，而不是LUT（查找表）的FPGA</p>
<p>  许多CGRA的工作聚焦于资源的<em>静态映射</em>：计算单元之间的互联通信通过离线计算完成，或作为编译过程的一部分，这样可以尽可能提高运行效率；同时CGRA还具有硬件加速器资源虚拟化的特点——在编写程序时可以直接使用高级语言，编译器负责将其直接映射到具体器件的连接。从程序映射的角度，CGRA是一个全连接的计算引擎集，将计算映射到这样的一个体系架构上非常简单</p>
<p>  不过这也使得它难以用Cuda或Verilog的思路编程——电路是不能修改的，开发者只能通过配置CGRA中加速引擎的互联逻辑实现编程；反过来讲，它可以高效实现算法加速，并且由于组成加速器的部件较少，这些部件到硬件按资源的映射过成也相对容易，更可贵的是内部空间利用率达到较高的程度。<em>动态映射</em>可以在运算时实现较高的效率——计算引擎根据需要实现的算法动态更改计算模块之间的连接拓扑，这是基于CGRA具有<em>全连接特性</em></p>
<blockquote>
<p>CGRA计算架构通过空域硬件结构组织不同粒度和不同功能的计算资源，通过硬件运行时配置，调整硬件功能，根据数据流的特点，让功能配置好的硬件资源互连形成相对固定的计算通路，从而以接近“专用电路”的方式进行数据驱动下的计算</p>
<p>CGRA的全连接特性是指计算模块可以在任意邻接模块之间建立动态连接</p>
</blockquote>
<p>  CGRA的实现还处在起步阶段，现在的开发主要依靠实验室，主要原因在于比起FPGA，CGRA更加依赖生态和编译器。目前一个典型的CGRA架构被称为CHARM，它使用一种称为加速器块设计（ABC）的硬件资源管理机制，它管理一些小的计算模块，被称为ABB（加速器构建模块），ABB以类似FPGA的岛形分布在片上，每个岛内部包含DMA、便签式存储器SPM、实现岛内互联的内部网络和实现岛间通信的网络接口。传统核心通过将描述ABB非循环通信图的配置写入普通共享内存中以调用加速器，然后ABC会根据ABB图最大限度提高新实例化的加速器性能，并为每个参与的ABB分配一些任务。为了进一步提升性能，ABB会继续调度加速器的其他实例直到资源用完或任务完成</p>
</li>
<li><p><strong>高速缓存</strong>：现代处理器中往往使用高速缓存（cache）来降低数据访问延时，并通过数据重用提高系统存储带宽。具有较高空间/时间局部性的数据块可以保存在高速缓存中，它通常使用硬件自动管理。高速缓存主要由两个块构成：<em>标签阵列</em>和<em>数据阵列</em>。</p>
<p>  标签阵列用于检查请求的数据块是否位于数据阵列中，数据阵列用于存储具体数据。</p>
</li>
<li><p><strong>便签式存储器</strong>：由软件管理的缓冲区（buffer），缓冲区是指能够使用硬件或软件进行管理的FIFO、堆栈或RAM组</p>
<p>  便签式存储器具有高速缓存不具有的以下优势：</p>
<ul>
<li><em>可编程性</em>：方便软件开发者使用，可以作为处理器核的近存储器（near memory）进行软件编程；也可作为专用处理器核或者硬件加速器的近存储器，使得程序员不需要担心底层的管理策略（由硬件状态机完成），只需要通过软件进行性能优化就可以提供更高自由度的缓冲区管理策略</li>
<li>可预测的访问延迟：由于高速缓存块是由通用的替换策略管理的，因此高速缓存的访问延迟很难预测，以至于经常出现<code>cache miss</code>的情况；但是便签式存储器可以保证在编译器优化下实现优化的数据重用来避免下一级存储器访问造成的性能下降</li>
<li>低功耗、小面积：高速缓存所使用的标签阵列和比较逻辑电路往往需要更大的面积；但便签式存储器只需要一个状态机进行控制，因此它能够减小使用的面积并减小动态功耗</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>机器学习与机器视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>多级放大器简介</title>
    <url>/2021/11/14/%E5%A4%9A%E7%BA%A7%E6%94%BE%E5%A4%A7%E5%99%A8%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="多级放大器"><a href="#多级放大器" class="headerlink" title="多级放大器"></a>多级放大器</h1><p>常见的共射放大电路放大系数$\beta_V=-\frac{\beta R_{C}}{R_{b1}}$</p>
<span id="more"></span>

<h2 id="耦合方式"><a href="#耦合方式" class="headerlink" title="耦合方式"></a>耦合方式</h2><p>将多个单级基本放大电路合理连接即构成多级放大电路</p>
<p>组成多级放大电路的每个基本电路称为一<strong>级</strong>，级与级之间的连接称为<strong>级间耦合</strong></p>
<p>有下列四种常见的耦合方式</p>
<ul>
<li><p>直接耦合</p>
<p>  可以放大交流和缓慢变化的直流信号，便于集成化</p>
<p>  但是各级静态工作点会互相影响——基极和集电极电位会随着级数增加而上升；并且存在<strong>零点漂移</strong></p>
<p>  改进方法：</p>
<ol>
<li>在后级的射极接入电阻，提高后级基极电位，但是会导致第二级的放大倍数下降</li>
<li>在后级的射极接入稳压二极管并上拉电阻（启动电阻）到Vcc，可以使后级的放大倍数损失减小，但是会导致集电极电压的变化范围减小</li>
<li>在前级和后级之间使用反接的稳压二极管耦合，并在后级的基极接入下拉电阻到地，可以做到不损失放大倍数，但是稳压管噪声较大，会对输出信号造成影响</li>
<li>混合使用NPN管和PNP管（对管）直接耦合，可以较完美地实现需求，实际经常使用的电路就是这种</li>
</ol>
</li>
<li><p>阻容耦合</p>
<p>  在前级和后级之间使用电容进行耦合</p>
<p>  静态工作点相互独立，在分立元件电路中广泛使用；但集成电路中难以制造大容量电容，不便于集成化</p>
</li>
<li><p>变压器耦合</p>
<p>  过去广泛采用的耦合方式，利用变压器的阻抗变换功能，但是难以高频工作，过去经常使用这种方式实现收音机放大电路</p>
</li>
<li><p>光电耦合</p>
<p>  使用光耦器件进行前后级耦合，耦合效果好、抗干扰能力强，但是难以做到良好的线性放大</p>
</li>
</ul>
<h2 id="多级放大器动态分析"><a href="#多级放大器动态分析" class="headerlink" title="多级放大器动态分析"></a>多级放大器动态分析</h2><h3 id="性能参数"><a href="#性能参数" class="headerlink" title="性能参数"></a>性能参数</h3><ol>
<li><p>电压放大倍数</p>
<p> 总电压放大倍数等于各级电压放大倍数的乘积</p>
<p> $\beta_A=\beta_1\times\beta_2\times\cdots\times\beta_n$</p>
<p> 各级的放大倍数、静态值等可以独立计算</p>
</li>
<li><p>输入电阻、输出电阻等同于从输入端口、输出端口分别看入电路的总电阻</p>
</li>
</ol>
<h3 id="直接耦合放大电路的零点漂移问题"><a href="#直接耦合放大电路的零点漂移问题" class="headerlink" title="直接耦合放大电路的零点漂移问题"></a>直接耦合放大电路的零点漂移问题</h3><p><strong>零点漂移</strong>：直接耦合时，输入电压为0，但输出电压离开零点，并缓慢地发生不规则变化的现象</p>
<p>原因：放大器件的参数受温度影响而使Q点不稳定，所以零点漂移也称为温度漂移</p>
<p><em>多级放大器会使零点漂移更加严重</em></p>
<p>抑制零点漂移的方法：</p>
<ol>
<li>引入直流负反馈</li>
<li>利用热敏元件补偿放大器零漂</li>
<li>使用差分放大电路，放大差分信号（只有这种方法可以达到完美抑制零点漂移）</li>
</ol>
<h2 id="差分放大电路"><a href="#差分放大电路" class="headerlink" title="差分放大电路"></a>差分放大电路</h2><p>核心思想：构造电压源补偿由于零点漂移带来的电压不稳定</p>
<p>差分放大电路也称为差动放大电路，电路以两只并联的三极管集电极电位差为输出，以共模或差模信号为输入，其中共模信号会被直接忽略，由于零点漂移造成的信号也是一种共模信号，所以会被去除</p>
<p>差分放大电路中构造了两个“虚地”——负载电阻的中点电位在差模信号作用下不变，相当于“接地”；对管射极相连节点的电位由于差分信号而不变，构造了另一个“接地点”</p>
<p>差分放大器具有四种接法</p>
<ul>
<li>双入双出</li>
<li>双入单出</li>
<li>单入双出</li>
<li>单入单出</li>
</ul>
<p>单端情况下还是具有一定的共模抑制比，但是不如双端效果好</p>
<p>差模电压放大倍数、共模电压放大倍数与单端输入或双端输入无关，只与输出方式有关</p>
<p>双端输出时，共模电压放大倍数$A_{VC}=0$</p>
<p>差模输入电阻始终是基本放大电路的两倍</p>
<p>输出电阻双端输出时为$2R_C$，单端输出时为$R_C$</p>
<p>双端输出时共模抑制比K<del>CMR</del>可认为等于无穷大，单端输出时为有限值</p>
<p>可搭配恒流源电路构造改进的差分放大电路</p>
<h2 id="互补放大电路"><a href="#互补放大电路" class="headerlink" title="互补放大电路"></a>互补放大电路</h2><p>基本要求：输出电阻低、最大不失真输出电压尽可能大</p>
<p>使用NPN、PNP对管采用图腾柱连接，实现推挽输出，一个三极管放大正半周信号，另一个放大负半周信号；但这种方案存在<strong>交越失真</strong></p>
<p>解决方案如下：</p>
<ol>
<li>使用两个二极管钳位输入，并使用射极-基极并联电阻给三极管提供静态电压</li>
<li>使用压敏电阻、NPN-PNP对管、构建U<del>BE</del>倍增电路等方式为对管提供静态电压</li>
<li>使用复合管结构，增大对管电流放大倍数，减小前级驱动电流</li>
</ol>
]]></content>
      <tags>
        <tag>电路设计</tag>
      </tags>
  </entry>
  <entry>
    <title>我的新博客</title>
    <url>/2021/11/13/%E6%88%91%E7%9A%84%E6%96%B0%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="搬家了！"><a href="#搬家了！" class="headerlink" title="搬家了！"></a>搬家了！</h1><p>准备逐步把博客写作从CSDN换到基于Github Pages和Hexo的自建站上（笑）</p>
<p>CSDN😅</p>
<p>顺便以后推广公众号恰烂钱（？）</p>
<p>总之，不定期更新</p>
<p>保障一个月两次的保底更新（大概）</p>
<p><strong>Hexo还没用熟</strong></p>
<p>支持Markdown和$\LaTeX$公式，至少比b乎那个好多了</p>
<p>以后应该会再多整点活</p>
]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>数模转换原理</title>
    <url>/2021/11/14/%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="数模转换与模数转换"><a href="#数模转换与模数转换" class="headerlink" title="数模转换与模数转换"></a>数模转换与模数转换</h1><p>这里以STM32G474为例来介绍STM32中的ADC与DAC编程</p>
<p>主要作为电赛的笔记</p>
<h2 id="模数转换ADC"><a href="#模数转换ADC" class="headerlink" title="模数转换ADC"></a>模数转换ADC</h2><span id="more"></span>

<h3 id="四个基本部分"><a href="#四个基本部分" class="headerlink" title="四个基本部分"></a>四个基本部分</h3><ul>
<li>采样：定时对连续变化的模拟信号进行测量得到的瞬时值</li>
<li>保持：采样结束后将得到信号保持一段时间，使ADC有充分时间进行ADC转换。一般采样脉冲频率越高、采样越密，采样值就越多，采样保持电路的输出信号就越接近输入信号的波形。对采样频率要求（满足采样定理）：采样频率F<del>s</del> &gt;= 2*输入模拟信号频谱中最高频率F<del>max</del></li>
<li>量化：将采样电压转换为某个最小单位电压的整数倍</li>
<li>编码：用二进制代码表示量化后的量化电平</li>
</ul>
<p>量化级越细，量化误差就越小，所用二进制代码的位数就越多，电路也越复杂</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>常见的ADC主要分成三种：</p>
<ul>
<li><p>积分型：将输入电压转换成脉冲宽度信号或脉冲频率，使用定时器/计数器获取数字值</p>
<ul>
<li>优点：电路简单、分辨率高</li>
<li>缺点：转换精度依赖于积分时间，转换速率较低</li>
</ul>
</li>
<li><p>逐次比较型：由一个比较器和DAC转换器通过逐次比较逻辑构成，从最高位开始顺序地对每一位将输入电压与内置DAC转换器的输出进行比较，经过n次比较来输出数字值</p>
<p>  这个类型的ADC可以看作使用快速逼近-快速排序的方法来让DAC输出值靠近模拟值来实现ADC</p>
<ul>
<li>优点：速度高，功耗低，在低分辨率（12位）式具有性价比优势</li>
<li>缺点：转换速率一般，电路规模中等</li>
</ul>
</li>
<li><p>Σ-Δ调制型：使用积分器、比较器、1位DAC转换器和数字滤波器等构成，将输入电压转换成脉冲宽度信号，使用数字滤波器处理后得到数字值</p>
<ul>
<li>优点：可以容易地做到高分辨率测量</li>
<li>缺点：转换速率低、电路规模大</li>
</ul>
</li>
</ul>
<h3 id="主要参数"><a href="#主要参数" class="headerlink" title="主要参数"></a>主要参数</h3><ol>
<li>分辨率：输出数字量变化一个相邻数值所需输入模拟电压的变化量，一般用二进制的位数表示，分辨率为n表示是满刻度F<del>s</del>的2的n次方分之一</li>
<li>量化误差：ADC的有限位数对模拟量进行量化而引起的误差。要准确表示模拟量，ADC的位数需要很大甚至无穷大，所以ADC器件都有量化误差。一个分辨率有限的ADC的阶梯状转换特性曲线与具有无限分辨率的ADC转化特性曲线之间的最大偏差就是量化误差</li>
<li>转换速率：每秒进行转换的次数</li>
<li>转换量程：ADC所能测量的最大电压，一般等于参考电压，超过此电压有可能损毁ADC。当信号较小时可以考虑降低参考电压来提高分辨率，<strong>改变参考电压后，对应的转换值也会改变，计算实际电压时需要将参考电压考虑进去</strong>，所以说一般参考电压都要做到很稳定且不带有高次谐波</li>
<li>偏移误差：ADC输入信号为0时，但ADC转换输出信号不为0的值</li>
<li>满刻度误差：ADC满刻度输出时对应的输入信号与理想输入信号值之差</li>
<li>线性度：实际ADC的转移函数和理想直线的最大偏移</li>
</ol>
<h3 id="STM32G4中的ADC"><a href="#STM32G4中的ADC" class="headerlink" title="STM32G4中的ADC"></a>STM32G4中的ADC</h3><p>基本特性：</p>
<ul>
<li>五路12/10/8/6位可编程分辨率ADC，内置自动校准</li>
<li><strong>ADC转换时间与AHB总线时钟频率无关，只能通过降低分辨率加快转换时间</strong></li>
<li>4Msps最大转化率与全分辨率</li>
<li>每个ADC有多达19路通道，各通道AD转换可以以单一、连续、扫描或不连续方式进行，ADC结果存储在左对齐/右对齐的16位数据寄存器中</li>
<li>有外部参考引脚，允许输入电压范围独立于电源</li>
<li>可调的单端和差分模式输入</li>
<li>ADC1和ADC2紧密耦合，ADC3和ADC4紧密耦合，可以分别以ADC1、ADC3作master模式进行双模式运行；ADC5独立控制</li>
<li>允许DMA控制</li>
</ul>
<p>程序可以通过轮询、中断、定时器中断、同步、DMA等等方式来获取ADC值</p>
<p>使用函数<code>HAL_ADC_Start()</code>启动一次ADC转换，同理可使用<code>HAL_ADC_Start_IT()</code>和<code>HAL_ADC_Start_DMA()</code>来以中断或DMA的方式使用ADC</p>
<p>使用函数<code>HAL_ADC_GetValue()</code>在启动ADC转换一定延时时间后获取上次转换得到的ADC值</p>
<p>使用<code>HAL_ADC_Stop()</code>、<code>HAL_ADC_Stop_IT()</code>、<code>HAL_ADC_Stop_DMA()</code>停止使用ADC</p>
<h2 id="数模转换DAC"><a href="#数模转换DAC" class="headerlink" title="数模转换DAC"></a>数模转换DAC</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>数字寄存器：寄存输入的数字量和控制信号</p>
<p>模拟开关和转换网络：转换网络一般由一列电阻构成，模拟开关和对应的电阻按位加权</p>
<p>参考电压源：用于确定转换系数</p>
<p>求和放大器：对来自转换网络的模拟量进行相加</p>
<p>DAC的操作过程类似积分</p>
<h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><ul>
<li><p>电压输出型：从电阻网络直接输出电压，通常会在输出端加放大器来降低输出阻抗。</p>
</li>
<li><p>在输出端不加放大器的电压输出型：减少了输出端部分的延迟，常用于高速场合</p>
</li>
<li><p>电流输出型：一般很少直接利用电流输出，大多数会外接电流-电压转换电路得到电压输出。根据如何进行电流-电压转换又分成两类：</p>
<ul>
<li>在输出引脚上接负载电阻<ul>
<li>缺点：输出阻抗高、必须在规定的输出电流范围内使用，否则可能损坏DAC</li>
</ul>
</li>
<li>外接运算放大器<ul>
<li>缺点：加入了外接运放和导线的延迟，响应变慢</li>
</ul>
</li>
</ul>
<p>  电流输出型很少用，一般使用电压输出型</p>
</li>
</ul>
<h3 id="主要参数-1"><a href="#主要参数-1" class="headerlink" title="主要参数"></a>主要参数</h3><ol>
<li>分辨率：最小输出电压（也就是输入数字量为1时的电压）与最大输出电压（也就是输入数字量为最大（每一位都是1）时的电压）之比。一般通过输入数字量的位数来表示</li>
<li>转换量程：DAC能输出的最大电压，一般的关于参考电压或其倍数</li>
<li>建立时间：从输入数字量到输出模拟量之间的延时时间</li>
<li>转换精度：与ADC的转换精度类似</li>
</ol>
<h3 id="STM32G4中的DAC"><a href="#STM32G4中的DAC" class="headerlink" title="STM32G4中的DAC"></a>STM32G4中的DAC</h3><p>基本特性：</p>
<ul>
<li>4路配置为8位/12位的电压输出DAC，3个1MHz速率的DAC外部输出通道；4个15MHz速率的DAC内部输出通道</li>
<li>可生成噪声、三角波、锯齿波</li>
<li>可实现双DAC通道，两个通道组合在一起进行同步更新操作，转换可以独立或同步地完成</li>
<li>可通过设置独立的输入参考电压VREF+来获得更好的分辨率（注意该引脚和其他模拟外设如ADC、OPAMP等共用）</li>
<li>DAC1、DAC2引脚由GPIO复用；DAC3、DAC4仅用于内部输出</li>
<li>可开启输出缓冲</li>
<li>可单独启用的DAC输出缓冲器来输出高电流</li>
<li>支持低功耗模式、采样模式、保持模式，支持独立校准</li>
</ul>
<p>可直接使用<code>HAL_DAC_SetValue()</code>来设置DAC输出值</p>
<p>一般将某个波形的所有输出值保存在一个数组中并传给函数来输出特定波形；可以配合定时器来输出方波、三角波等</p>
]]></content>
      <tags>
        <tag>电赛笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>电机控制简介</title>
    <url>/2021/11/14/%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>本篇博文主要使用HAL库和CubeMX进行代码示例，毕竟电赛时间那么紧张，写STP库的时间都够CubeMX重开一局了</p>
<h1 id="直流电机控制"><a href="#直流电机控制" class="headerlink" title="直流电机控制"></a>直流电机控制</h1><p>根据电机学，直流电机转速<br>$$<br>n=\frac{U-IR}{K\phi}<br>$$<br>其中U为电枢端电压，I为电枢电流，R为电枢电路总电阻，Φ为每极磁通量，K为电机结构参数</p>
<p>直流电动机的转速控制方法有两种</p>
<ul>
<li>励磁控制法：对励磁磁通进行控制</li>
<li>电枢控制法：对电枢电压进行控制</li>
</ul>
<p>励磁控制阀在低速状态下收到磁极饱和限制，在高速时受换向火花和换向器结构强度的限制，动态响应较差，因此很少使用；大多数应用场合都使用电枢电压控制法，在保证励磁恒定的情况下使用单片机或相关电子器件输出<strong>PWM</strong>来直接实现直流电动机调速</p>
<h2 id="直流电机调速"><a href="#直流电机调速" class="headerlink" title="直流电机调速"></a>直流电机调速</h2><p>直流电机的调速思路就是“力大砖飞”，在电机控制线两端加适当电压，电压越高转速越快。可以通过功率半导体器件产生恒定的电压供给电机；对于数字器件而言很难控制电压精准保持在某一模拟值，因此使用PWM进行调速。</p>
<p>无论是模拟方法还是数字方法，都需要使用功率半导体器件，只不过使用方式有所不同。模拟电路通过线性放大的驱动方式，输出波动小、线性好，对临近电路干扰小，但存在效率低和散热问题；而数字电路通过耦合器件发出PWM使功率器件输出方波加在电机两端，通过改变方波的占空比来实现调节电机转速，往往对临近电路存在干扰，但是更易于实现。</p>
<p>基于PWM调速的电路往往包含三个部分</p>
<span id="more"></span>

<h3 id="驱动电路"><a href="#驱动电路" class="headerlink" title="驱动电路"></a>驱动电路</h3><p>一般使用晶体管或场效应管构成的半桥、全桥、三相桥电路，或直接使用护照那用的电机驱动功率IC。</p>
<p>常见的电机驱动芯片有L298N、ULN2003等</p>
<p>半桥拓扑采用推挽输出，<strong>需要保证两晶体管不同时开合</strong></p>
<p>全桥拓扑又称H桥，需要确定一个死区时间，在同一时间只有两个对称的桥臂晶体管导通，<strong>绝对不能让四路晶体管同时导通</strong></p>
<p>三相桥需要更严谨的时间控制，如果出现桥臂同时导通的情况很可能导致炸管</p>
<p>三者适用的功率逐次增大</p>
<p>还要注意电机两端应跨接续流二极管</p>
<h3 id="隔离电路"><a href="#隔离电路" class="headerlink" title="隔离电路"></a>隔离电路</h3><p>一般来说直流电机的驱动电压都在6V及以上，而常见的MCU供电、输出电压都在3.3V-5V，因此二者之间通常需要隔离</p>
<p>隔离器件可以是光耦、数字隔离器等</p>
<p>通常由于隔离设备的驱动能力不足，还需要在输出端加入三极管、场效应管放大电路或图腾柱推挽输出电路。比较方便的解决方案是直接使用达林顿管对电机进行控制，但是需要考虑达林顿管的耐压和发热</p>
<h3 id="控制电路"><a href="#控制电路" class="headerlink" title="控制电路"></a>控制电路</h3><p>大多数MCU都具有PWM输出功能，高性能的MCU往往还会配备控制死区时间、可以快速调节占空比、实现多路PWM同步/反相的高级控制功能；低端MCU也往往可以通过延时程序配合GPIO输出实现不精确的PWM功能</p>
<p>改变占空比的基本控制方法有：</p>
<ul>
<li>定宽调频法：保持PWM占空比不变，改变输出频率</li>
<li>定频调宽法：保持PWM频率不变，改变占空比</li>
<li>调频调宽法：不常用，同时改变频率和占空比</li>
</ul>
<h3 id="基于stm32f407的HAL库实现"><a href="#基于stm32f407的HAL库实现" class="headerlink" title="基于stm32f407的HAL库实现"></a>基于stm32f407的HAL库实现</h3><p>首先需要设置CubeMX或自己编写的外设初始化代码，配置好PSC寄存器和ARR寄存器，保证恒定的PWM频率</p>
<p>如果使用CubeMX只要可视化地调节选项即可；如果自己编写可以参考如下代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">htim1.Instance = TIM1; <span class="comment">//选择定时器实例</span></span><br><span class="line">htim1.Init.Prescaler = <span class="number">0</span>; <span class="comment">//这里设置PSC寄存器值</span></span><br><span class="line">htim1.Init.CounterMode = TIM_COUNTERMODE_UP; <span class="comment">//这里设置定时器模式</span></span><br><span class="line">htim1.Init.Period = <span class="number">65535</span>; <span class="comment">//这里设置ARR寄存器值</span></span><br><span class="line">htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1; <span class="comment">//这里设置分频值</span></span><br><span class="line">htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE; <span class="comment">//这里设置是否使能自动重装计数器</span></span><br></pre></td></tr></table></figure>

<p>使用定时器前需要先开启PWM通道</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_TIM_PWM_Start(&amp;htimx, TIM_CHANNEL_x);</span><br><span class="line"><span class="comment">//函数原型如下</span></span><br><span class="line"><span class="function">HAL_StatusTypeDef <span class="title">HAL_TIM_PWM_Start</span><span class="params">(TIM_HandleTypeDef *htim, <span class="keyword">uint32_t</span> Channel)</span></span></span><br></pre></td></tr></table></figure>

<p>然后通过在应用程序内修改比较值来实现定频调宽法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__HAL_TIM_SetCompare(&amp;htimx, TIM_CHANNEL_x, PWM_CompareValue);</span><br><span class="line"><span class="comment">//宏函数原型如下</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAL_TIM_SetCompare            __HAL_TIM_SET_COMPARE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAL_TIM_SET_COMPARE(__HANDLE__, __CHANNEL__, __COMPARE__) \</span></span><br><span class="line"><span class="meta">  (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)-&gt;Instance-&gt;CCR1 = (__COMPARE__)) :\</span></span><br><span class="line"><span class="meta">   ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)-&gt;Instance-&gt;CCR2 = (__COMPARE__)) :\</span></span><br><span class="line"><span class="meta">   ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)-&gt;Instance-&gt;CCR3 = (__COMPARE__)) :\</span></span><br><span class="line"><span class="meta">   ((__HANDLE__)-&gt;Instance-&gt;CCR4 = (__COMPARE__)))</span></span><br><span class="line"><span class="comment">//__HAL_TIM_SetCompare是老版本HAL库用法，新版本里为了统一宏函数，使用了lagency.h文件来对__HAL_TIM_SetCompare进行重定向，它和新版本的函数__HAL_TIM_SET_COMPARE等效</span></span><br></pre></td></tr></table></figure>

<p>特别地，HAL库允许直接修改CCR来改变定时器比较值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">htimx.Instance-&gt;CCRn = PWM_CompareValue;</span><br></pre></td></tr></table></figure>

<h1 id="步进电机控制"><a href="#步进电机控制" class="headerlink" title="步进电机控制"></a>步进电机控制</h1><p>步进电机是一种将电脉冲转化为角位移的电机机构。当它收到一个脉冲信号，就会按照设定的方向转动一个固定的角度，该角度称为电机的<strong>步距角</strong>。可以通过控制脉冲个数来控制角位移量；可以通过控制脉冲频率实现步进电机的调速</p>
<p>步进电机的转子一般为多极分布，定子上嵌有多相星形连接的控制绕组，每输入一次电脉冲信号，转子就旋转一步。步进电机的种类很多，可大致分成：</p>
<ul>
<li>反应式</li>
<li>永磁式</li>
<li>混合式</li>
</ul>
<p>还可以按相数分为单相、两相、三相三种</p>
<p><strong>如果给处于错齿状态的相通电</strong>，则转子会向磁导率最大、磁阻最小的位置转动，也就是<strong>趋于齿运动</strong></p>
<p>一个步进电机中往往还会加入减速装置来让其达到更高的精度，获得更高的转动力矩。</p>
<h3 id="基于stm32f407的HAL库实现-1"><a href="#基于stm32f407的HAL库实现-1" class="headerlink" title="基于stm32f407的HAL库实现"></a>基于stm32f407的HAL库实现</h3><p>首先使用CubeMX或自行编写初始化代码对外设进行配置 ，主要配置的参数如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">htim8.Instance = TIM8; <span class="comment">//选择合适的定时器</span></span><br><span class="line">htim8.Init.Prescaler = <span class="number">500</span>; <span class="comment">//配置预分频器</span></span><br><span class="line">htim8.Init.CounterMode = TIM_COUNTERMODE_UP; <span class="comment">//设置计数模式</span></span><br><span class="line">htim8.Init.Period = <span class="number">2000</span>; <span class="comment">//配置重装载值</span></span><br><span class="line">htim8.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;</span><br><span class="line">htim8.Init.RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">htim8.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;</span><br><span class="line"></span><br><span class="line">sConfigOC.Pulse = <span class="number">1000</span>; <span class="comment">//设置预定频数</span></span><br></pre></td></tr></table></figure>

<p>使用以下函数开启PWM输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_TIM_PWM_Start(&amp;htimx, TIM_CHANNEL_x);</span><br></pre></td></tr></table></figure>

<p>一般来说使用步进电机的基本方式是精准控制其行进步数，可以通过中断回调函数实现功能</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_TIM_PWM_Start_IT(&amp;htim8, TIM_CHANNEL_1); <span class="comment">//初始化时开启中断</span></span><br><span class="line"></span><br><span class="line">HAL_TIM_PWM_Stop_IT(&amp;htim8, TIM_CHANNEL_1); <span class="comment">//要设置频率参数前必须关闭中断</span></span><br><span class="line">TIM8-&gt;PSC = <span class="number">71</span>; <span class="comment">//将目标定时器8修改为72分频</span></span><br><span class="line"><span class="comment">//在之后的回调函数里再次打开中断</span></span><br></pre></td></tr></table></figure>

<p>通过定义中断回调函数即可实现步数控制功能</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_TIM_PWM_PulseFinishedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(htim-&gt;Instance == TIM8)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(count &lt; <span class="number">100</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			count++; <span class="comment">//计算步数</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">			HAL_TIM_PWM_Stop_IT(&amp;htim8, TIM_CHANNEL_1); <span class="comment">//再次打开中断</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过输出不同引脚的信号到电机控制器来控制步进电机的正反转</p>
<h3 id="基于步进电机专用控制IC的实现"><a href="#基于步进电机专用控制IC的实现" class="headerlink" title="基于步进电机专用控制IC的实现"></a>基于步进电机专用控制IC的实现</h3><p>为了更简便、精准地控制步进电机，常使用MCU搭配专用的电机控制IC来驱动电机——TI生产的DRV8824/8825以及更为常见的A4988都可以用来驱动常见的两相步进电机。一般根据datasheet中的典型应用设计出专用于控制步进电机的模块电路来实现控制功能。除了一般的正反转外，模块还提供了步进细分功能。下面分别以<strong>DRV8825</strong>和<strong>A4988</strong>步进电机驱动模块为例说明</p>
<p>步进电机的<strong>步进细分</strong>控制是由驱动器精确控制步进电机的相电流来实现的，细分会让电机运转更加平滑；换句话说，细分控制就是让驱动电路在输出脉冲的同时控制输出电压来实现电机的平滑启动和步进停止</p>
<ul>
<li><p>DRV8825模块</p>
<p>  DRV8825是TI的集成步进电机驱动芯片。芯片内部集成了2个H桥和1/32微步进分度器，可以驱动一个双极型电机或两个直流有刷电机。输入电压范围8.2~45V，可以提供1.75A的驱动电流， 芯片在24V、25°C的工作状态下可提供2.5A的峰值电流。芯片还集成了短路、过热、欠压及交叉传导保护电路，能够检测故障状况并迅速切断H桥，从而保护电机</p>
<p>  适用的电机类型：DRV8825驱动电机的类型主要与电机工作电流有关，理论上工作电流小于2A的步进电机都可以驱动。基于安全考虑，芯片上不加散热片，电流最好控制在1.5A以下；如果加散热片，电流峰值可到2.5A。</p>
<p>  模块接线如下：</p>
<p>  <img src="/2021/11/14/%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E7%AE%80%E4%BB%8B/DRV8824_DRV8825_pinout.png" alt="DRV8824_DRV8825_pinout"></p>
<p>  其中需要<strong>数字、模拟部分分别接地</strong>，一般来说VMOT旁边的GND是功率地，另一个GND则是数字地。同时<strong>功率电源需要接入100uF的旁路电容</strong>来减轻对数字部分的影响</p>
<p>  <strong>ENABLE引脚用于控制该模块是否启用，默认该引脚拉低，模块始终启用；RESET负责复位模块；SLEEP用于控制进入低功耗睡眠模式，当不使用电机时可以下拉该引脚来将功耗降到最低；三个引脚都是低电平有效，所以正常使用时都应接VCC（数字电源）</strong></p>
<p>  <strong>FAULT引脚（FLT）用于指示故障，一旦由于过电流保护或热关断，IC内部禁用H桥FET时，该引脚就会输出低电平，一般来说该引脚会在模块内部与SLEEP引脚短路，起到自动故障复位的效果</strong></p>
<p>  <strong>STEP引脚用于驱动电机转动，需要输入PWM波，频率越高，电机转动越快</strong></p>
<p>  <strong>DIR引脚用于控制电机转动方向，高电平正转，低电平反转</strong></p>
<p>  步进电机可以对应连接1B-1A-2A-2B、2B-2A-1A-1B、1A-1B-2B-2A、2A-2B-1B-1A，主要取决于需要的转动方向，总之只要<strong>同一相的两根线接到对应相的驱动引脚</strong>即可；特别地，如果电机不能正常运行，抖动严重，有可能是驱动板没有焊接好或某一相断开或两相接错导致缺相、错相；如果步进电机没有按照正确的顺序进行连接，可能导致无法工作或转动方向异常；如果步进电机扭力不足乃至丢步，可以尝试加大DRV8825的输出电流。驱动板上一般会搭配一个精密电位器用于调节输出电流，尝试调节该电位器来获取更好的输出效果，精密电位器与输出电流限制的计算公式为：<em>限制电流 = 电位器电压 * 2</em>，单位A</p>
<p>  <strong>通过控制M0、M1、M2的接地和接VCC（数字电源），可以根据下表来实现不同精密度的步进细分控制</strong></p>
<table>
<thead>
<tr>
<th>M0</th>
<th>M1</th>
<th>M2</th>
<th>细分类型</th>
</tr>
</thead>
<tbody><tr>
<td>Low</td>
<td>Low</td>
<td>Low</td>
<td>Full step</td>
</tr>
<tr>
<td>High</td>
<td>Low</td>
<td>Low</td>
<td>1/2 step</td>
</tr>
<tr>
<td>Low</td>
<td>High</td>
<td>Low</td>
<td>1/4 step</td>
</tr>
<tr>
<td>High</td>
<td>High</td>
<td>Low</td>
<td>1/8 step</td>
</tr>
<tr>
<td>Low</td>
<td>Low</td>
<td>High</td>
<td>1/16 step</td>
</tr>
<tr>
<td>High</td>
<td>Low</td>
<td>High</td>
<td>1/32 step</td>
</tr>
<tr>
<td>Low</td>
<td>High</td>
<td>High</td>
<td>1/32 step</td>
</tr>
<tr>
<td>High</td>
<td>High</td>
<td>High</td>
<td>1/32 step</td>
</tr>
</tbody></table>
</li>
<li><p>A4988模块</p>
<p>  相关控制方法与DRV8825基本一致，引脚也同理，两者最大的差别在于驱动电流和价格</p>
<p>  A4988价格更低，但是峰值驱动电流只有2A，内阻典型值为320Ω，最大耐压35V，所以DRV8825可以用来取代A4988，但是A4988不能取代DRV8825</p>
</li>
</ul>
<h1 id="舵机控制"><a href="#舵机控制" class="headerlink" title="舵机控制"></a>舵机控制</h1><p>舵机也称伺服电机、伺服驱动器，它接受一定的控制信号，输出一定的角度，适用于需要角度不断变化并可以保持的控制系统</p>
<p>舵机实际上是一个独立的闭环控制系统，通过其内部的机械或电路反馈控制其角度</p>
<p>工作过程如下：</p>
<ol>
<li>控制器向舵机发出控制信号</li>
<li>内部电路判断转动方向</li>
<li>驱动电路控制无核心马达转动</li>
<li>动力通过减速齿轮传送到摆臂</li>
<li>位置检测器回传摆臂数据</li>
<li>如果未达到指定位置则继续运动，否则停止</li>
</ol>
<p>其中位置检测器一般使用可变电阻，当舵机转动时电阻值会跟着改变，由此可以判断舵机是否达到指定位置</p>
<h2 id="舵机控制方法"><a href="#舵机控制方法" class="headerlink" title="舵机控制方法"></a>舵机控制方法</h2><p>标准舵机由电源、地线、控制线三条连接线，电源电压通常为4-6V，一般使用5V供电即可，但是需要电源带载能力够强。控制线一般输入方波信号，周期一般为20ms（频率50Hz）即可，具体情况应查看舵机生产商的说明。<strong>通过改变方波的占空比来改变舵机的角度</strong>，舵机角度和脉冲宽度成正比</p>
<p>舵机一般可以提供相当强的扭力，所以可以选择大扭力舵机用在机械臂等需要高强度的地方</p>
<h3 id="基于stm32f407的HAL库实现-2"><a href="#基于stm32f407的HAL库实现-2" class="headerlink" title="基于stm32f407的HAL库实现"></a>基于stm32f407的HAL库实现</h3><p>数字舵机依靠PWM进行控制。<strong>对于180°的舵机，一般周期为20ms（频率为50Hz）</strong>，脉宽为500–2500us。其中为1500us使得舵机转轮处于中间位置，即90°位置，如果在500-1500us和1500–2500us之间则分别会朝着0–90°和90–180°的方向旋转。给定固定占空比，舵机则会转到相应的角度，计算公式如下：</p>
<p>$$<br>占空比D =\frac{1}{90} *角度\theta + 0.5<br>$$<br>对应HAL库实现如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Servo_Control</span><span class="params">(<span class="keyword">uint16_t</span> angle)</span> <span class="comment">//angle为角度值，0~180</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> temp;</span><br><span class="line">	temp = (<span class="number">1.0</span> / <span class="number">90.0</span>) * angle + <span class="number">0.5</span>;<span class="comment">//占空比值 = 1/9 * 角度 + 5</span></span><br><span class="line">	__HAL_TIM_SET_COMPARE(&amp;htimx, TIM_CHANNEL_n, (<span class="keyword">uint16_t</span>)temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用下面的代码使能定时器时基单元和PWM输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_TIM_Base_Start(&amp;htimx);</span><br><span class="line">HAL_TIM_PWM_Start(&amp;htimx, TIM_CHANNEL_n);</span><br></pre></td></tr></table></figure>

<p>使用下面的代码关闭定时器时基单元和PWM输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_TIM_Base_Stop(&amp;htimx);</span><br><span class="line">HAL_TIM_PWM_Stop(&amp;htimx, TIM_CHANNEL_n);</span><br></pre></td></tr></table></figure>

<p>还可以直接通过改变CCR寄存器的值来控制舵机</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIMx-&gt;CCRn = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>电赛笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>电路设计从入门到弃坑0【电路概论】</title>
    <url>/2021/11/13/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E7%94%B5%E8%B7%AF%E6%A6%82%E8%AE%BA%E3%80%91/</url>
    <content><![CDATA[<h1 id="电路设计从入门到弃坑0【电路概论】"><a href="#电路设计从入门到弃坑0【电路概论】" class="headerlink" title="电路设计从入门到弃坑0【电路概论】"></a>电路设计从入门到弃坑0【电路概论】</h1><p>在本系列博客中，将遵循以下缩写/简写</p>
<ul>
<li>电路原理：电子线路、电子线路分析基础等基础电路课</li>
<li>模电：模拟电子电路、模拟电路、模拟电子技术、模拟电子线路等模拟电路课</li>
<li>数电：数字电子电路、数字电路、数字电子技术、数字电子线路等数字电路课</li>
<li>通信原理：通信原理、通信电子线路、通信电子电路、高频电子电路、高频电子线路等高频电路及通信理论课</li>
<li>强电：功率电子电路、功率电子线路、电力电子电路、电力电路等电力电子系统及理论课</li>
</ul>
<p>电路原理阐述了电路运行的基本规律：使用抽象电路模型、电磁学、图论、高等数学、线性代数、拉普拉斯变换等基础学科知识描述电路，提供一般的电路分析方法</p>
<p>模电则是从半导体器件的性质介绍如何使用这些器件构建能够对电信号或功率电压电流进行处理的电路</p>
<p>数电针对逻辑电路进行分析，结合布尔代数引入了晶体管在导通、截至两状态下的应用，并提炼出使用硬件描述语言对数字电路进行设计、分析、仿真的基本方法</p>
<p>通信原理则从分布参数电路与谐振、傅里叶分析角度解释模拟电路工作在高频情况下的状态与应用，并根据电磁场与电磁波理论介绍如何对通信信号进行调制-解调，以实现远距离电通信</p>
<p>强电则结合电机学、电工学相关知识，阐明功率半导体器件的工作原理和应用，主要关注功率、效率、质量三个要素</p>
<span id="more"></span>

<h3 id="专有名词解释"><a href="#专有名词解释" class="headerlink" title="专有名词解释"></a>专有名词解释</h3><p>本教程中使用的专有名词是更贴近直观的解释，和专业参考书籍存在一定差异，请以专业参考书为准</p>
<ul>
<li>电路拓扑：就是电路图的“形式”——把具体元件抽离出电路图，把实际电路图变换成理想电路模型，抽象出节点、支路后剩下的一个图就称为电路拓扑。可以形象理解成电路的套路或者说格式</li>
<li>系统：电路实现其功能过程的抽象。可以形象理解成电路功能框图</li>
<li>信息：就是信息论里面的信息</li>
<li>信号：从系统角度看，每个支路量都承载了信息，因此支路量可以称为信号</li>
<li>激励-响应：从系统的角度看电路时，系统中某个功能框的输入称为激励，系统某个功能框的输出称为响应</li>
<li>反馈：把某个响应引入到激励部分或功能框内部的过程称为反馈，对应的信号称为反馈信号</li>
</ul>
<h2 id="模电"><a href="#模电" class="headerlink" title="模电"></a>模电</h2><p>模电的知识结构是自下而上的</p>
<h3 id="半导体物理与半导体器件"><a href="#半导体物理与半导体器件" class="headerlink" title="半导体物理与半导体器件"></a>半导体物理与半导体器件</h3><p>讲述掺杂与导电性、PN结、双结型晶体管、场效应管等的基本物理原理和制造工艺对器件性能的影响</p>
<p>这一部分内容更偏重理论，和电路原理一样属于帮助理解模电、数电等工程应用的理论基础</p>
<h3 id="常见的半导体器件"><a href="#常见的半导体器件" class="headerlink" title="常见的半导体器件"></a>常见的半导体器件</h3><p>二极管、三极管、场效应管等基本的半导体器件，连同它们的变种器件，共同组成了模拟电子电路，经由开关频率特殊优化的开关管器件则构成了数字电路的基础——逻辑门和触发器</p>
<h4 id="二极管"><a href="#二极管" class="headerlink" title="二极管"></a>二极管</h4><p>由一个PN结封装成器件，就得到了具有单向导电性的二极管</p>
<p>生产中用到的不仅有二极管的单向导电性，还有击穿电压、漏电流等等一系列特性</p>
<h4 id="三极管和场效应管"><a href="#三极管和场效应管" class="headerlink" title="三极管和场效应管"></a>三极管和场效应管</h4><p>两个PN结封装成一个器件，就得到了三极管；而利用金属-氧化物绝缘层-半导体形式封装产生的电场效应，可以生产出场效应管。</p>
<p>三极管一般是电流控制电流型器件；而场效应管一般是电压控制电压型器件，二者可以互补——于是出现了结合二者，能够实现高功率输出的晶闸管（可控硅）和IGBT（绝缘栅双极型晶体管），以及复合单一器件的达林顿管</p>
<p>早期设备中使用真空管（电子管），正是因为半导体技术的发展才让三极管取代了真空管，但是二者的功能是一致的：<strong>对电信号加以控制</strong></p>
<h3 id="晶体管信号放大电路"><a href="#晶体管信号放大电路" class="headerlink" title="晶体管信号放大电路"></a>晶体管信号放大电路</h3><p>这里的晶体管是BJT（双结型晶体管，也就是三极管）和FET（场效应管）的统称</p>
<p>晶体管通过某些组合，可以最大限度发挥其控制信号的作用，而这种电路一般用于放大某些小信号，所以被称为晶体管信号放大电路。</p>
<p>放大电路并不是指输入1V，凭空就能输出3V，而是指<em>输入信号1V，通过外加2V的供电，能输出为2V的信号</em></p>
<p>信号放大电路往往看重信号的保真程度和信号的放大倍数，然而晶体管往往很容易受到门限电压、温度升高、电源变化等影响造成信号失真，为了避免这些问题，人们就对普通放大电路进行改进；同时为了获取更高的放大倍数，常常采用前级-输入级-驱动级-输出级这样的多级放大模式，从而提高信号放大倍数</p>
<p>主要参考的性能参数就是电压增益和电流增益：$A_v=\frac{v_o}{v_i}$ $A_i=\frac{i_o}{i_i}$</p>
<h3 id="晶体管功率放大电路"><a href="#晶体管功率放大电路" class="headerlink" title="晶体管功率放大电路"></a>晶体管功率放大电路</h3><p>对于一些特殊的应用（比如音响），信号放大电路无法驱动后级输出设备（扬声器）</p>
<p>于是出现了晶体管功率放大电路</p>
<p>这类电路一般使用特殊设计的能经受大电流、高电压的晶体管作为放大器件，于是可以在电源部分加大功率</p>
<p>通常需要注意功率放大电路的效率：$\eta=\frac{P_L}{P_S}$</p>
<h3 id="晶体管振荡电路"><a href="#晶体管振荡电路" class="headerlink" title="晶体管振荡电路"></a>晶体管振荡电路</h3><p>为了控制或产生周期性的激励，人们还设计出了能够产生振荡信号的晶体管电路</p>
<p>这种电路建立在放大电路和闭环控制理论的基础上，利用反馈进行工作</p>
<p>一般分立式元件难以产生高精度的信号输出，现在一般使用单片机（微控制器）或专用的集成电路生成振荡信号</p>
<h3 id="集成运算放大器"><a href="#集成运算放大器" class="headerlink" title="集成运算放大器"></a>集成运算放大器</h3><p>随着集成电路技术的发展，可以将多个二极管和晶体管集成在单个芯片中，内部大多为模拟电路的芯片被称为模拟集成电路，内部结构中多数字电路的芯片则是数字集成电路。其中通过将晶体管信号放大电路集成在一个芯片上，可以实现良好的放大性能，这种模拟集成电路就是集成运算放大器</p>
<p>集成运算放大器具有虚短、虚短、高输入阻抗、低输出阻抗等特征，利用这些特征可以组合出模拟运算电路和其他特殊的放大电路</p>
<p>集成运放工作在晶体管的基础上</p>
<h3 id="集成功率放大器"><a href="#集成功率放大器" class="headerlink" title="集成功率放大器"></a>集成功率放大器</h3><p>集成功率放大器即集成功放，是分立式晶体管功率放大器在功率半导体器件发展的基础上形成的一套新型集成电路</p>
<p>现代模拟电路具有集成化、小型化的趋势，集成功率电路正是舍弃了一部分高功率特性换来了更高的转换效率和更小的体积</p>
<h3 id="电源管理芯片和功率电源电路"><a href="#电源管理芯片和功率电源电路" class="headerlink" title="电源管理芯片和功率电源电路"></a>电源管理芯片和功率电源电路</h3><p>模拟电路的另一作用就是基于变压器、二极管、晶体管、基本电抗元件等构建稳压或恒流电源</p>
<p>在此基础上伴随半导体技术的发展，氮化镓、氮化砷等新型功率半导体器件为实现小型化、大功率、高效率的电源电路提供了可能</p>
<h2 id="数电"><a href="#数电" class="headerlink" title="数电"></a>数电</h2><p>数电的知识结构是从抽象到具体的</p>
<h3 id="布尔代数"><a href="#布尔代数" class="headerlink" title="布尔代数"></a>布尔代数</h3><p>布尔代数就是逻辑代数，使用布尔代数可以化简很多代数运算，并让电路得以实现</p>
<p>数电的基础是数学，数电的所有器件都是为了解决数学计算问题而设计</p>
<p>所以布尔代数是数字电路的基础</p>
<h3 id="开关管与逻辑门"><a href="#开关管与逻辑门" class="headerlink" title="开关管与逻辑门"></a>开关管与逻辑门</h3><p>电路可以使用高电平或低电平表示布尔代数中的0和1，进而实现数学计算</p>
<p>为了对数字信号进行处理，前人设计出了三种基本的逻辑门——与门、或门、非门</p>
<p>使用MOSFET（金属氧化物半导体场效应管）可以实现这三种逻辑门，进而实现更多复杂功能</p>
<p>在现代集成电路技术中，多采用CMOS工艺，将两个MOSFET制造在一起，并通过两个成对的MOSFET实现基础的逻辑门</p>
<p>只使用逻辑门构成的数字电路称为<strong>组合逻辑电路</strong></p>
<p>组合逻辑电路只能“瞬时”（由于寄生电容的存在，实际的组合逻辑电路存在延迟）地反映当前输入对应的输出，换句话说，它可以描述函数关系，但不能描述状态关系</p>
<h3 id="触发器与锁存器"><a href="#触发器与锁存器" class="headerlink" title="触发器与锁存器"></a>触发器与锁存器</h3><p>使用CMOS器件还可以制造具有“记忆”功能的器件——锁存器</p>
<p>锁存器可以暂时地保存输入的电平，通过再次加入一对MOSFET便可以让锁存器“滴答”（Tik-Tok）起来，这就是所谓的触发器</p>
<p>触发器是一种在外部信号输入后输出之前保存过电平的器件</p>
<p>使用触发器就可以实现随状态变化的数字电路，我们一般将其称为<strong>状态机</strong></p>
<h2 id="数电模电混合电路"><a href="#数电模电混合电路" class="headerlink" title="数电模电混合电路"></a>数电模电混合电路</h2><p>在生活中的任何一个角落，都有数模混合电路的存在——模拟电路负责供能、处理信号；数字电路负责对电信号进行计算、控制。</p>
<p>本系列博客将结合个人所学，以模电-数电-数模混合电路的逻辑讲述电路设计中的一些基础知识与技巧，同步进行开关电源、MCU板级外设电路等成体系电路的设计方法说明</p>
<p><strong>长期维护更新</strong></p>
<p>作者水平有限，如有错误疏漏，敬请谅解。</p>
]]></content>
      <tags>
        <tag>电路设计</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔</title>
    <url>/2021/11/13/%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<h1 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h1><p>所有的随笔都会放在这里OvO</p>
<p>可能还会扔些沙雕图……</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>集成运放简介</title>
    <url>/2021/11/14/%E9%9B%86%E6%88%90%E8%BF%90%E6%94%BE%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="集成运放概述"><a href="#集成运放概述" class="headerlink" title="集成运放概述"></a>集成运放概述</h1><p>常见的模拟集成电路类型</p>
<ul>
<li>集成运算放大器OP</li>
<li>集成功率放大器</li>
<li>集成高频放大器</li>
<li>集成中频放大器</li>
<li>集成比较器</li>
<li>集成乘法器</li>
<li>集成稳压器</li>
<li>集成数模/模数转换器ADC/DAC</li>
</ul>
<h3 id="模拟集成电路的特性"><a href="#模拟集成电路的特性" class="headerlink" title="模拟集成电路的特性"></a>模拟集成电路的特性</h3><p>集成电路中一般使用三极管组成恒流源电路来部分替代电阻</p>
<p>硅片上难以制作大电容、大电感，因此电路常常使用直接耦合的方式</p>
<p>常采用复合管的方式制作较大放大倍数的三极管</p>
<span id="more"></span>

<h2 id="集成运放的基本组成"><a href="#集成运放的基本组成" class="headerlink" title="集成运放的基本组成"></a>集成运放的基本组成</h2><h3 id="输入级"><a href="#输入级" class="headerlink" title="输入级"></a>输入级</h3><p>输入级要求高阻抗，常使用射随器与差分放大器减少温漂和增大输入电阻</p>
<p>一般使用复合管构成差分放大器，配合共集-共基放大器，用额外三极管的基极输出信号，可以实现很大的输入电阻和很大的共模抑制比</p>
<p>将复合管共基接法可以改善频率响应</p>
<p>使用<strong>共模负反馈</strong>减小温漂、提高共模抑制比</p>
<h3 id="中间级"><a href="#中间级" class="headerlink" title="中间级"></a>中间级</h3><p>常采用共射放大器配合复合管获得高增益</p>
<p>使用互补放大电路实现高放大倍数并提高带载能力</p>
<p>也存在放大器两端外接矫正电容来提高电路容性，防止自激振荡的措施（抑制过高的放大倍数、抑制正反馈）</p>
<h3 id="输出级"><a href="#输出级" class="headerlink" title="输出级"></a>输出级</h3><p>要求低阻抗，常使用射随器减小输出电阻</p>
<p>可以使用准互补OCD电路来提高带载能力，并引入电阻-二极管<strong>过载保护电路</strong></p>
<h3 id="偏置电路"><a href="#偏置电路" class="headerlink" title="偏置电路"></a>偏置电路</h3><p>使用恒流源电路给予三极管合适的偏置电压电流</p>
<p>多使用<strong>镜像恒流源</strong>配合跨接在VCC、VEE之间的电阻来提供标准偏置电流</p>
<h2 id="集成运放的特性"><a href="#集成运放的特性" class="headerlink" title="集成运放的特性"></a>集成运放的特性</h2><p>集成运放的开环放大倍数$A_{od}$非常大，一般使用负反馈的方式构造可控倍数的放大器或使用深度正反馈构造自激振荡电路</p>
<h3 id="开环差模电压增益"><a href="#开环差模电压增益" class="headerlink" title="开环差模电压增益"></a>开环差模电压增益</h3><p>直观上的运放开环情况下对差模信号的电压增益</p>
<p>用$A_{od}$表示，一般用对数表示，单位分贝</p>
<p>实际情况下运放A<del>od</del>在100到140之间</p>
<h3 id="输入失调电压、电流"><a href="#输入失调电压、电流" class="headerlink" title="输入失调电压、电流"></a>输入失调电压、电流</h3><p>为了使输出电压为0，在输入端需要加的补偿电压</p>
<p>一般运放在1-10mV</p>
<p>高端运放要保证在1mV以下</p>
<h3 id="输入失调电压、电流温漂"><a href="#输入失调电压、电流温漂" class="headerlink" title="输入失调电压、电流温漂"></a>输入失调电压、电流温漂</h3><p>由于温漂导致的输入失调电压增高情况</p>
<h3 id="输入偏置电流"><a href="#输入偏置电流" class="headerlink" title="输入偏置电流"></a>输入偏置电流</h3><p>输出电压为0时，两个输入端偏置电流的平均值</p>
<h3 id="差模输入电阻"><a href="#差模输入电阻" class="headerlink" title="差模输入电阻"></a>差模输入电阻</h3><p>一般要求很大，在几十MΩ</p>
<h3 id="共模抑制比"><a href="#共模抑制比" class="headerlink" title="共模抑制比"></a>共模抑制比</h3><p>多数运放在80-160dB之间</p>
<h3 id="最大共模、差模输入电压"><a href="#最大共模、差模输入电压" class="headerlink" title="最大共模、差模输入电压"></a>最大共模、差模输入电压</h3><p>直观上就是集成运放的耐压</p>
<p>一定程度上表征运放的耐静电程度</p>
<h3 id="3dB带宽fH"><a href="#3dB带宽fH" class="headerlink" title="-3dB带宽fH"></a>-3dB带宽f<del>H</del></h3><p>表示A<del>od</del>下降3dB时的频率。一般集成运放的f<del>H</del>在几H到几千Hz</p>
<h3 id="单位增益带宽"><a href="#单位增益带宽" class="headerlink" title="单位增益带宽"></a>单位增益带宽</h3><p>A<del>od</del>降低到0时的频率，此时运放开环差模电压放大倍数=1</p>
<h3 id="转换速率"><a href="#转换速率" class="headerlink" title="转换速率"></a>转换速率</h3><p>集成运放对输入-输入信号的转换速率</p>
<h2 id="单极型集成运放"><a href="#单极型集成运放" class="headerlink" title="单极型集成运放"></a>单极型集成运放</h2><p>三极管又称为BJT（双结型晶体管），组成双极型集成运放；也可以使用MOSFET组成单极型集成运放</p>
<p>采用耗尽型NMOS组成双入双出差分放大电路、使用增强型NMOS组成有源负载，并使用电流源组成偏置电路</p>
]]></content>
      <tags>
        <tag>电赛笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32深入学习【GPIO】</title>
    <url>/2021/11/14/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90GPIO%E3%80%91/</url>
    <content><![CDATA[<p>本文章根据stm32f4xx中文参考手册整理，可供学习其他arm内核单片机/stm32系列单片机参考</p>
<p>如果对其中的内容有疑问，可以参考RCC、定时器、中断相关部分的解析</p>
<p>以下内容使用SPL库（标准库）作为代码示例，HAL库是更高层的封装，想HAL库的使用可以查看其他教程</p>
<h1 id="GPIO电路"><a href="#GPIO电路" class="headerlink" title="GPIO电路"></a>GPIO电路</h1><p>每个GPIO端口包括4个32位配置寄存器、2个32位数据寄存器、1个32位置位/复位寄存器、1个32位锁定寄存器和2个32位复用功能寄存器。每个IO端口位均可自由编程，但IO端口寄存器必须按32位字、半字或字节进行访问</p>
<p>基本电路图如下所示：</p>
<p><img src="/2021/11/14/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90GPIO%E3%80%91/image-20210415214054864.png" alt="image-20210415214054864"></p>
<p>主要分为以下几个部分</p>
<h2 id="输入电路"><a href="#输入电路" class="headerlink" title="输入电路"></a>输入电路</h2><p>输入部分通过两个<strong>保护二极管</strong>进行钳位，保证GPIO容忍电压对V<del>SS</del>为5V，注意这里的V<del>SS</del>指的是电源地，而不是V<del>DD</del>信号地</p>
<p>输入信号经过可编程的<strong>上拉/下拉电阻</strong>后进入<strong>输入驱动器</strong>。</p>
<ul>
<li>如果使能了ADC等接入外部模拟信号的片上外设，就能从GPIO直接读取模拟信号</li>
<li>如果使能了复用功能，外部信号则会通过一个TTL<strong>施密特触发器</strong>，直接缓冲进入相关数字信号外设</li>
<li>如果正常使用GPIO的读功能，外部信号会在被施密特触发器变为数字信号后进入<strong>输入数据寄存器</strong></li>
</ul>
<p>这里的施密特触发器相当于一个FIFO，能够保存外部模拟信号的快照，以此作为数字量供给片上外设</p>
<p><strong>引脚配置为输入模式后，输入数据寄存器会每1个AHB1时钟周期捕获以此GPIO外部数据</strong></p>
<h2 id="输出电路"><a href="#输出电路" class="headerlink" title="输出电路"></a>输出电路</h2><p>输出部分通过两个MOSFET控制，PMOS、NMOS以图腾柱方式组合，形成<strong>推挽输出</strong>结构。为了保证输出的速度，使用专用的驱动电路控制MOSFET，输出速率就由该驱动电路决定</p>
<ul>
<li>如果正常使用GPIO的写功能，来自CPU的配置数据会先保存在<strong>置位/复位寄存器</strong>，之后转换保存在<strong>输出数据寄存器</strong>中，驱动电路根据输出数据寄存器的值实时控制输出，这就起到了内部时钟和外设操作频率的退耦</li>
<li>如果使用了其他能读写GPIO的外设，会由外设直接向输出数据寄存器中写值，这样就简轻了CPU的控制负担</li>
<li>如果使能了复用功能，来自复用外设的控制信号会直接绕过输出数据寄存器，直接通过一个两路选择器操作输出控制电路</li>
</ul>
<p>所有来自MOSFET输出的信号会经过<strong>上/下拉电路</strong>，这就能将片内CMOS电压转换为片外TTL电压进行输出</p>
<p>同样输出也经过钳位二极管保护，防止出现电流倒灌等问题</p>
<p><strong>引脚配置为输出模式后，写入到输出数据寄存器的值会在GPIO上输出</strong></p>
<h2 id="时序控制电路"><a href="#时序控制电路" class="headerlink" title="时序控制电路"></a>时序控制电路</h2><p>大多数GPIO的寄存器都是基于时序电路实现（D触发器、锁存器等）</p>
<p>最重要的就是置位复位寄存器 (GPIOx_BSRR)：这是一个32位寄存器，它允许应用程序在输出数据寄存器(GPIOx_ODR) 中对各个单独的数据位执行置位和复位操作。</p>
<blockquote>
<p>置位复位寄存器的大小是GPIOx_ODR的二倍，所以GPIOx_ODR中的每个数据位都能对应于GPIOx_BSRR中的两个控制位：BSRR(i) 和<br>BSRR(i+SIZE)。当写入1时，BSRR(i)位会置位对应的ODR(i) 位；同时BSRR(i+SIZE) 位会清零ODR(i)对应的位；在GPIOx_BSRR中向任何位写入0都不会对GPIOx_ODR中的对应位产生任何影响。如果在GPIOx_BSRR中同时尝试对某个位执行置位和清零操作，则<strong>置位操作优先</strong>。</p>
<p>注意使用GPIOx_BSRR寄存器更改GPIOx_ODR中各个位的值是一个“单次”操作，不会锁定GPIOx_ODR位。用户随时都可以直接访问GPIOx_ODR位</p>
<p>特别地，对GPIOx_ODR进行位操作是原子操作，软件无需禁止中断，且在一次原子AHB1写访问中，可以修改一个或多个位</p>
</blockquote>
<h2 id="GPIO复位"><a href="#GPIO复位" class="headerlink" title="GPIO复位"></a>GPIO复位</h2><h3 id="调试引脚复位"><a href="#调试引脚复位" class="headerlink" title="调试引脚复位"></a>调试引脚复位</h3><p>复位后调试引脚处于复位功能上拉/下拉状态：</p>
<ul>
<li>PA15-JTDI上拉</li>
<li>PA14-JTCK/SWCLK下拉</li>
<li>PA13-JTMS/SWDAT下拉</li>
<li>PB4-NJTRST上拉</li>
<li>PB3-JTDO浮空</li>
</ul>
<h3 id="其他复位"><a href="#其他复位" class="headerlink" title="其他复位"></a>其他复位</h3><p>在复位期间及复位刚刚完成后，复用功能尚未激活，GPIO端口被配置为输入浮空模式</p>
<p>完成复位后，所有GPIO都会连接到系统的复用功能 0 (AF0)</p>
<h1 id="GPIO外设控制寄存器及配置"><a href="#GPIO外设控制寄存器及配置" class="headerlink" title="GPIO外设控制寄存器及配置"></a>GPIO外设控制寄存器及配置</h1><p>可通过字节（8 位）、半字（16 位）或字（32 位）对 GPIO 寄存器进行访问</p>
<p><strong>寄存器地址见参考手册</strong></p>
<p>GPIOx_MODER模式控制寄存器：选择 I/O 方向与模式</p>
<p>GPIOx_PUPDR上下拉数据寄存器：控制内部上拉/下拉电阻</p>
<p>GPIOx_OTYPER输出类型寄存器：选择输出类型</p>
<p>GPIOx_OSPEEDR输出速度寄存器：选择输出速度</p>
<p>GPIOx_IDR输入数据寄存器：通过 I/O 输入的数据存储到该寄存器，这是个只读寄存器</p>
<p>GPIOx_ODR输出数据寄存器：存储待输出数据，可对其进行读写访问</p>
<p>GPIOx_AFRL复用功能寄存器低8位：根据应用程序的要求将某个复用功能连接到其它某个引脚</p>
<p>GPIOx_AFRH复用功能寄存器高8位：根据应用程序的要求将某个复用功能连接到其它某个引脚</p>
<p>通过将特定的写序列应用到GPIOx_LCKR寄存器，可以冻结GPIO外设控制寄存器</p>
<h2 id="配置输入"><a href="#配置输入" class="headerlink" title="配置输入"></a>配置输入</h2><p>输入数据寄存器GPIOx_IDR是一个只读的寄存器，在使用时只要将GPIO通过GPIOx_MODER设置为输入模式后访问该寄存器就可以读取到当前采样值，输入数据寄存器会在每个时钟频率对外界信号进行一次采样</p>
<p>所有端口都具有外部中断功能。<strong>要使用外部中断线，必须将端口配置为输入模式</strong></p>
<p>使用库函数配置如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PA4_PE0_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;<span class="comment">//这里是stm32库定义的外设初始化结构体，在此进行“例化”</span></span><br><span class="line">	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA|RCC_AHB1Periph_GPIOE, ENABLE);<span class="comment">//使能GPIOA,GPIOE时钟</span></span><br><span class="line"></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;<span class="comment">//配置P4</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;<span class="comment">//配置为普通输入模式</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;<span class="comment">//速度设置为100M</span></span><br><span class="line">	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;<span class="comment">//配置为内部下拉</span></span><br><span class="line">    </span><br><span class="line">	GPIO_Init(GPIOE, &amp;GPIO_InitStructure);<span class="comment">//初始化GPIOE4</span></span><br><span class="line">	 </span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;<span class="comment">//修改为Pin0</span></span><br><span class="line">	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;<span class="comment">//内部下拉</span></span><br><span class="line">    </span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<span class="comment">//初始化GPIOE0</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>外部中断的配置可以参考【NVIC中断控制】相关文章，这里不列出</p>
<p>使用下面的函数读取GPIO输入值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">GPIO_ReadInputDataBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="keyword">uint16_t</span> GPIO_Pin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="keyword">uint8_t</span> bitstatus = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">/* Check the parameters */</span></span><br><span class="line">  	assert_param(IS_GPIO_ALL_PERIPH(GPIOx));</span><br><span class="line">  	assert_param(IS_GET_GPIO_PIN(GPIO_Pin));</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">if</span> ((GPIOx-&gt;IDR &amp; GPIO_Pin) != (<span class="keyword">uint32_t</span>)Bit_RESET)</span><br><span class="line">  	&#123;</span><br><span class="line">   	 	bitstatus = (<span class="keyword">uint8_t</span>)Bit_SET;<span class="comment">//通过读取判断寄存器的值来获取当前输入值</span></span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">else</span></span><br><span class="line">  	&#123;</span><br><span class="line">    	bitstatus = (<span class="keyword">uint8_t</span>)Bit_RESET;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> bitstatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置输出"><a href="#配置输出" class="headerlink" title="配置输出"></a>配置输出</h2><p>输出数据寄存器 GPIOx_ODR</p>
<p>使用库函数配置如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PF9_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;    	 </span><br><span class="line">  	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">  	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF, ENABLE);<span class="comment">//使能GPIOF时钟</span></span><br><span class="line"></span><br><span class="line">  	<span class="comment">//GPIOF9初始化设置</span></span><br><span class="line">  	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;<span class="comment">//要配置的位是第9位</span></span><br><span class="line">  	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;<span class="comment">//普通输出模式</span></span><br><span class="line">  	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;<span class="comment">//推挽输出</span></span><br><span class="line">  	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;<span class="comment">//速度配置位100MHz</span></span><br><span class="line">  	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;<span class="comment">//配置上拉</span></span><br><span class="line">    </span><br><span class="line">  	GPIO_Init(GPIOF, &amp;GPIO_InitStructure);<span class="comment">//对GPIOF按照上面的配置进行初始化</span></span><br><span class="line">	</span><br><span class="line">    GPIO_SetBits(GPIOF,GPIO_Pin_9 | GPIO_Pin_10);<span class="comment">//GPIOF9,F10设置高，灯灭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>库函数的底层都是对寄存器的操作，摘录如下：</p>
<p>时钟控制库函数是对RCC寄存器进行操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RCC_APB2PeriphClockCmd</span><span class="params">(<span class="keyword">uint32_t</span> RCC_APB2Periph, FunctionalState NewState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));<span class="comment">//这里检查是否使用了正确的参数</span></span><br><span class="line">  	assert_param(IS_FUNCTIONAL_STATE(NewState));</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">if</span> (NewState != DISABLE)</span><br><span class="line">  	&#123;</span><br><span class="line">    	RCC-&gt;APB2ENR |= RCC_APB2Periph;</span><br><span class="line">        <span class="comment">//参数设置为ENABLE时就使用上面提供的参数开启RCC寄存器下属APB2使能寄存器中的相关外设时钟控制位</span></span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">else</span></span><br><span class="line">  	&#123;</span><br><span class="line">    	RCC-&gt;APB2ENR &amp;= ~RCC_APB2Periph;</span><br><span class="line">        <span class="comment">//否则关闭相对应的控制位</span></span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化结构体是对GPIO控制寄存器的封装</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  	<span class="keyword">uint32_t</span> GPIO_Pin;</span><br><span class="line">  	GPIOMode_TypeDef GPIO_Mode;</span><br><span class="line">  	GPIOSpeed_TypeDef GPIO_Speed;</span><br><span class="line">  	GPIOOType_TypeDef GPIO_OType;</span><br><span class="line">  	GPIOPuPd_TypeDef GPIO_PuPd;</span><br><span class="line">&#125;GPIO_InitTypeDef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">  	GPIO_Mode_IN   = <span class="number">0x00</span>, <span class="comment">/*!&lt; GPIO Input Mode */</span></span><br><span class="line">  	GPIO_Mode_OUT  = <span class="number">0x01</span>, <span class="comment">/*!&lt; GPIO Output Mode */</span></span><br><span class="line">  	GPIO_Mode_AF   = <span class="number">0x02</span>, <span class="comment">/*!&lt; GPIO Alternate function Mode */</span></span><br><span class="line">  	GPIO_Mode_AN   = <span class="number">0x03</span>  <span class="comment">/*!&lt; GPIO Analog Mode */</span></span><br><span class="line">&#125;GPIOMode_TypeDef;<span class="comment">//对应GPIO_Mode的枚举量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">  	GPIO_OType_PP = <span class="number">0x00</span>,</span><br><span class="line">  	GPIO_OType_OD = <span class="number">0x01</span></span><br><span class="line">&#125;GPIOOType_TypeDef;<span class="comment">//对应GPIO_OType的枚举量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">  	GPIO_Low_Speed     = <span class="number">0x00</span>, <span class="comment">/*!&lt; Low speed    */</span></span><br><span class="line">  	GPIO_Medium_Speed  = <span class="number">0x01</span>, <span class="comment">/*!&lt; Medium speed */</span></span><br><span class="line">  	GPIO_Fast_Speed    = <span class="number">0x02</span>, <span class="comment">/*!&lt; Fast speed   */</span></span><br><span class="line">  	GPIO_High_Speed    = <span class="number">0x03</span>  <span class="comment">/*!&lt; High speed   */</span></span><br><span class="line">&#125;GPIOSpeed_TypeDef;<span class="comment">//对应GPIO_Speed的枚举量</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  GPIO_Speed_2MHz    GPIO_Low_Speed    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  GPIO_Speed_25MHz   GPIO_Medium_Speed </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  GPIO_Speed_50MHz   GPIO_Fast_Speed </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  GPIO_Speed_100MHz  GPIO_High_Speed</span></span><br><span class="line"><span class="comment">//再对枚举量封装一遍，便于直观设置GPIO速度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">  	GPIO_PuPd_NOPULL = <span class="number">0x00</span>,</span><br><span class="line">  	GPIO_PuPd_UP     = <span class="number">0x01</span>,</span><br><span class="line">  	GPIO_PuPd_DOWN   = <span class="number">0x02</span></span><br><span class="line">&#125;GPIOPuPd_TypeDef;</span><br><span class="line"><span class="comment">//对应GPIO_PuPd的枚举量</span></span><br></pre></td></tr></table></figure>

<p>GPIO初始化函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_Init</span><span class="params">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> pinpos = <span class="number">0x00</span>, pos = <span class="number">0x00</span> , currentpin = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));</span><br><span class="line">  assert_param(IS_GPIO_PIN(GPIO_InitStruct-&gt;GPIO_Pin));</span><br><span class="line">  assert_param(IS_GPIO_MODE(GPIO_InitStruct-&gt;GPIO_Mode));</span><br><span class="line">  assert_param(IS_GPIO_PUPD(GPIO_InitStruct-&gt;GPIO_PuPd));</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">for</span> (pinpos = <span class="number">0x00</span>; pinpos &lt; <span class="number">0x10</span>; pinpos++)</span><br><span class="line">  	&#123;</span><br><span class="line">    	pos = ((<span class="keyword">uint32_t</span>)<span class="number">0x01</span>) &lt;&lt; pinpos;</span><br><span class="line">    	<span class="comment">//从参数获取GPIO引脚位</span></span><br><span class="line">    	currentpin = (GPIO_InitStruct-&gt;GPIO_Pin) &amp; pos;</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">if</span> (currentpin == pos)</span><br><span class="line">    	&#123;</span><br><span class="line">            <span class="comment">//配置输入/输出模式参数</span></span><br><span class="line">      		GPIOx-&gt;MODER  &amp;= ~(GPIO_MODER_MODER0 &lt;&lt; (pinpos * <span class="number">2</span>));</span><br><span class="line">      		GPIOx-&gt;MODER |= (((<span class="keyword">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_Mode) &lt;&lt; (pinpos * <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果是输出或复用模式，则可以配置下面几个参数，否则在初始化结构体中无论怎么配置都不会生效</span></span><br><span class="line">      <span class="keyword">if</span> ((GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_AF))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* Check Speed mode parameters */</span></span><br><span class="line">        assert_param(IS_GPIO_SPEED(GPIO_InitStruct-&gt;GPIO_Speed));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//配置速度参数</span></span><br><span class="line">        GPIOx-&gt;OSPEEDR &amp;= ~(GPIO_OSPEEDER_OSPEEDR0 &lt;&lt; (pinpos * <span class="number">2</span>));</span><br><span class="line">        GPIOx-&gt;OSPEEDR |= ((<span class="keyword">uint32_t</span>)(GPIO_InitStruct-&gt;GPIO_Speed) &lt;&lt; (pinpos * <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check Output mode parameters */</span></span><br><span class="line">        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct-&gt;GPIO_OType));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//配置输出方式参数</span></span><br><span class="line">        GPIOx-&gt;OTYPER  &amp;= ~((GPIO_OTYPER_OT_0) &lt;&lt; ((<span class="keyword">uint16_t</span>)pinpos)) ;</span><br><span class="line">        GPIOx-&gt;OTYPER |= (<span class="keyword">uint16_t</span>)(((<span class="keyword">uint16_t</span>)GPIO_InitStruct-&gt;GPIO_OType) &lt;&lt; ((<span class="keyword">uint16_t</span>)pinpos));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      	<span class="comment">//上拉/下拉寄存器设置</span></span><br><span class="line">      	GPIOx-&gt;PUPDR &amp;= ~(GPIO_PUPDR_PUPDR0 &lt;&lt; ((<span class="keyword">uint16_t</span>)pinpos * <span class="number">2</span>));</span><br><span class="line">      	GPIOx-&gt;PUPDR |= (((<span class="keyword">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_PuPd) &lt;&lt; (pinpos * <span class="number">2</span>));</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GPIO输出控制函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_SetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="keyword">uint16_t</span> GPIO_Pin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="comment">/* Check the parameters */</span></span><br><span class="line">  	assert_param(IS_GPIO_ALL_PERIPH(GPIOx));</span><br><span class="line">  	assert_param(IS_GPIO_PIN(GPIO_Pin));</span><br><span class="line"></span><br><span class="line">  	GPIOx-&gt;BSRRL = GPIO_Pin;<span class="comment">//直接对GPIO引脚置位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_ResetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="keyword">uint16_t</span> GPIO_Pin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="comment">/* Check the parameters */</span></span><br><span class="line">  	assert_param(IS_GPIO_ALL_PERIPH(GPIOx));</span><br><span class="line">  	assert_param(IS_GPIO_PIN(GPIO_Pin));</span><br><span class="line"></span><br><span class="line">  	GPIOx-&gt;BSRRH = GPIO_Pin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_WriteBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="keyword">uint16_t</span> GPIO_Pin, BitAction BitVal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="comment">/* Check the parameters */</span></span><br><span class="line">  	assert_param(IS_GPIO_ALL_PERIPH(GPIOx));</span><br><span class="line">  	assert_param(IS_GET_GPIO_PIN(GPIO_Pin));</span><br><span class="line">  	assert_param(IS_GPIO_BIT_ACTION(BitVal));</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">if</span> (BitVal != Bit_RESET)</span><br><span class="line">  	&#123;</span><br><span class="line">    	GPIOx-&gt;BSRRL = GPIO_Pin;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">else</span></span><br><span class="line">  	&#123;</span><br><span class="line">    	GPIOx-&gt;BSRRH = GPIO_Pin ;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">  	Bit_RESET = <span class="number">0</span>,</span><br><span class="line">  	Bit_SET</span><br><span class="line">&#125;BitAction;</span><br><span class="line"><span class="comment">//对应BitVal的枚举量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//还有一个比较方便的翻转输出值函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_ToggleBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="keyword">uint16_t</span> GPIO_Pin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="comment">/* Check the parameters */</span></span><br><span class="line">  	assert_param(IS_GPIO_ALL_PERIPH(GPIOx));</span><br><span class="line"></span><br><span class="line">  	GPIOx-&gt;ODR ^= GPIO_Pin;<span class="comment">//异或运算，如果和之前的值相同，则反转；可以通过多次使用该函数反转输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//很莽的一个函数，直接设置GPIO端口值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_Write</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="keyword">uint16_t</span> PortVal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="comment">/* Check the parameters */</span></span><br><span class="line">  	assert_param(IS_GPIO_ALL_PERIPH(GPIOx));</span><br><span class="line"></span><br><span class="line">  	GPIOx-&gt;ODR = PortVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="开漏模式与推挽模式"><a href="#开漏模式与推挽模式" class="headerlink" title="开漏模式与推挽模式"></a>开漏模式与推挽模式</h3><p>开漏模式：输出寄存器中置0位可激活连接到V<del>SS</del>的N-MOS，而输出寄存器中置1会使端口保持高阻态z，连接到V<del>DD</del>的P-MOS始终不会开启，也就是说配置寄存器只会控制GPIO的开漏<br>推挽模式：输出寄存器中置0位可激活N-MOS，而输出寄存器中置1可激活P-MOS，达到推挽输出的效果</p>
<h2 id="模拟配置"><a href="#模拟配置" class="headerlink" title="模拟配置"></a>模拟配置</h2><p>一下内容摘自参考手册原文</p>
<blockquote>
<p>对 I/O 端口进行编程作为模拟配置时</p>
<p>● 输出缓冲器被禁止</p>
<p>● 施密特触发器输入停用，I/O 引脚的每个模拟输入的功耗变为零。施密特触发器的输出被强制处理为恒定值 (0)</p>
<p>● 弱上拉和下拉电阻被关闭</p>
<p>● 对输入数据寄存器的读访问值为“0”</p>
</blockquote>
<p>注意：<strong>在模拟配置中，I/O引脚不能为5V容忍</strong></p>
<h2 id="振荡器引脚和RTC引脚作为GPIO"><a href="#振荡器引脚和RTC引脚作为GPIO" class="headerlink" title="振荡器引脚和RTC引脚作为GPIO"></a>振荡器引脚和RTC引脚作为GPIO</h2><p>当LSE振荡器处于关闭状态时，可分别将LSE引脚OSC32_IN和OSC32_OUT用作普通的PC14和PC15引脚</p>
<p>但当LSE开启时，两个引脚只能作为LSE引脚，LSE的优先级是高于GPIO配置的，所以程序中对这两个引脚的GPIO配置会被无效</p>
<p>当HSE振荡器处于关闭状态时，可分别将HSE振荡器引脚OSC_IN和OSC_OUT用作PH0和PH1引脚</p>
<p>但当HSE振荡器处于开启状态时，PH0/PH1只能被配置为OSC_IN/OSC_OUT HSE振荡器引脚，也是优先于GPIO配置</p>
<p>另外还有RTC_AF1和RTC_AF2两个引脚，可以用来检测入侵或时间戳时间、RTC_ALARM或RTC_CALIB RTC输出</p>
<p>设置为RTC_ALARM输出时可用于两个RTC输出或RTC的唤醒，有RTC_CR寄存器中的OSEL[1:0]位配置</p>
<p>其他功能查看参数手册即可</p>
<h2 id="锁定GPIO"><a href="#锁定GPIO" class="headerlink" title="锁定GPIO"></a>锁定GPIO</h2><p>在库函数中提供了锁定GPIO的函数，摘录如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_PinLockConfig</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="keyword">uint16_t</span> GPIO_Pin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __IO <span class="keyword">uint32_t</span> tmp = <span class="number">0x00010000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));</span><br><span class="line">  assert_param(IS_GPIO_PIN(GPIO_Pin));</span><br><span class="line"></span><br><span class="line">  tmp |= GPIO_Pin;</span><br><span class="line">  <span class="comment">/* Set LCKK bit */</span></span><br><span class="line">  GPIOx-&gt;LCKR = tmp;</span><br><span class="line">  <span class="comment">/* Reset LCKK bit */</span></span><br><span class="line">  GPIOx-&gt;LCKR =  GPIO_Pin;</span><br><span class="line">  <span class="comment">/* Set LCKK bit */</span></span><br><span class="line">  GPIOx-&gt;LCKR = tmp;</span><br><span class="line">  <span class="comment">/* Read LCKK bit*/</span></span><br><span class="line">  tmp = GPIOx-&gt;LCKR;</span><br><span class="line">  <span class="comment">/* Read LCKK bit*/</span></span><br><span class="line">  tmp = GPIOx-&gt;LCKR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接输入GPIOx和要锁定的引脚就可以进行锁定</p>
<h1 id="GPIO复用"><a href="#GPIO复用" class="headerlink" title="GPIO复用"></a>GPIO复用</h1><h2 id="GPIO复用器"><a href="#GPIO复用器" class="headerlink" title="GPIO复用器"></a>GPIO复用器</h2><p><strong>每个GPIO引脚都有一个采用16路复用功能输入的复用器</strong>，GPIO通过这些复用器连接到片上外设，这个复用器一次仅允许一个外设的复用功能连接到GPIO引脚，确保共用同一个GPIO引脚的外设之间不会发生冲突</p>
<p>复用器输入从AF0到AF15，通过引脚复用寄存器的低8位GPIOx_AFRL和高8位GPIOx_AFRH分别设置</p>
<p>外设的复用功能映射到AF1至AF13，AF0是悬空状态，AF15则是系统的EVENTOUT接入</p>
<h3 id="EVENTOUT"><a href="#EVENTOUT" class="headerlink" title="EVENTOUT"></a>EVENTOUT</h3><p>参考ARM内核部分内容</p>
<h2 id="GPIO复用输入输出"><a href="#GPIO复用输入输出" class="headerlink" title="GPIO复用输入输出"></a>GPIO复用输入输出</h2><p>在库函数中使用以下方式设置GPIO连接到复用器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_PinAFConfig(GPIOF,GPIO_PinSource9,GPIO_AF_TIM14);<span class="comment">//GPIOF9通过复用器连接到定时器14</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;<span class="comment">//在初始化结构体中配置为复用</span></span><br><span class="line"><span class="comment">//开启GPIO时钟同时也要开启所要复用外设的时钟</span></span><br><span class="line"><span class="comment">//不要忘记使能外设</span></span><br><span class="line"><span class="comment">//GPIO的其他功能按照正常配置即可</span></span><br></pre></td></tr></table></figure>

<p>复用功能设置库函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_PinAFConfig</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="keyword">uint16_t</span> GPIO_PinSource, <span class="keyword">uint8_t</span> GPIO_AF)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="keyword">uint32_t</span> temp = <span class="number">0x00</span>;</span><br><span class="line">  	<span class="keyword">uint32_t</span> temp_2 = <span class="number">0x00</span>;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">/* Check the parameters */</span></span><br><span class="line">  	assert_param(IS_GPIO_ALL_PERIPH(GPIOx));</span><br><span class="line">  	assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));</span><br><span class="line">  	assert_param(IS_GPIO_AF(GPIO_AF));</span><br><span class="line">  </span><br><span class="line">  	temp = ((<span class="keyword">uint32_t</span>)(GPIO_AF) &lt;&lt; ((<span class="keyword">uint32_t</span>)((<span class="keyword">uint32_t</span>)GPIO_PinSource &amp; (<span class="keyword">uint32_t</span>)<span class="number">0x07</span>) * <span class="number">4</span>)) ;</span><br><span class="line">  	GPIOx-&gt;AFR[GPIO_PinSource &gt;&gt; <span class="number">0x03</span>] &amp;= ~((<span class="keyword">uint32_t</span>)<span class="number">0xF</span> &lt;&lt; ((<span class="keyword">uint32_t</span>)((<span class="keyword">uint32_t</span>)GPIO_PinSource &amp; (<span class="keyword">uint32_t</span>)<span class="number">0x07</span>) * <span class="number">4</span>)) ;</span><br><span class="line">    <span class="comment">//设置复用寄存器</span></span><br><span class="line">    </span><br><span class="line">  	temp_2 = GPIOx-&gt;AFR[GPIO_PinSource &gt;&gt; <span class="number">0x03</span>] | temp;</span><br><span class="line">  	GPIOx-&gt;AFR[GPIO_PinSource &gt;&gt; <span class="number">0x03</span>] = temp_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在库函数中提供的参考表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* GPIO_AFSelection: 选择被用于复用的引脚</span></span><br><span class="line"><span class="comment">  *          This parameter can be one of the following values:</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_RTC_50Hz: Connect RTC_50Hz pin to AF0 (default after reset) </span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_MCO: Connect MCO pin (MCO1 and MCO2) to AF0 (default after reset) </span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_TAMPER: Connect TAMPER pins (TAMPER_1 and TAMPER_2) to AF0 (default after reset) </span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_SWJ: Connect SWJ pins (SWD and JTAG)to AF0 (default after reset) </span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_TRACE: Connect TRACE pins to AF0 (default after reset)</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_TIM1: Connect TIM1 pins to AF1</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_TIM2: Connect TIM2 pins to AF1</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_TIM3: Connect TIM3 pins to AF2</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_TIM4: Connect TIM4 pins to AF2</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_TIM5: Connect TIM5 pins to AF2</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_TIM8: Connect TIM8 pins to AF3</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_TIM9: Connect TIM9 pins to AF3</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_TIM10: Connect TIM10 pins to AF3</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_TIM11: Connect TIM11 pins to AF3</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_I2C1: Connect I2C1 pins to AF4</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_I2C2: Connect I2C2 pins to AF4</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_I2C3: Connect I2C3 pins to AF4</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_SPI1: Connect SPI1 pins to AF5</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_SPI2: Connect SPI2/I2S2 pins to AF5</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_SPI4: Connect SPI4 pins to AF5 </span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_SPI5: Connect SPI5 pins to AF5 </span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_SPI6: Connect SPI6 pins to AF5</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_SAI1: Connect SAI1 pins to AF6 for STM32F42xxx/43xxx devices.       </span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_SPI3: Connect SPI3/I2S3 pins to AF6</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_I2S3ext: Connect I2S3ext pins to AF7</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_USART1: Connect USART1 pins to AF7</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_USART2: Connect USART2 pins to AF7</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_USART3: Connect USART3 pins to AF7</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_UART4: Connect UART4 pins to AF8</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_UART5: Connect UART5 pins to AF8</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_USART6: Connect USART6 pins to AF8</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_UART7: Connect UART7 pins to AF8</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_UART8: Connect UART8 pins to AF8</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_CAN1: Connect CAN1 pins to AF9</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_CAN2: Connect CAN2 pins to AF9</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_TIM12: Connect TIM12 pins to AF9</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_TIM13: Connect TIM13 pins to AF9</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_TIM14: Connect TIM14 pins to AF9</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_OTG_FS: Connect OTG_FS pins to AF10</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_OTG_HS: Connect OTG_HS pins to AF10</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_ETH: Connect ETHERNET pins to AF11</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_FSMC: Connect FSMC pins to AF12 </span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_FMC: Connect FMC pins to AF12 for STM32F42xxx/43xxx devices.   </span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_OTG_HS_FS: Connect OTG HS (configured in FS) pins to AF12</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_SDIO: Connect SDIO pins to AF12</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_DCMI: Connect DCMI pins to AF13</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_LTDC: Connect LTDC pins to AF14 for STM32F429xx/439xx devices. </span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_EVENTOUT: Connect EVENTOUT pins to AF15</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="使用GPIO的步骤"><a href="#使用GPIO的步骤" class="headerlink" title="使用GPIO的步骤"></a>使用GPIO的步骤</h1><ol>
<li><p>系统功能</p>
<p>复位后GPIO自动连接AF0，然后会根据寄存器配置进行初始化，在这个阶段会进行JTAG/SWD、RTC参考输入、MCO1、MCO2等系统功能的引脚初始化</p>
</li>
<li><p>GPIO输入输出配置</p>
<p>在GPIOx_MODER寄存器中将所需 I/O 配置为输出或输入即可进行独立的输入输出</p>
<p>注意需要打开GPIO时钟！</p>
</li>
<li><p>外设复用使能</p>
<p>对于ADC和DAC，需要在GPIOx_MODER寄存器中将所需 I/O 配置为模拟输入/输出</p>
<p>对其他外设则需要在GPIOx_MODER寄存器中使能复用</p>
</li>
<li><p>其他选项</p>
<p>通过GPIOx_OTYPER、GPIOx_PUPDR和GPIOx_OSPEEDER寄存器，分别选择类型、上拉/下拉以及输出速度</p>
<p>在GPIOx_AFRL或GPIOx_AFRH寄存器中选择连接的具体复用外设</p>
<p>外设能复用的GPIO是唯一的，应该使用CubeMX或查阅芯片参考手册来设置</p>
</li>
<li><p>配置EVENTOUT</p>
<p>通过将复用器连接到AF15来配置用于输出Cortex-M4内核EVENTOUT信号的GPIO引脚</p>
<p>注意：对于stm32f407，EVENTOUT不会映射到PC13、PC14、PC15、PH0、PH1、PI8引脚</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>常用控制算法</title>
    <url>/2021/11/14/%E5%B8%B8%E7%94%A8%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="硬件控制算法"><a href="#硬件控制算法" class="headerlink" title="硬件控制算法"></a>硬件控制算法</h1><p>可应用的电路系统一般由模拟电路和数字电路组成。模拟电路用于电信号的处理和提供电源；数字电路则用于采集非电信号数据和控制系统。一般来说系统控制使用MCU、DSP或FPGA通过软件编程实现，在其中常使用用于控制系统的各种算法。</p>
<span id="more"></span>

<h2 id="PID算法"><a href="#PID算法" class="headerlink" title="PID算法"></a>PID算法</h2><h3 id="PID算法简介"><a href="#PID算法简介" class="headerlink" title="PID算法简介"></a>PID算法简介</h3><p>PID算法是一种很成熟、应用广泛的连续时间控制系统算法，最突出优点在于：</p>
<ul>
<li>结构典型</li>
<li>方便参数整定</li>
<li>可以灵活更改结构</li>
</ul>
<p>除了数字PID，还存在使用电阻、电容反馈与集成运放配合实现的模拟PID，但是因为其不便于修改和调参，适用范围不广</p>
<p>PID是一种典型的闭环控制算法，使用PID控制器<em>D(s)<em>来完成控制，该控制器读取输出量</em>y(t)<em>和给定量</em>r(t)<em>，计算得到二者之间的误差</em>e(t)=r(t)-t(t)<em>，并获取其比例、积分、微分的线性组合来构成控制量</em>u(t)<em>，通过改变调节器参数</em>K<del>p</del>，K<del>i</del>，K<del>d</del><em>来实现控制，计算公式如下<br>$$<br>u(t)=K_P[e(t)+\frac{1}{T_I} \int_0^t e(t)dt+T_D \frac{de(t)}{dt}]<br>$$<br>或者可以采用变形公式<br>$$<br>u(t)=K_P\ e(t)+K_I \int_0^t e(t)dt+K_D \frac{de(t)}{dt}<br>$$<br>其中**三个参数P、I、D分别表示比例、积分、微分</em></em></p>
<p>实际应用中最常使用PI甚至只使用P参数来进行控制。因为D参数常常会引入不确定性，增大调参的难度。</p>
<p>三个参数的特性如下：</p>
<ul>
<li><p>比例调节参数K<del>P</del></p>
<p>  按比例反映系统的误差，一旦系统出现偏差比例调节就会进行，<strong>比例调节是主要的控制部分</strong>。但是过大的比例会使系统稳定性下降，系统反应更灵敏、速度加快、稳态误差更小，但是震荡次数会显著增多，调节时间也会加长；过小的比例则会导致系统很难回到稳态</p>
</li>
<li><p>积分调节参数K<del>I</del></p>
<p>  这个参数本质上是通过给定量和输出量之间稳态值的差来消除系统稳态误差，<strong>用于提高系统的控制精度</strong>。但过高的调节参数会导致系统稳定性下降，动态响应变慢，超调增大，该参数一般不单独作用，至少需要和P参数共用</p>
</li>
<li><p>微分调节参数K<del>D</del></p>
<p>  用于反映系统偏差信号的变化率，可以一定程度上预测偏差的变化趋势，<strong>起到超前控制作用</strong>。但是该参数难以整定，且过强的微分调节会使系统剧烈震荡，且对噪声干扰有放大作用，对抗干扰不利</p>
</li>
</ul>
<h3 id="数字PID控制"><a href="#数字PID控制" class="headerlink" title="数字PID控制"></a>数字PID控制</h3><p>数字控制系统大多数是采样数据控制系统，进入系统的连续时间信号必须经过采样和量化后转换为数字量才能进行相应的计算和处理，所以其中的参数需要使用数字计算去逼近，当采样周期短时可以使用求和代替积分，使用差商代替微商，<strong>将描述连续时间的PID算法微分方程变成描述离散时间的差分方程</strong></p>
<p>实际使用时有两种思路：</p>
<ol>
<li><p>位置式PID</p>
<p> 差分方程为<br> $$<br> u_n=K_P+[e_n+\frac{T_S}{T_I} \sum_{i=0}^n e_i+\frac{T_D}{T_S} (e_n - e_{n-1})]+u_0=K_P e_n +K_I \sum_{i=0}^n e_i+K_D(e_n - e_{n-1})+u_0<br> $$<br> 此式即数字PID算法的非递推形式——全量算法，$u_0$为控制量基准值，n=0时将会采用该值；$u_n$是第n个采样时刻的控制量；$T_S$为采样周期，在算法中为了实现求和，必须存储系统偏差的全部值$e_i$，该式求得全量输出$u_n$是控制量的绝对数值，决定了执行机构在控制系统中的位置</p>
<p> 因此称这种算法为位置算法</p>
</li>
<li><p>增量式PID</p>
<p> 当驱动步进电机这样需要控制量的增量的执行机构时，需要用增量算法，差分方程为<br> $$<br> \Delta u_n=u_n-u_{n-1}=K_P[e_n - e_{n-1}+\frac{T_S}{T_I}e_n +\frac{T_D}{T_S}(e_n -2e_{n-1}+e_{n-2})]<br> $$<br> 这时的输出值能体现各次误差量对控制作用的影响，计算时只需要存储最近的三个误差采样值$e_n,e_{n-1},e_{n-2}$</p>
</li>
</ol>
<h3 id="PID算法的饱和特性"><a href="#PID算法的饱和特性" class="headerlink" title="PID算法的饱和特性"></a>PID算法的饱和特性</h3><p>实际的控制系统存在这样的特性：当控制变量达到一定值后，系统的输出变量便不再增长，系统进入饱和区，称为<strong>饱和特性</strong>，这就要求系统的控制变量必须限制在某个范围之内$u_{min}\le u\le u_{max}$。有时对于控制量的变化率也有限制$|\frac{du}{dt}|\le|\frac{du_{max}}{dt}| $，为了能让控制系统更加稳定，需要对位置算法进行改进；虽然增量算法中没有累加和项，不会出现积分饱和，但是可能出现比例和微分饱和，需要使用积累补偿法，将因为饱和而未能执行的控制增量信息累积起来，一旦可能时再补充执行</p>
<p>位置算法的饱和主要由积分项引起，称为<strong>积分饱和</strong>，可以使用三种方法必免积分积累过大</p>
<ol>
<li><p>积分分离法</p>
<p> 在误差量较大时不进行积分，直到误差在一定值之内时才在控制量的计算中加入积分累积，差分方程为<br> $$<br> u_n=K_P e_n + K_I \sum_{i=0}^n K_i e_i +K_D(e_n -e_{n-1})<br> $$<br> 其中K<del>i</del>在$e_x\le \epsilon$时为1，在$e_x\ge \epsilon$时为0，以$\epsilon$作为门限值可以有效削减积分饱和</p>
</li>
<li><p>遇限削弱积分法</p>
<p> 当<strong>控制进入饱和区后便不再进行积分项的累加</strong>，只执行削弱积分的运算，使用该算法可以避免控制量长时间停留在饱和区</p>
</li>
<li><p>有效偏差法</p>
<p> 将<strong>实际执行的控制量对应的误差值</strong>作为有效误差值进行积分累加，而不是使用实际的误差值进行积分累加</p>
</li>
</ol>
<h3 id="PID调参（参数整定）"><a href="#PID调参（参数整定）" class="headerlink" title="PID调参（参数整定）"></a>PID调参（参数整定）</h3><ol>
<li><p>确定PID控制器结构</p>
<ul>
<li>控制结果比较宽松且要求稳定性的控制系统：P或PD控制器</li>
<li>必须消除稳态误差且要求精度的控制系统：PI或PID控制器</li>
<li>存在滞后的对象：PI控制器或PID控制器</li>
</ul>
<p> 一般情况下，P、PI、PID控制器应用较多，ID控制器可以说根本不用</p>
</li>
<li><p>调参</p>
<p> 参数选择要根据受控对象的具体特性和对控制系统的性能要求进行，工程上一般要求整个闭环系统是稳定的，对给定量的变化能迅速响应并平滑跟踪，超调量小；要求抗干扰性较高；总体上遵循解决主要问题，统筹兼顾其他方面，适量折中的思路</p>
<p> PID三个参数一般通过玄学调参或者经验公式确定</p>
<p> 采样周期选择可以通过以下方面进行确定：</p>
<ol>
<li>香农采样定理：$T_S \le \frac{\pi}{\omega_{max}}$（ω为被采样信号的上限角频率），用于确定采样周期的上限</li>
<li>有跟踪要求的闭环系统要适量减小采样周期</li>
<li>要求采样周期有一定宽度来确定计算精度，减少系统算力成本</li>
<li>通过经验公式和玄学调参来确定</li>
</ol>
<p> PID参数的基本调整方法如下：</p>
<ol>
<li>比例项逐次独立实验，取其中反应最快、超调最小的曲线</li>
<li>加入积分项，将之前选择的比例系数减小为50%到80%，再将积分时间置为较大值，观测响应曲线，再逐次减小积分时间，选择其中响应震荡次数较少、能快速趋近结果的参数</li>
<li>加入微分项减小超调和震荡，先设置T<del>D</del>=0，再逐渐加大微分项，在此基础上维持比例项80%到120%调节范围，积分项50%到150%调节范围</li>
<li>如果出现玄学问题可以直接随机调参，运气是实力的一部分</li>
</ol>
</li>
<li><p>特殊调参方法</p>
<ol>
<li><p>选足够短的采样周期，先使用P控制器，逐渐加大比例放大系数逐次实验直到系统对输入的阶跃信号响应出现稳定边缘的临界震荡，将此时的比例放大系数记为$K_r$，临界震荡周期记为$T_r$</p>
</li>
<li><p>以连续时间PID控制器为基准，使用误差平方积分作为评价函数，控制度<br> $$<br> \frac{min \int_0^{\inf} e^2(t)dt（数字控制）}{min\int_0^\inf e^2(t)dt（模拟控制）}<br> $$<br> 保证其必定大于1的前提下，选定一个合适的控制度</p>
</li>
<li><p>查经验公式表获取对应参数</p>
</li>
<li><p>实际检验参数并进行微调</p>
</li>
</ol>
</li>
</ol>
<h2 id="运动调节算法"><a href="#运动调节算法" class="headerlink" title="运动调节算法"></a>运动调节算法</h2><h3 id="大林算法"><a href="#大林算法" class="headerlink" title="大林算法"></a>大林算法</h3><p>许多工程中会遇到纯滞后调节系统，要求系统具有以下特征：</p>
<ul>
<li>滞后时间长</li>
<li>系统动态特性和稳定性高</li>
<li>没有或很少超调量</li>
</ul>
<p>一般使用大林算法处理这类问题。该算法由IBM的大林（Dahlin）设计，专用于处理带有纯滞后的一阶或二阶惯性环节，其传递函数分别为<br>$$<br>G_c(s)=\frac{Ke^{-\theta s}}{\tau_1 s +1}<br>$$<br>或<br>$$<br>G_c(s)=\frac{Ke^{-\theta s}}{(\tau_1 s+1)(\tau_2 s +1)}<br>$$<br>其中τ1和2都是对象的时间常数，θ=Nτ是对象的纯滞后时间，N为正整数，K为对象的放大倍数</p>
<p>该算法适合对ADC、DAC等需要一定时间的转换器或带有硬件运算电路的设备进行控制，使得整个闭环系统的传递参数为带有纯滞后时间的一阶惯性环节，即<br>$$<br>\Phi(s)=\frac{e^{-\theta s}}{\tau_1 s +1}<br>$$<br>算法数字控制器的最终表达式：<br>$$<br>U(k)=a_1 E(k)-a_2E(k-1)+b_1 U(k-1) +(1-b_1)U(k-N-1)<br>$$<br>U(k)为k时刻的输出值，E(k)是k时刻的误差值，E(k-1)是k-1时刻的误差值，U(k-N-1)是k-N-1时刻的输出值</p>
<p>该算法调参依旧很玄学，但是没有PID那么玄学，只要根据系统飞升曲线确定对象的纯滞后时间θ和系统时间常数τ，微调选取采样周期再不断调整τ值一般就能获得理想效果</p>
<p>该算法最大的优势就是消除了由于超调引起的系统不稳定因素</p>
<h3 id="模糊控制算法"><a href="#模糊控制算法" class="headerlink" title="模糊控制算法"></a>模糊控制算法</h3><p>当系统影响因素极度复杂，难以建立数学模型时，需要使用模糊控制算法。这是一种鲁棒性强、抗干扰、抗参数变化的非线性控制算法，适用于非线性、动态特征不易掌握及纯滞后系统的控制。模糊控制不受数学模型的束缚，采用模糊控制表，在调试过程中反复经过人工修正，建立模糊控制算法、确立模糊规则是设计模糊控制系统中最重要的环节。模糊控制算法的问题在于稳态精度低、易饱和、适应能力有限、没有形成完整的理论体系。</p>
<p>这一算法需要以下步骤实现建模：</p>
<ol>
<li><p>归纳实验经验：将经验公式归结为一组条件语句，称为<strong>模糊控制规则</strong>或模糊控制模型</p>
</li>
<li><p>将误差e和误差变化率de/dt进行模糊化处理：将输入变量映射到一个合适的响应领域或模糊集合的标识符</p>
<p> 本人接盘的一个项目代码里存在以下代码（关键数据已经模糊替换处理）</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	u8 AFlag = (RotateNum &gt; StraightNum);</span><br><span class="line">	u8 BFlag = ((RotateNum + StraightNum) &gt; Magicnumber);</span><br><span class="line">	u8 CFlag = (RotateNum &gt; Magicnumber);</span><br><span class="line">	u8 DFlag = (StraightNum &gt; Magicnumber);</span><br><span class="line">	u8 SFlag = AFlag * Magicnumber + BFlag * Magicnumber + CFlag * Magicnumber + DFlag;</span><br><span class="line">	<span class="keyword">switch</span> (condition)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> Magicnumber:</span><br><span class="line">	<span class="keyword">case</span> Magicnumber:</span><br><span class="line">		*MoveThruster[<span class="number">0</span>] = (u32) (RotateNum);</span><br><span class="line">		*MoveThruster[<span class="number">1</span>] = (u32) (RotateNum);</span><br><span class="line">		*MoveThruster[<span class="number">2</span>] = (u32) ((Magicnumber - RotateNum + StraightNum));</span><br><span class="line">		*MoveThruster[<span class="number">3</span>] = (u32) ((Magicnumber - RotateNum + StraightNum));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> Magicnumber:</span><br><span class="line">	<span class="keyword">case</span> Magicnumber:</span><br><span class="line">		*MoveThruster[<span class="number">0</span>] = (u32) (StraightNum);</span><br><span class="line">		*MoveThruster[<span class="number">1</span>] = (u32) (StraightNum);</span><br><span class="line">		*MoveThruster[<span class="number">2</span>] = (u32) ((Magicnumber - RotateNum + StraightNum));</span><br><span class="line">		*MoveThruster[<span class="number">3</span>] = (u32) ((Magicnumber - RotateNum + StraightNum));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> Magicnumber:</span><br><span class="line">	<span class="keyword">case</span> Magicnumber:</span><br><span class="line">		*MoveThruster[<span class="number">0</span>] = (u32) ((RotateNum + StraightNum - Magicnumber));</span><br><span class="line">		*MoveThruster[<span class="number">1</span>] = (u32) ((RotateNum + StraightNum - Magicnumber));</span><br><span class="line">		*MoveThruster[<span class="number">2</span>] = (u32) (StraightNum);</span><br><span class="line">		*MoveThruster[<span class="number">3</span>] = (u32) (StraightNum);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> Magicnumber:</span><br><span class="line">	<span class="keyword">case</span> Magicnumber:</span><br><span class="line">		*MoveThruster[<span class="number">0</span>] = (u32) ((RotateNum + StraightNum - Magicnumber));</span><br><span class="line">		*MoveThruster[<span class="number">1</span>] = (u32) ((RotateNum + StraightNum - Magicnumber));</span><br><span class="line">		*MoveThruster[<span class="number">2</span>] = (u32) ((Magicnumber - RotateNum));</span><br><span class="line">		*MoveThruster[<span class="number">3</span>] = (u32) ((Magicnumber - RotateNum));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*MoveThruster[<span class="number">4</span>] = (u32) (VerticalNum);</span><br><span class="line">	*MoveThruster[<span class="number">5</span>] = (u32) (VerticalNum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (condition == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	*MoveThruster[<span class="number">0</span>] = (u32) (*PDRotate);</span><br><span class="line">	*MoveThruster[<span class="number">1</span>] = (u32) ((Magicnumber - *PDRotate));</span><br><span class="line">	*MoveThruster[<span class="number">2</span>] = (u32) (*PDRotate);</span><br><span class="line">	*MoveThruster[<span class="number">3</span>] = (u32) (Magicnumber - *PDRotate);</span><br><span class="line">	*MoveThruster[<span class="number">4</span>] = (u32) (VerticalNum);</span><br><span class="line">	*MoveThruster[<span class="number">5</span>] = (u32) (VerticalNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 就是一个模糊控制算法的例子，其中的Magicnumber都是经过大量实验确定的控制数据。使用python自带的map函数可以很好地对数据进行映射。</p>
</li>
<li><p>应用模糊算法：根据控制规则计算出模糊控制量C，之后通过多次实验校准模糊控制规则</p>
</li>
<li><p>构造基本模糊控制器查询表：将之前的一整套控制方法写成库或表</p>
</li>
</ol>
<p>其中确定控制数据的步骤最为关键，称为<strong>解模糊化</strong></p>
<h3 id="神经网络算法"><a href="#神经网络算法" class="headerlink" title="神经网络算法"></a>神经网络算法</h3><p>自动调准控制模型，适应性极强，但算法较复杂，需求算力高，一般的MCU难以实现，一般使用专门的硬件加速单元配合高性能嵌入式处理器实现</p>
<p>算法原理比较复杂，我一个辣鸡电工的也不是很懂（悲）</p>
<h2 id="运动姿态控制算法"><a href="#运动姿态控制算法" class="headerlink" title="运动姿态控制算法"></a>运动姿态控制算法</h2><p>Bresenhan算法是常用的图形扫描算法，只使用整数加法和乘2运算即可实现，可以在低算力水平的MCU中搭载，实现控制物体按规律运动的效果</p>
<h3 id="产生线段的整数Bresenham算法"><a href="#产生线段的整数Bresenham算法" class="headerlink" title="产生线段的整数Bresenham算法"></a>产生线段的整数Bresenham算法</h3><p>直线方程$y=mx+b$，在现实中位于(x0,y0)的物体运动可能有多种趋势，但总体上可以分为以下两种：</p>
<ul>
<li>靠近(x0+1,y0)</li>
<li>靠近(x0+1,y0+1)</li>
</ul>
<p>根据这两种趋势分别计算他们到直线$y=mx+b$的距离d1、d2，在求出两距离之差$\Delta d=d_1-d_2=2m(x_i +1)-2y_i +2b-1$</p>
<p>根据Δd&gt;0，直线上点离(x0+1,y0+1)较近；Δd&lt;0，直线上点离(x0+1,y0)较近，再用该式乘Δx即可得到一般的判别式<br>$$<br>p_1=2\Delta y-\Delta x，x_{i+1}=x_i+1 \<br>y_{i+1}=y_i +1,p_{i+1}=p_i +2(\Delta y-\Delta x)，当p_i\ge 0 \<br>y_{i+1}=y_i,p_{i+1}=p_i +2\Delta y，当p_i&lt; 0<br>$$<br>只需将原公式适当修正，用$|\Delta y|$、$|\Delta x|$替换$\Delta y$、$\Delta x$就能轻易得到向后方运动的线段</p>
<h3 id="产生圆的整数Bresenham算法"><a href="#产生圆的整数Bresenham算法" class="headerlink" title="产生圆的整数Bresenham算法"></a>产生圆的整数Bresenham算法</h3><p>对于圆来说需要用尽可能多的点表示出控制对象需要经过的轨迹点，Bresenham算法也有与上面求直线类似的公式<br>$$<br>p_i=2(x_i+1)^2 +2y_i^2 -2y_i -2R^2 +1 \<br>x_{i+1}=x_i +1 \<br>y_{i+1}=y_i,p_{i+1}=p_i+4x_i+6，若p_i&lt;0 \<br>y_{i+1}=y_i-1,p_{i+1}=p_i +4(x_i-y_i)+10 ，若p_i\ge 0<br>$$<br>将圆分成八个方位，将上式镜像对称即可获得其他七个方位的公式，显而易见计算它需要消耗大量算力资源有两种解决方案：</p>
<ol>
<li>使用RAM存储前1/8的坐标数据，然后通过镜像对称求出剩下的1/8坐标，然后调整顺序输出。这种方法可以节省算力，但是需要耗费大量RAM空间，可能还需要扩展片外RAM</li>
<li>按顺时针求出8组1/8圆的Bresenham算法表达式，在接下来的控制过程中依次切换使用。这种方法不需要额外扩充RAM，但是需要花费经历处理控制-运算衔接问题。在一些性能足够的MCU上可以使用RTOS来减少需要的处理精力，因此这种方法可以有效平衡硬件和需求</li>
</ol>
<h2 id="数字滤波"><a href="#数字滤波" class="headerlink" title="数字滤波"></a>数字滤波</h2><p>数字滤波指使用数值运算达到改变输入信号中所含频率分量的相对比例，或滤除某些频率分量的目的。常用于处理坏点数据、对信号进行平滑处理、消除毛刺等用途</p>
<p>最简单的滤波其实就是按钮软件消抖</p>
<h3 id="限幅滤波"><a href="#限幅滤波" class="headerlink" title="限幅滤波"></a>限幅滤波</h3><p>又叫程序判断滤波，根据多次采集到的数据，如果当前采集值和前一次采集值维持在一定偏差ΔD之内，则将每次采集到的数据和前一次数据进行比较，如果它们差的绝对值小于ΔD，则本次采集到的数据有效，否则舍弃</p>
<p>这种滤波器可以克服偶然因素引入的脉冲干扰和波形上的尖峰毛刺，但是难以抑制周期性干扰且对于波形处理的平滑度较差，只能算作一种最简单的基本滤波</p>
<h3 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h3><p>将原来的采样间隔进行细分，在原有基础上采样N次，然后把N次采样值按照大小排序，取中位数为本次采样值。</p>
<p>能够有效克服偶然因素带来的干扰，对于变化缓慢的被测参数有良好的滤波效果，但对于快速变化的信号则不太适用。算法实现方面，一般采用冒泡排序、选择排序、快速排序等算法，由于引入了排序算法，该方法不能处理速度要求很高的信号，算法的运算速度和占用RAM直接受所选择的N值决定</p>
<h3 id="算术平均滤波"><a href="#算术平均滤波" class="headerlink" title="算术平均滤波"></a>算术平均滤波</h3><p>和中值滤波的实现思路类似，但是需要取N次采样的算术平均值。</p>
<p>该算法难以对高速信号使用（除非搭配死贵的高速FPGA和烦到爆炸的等长走线进行硬件级别的算法滤波）</p>
<h3 id="递推平均滤波"><a href="#递推平均滤波" class="headerlink" title="递推平均滤波"></a>递推平均滤波</h3><p>又称为滑动平均滤波，将连续的N个采样值设为一个FIFO（先入先出队列），队长就为N，将队列中的N个数据进行算术平均滤波</p>
<p>这种方法对于周期性干扰具有非常好的抑制作用，具有很高的平滑度，但是灵敏度较低，对于偶然出现的脉冲干扰抑制作用较差，不适用于脉冲干扰较严重的场合。</p>
<p>该算法原理也可以应用在<strong>软件陷波器</strong>上。取N=S/f。其中S是美妙的采样次数，即采样率；f是要消除的谐波的频率，S、N都要取整数，这样最终就能实现对于f频率谐波的定向消除（采样平均值Y=Σ1/N，最终获得Y-C）</p>
<h3 id="中值平均滤波"><a href="#中值平均滤波" class="headerlink" title="中值平均滤波"></a>中值平均滤波</h3><p>选取N个采样，去掉其中最大值和最小值，再进行算术平均滤波，融合了中值滤波和平均滤波的特点，但也继承了二者的缺点</p>
<h3 id="限幅平均滤波"><a href="#限幅平均滤波" class="headerlink" title="限幅平均滤波"></a>限幅平均滤波</h3><p>先限幅滤波，再进行算术平均滤波</p>
<p>可以有效抑制偶然出现的脉冲干扰并消除采样偏差，但仍旧不适合高速信号处理</p>
<h3 id="一阶滞后滤波"><a href="#一阶滞后滤波" class="headerlink" title="一阶滞后滤波"></a>一阶滞后滤波</h3><p>取用一个比例常数0&lt;k&lt;1，使用以下公式计算本次输出结果：<br>$$<br>Output=k*T_n +(1-k)*T_{n-1}<br>$$<br>其中T<del>n</del>为本次采样值，T<del>n-1</del>为上次输出值</p>
<p>该方法类似PID，但是会造成相位滞后，灵敏度较低，难以消除频率高于采样频率一半的干扰信号</p>
<p>不过对于周期性干扰具有良好的抑制作用且运算量不大，适用于频率较高、相位要求不高的场合</p>
<h3 id="加权递推平均滤波"><a href="#加权递推平均滤波" class="headerlink" title="加权递推平均滤波"></a>加权递推平均滤波</h3><p>赋予不同时刻的FIFO采样值不同的权重，在对其进行递推平均滤波</p>
<p>适合在有较大纯滞后时间常数的对象和采样周期短的情况；难以反映变化较慢、采样周期长的情况，且占用RAM较多</p>
<h3 id="消抖滤波"><a href="#消抖滤波" class="headerlink" title="消抖滤波"></a>消抖滤波</h3><p>又称为数字消抖，通过设置一个滤波计数器，将每次采样值与当前有效值比较，如果采样值和有效值相等则清零，否则计数器+1并判断计数器是否达到上限，如果计数器溢出则将本次值替换为当前有效值，再清零计数器</p>
<p>常用于对变化缓慢的被测参数进行滤波，可避免系统在临界值附近时的波动跳变，但并不适用于快速变化的参数测量控制</p>
<h3 id="限幅消抖滤波"><a href="#限幅消抖滤波" class="headerlink" title="限幅消抖滤波"></a>限幅消抖滤波</h3><p>先使用限幅滤波，再进行消抖滤波</p>
<p>避免将干扰值导入系统，但不适用于快速变化的参数</p>
<h3 id="复杂数字滤波"><a href="#复杂数字滤波" class="headerlink" title="复杂数字滤波"></a>复杂数字滤波</h3><p>卡尔曼滤波、IIR滤波、高阶滤波等都需要复杂的运算过程，经常需要使用浮点运算，因此需要搭载的MCU具有一定的算力才能使用</p>
]]></content>
      <tags>
        <tag>电赛笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>现代C语言1</title>
    <url>/2021/11/14/%E7%8E%B0%E4%BB%A3C%E8%AF%AD%E8%A8%801/</url>
    <content><![CDATA[<p>本篇内容根据《C程序设计新思维》编写，作者水平有限，难免存在疏漏和错误，有问题请指出</p>
<h1 id="C与POSIX的历史"><a href="#C与POSIX的历史" class="headerlink" title="C与POSIX的历史"></a>C与POSIX的历史</h1><p><strong>C、UNIX、POSIX的存在是紧密相连的</strong></p>
<p>C和UNIX都是在20世纪70年代由贝尔实验室的设计，而贝尔有一项与美国政府达成的协议：贝尔将不会把自身的研究扩张到软件领域，所以UNIX被免费发放给学者进行研究、重建；UNIX商标则被在数家公司之间专卖。在这个过程中，一些黑客们改进了UNIX，并增加了很多变体，于是在<strong>1988年IEEE建立了POSIX标准</strong>，提供了一个类UNIX操作系统的公共基础</p>
<h3 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h3><p>规定了shell script如何工作、常用的命令行工具如何工作、能够提供哪些C库等等</p>
<p>除了微软的Windows系列操作系统，<strong>几乎所有操作系统都建立在POSIX兼容的基础上</strong></p>
<p>特别地，加州大学伯克利分校的一些黑客们对UNIX进行了几乎翻天覆地的改进（重写UNIX的基础代码），产生了伯克利软件发行版（Berkeley Software istribution）BSD——苹果的MacOS正建立在这一发行版上</p>
<h3 id="GNU"><a href="#GNU" class="headerlink" title="GNU"></a>GNU</h3><p>GNU工程即GNU’s Not UNIX工程，由笔者很敬佩的理查德斯托曼主持开工，大多数的Linux发行版都使用了GNU工具（这就是为什么Linux的全称是GNU/Linux），GNU工程下所有软件都是“自由软件”（想了解自由软件或“Free Software”的详情，推荐阅读理查德斯托曼传记《若为自由故》），这就意味着GPL！</p>
<p>GNU工程下属的GNU C Compiler就是为大家所熟知的C编译器gcc</p>
<span id="more"></span>

<h2 id="K-amp-R-C"><a href="#K-amp-R-C" class="headerlink" title="K&amp;R C"></a>K&amp;R C</h2><p>由Dennis Ritchie和Ken Thompson以及其他的开发者共同发明的<strong>最原始的C标准</strong></p>
<h2 id="ANSI-C89"><a href="#ANSI-C89" class="headerlink" title="ANSI C89"></a>ANSI C89</h2><p>更被人所熟知的名字是简称“<strong>ANSI C</strong>”，这个版本是C的第一个成熟、统一的版本</p>
<p>在ANSI C成为主流这段时间内，分离出了C++</p>
<p>当下的POSIX规定了必须通过提供C99命令来提供C编译器</p>
<h2 id="ANSI-C99"><a href="#ANSI-C99" class="headerlink" title="ANSI C99"></a>ANSI C99</h2><p>吸收了<strong>单行注释、for(int i=0;i&lt;N;i++)格式</strong>等源自C++特性的ISO标准化版本</p>
<h2 id="C11"><a href="#C11" class="headerlink" title="C11"></a>C11</h2><p>在2011年新定义的版本，做出了泛型函数、安全性提升等<strong>“离经叛道”的改变</strong></p>
<p>GCC以光速支持了这个标准</p>
<h1 id="C开发环境搭建"><a href="#C开发环境搭建" class="headerlink" title="C开发环境搭建"></a>C开发环境搭建</h1><p>C开发环境=包管理器+C库+C编译器+调试器+代码编辑器+C编译器辅助工具+打包工具+shell脚本控制工具+版本控制工具+C接口</p>
<p>看上去很复杂，实际上也很复杂=)</p>
<p>为什么不用IDE呢？当你用C开发某些小众嵌入式设备程序时就明白了（包括但不仅限于目前的MIPS、xtensa、RISC-V、你自己花三年用verilog写出来的CPU（可能还莫名其妙移植了一个操作系统和对应的C编译器，也许会有这样的dalao吧）），IDE？TMD！</p>
<h2 id="包管理器与编译环境"><a href="#包管理器与编译环境" class="headerlink" title="包管理器与编译环境"></a>包管理器与编译环境</h2><blockquote>
<p>IDE？狗都不用！真男人都是记事本+编译器！</p>
</blockquote>
<h3 id="包管理器"><a href="#包管理器" class="headerlink" title="包管理器"></a>包管理器</h3><p>每个系统都具有不同的软件包组织方式，所以你的软件很可能被安装在某个犄角旮旯，这就需要包管理器来帮助安装软件；虽然说很奇怪，但windows下也有包管理器</p>
<p>安装完包管理器后，就能用它安装gcc或clang这种编译器、GDB调试器、Valgrind内存使用错误检测器、Gprof（一个运行效率评测软件）、make工具、（如果你很nb还可以安装cmake工具）、Pkg-config（查找库的工具）、Doxygen（用于生成程序文档的工具）、你喜欢的文本编辑器（包括但不仅限于Emacs、Vim、VSCode、Sublime、记事本），除此之外，还能安装一些跨平台的IDE（虽然不太推荐，但eclipse就是最大众的选择，XCode需要有钱人才能买得起（指苹果电脑），Code::blocks在win下工作有点拉跨），还有必要的git工具、autoconf、automake、libtool，以及最重要的增加程序猿B格的Z shell、oh-my-zsh</p>
<p>包管理器还能管理C库，用一些新C库（libcURL、libGLib、libGSL、libSQLite3、libXML2），你可以实现很炫酷的现代C语言开发以及防止重新造轮子</p>
<p>对于一个包管理器，常会提供供用户使用的包和供开发者使用的包，在安装时应该选择带有-dev或-devel的包</p>
<h3 id="包管理器的安装"><a href="#包管理器的安装" class="headerlink" title="包管理器的安装"></a>包管理器的安装</h3><p>在Linux下，包管理器分为两大阵营：</p>
<ul>
<li>Debian系的apt</li>
<li>Red hat系的yum</li>
</ul>
<p>目前而言，两边其实都很好用、易上手，不过根据程序猿的性格不同，选择yum的程序猿多少沾点（我使用apt，就是要引战！），另外还有一个叫的Arch的发行版，因为我一直没有能把它安装上，所以不知道那个<code>pacman -S</code>是什么东西</p>
<p>在Windows下，微软很nt（逆天，指微软很厉害）地提供了方便的软件安装方式：让你的C盘变红。不过Windows还是勉为其难地提供了一个POSIX兼容的东西——Cygwin是许多自由软件的集合，最初由Cygnus Solutions开发，用于各种版本的Microsoft  Windows上，运行UNIX类系统。Cygwin的主要目的是通过重新编译，将POSIX系统（例如Linux、BSD，以及其他Unix系统）上的软件移植到Windows上，可以在Cygwin网站上下载包管理工具，配合一个终端（Terminal）即可实现在Win下进行Linux开发（虽然很蛋疼）。安装方法参考百度（笑）</p>
<p>微软最近还开发了一个叫WSL（Windows Subsystem of Linux，最新版本是跑在windows自带虚拟机Hyper-V上的WSL2）的东西，这个东西可以让你在windows下进行不完全的linux使用（用的发行版是ubuntu），笔者目前使用的就是这个软件，安装很方便——开启Hyper-V和虚拟化、打开Microsoft应用商店搜索WSL点击下载安装即可，不过所有东西就被塞进了C盘。</p>
<h3 id="搭建C编译器并执行编译"><a href="#搭建C编译器并执行编译" class="headerlink" title="搭建C编译器并执行编译"></a>搭建C编译器并执行编译</h3><p>在POSIX环境下，一切都很方便，apt install能解决一切问题，想安装什么就<code>sudo apt install xxx</code></p>
<p>非POSIX环境下，可以使用MinGW来实现标准C编译器和一些基础工具，或者使用很好用的WSL</p>
<p>可以使用命令行下的编译器执行编译：</p>
<ol>
<li>设置一个变量，代表编译器使用的编译选项</li>
<li>设置变量代表要链接的库，一般要分开指出编译时和运行时链接的库</li>
<li>设置一个使用这些变量来协调编译的系统</li>
</ol>
<p>完整的gcc编译器命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc test.c -o test -lm -g -Wall -O3 -std=gnu11</span><br></pre></td></tr></table></figure>

<p>该命令告诉编译器通过程序中的#include包含库函数，并告诉链接器通过命令行中的-lm链接库文件</p>
<p>-o用于指定输出文件的名字，否则会得到一个默认的a.out作为可执行文件名</p>
<p>-g表示加入调试负好，如果没有这个选项，调试器就不会显示变量或者函数的名字</p>
<p>-std=gnu11是gcc的特有选项，允许使用c11和POSIX标准的代码；同理可以使用-std=gnu99来使用c99标准</p>
<p>-O3表示优化等级为3级，尝试已知的所有方法去建立更快的代码</p>
<p>-Wall用于添加编译器警告</p>
<h4 id="Windows下的编译"><a href="#Windows下的编译" class="headerlink" title="Windows下的编译"></a>Windows下的编译</h4><p>微软顽强地抗拒C语言，所以一般在Windows下编译c程序都使用MinGW或cygwin环境，在这些环境中编译后可以得到Windows本地的二进制代码（当然也可以使用宇宙第一IDE VS，在此不讨论）</p>
<p>但伴随的缺点就是缺少使用体验很爽的C库！</p>
<h3 id="链接函数库"><a href="#链接函数库" class="headerlink" title="链接函数库"></a>链接函数库</h3><p>安装编译器后，链接工具会被自动安装好</p>
<p>GCC可以自动完成优化-编译-链接一条龙</p>
<p>连接函数库之前需要注意的就是路径：编译器需要知道在哪个目录去查找正确的头文件和目标文件。典型的库存放位置可能有三种：</p>
<ul>
<li>由操作系统预定义某个目录来安装操作系统需要的库文件</li>
<li>本地系统管理员可能会准备一个用于安装包的目录</li>
<li>用户从操作系统给出路径中查询到库并具有使用权限</li>
</ul>
<p>使用以下命令行来指定头文件搜索目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -I 头文件所在目录 需要链接的.c文件名 -o 生成的.o文件名 -L 某个库所在的目录</span><br></pre></td></tr></table></figure>

<p>参数-I用于添加指定的路径到头文件的搜索路径范围内，编译器会在这个路径范围内搜索放在代码中用<code>#include</code>指定的头文件</p>
<p>参数-L用于添加指定的路径到库的搜索路径范围内</p>
<p>注意：<strong>最原始的依赖库放在参数最后面，引用了很多库且被当前编译文件引用的子库紧跟在-L之后</strong></p>
<p>因为链接器的工作方式是：</p>
<ol>
<li>查看-L参数后的第一个目标，将其中无法解析的函数、结构体、变量记入一个列表，然后查看下一个目标</li>
<li>在下一个目标中寻找未知元素列表中的项目并删去已经得知的项目或继续添加未知元素</li>
<li>重复上述过程，直到搜索完最后的文件</li>
<li>如果仍存在为解析的符号，则终止运行并报错</li>
</ol>
<p>正是因为这种工作方式，很多时候安装依赖库的顺序和编译的顺序不当就会导致“玄学错误”</p>
<p>以上方式就是常规的静态库链接方式，当然现在的软件没什么用静态库的了，嵌入式软件倒是个例外（不过也有些RTOS在嵌入式设备上应用了动态链接极制）。共享库用于动态链接，使用以下Makefile参数来告诉编译器从哪里寻找共享库来进行动态链接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">LDADD=-L libpath: xxxxxx -Wl,-R libpath: xxxxxx</span><br></pre></td></tr></table></figure>

<p>-L参数告诉编译器到哪里找到库来解析符号</p>
<p>-Wl参数从编译器传递后面的路径到链接器，链接器会将给定的-R嵌入到所连接的库的运行时搜索路径</p>
<h2 id="Makefile简介"><a href="#Makefile简介" class="headerlink" title="Makefile简介"></a>Makefile简介</h2><blockquote>
<p>Make工具就是天！——沃·兹基硕德</p>
</blockquote>
<p>Make工具是一个可以自动执行编译、链接等工作的程序，它也有POSIX标准化，需要通过读入Makefile作为指令和变量，很多嵌入式开发（包括交叉编译和底层软件编译）都要和它打交道</p>
<p>一般来说使用gcc编译一个文件需要像下面这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc hello.c -o hello.o</span><br></pre></td></tr></table></figure>

<p>对于几个文件的编译还算简单，但是如果是一个很大的工程，包含了数不清的文件，每个文件都互相依赖，那么写shell script就会很绝望了；使用makefile就会让编译工作轻松一点</p>
<p>最小的Makefile如下所示</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">P=helloworld</span><br><span class="line">OBJECTS=</span><br><span class="line">CFLAGS = -g -Wall -O3</span><br><span class="line">LDLIBS=</span><br><span class="line">CC=c99</span><br><span class="line"></span><br><span class="line"><span class="variable">$(P)</span>:<span class="variable">$(OBJECTS)</span></span><br></pre></td></tr></table></figure>

<p>现在一般都使用GNU Make工具（GNU：没错还是我），需要将编写的Makefile命名为<code>Makefile</code>并将其与.c文件放在同一目录下，在命令行中输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<p>就可以进行自动化编译了</p>
<p>当然可以在后面添加参数<code>-jn</code>其中n表示你使用的cpu线程数——这就是多线程编译，可以提高编译速度；但是相对应的就不会生成每个.c文件对应的warning，并且会自动在第一个error处停下，并且不会告诉你error发生在哪里，所以如果是第一次编译请不要使用这个参数</p>
<h3 id="make语法"><a href="#make语法" class="headerlink" title="make语法"></a>make语法</h3><p>makefile的语法有两种流派：POSIX型和C shell型，现在的makefile大多使用POSIX型或其近似的语法；而CMake工具的cmakelist则选择了类似C shell的语法</p>
<p>make和shell一样使用$指代变量的值，但shell要求使用<code>$var</code>，make则要求使用<code>$(var)</code>形式</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(P)</span>:<span class="variable">$(OBJECTS)</span> <span class="comment">#相当于program_name=</span></span><br></pre></td></tr></table></figure>

<p>有以下几种方法让make工具识别变量：</p>
<ul>
<li>调用make之前在shell中设定变量并使用export命令导出</li>
<li>将export命令写入shell启动脚本中，就可以在启动shell时自动完成变量加载</li>
<li>在一个命令前放置赋值操作，这将把变量设置为一个环境变量</li>
<li>在Makefile的头部设定变量</li>
<li>在命令行中使用make指令后接要设置的变量，这些变量会独立于shell作为make工具的变量存在</li>
</ul>
<p>在C代码中可以使用getenv函数获取环境变量信息，这需要调用stdlib.h库</p>
<p>make工具也提供了一些内置的变量，如下所示：</p>
<ul>
<li><p>$@</p>
<p>返回完整的目标文件名（目标文件就是从.c文件中编译得到的.o文件）</p>
</li>
<li><p>$*</p>
<p>返回不带文件名后缀的目标文件</p>
</li>
<li><p>$&lt;</p>
<p>返回触发和制作该目标文件的文件的名称</p>
</li>
</ul>
<p>Makefile的标准形式如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">target:dependencies</span></span><br><span class="line">	script</span><br></pre></td></tr></table></figure>

<p>输入命令<code>make target</code>时，对应的target就会被调用，检查dependencies是否是较早（target文件比dependencies更新）的文件，如果检查通过则运行所有的dependencies，结束后再运行target部分的脚本；如果检查不通过则对script的处理会被暂停</p>
<p>Makefile基本上就是目标target、依赖dependencies、脚本script三者所组成的一系列规则。make工具就是根据Makefile的规则决定如何编译和链接程序或者执行其它操作（包括但不仅限于自动下载远程程序、解压缩包、打补丁、设定参数、编译并将软件安装到系统中指定位置等）</p>
<h3 id="Make的本质"><a href="#Make的本质" class="headerlink" title="Make的本质"></a>Make的本质</h3><p>在编写小工程，特别是只有不多文件的情况下，在shell里使用gcc就可以了，如果工程数量继续增长，自行编写Shell Script也很简单；但是如果是依赖条件复杂的大工程，直接使用编译器就会很繁琐，这时候通常使用<strong>构建工具</strong>来辅助</p>
<blockquote>
<p>构建工具 (software construction tool)  是一种软件，它可以根据一定的规则或指令，将源代码编译成可执行的二进制程序。这是构建工具最基本也是最重要的功能。实际上构建工具的功能不止于此，通常这些规则有一定的语法，并组织成文件。这些文件用来控制构建工具的行为，在完成软件构建之外，也可以做其他事情。</p>
</blockquote>
<p>Linux的内核、Linux上运行的大多数Qt软件、洗衣机的主控、ESP32的底层文件……都是用Make工具完成构建的，这是历史最为悠久的开源构建工具，但是正因如此它的语法比较混乱，且不被Windows支持（除非使用上文提到的Cygwin环境）。除此之外，只要外部条件稍微变化一些，就需要修改软件的Makefile。为了让安装软件更加容易，程序员开发出了几个神奇的生成工具：Ninja、Automake、SCons、CMake。利用这些改善过的工具，编程者只需要写一些预先定义好的宏，提交给程序自动处理，就会生成一个可以供Make工具使用的Makefile文件，再配合使用工具产生的自动配置文件configure即可产生一份符合GNU-Makefile规定的Makefile；或者直接通过自己独有的软件编译方式对工程进行生成。</p>
<h2 id="Ninja简介"><a href="#Ninja简介" class="headerlink" title="Ninja简介"></a>Ninja简介</h2><p>除了Make工具外，Ninja也是一个自动化编译的构建工具。它由Google的一名程序员开发，通过将编译任务并行化大大提高编译速度</p>
<p>它并不使用Makefile，而是用一套自己组织的<code>.ninja</code>脚本</p>
<p>现在Android Studio等都选用了Ninja作为编译工具，也有许多嵌入式设备厂商自己的SDK使用了ninja</p>
<p>ninja的安装方法和make一样</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install ninja</span><br></pre></td></tr></table></figure>

<p>或者可以从github上拉取最新版本的ninja源码，然后自行编译安装</p>
<p>只不过make支持POSIX标准，可以直接在linux上运行；但是ninja需要事先安装一些依赖，具体情况可以参考<a href="https://ninja-build.org/">官网</a></p>
<p>这里不多介绍ninja的使用方法</p>
<h2 id="SCons简介"><a href="#SCons简介" class="headerlink" title="SCons简介"></a>SCons简介</h2><p>SCons是另一套由Python编写的开源构建系统，它和Make、Ninja一样可以生成脚本进行快速编译，但是SCons有一个最厉害的地方：<strong>它使用的是python脚本，能够使用标准的Python语法编写构建工程</strong></p>
<p>详情可以参考<a href="https://www.scons.org/">官网</a></p>
<p>SCons的脚本称为<em>SConscript</em>，支持多种编译器，包括但不仅限于gcc、clang，甚至支持很多公司专有的交叉编译工具</p>
<p>它的安装也比较简单：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install python #安装依赖——这玩意是用python写的</span><br><span class="line">sudo apt install scons</span><br></pre></td></tr></table></figure>

<p>直接在程序目录使用下面的指令就可以轻松完成很多原本需要Makefile写很多才能完成的任务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scons #相当于make</span><br><span class="line">scons -c #相当于make clean</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面的就是个开胃菜，和make没差很多；下面才是scons的神奇之处</span></span><br><span class="line">touch SConstruct</span><br><span class="line">vim SConstruct #新建一个SCons脚本</span><br><span class="line">Program(&#x27;testPro1&#x27;, Glob(&#x27;*.cpp&#x27;)) #写完以后直接保存退出</span><br><span class="line">scons #直接回到shell来一个执的行，testPro1就构建完毕了</span><br></pre></td></tr></table></figure>

<p>除了直接使用<code>scons</code>命令生成外，SCons还支持一些扩展功能</p>
<p>RT-Thread就将它扩展为了keil MDK/IAR/VS/CubeIDE工程生成器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scons --target=xxx #生成某个IDE的工程</span><br></pre></td></tr></table></figure>

<p>SConscript还能执行一些方便的内置函数</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">GetCurrentDir() <span class="comment">#获取当前路径</span></span><br><span class="line">Glob() <span class="comment">#获取当前目录下的所有文件，支持在里面使用表达式匹配</span></span><br><span class="line">Glob(&#x27;*.c&#x27;) <span class="comment">#获取当前目录下的.c文件</span></span><br><span class="line">Split(str) <span class="comment">#将字符串str分割成一个列表</span></span><br></pre></td></tr></table></figure>

<p>具体的SCons使用还要更复杂一些，所有使用方法都可以参考官网或者使用到SCons的SDK说明，即用即查，不需要特意学习</p>
<h2 id="Automake简介"><a href="#Automake简介" class="headerlink" title="Automake简介"></a>Automake简介</h2><p>Automake是正统的GNU软件，它用来生成Make构建系统。</p>
<p>这是一个套娃：gcc/clang是编译器，或者说构建工具；Make/Ninja/SCons是构建系统；Automake/CMake则是<strong>生成构建系统的系统</strong></p>
<h2 id="CMake简介"><a href="#CMake简介" class="headerlink" title="CMake简介"></a>CMake简介</h2><p>CMake是比Automake更常用一些的系统，它通过读取<code>CMakeLists.txt</code>中的规则来构建编译系统</p>
<p>它的脚本格式大致如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.9</span>) <span class="comment">#注明需要的cmake工具版本</span></span><br><span class="line"><span class="keyword">project</span>(HelloWorld) <span class="comment">#工程名</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>) <span class="comment">#设置要使用编译器版本</span></span><br><span class="line"><span class="keyword">add_executable</span>(HelloWorld main.cpp) <span class="comment">#指定源文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#下面是负责程序安装的指令</span></span><br><span class="line"><span class="keyword">install</span>(TARGETS HelloWorld DESTINATION bin) <span class="comment">#指定将生成的程序文件安装到/usr/local/bin</span></span><br><span class="line"><span class="keyword">install</span>(FILES HelloWorld.h DESTINATION <span class="keyword">include</span>) <span class="comment">#指定将库文件保存到/usr/local/include</span></span><br></pre></td></tr></table></figure>

<p>在shell中使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir build #惯用方式，将所有生成的文件保存至build目录</span><br><span class="line">cd build</span><br><span class="line">cmake .. #对上一级也就是工程项目主目录执行cmake，前提是CMakeLists.txt保存在工程项目主目录</span><br><span class="line"><span class="meta">#</span><span class="bash">所有生成的文件会被保存到build目录，包括Makefile</span></span><br><span class="line">make #执行make</span><br></pre></td></tr></table></figure>

<p>就可以完成所有编译任务</p>
<p><strong>它可以将Makefile的编写完全转化成CMakeLists的编写</strong>，虽然看上去多此一举，但实际上增强了编译时的可靠性和程序的可移植性</p>
<h2 id="Kconfig简介"><a href="#Kconfig简介" class="headerlink" title="Kconfig简介"></a>Kconfig简介</h2><blockquote>
<p>半个可视化也是可视化——伽利略（？）</p>
</blockquote>
<p>一般来说一个工程完全可以依靠CMake-Make-GCC的工具链完成编译，但实际上很多与c语言打交道的底层程序需要适配各种不同的情况，这就需要使用<strong>代码模块化</strong>思想：将一套代码分成多个模块以适应不同情景</p>
<p>最典型的就是Linux内核了：有的设备是嵌入式的，有的设备是高性能的，有的设备带摄像头、网口，有的设备只有WiFi，有的设备自带一堆硬件加速器，有的设备使用RISC-V架构——而Linux内核需要针对这些情况进行优化，因此它使用了“宏内核”思想，内核接管一切驱动程序的管理，将底层所有设备归类交给不同的驱动程序管理。这时Linux的内核编译就需要事先确定目标设备上都有什么，预先选好要加入工程的组件再生成源代码（这也使用了C预编译器的一部分功能）</p>
<p>负责灵活配置编译单元——说人话就是从一堆预先写好的代码里挑选出合适的代码的工具就是<strong>Kconfig</strong></p>
<p>Kconfig工具生成CMakeList的设置参数；之后调用<code>make menuconfig</code>配置<code>.cmake</code>文件用于将Kconfig生成的参数赋值给CMake变量、<code>.mk</code>配置文件用于保存make工具的编译变量、<code>.h</code>文件用于提供C语言的编译基础；再然后使用CMake工具生成Makefile；最后使用Make工具进行编译，就可以生成一个bin文件了</p>
<p>这里着重强调一下Kconfig的使用——因为它是Linux内核编译的最重要辅助工具之一——在编译内核时，需要用到<code>make menuconfig</code>指令，而这个指令并没有直接调用make、cmake工具，而是先借助Kconfig工具打开一个蓝色的配置菜单界面，如下所示</p>
<p><img src="/2021/11/14/%E7%8E%B0%E4%BB%A3C%E8%AF%AD%E8%A8%801/image-20210820192752213.png" alt="image-20210820192752213"></p>
<p>这个蓝色的菜单可以说是最经典的多级菜单程序，但这里我们不说多级菜单的实现，仅仅谈它使用的脚本工具<strong>Kconfig</strong></p>
<p>使用<strong>config</strong>语句定义一组新的配置选项</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">config CONFIG_A</span><br><span class="line">    <span class="keyword">bool</span> <span class="string">&quot;Enable MyConfig&quot;</span></span><br><span class="line">    select SELECTED</span><br><span class="line">    <span class="keyword">default</span> y</span><br><span class="line">    help</span><br><span class="line">    My Config</span><br></pre></td></tr></table></figure>

<p><strong>bool</strong>表示配置<strong>选项的类型</strong>，每个config菜单项都要有类型定义，变量有5种类型：<code>bool</code>布尔，也就是二选一（y或n）、<code>tristate</code>三态，也就是三选一、<code>string</code>字符串，也就是用户从给出的一堆字符串里选择一个、<code>hex</code>十六进制，也就是用户要选择一个十六进制数、<code>int</code>整型，也就是用户需要选择一个整数，需要注意：这里的<em>用户选择</em>是不严谨的，实际上==选项类型决定了Kconfig会生成什么样的#define语句提供给C源代码==；**”Enable MyConfig”<strong>表示该</strong>选项的名称<strong>；</strong>select<strong>表示如果当前配置选项被</strong>选中<strong>，则SELECTED就会被选中；</strong>default<strong>后面跟的参数表示配置选项的</strong>默认值**；help后面跟的语句会作为帮助信息提供给用户</p>
<p>使用<strong>menu/endmenu块</strong>来生成一个菜单，这个菜单里面可以包含复数个config语句，也可以包含子菜单</p>
<p>使用<strong>if/endif块</strong>来实现条件判断</p>
<p>使用<strong>menuconfig</strong>语句表示带菜单的配置项，也就是可展开的菜单</p>
<p>使用<strong>choice/endchoice</strong>语句将多个类似的配置选项组合在一起，供用户选择一组配置项，也就是“弹窗”子菜单</p>
<p>使用<strong>comment</strong>语句定义帮助信息，这些东西会出现在界面第一行</p>
<p>使用<strong>source</strong>语句读取另一个文件中的Kconfig文件</p>
<h2 id="以上软件的组织架构"><a href="#以上软件的组织架构" class="headerlink" title="以上软件的组织架构"></a>以上软件的组织架构</h2><h3 id="半可视化编译配置工具"><a href="#半可视化编译配置工具" class="headerlink" title="半可视化编译配置工具"></a>半可视化编译配置工具</h3><p>Kconfig</p>
<h4 id="构建工具生成器"><a href="#构建工具生成器" class="headerlink" title="构建工具生成器"></a>构建工具生成器</h4><p>CMake</p>
<p>Automake</p>
<h5 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h5><p>Make</p>
<p>Ninja</p>
<p>SCons</p>
<h2 id="调试器GDB"><a href="#调试器GDB" class="headerlink" title="调试器GDB"></a>调试器GDB</h2><p>GDB是目前最常用的调试器（没有之一），它支持多平台、多目标的调试过程。</p>
<p>调试器，顾名思义就是用于调试程序的软件。它能够给出底层的变量变化和回溯的信息，同时可以追踪内存和寄存器中数值的变化，一般的调试器可以提供<strong>断点</strong>功能和<strong>追踪</strong>功能。编译时，在gcc指令后加入-g参数即可启用调试功能，不过这会导致程序变大一些</p>
<p>gdb可以直接在命令行模式中使用，但是一般来说各种代码编辑器和IDE会将gdb嵌入，并提供可视化的调试功能，下面是一些使用命令行模式gdb时会用到的指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb &lt;file&gt; # 使用gdb调试文件</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">--下面会进入gdb命令行--</span></span><br><span class="line">(gdb) r # 正常执行程序直到遇到错误或断点</span><br><span class="line">(gdb) l # 显示运行到的那一行代码</span><br><span class="line">(gdb) l &lt;部分代码&gt; # 显示以某行为中心的部分代码</span><br><span class="line">(gdb) b &lt;部分代码&gt; # 在某行代码处打断点</span><br><span class="line">(gdb) p &lt;变量/指针&gt; # 输出某变量/指针的值</span><br><span class="line">(gdb) bt # 列举出堆栈帧</span><br><span class="line">(gdb) info threads # 获取程序使用线程列表</span><br><span class="line">(gdb) n # 重复单步运行程序</span><br><span class="line">(gdb) b &lt;行号&gt; # 在某一行打断点</span><br><span class="line">(gdb) r # 重新开始一个循环</span><br><span class="line">(gdb) c # 继续运行程序直到完成当前循环或运行到return</span><br><span class="line">(gdb) disp &lt;变量&gt; # 将某变量的变化在调试过程中自动显示</span><br><span class="line">(gdb) &lt;Enter&gt; # 重复上一步命令</span><br><span class="line">(gdb) f &lt;帧号&gt; # 查看某一帧</span><br></pre></td></tr></table></figure>

<p>任何函数都会在内存中占据一个空间，称为函数<strong>帧</strong>，函数帧会使用特殊的数据结构保存与这个函数有关的所有信息，gdb则可以直接查阅堆栈帧并获取信息。</p>
<p>现在的调试过程已经基本不需要使用gdb的命令行模式了（除非是对跑在某些极少有人使用的、没有开源社区提供gdb调试工具的莫名其妙的cpu上的程序），VSCode、Sublime、Vim、Emacs里面都内置了gdb的（半）图形化调试只需要知道如何打断点、单步调试、查看汇编等基本操作就可以进行有效调试了</p>
]]></content>
      <tags>
        <tag>C语言进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>MSP430简介</title>
    <url>/2021/11/13/msp430%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="MSP430"><a href="#MSP430" class="headerlink" title="MSP430"></a>MSP430</h1><p>该MCU是由德州仪器TI生产的16位低功耗单片机</p>
<span id="more"></span>

<p>主要分以下型号：</p>
<ul>
<li>专注低功耗的<strong>1xx</strong>通用型，配备1KB-60KB FLASH、512B-10KB RAM，工作时耗电仅达200uA/MIPS，RAM保持模式耗电0.1uA，RTC模式耗电0.7uA；可在6us之内快速唤醒。搭载10/12位斜率SAR ADC，集成模拟比较器、DMA、硬件乘法器、BOR、SVS、12位DAC</li>
<li>能耗比高的<strong>F2xx</strong>通用型，性能<a href="mailto:&#49;&#54;&#77;&#73;&#80;&#x53;&#x40;&#51;&#x2e;&#51;&#86;">&#49;&#54;&#77;&#73;&#80;&#x53;&#x40;&#51;&#x2e;&#51;&#86;</a>，配备1-120KB FLASH，8-128KB RAM，工作耗电220uA，配备10/12位斜率SAR ADC，集成16位Σ-ΔADC，基本上等于1xx的升级版</li>
<li><strong>性价比</strong>高的<strong>G2xx</strong>经济型，性能<a href="mailto:&#49;&#x36;&#x4d;&#x49;&#80;&#83;&#x40;&#x33;&#46;&#x33;&#x56;">&#49;&#x36;&#x4d;&#x49;&#80;&#83;&#x40;&#x33;&#46;&#x33;&#x56;</a>，对标友商stm32l，主打模拟外设和低功耗</li>
<li>面向计量和智能电网的AFE2xx专用型：性能略低于以上两个2xx系列，但是集成了1-3个独立的24位Σ-ΔADC，一个16位定时器、一个16位硬件乘法器、USART控制器、看门狗和GPIO</li>
<li>停产的老型号3xx</li>
<li>面向低功耗<strong>多媒体</strong>的<strong>4xx</strong>控制型，8-16MIPS处理性能，<strong>配备LCD控制器</strong>、<strong>FLL、SVS</strong>，针对低功耗测量和医疗应用，功耗和1xx相近，4-120KB FLASH、8-256KB RAM，引脚丰富最多可达80Pin，配备10/12位斜率SAR、16位Σ-ΔADC，同样集成了12位ADC、DMA、硬件乘法器、运放、USCI模块等</li>
<li><strong>超高能耗比的5xx超低功耗型</strong>，能达到<a href="mailto:&#50;&#x35;&#77;&#73;&#x50;&#83;&#x40;&#51;&#46;&#x33;&#x56;">&#50;&#x35;&#77;&#73;&#x50;&#83;&#x40;&#51;&#46;&#x33;&#x56;</a>，工作模式功耗165uA/MIPS，RTC模式2.5uA，RAM保持模式可达1uA，待机唤醒时间极短，小于5ms，配备256KB FLASH、18KB RAM，额外集成了USB、模拟比较器</li>
<li>高性能、低功耗的6xx系列旗舰型，达到<a href="mailto:&#x32;&#53;&#x4d;&#73;&#x50;&#x53;&#x40;&#x33;&#46;&#x33;&#x56;">&#x32;&#53;&#x4d;&#73;&#x50;&#x53;&#x40;&#x33;&#46;&#x33;&#x56;</a>，配备功耗优化的创新电源管理模块和USB控制器，配备LCD控制器，有256KB FLASH、18KB RAM，74Pin引脚，功耗与5xx系列相同，还额外集成了电压管理模块</li>
<li>基于<strong>FRAM</strong>技术的<strong>FRxx</strong>系列，和主要的F系列差别在于使用了FRAM存储技术，能够达到更快的FLASH访问速度并在所有功率模式下实现零功率状态保持，即使发生功率损耗的情况也可以保证写入操作，写入寿命能达到100M个周期，不再需要EEPROM</li>
<li>低电压C、L系列，两个谢列都可以在0.9-1.65V电压范围内工作并提供4MIPS的性能</li>
<li>集成射频基带的CC无线系列，具有低于1GHz的片上射频收发器，工作电压为1.8-3.3V，处理性能20MIPS</li>
<li>特殊系列：面对车规应用、电容触摸、超声波测量、DSP等等特殊用途的系列设备</li>
</ul>
<p>综合来看MSP430具有以下特点：</p>
<ol>
<li><p>超低功耗</p>
<p>使用1.8-3.6V低电压供电，RAM数据保持方式下耗电仅为0.1μA/MIPS，活动模式下耗电也仅仅为250μA/MIPS，IO输入端口漏电流仅为50mA，相比之下只有stm8和stm32l0系列能够达到同等级的低功耗水准。普通的8051则远远落后</p>
</li>
<li><p>能效比高，针对算法加速</p>
<p>MSP430基于RISC架构，采用了一般DSP才有的16位多功能硬件乘法器、硬件乘-加功能、DMA等架构，可以高效实现如FFT、DFT、FIR滤波等数字信号处理算法</p>
</li>
<li><p>模拟外设技术高</p>
<p>MSP430片内集成多种模拟外设，包括液晶驱动器和ADC、DAC等，具体外设由型号决定</p>
</li>
<li><p>外设寄存器直接按位寻址</p>
<p>外设寄存器可以直接进行赋值、按位操作</p>
</li>
</ol>
<p>msp430系列使用了冯诺依曼架构，并构建了MAB（存储器地址总线）、MDB（存储器数据总线）两个总线协议，其中RAM、FLASH共用同一个地址空间，程序被下载到FLASH，设备复位后自动读取并执行程序指令，局部变量存储在RAM，BSS段变量存储在FLASH，FLASH掉电不丢失</p>
<p>设备内部时钟至少具有3套时钟源：</p>
<ol>
<li>LFXT1CLK：低频时钟，32.768kHz</li>
<li>XT2CLK：高频时钟，8MHz</li>
<li>DCOCLK：片内数字控制RC振荡器，经常用作系统和外设时钟信号，其稳定性由FLL与硬件控制</li>
</ol>
<p>三套时钟源可以被设备单独选用，时钟通过片内总线提供给设备；有些型号还具有更多类型的时钟源</p>
<p>DMA可以直接接管总线以提高传输效率（不同于AMBA总线的仲裁，MAB、MDB总线只采用主控设备-从设备的方式）</p>
<p>CPU则采用了双总线位宽的灵活处理方式，分为<strong>16位寻址的CPU</strong>和<strong>20位寻址的CPUX</strong>。CPU采用RISC架构，配备27条指令和7种统一的寻址模式，寻址空间64KB；CPUX寻址空间为1MB，采用面向控制的结构和指令系统，集成了计算分支、表处理等特性，可以在不分页的情况下处理1MB的地址范围，属于RISC正交指令集（正交：指令集的绝大多数指令格式相同、长度相同，所有寄存器的寻址可以替换；而指令的操作码、寻址方式、操作数寄存器字段的取值相互独立），可以实现MTM（内存到内存）传输，不需要经过中间寄存器，一并对16位CPU实现了兼容</p>
<p>在电赛中最常用的就是==<strong>MSP430F5529</strong>==，下面均以F5529为例说明</p>
<h2 id="外围电路设计"><a href="#外围电路设计" class="headerlink" title="外围电路设计"></a>外围电路设计</h2><h3 id="供电"><a href="#供电" class="headerlink" title="供电"></a>供电</h3><p>MCU部分模拟外设和FLASH、RAM对于电源要求较高，但是MCU数字部分对于电源要求较低，因此采用双电源——模拟/数字的方式为MCU供电。模拟-数字电源之间采用磁珠跨接3.3V和地除杂波，同时需要使用10uF、100nF电容并联进行滤波，10uF用于滤除低频杂波，100nF则用于旁路</p>
<h3 id="复位"><a href="#复位" class="headerlink" title="复位"></a>复位</h3><p>RST引脚低电平有效，因此和一般单片机的复位电路一样即可</p>
<h3 id="晶振"><a href="#晶振" class="headerlink" title="晶振"></a>晶振</h3><p>需要使用两个晶振接入来保证电源稳定，<strong>XT1接低频32.768kHz</strong>，<strong>XT2接高频晶振，一般为4MHz</strong>，因为内部电容不足以起振，所以同时需要单独配备20-30pF的匹配电容，一般使用22pF电容</p>
<h3 id="USB"><a href="#USB" class="headerlink" title="USB"></a>USB</h3><p>f5529具有USB控制器，能够使用4芯电缆：5V、D+、D-、GND，并可以兼容USB OTG的ID线。</p>
<h2 id="编译烧录"><a href="#编译烧录" class="headerlink" title="编译烧录"></a>编译烧录</h2><p>MSP430支持JTAG和SBW（Spy-Bi-Wire，TI指定的两线调试接口，信号叫为SBWTCK和SBWTDIO）</p>
<p>同时也支持BSL（BootStrap Loader），或者说BootLoader加载程序烧录可以通过USB、UART等对单片机进行ISP烧录，在PUR引脚和USB D+之间跨接1.4k电阻，下连1M电阻到地，并通过一个加了限流电阻（一般为100Ω）的微动开关连接到VCC即可实现USB的BSL烧录</p>
<p>MSP430的开发环境是TI基于eclipse开发的Code Composer Studio，简称<strong>CCS</strong>，在其中使用专用的MSP430 Compile与Linker即可实现C程序编译链接</p>
<h3 id="关键字和内联函数"><a href="#关键字和内联函数" class="headerlink" title="关键字和内联函数"></a>关键字和内联函数</h3><p>同时CCS支持了一些扩展关键字，列举如下：</p>
<ul>
<li><p><code>__asm</code>用于C语言内嵌汇编，这个和keil一样</p>
</li>
<li><p><code>__interrupt</code>放在函数前指示中断函数，一般和#pragma指令共用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=UART0RX_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">UART_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>上例指示了一个串口0接收中断，#pragma指令让中断向量表中的地址位重定向了</p>
</li>
<li><p><code>__monitor</code>放在函数前，在执行到函数时自动关闭全局中断，类似__atom指令</p>
</li>
<li><p><code>__no_init</code>放在全局变量钱让程序启动时不被变量赋初值</p>
</li>
<li><p><code>__raw</code>关闭中断服务函数的恢复现场能力，这会导致中断服务函数无法返回</p>
</li>
<li><p><code>__regvar</code>声明变量为寄存器变量，注意不能使用指针指向寄存器变量，并且必须搭配使用__no_init禁止初始化</p>
</li>
<li><p><code>sfrb</code>用于声明单字节IO数据类型对象，和51一样用于定义寄存器地址</p>
</li>
</ul>
<p>除了关键字外，CCS还包含了许多内联函数，常见的几个摘录如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__no_operation();<span class="comment">//空指令，相当于NOP</span></span><br><span class="line">__enable_interrupt();<span class="comment">//打开全局中断</span></span><br><span class="line">__disable_interrupt();<span class="comment">//关闭全局中断</span></span><br><span class="line">__delay_cycles(<span class="keyword">unsigned</span> <span class="keyword">long</span> __cycles);<span class="comment">//延时__cycles个主时钟（MCLK）周期</span></span><br><span class="line">__set_SP_register(<span class="keyword">unsigned</span> <span class="keyword">short</span>);<span class="comment">//为堆栈指针寄存器SP赋值</span></span><br></pre></td></tr></table></figure>

<h3 id="预定义寄存器"><a href="#预定义寄存器" class="headerlink" title="预定义寄存器"></a>预定义寄存器</h3><p>CCS中还预置了一些单片机常用的寄存器和配置，如下所示</p>
<ol>
<li><p>端口定义，其中x表示端口号</p>
<p>PxIN：端口输入寄存器</p>
<p>PxOUT：端口输出寄存器</p>
<p>PxDIR：端口方向控制寄存器</p>
<p>PxSEL：端口复用寄存器</p>
<p>注意：<strong>MSP430不支持位操作，一般通过屏蔽位的方法实现位操作，这是它和51开发方面最大的不同</strong>，如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT0 00000001b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT1 00000010b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT2 00000100b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT3 00001000b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT4 00010000b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT5 00100000b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT6 01000000b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT7 10000000b</span></span><br><span class="line"></span><br><span class="line">P1OUT |= BIT0;</span><br><span class="line"><span class="comment">//这样可以实现P1.0输出</span></span><br><span class="line"></span><br><span class="line">P1OUT |= BIT4;</span><br><span class="line"><span class="comment">//这样可以实现P1.0和P1.3同时输出</span></span><br><span class="line"></span><br><span class="line">P1OUT &amp;= ~BIT1;</span><br><span class="line"><span class="comment">//这样可以取消P1.0的输出</span></span><br></pre></td></tr></table></figure></li>
<li><p>低功耗模式的进入和退出</p>
<p>CCS预定义了一些宏指令用来实现低功耗模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LPM3;<span class="comment">//进入低功耗模式</span></span><br><span class="line">LPM3_EXIT;<span class="comment">//退出低功耗模式</span></span><br></pre></td></tr></table></figure>

<p>其中数字可以写0-4，分别对应四种低功耗模式</p>
</li>
<li><p>外设寄存器</p>
<p>各种片上外设的寄存器都被定义为了宏，可以通过<code>|=</code>与<code>&amp;=~</code>的方式进行按位控制</p>
</li>
<li><p>部分常用代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_dint(); <span class="comment">//等效于__disable_interrupt</span></span><br><span class="line">_EINT(); <span class="comment">//等效于__enable_interrupt</span></span><br><span class="line">_NOP(); <span class="comment">//空指令</span></span><br><span class="line">_OPC(x); <span class="comment">//在指令流中插入一个常熟，对与参数对应的任何指令进行编码</span></span><br><span class="line">_SWAP_BYTES(x); <span class="comment">//将无符号16位整数的高8位和低8位交换</span></span><br><span class="line">monitor <span class="comment">//关键字__monitor的宏定义</span></span><br><span class="line">no_init <span class="comment">//关键字__no_init的宏定义</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>综上所述，MSP430的开发和8051的开发非常类似，并没有stm32的库封装，而是直接操作寄存器。这不仅仅是由于MSP430的性能较低，也是由于这样的编程方式写出的代码更加简洁、指令量更少，能突出体现MSP430低功耗的优势</p>
<h2 id="片上外设开发"><a href="#片上外设开发" class="headerlink" title="片上外设开发"></a>片上外设开发</h2><p>MSP430的片上外设寄存器具体配置和51单片机的很像，但是有一些功能更加复杂，和stm32的寄存器接近，同时也提供了简化操作的库函数</p>
<h3 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h3><p>f5529一共有80个引脚，和stm32的<strong>gpio</strong>结构类似，并且也具有<strong>复用功能</strong>。除此之外某些引脚具备基本的<strong>电源功能</strong>，分别能够为MCU的片上数字电路和模拟电路供电，一般情况下可以共用一个电源，但在某些高精度测量场合需要双电源隔离供电。msp430还具有一个USB电源，可以直接输出5V供电，经过片上LDO后能在端口VBUS处输出稳定的3.3V电压供单片机和外设使用，最大驱动电流60mA</p>
<p>其中P1、P2端口IO都具有外部中断能力，分别对应P1IV中断向量和P2IV中断向量。端口可单独配置强驱动和弱驱动模式，<strong>强驱动模式下全片最大输出电流100mA，单端口最大电流15mA；弱驱动模式下全片最大输出电流48mA，单端口最大电流6mA</strong></p>
<p>寄存器操作可以通过上面介绍过的屏蔽位法，也可以通过分别操作寄存器高8位和低8位的方法实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用三种方法将P1.1和P2.2配置为输出功能</span></span><br><span class="line">P1DIR |= <span class="number">0x02</span>; <span class="comment">//0x02 == 00000010b</span></span><br><span class="line">P2DIR |= <span class="number">0x04</span>; <span class="comment">//0x04 == 00000100b</span></span><br><span class="line"></span><br><span class="line">PADIR_L |= <span class="number">0x02</span>; <span class="comment">//DIR寄存器低8位，代表P1</span></span><br><span class="line">PADIR_H |= <span class="number">0x04</span>; <span class="comment">//DIR寄存器高8位，代表P2</span></span><br><span class="line"></span><br><span class="line">PADIR |= <span class="number">0x0402</span>; <span class="comment">//直接操作DIR寄存器，将其视作uint16_t</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>端口配置</p>
<p>如下配置端口为输入状态并配置内部上拉</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P1DIR &amp;= ~BIT1; <span class="comment">//BIT1 == 0x00000010b，设置P1.1为输入模式</span></span><br><span class="line">P1REN |= BIT1; <span class="comment">//使能上下拉电阻</span></span><br><span class="line">P1OUT |= BIT1; <span class="comment">//P1.1配置上拉电阻</span></span><br></pre></td></tr></table></figure>

<p>通过配置PxDIR.n |= 1可以将相应的IO口配置为输出状态，在输出状态下，PxREN、PxIN无效。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P1OUT |= BIT1; <span class="comment">//P1.1输出高电平</span></span><br><span class="line">P1OUT &amp;= ~BIT1; <span class="comment">//P1.1输出低电平</span></span><br><span class="line"></span><br><span class="line">P1DS<span class="number">.1</span> &amp;= ~BIT1; <span class="comment">//配置P1.1为弱驱动输出</span></span><br><span class="line">P1DS<span class="number">.1</span> |= BIT1; <span class="comment">//配置P1.1为强驱动输出</span></span><br></pre></td></tr></table></figure></li>
<li><p>端口复用配置</p>
<p>基本每个IO都有端口复用功能，通过配置PxSEL.n把对应的IO口配置为复用功能</p>
<p>使用以下代码配置P1.0为定时器A0时钟输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P1DIR &amp;= ~BIT0; <span class="comment">//设置P1.0为输入状态</span></span><br><span class="line">P1SEL |= BIT0; <span class="comment">//将P1.0复用为定时器A0时钟输入</span></span><br></pre></td></tr></table></figure>

<p>相关配置需要按照datasheet中的端口复用表选择</p>
</li>
</ol>
<h3 id="时钟系统与低功耗"><a href="#时钟系统与低功耗" class="headerlink" title="时钟系统与低功耗"></a>时钟系统与低功耗</h3><p>msp430f5529具有<strong>5种时钟源</strong>（XT1CLK、XT2CLK、VLOCLK、REFOCLK、DCOCLK）和<strong>3种时钟信号</strong>（MCLK、SMCLK、ACLK）</p>
<p>时钟系统可以软件配置成不需要外部晶振、需要一个外部晶振、需要两个外部晶振、外部时钟输入等方式，最极端的情况下单片机内部具有自身振荡器可以为CPU及片上外设提供系统时钟</p>
<p>时钟系统的安全性比较重要，msp430配备了紧急保护系统，在外部时钟故障时会自动选择内部时钟源REFOCLK或VLOCLK作为时钟信号，并产生响应故障信号（可选中断）</p>
<p>系统时钟大致分为两级，<em>信号生成级</em>和<em>信号分配级</em>，中间通过MUX连接。信号生成级别分为三个模块基本的OSC模块可以通过晶振旁路、内部REFO或VLO直接输出XT1CLK、VLOCLK、REFOCLK三种信号；可选的XT2模块直接输出XT2晶振的4MHz时钟作为XT2CLK；可以通过晶振旁路和FLL（Frequency Locked Loop锁频环）进行晶振时钟倍频和分频，信号源（即FLLREFCLK反馈时钟）通过MUX直接引用XT1CLK、REFOCLK、XT2CLK之一，经过多个倍频分频器后输出为DCOCLK和DCOCLKDIV。所有信号分别输出到信号分配级，通过MUX分配给ACLK、MCLK、SMCLK</p>
<p><strong>XT1CLK</strong>：<strong>外部低频或高频时钟源</strong>，默认关闭，需要接入外部晶振并通过软件使晶振起振后再使用，一般使用32.768kHz的低频晶振，但是也可以使用4-32MHz的外部高频时钟源，<strong>端口P5.4、P5.5</strong></p>
<p>使用下面的代码对时钟源进行配置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P5SEL |= BIT4 | BIT5; <span class="comment">//配置P5.4、P5.5为XT1复用功能</span></span><br><span class="line">UCSCTL6 |= XCAP_3; <span class="comment">//配置匹配电容为12pF</span></span><br><span class="line">UCSCTL6 &amp;= ~XT1OFF; <span class="comment">//使能XT1，使外部晶振起振</span></span><br><span class="line"><span class="keyword">while</span>(SFRIFG1 &amp; OFIFG)</span><br><span class="line">&#123;</span><br><span class="line">    UCSCTL7 &amp;= ~(XT2OFFG + XT1LFOFFG + DCOFFG); <span class="comment">//清除三类时钟故障标志位，等待起振</span></span><br><span class="line">    SFRIFG1 &amp;= ~OFIFG; <span class="comment">//清除震荡器故障标志位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>XT2CLK</strong>：和XT1CLK类似，但只能接4-32MHz的<strong>高频晶振</strong>，一般接入4MHz晶振，需要额外加匹配电容方便起振。<strong>端口P5.2、P5.3</strong></p>
<p>需要注意的是在配置SMCLK和MCLK为XT2CLK时钟源之前需要先修改ACLK和REFCLK的时钟源，因为它们的时钟源默认为XT1CLK，但这里并没有启动，所以会导致没有必要的XT1CLK始终故障，会影响判断XT2是否起振，实现代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P5SEL |= BIT2 | BIT3; <span class="comment">//配置P5.2、P5.3为XT2复用功能</span></span><br><span class="line">UCSCTL6 &amp;= ~XT2OFF; <span class="comment">//使能XT2</span></span><br><span class="line">UCSCTL4 = UCSCTL4 &amp; (~(SELA_7)) | SELA_1; <span class="comment">//将ACLK配置为VLOCLK</span></span><br><span class="line">UCSCTL3 |= SELREF_2; <span class="comment">//将REFCLK配置为REFOCLK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(SFRIFG1 &amp; OFIFG)</span><br><span class="line">&#123;</span><br><span class="line">    UCSCTL7 &amp;= ~(XT2OFFG + XT1LFOFFG + DCOFFG); <span class="comment">//清除三类时钟故障标志位，等待起振</span></span><br><span class="line">    SFRIFG1 &amp;= ~OFIFG; <span class="comment">//清除震荡器故障标志位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>VLOCLK</strong>：<strong>内部低功耗、低频时钟源</strong>，<strong>频率10kHz</strong>，精度较低，会随电源电压和温度产生较大漂移，用于不需要精准时钟基准的系统控制，被使用时自动开启、不使用时自动关闭，低功耗唤醒模式下回优先使用该时钟源作为系统和看门狗时钟</p>
<p>配置UCSCTL4选择</p>
<p><strong>REFOCLK</strong>：<strong>内部修整低频参考时钟源，精度较高，32.768kHz</strong>，和VLOCLK一样不需要配置寄存器进行起振，若未使用外部晶振，系统会自动选择该时钟源作为ACLK和DCOCLK锁频环参考时钟源</p>
<p>通过UCSCTL4选择</p>
<p><strong>DCOCLK</strong>：内部数字控制时钟源，具有宽工作频率，<strong>最高可产生25MHz时钟频率</strong>，可以和FLL配合控制参考时钟，也可以引入其他时钟源反馈进行时钟分频/倍频，但是需要额外配置</p>
<p>这是f5xx中<strong>最常用的时钟源</strong>，类似于stm32的PLL时钟（它的内部也是类似的PLL）</p>
<p>其频率计算公式如下<br>$$<br>DCOCLK = D \times (N+1) \times \frac{REFCLK}{n} \<br>DCOCLKDIV = (N+1) \times \frac{REFCLK}{n}<br>$$<br>REFCLK来源见上文</p>
<p>n为输入时钟分频，通过UCSCTL3中的FLLCLKDIV设定，查找该寄存器介绍可知其取值0-7，对应n取值2^p^，默认为0，不分频</p>
<p>D通过UCSCTL2中的FLLD设对，可取值0-7，对应D取值2^p^，默认为1，即D=2，二分频</p>
<p>N可以通过UCSCTL2中的FLLN设定，取值0-1023，当FLLN=0时，N=1，除此之外N=FLLN，默认为31，即N=31</p>
<p>如果系统复位后不进行任何设置，DCOCLK=2097152Hz，DCOCLKDIV=1048576Hz</p>
<p><strong>MCLK和SMCLK都默认选择DCOCLKDIV作为时钟源</strong>。</p>
<p>通过配置DCORSEL、DCOx、MOD来选择DCO的频率设置范围（最小值和最大值）</p>
<p>详细内容参考datasheet</p>
<p><strong>MODOSC</strong>：内部模块振荡器，是<strong>UCS时钟模块下属的振荡器</strong>，能产生<strong>4.8MHz的MODCLK时钟</strong>，用于FLASH、ADC等片上外设</p>
<p><strong>MCLK</strong>：为CPU和片上外设提供<strong>主时钟</strong>，默认使用DCOCLKDIV</p>
<p>通过配置DIVM选择MCLK分频系数为1、2、4、8、16、32</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UCSCTL4 = UCSCTL4 &amp; (~SELM_7) | SELM_0; <span class="comment">//XT1CLK时钟源</span></span><br><span class="line">UCSCTL4 = UCSCTL4 &amp; (~SELM_7) | SELM_1; <span class="comment">//VLOCLK时钟源</span></span><br><span class="line">UCSCTL4 = UCSCTL4 &amp; (~SELM_7) | SELM_2; <span class="comment">//REFOCLK时钟源</span></span><br><span class="line">UCSCTL4 = UCSCTL4 &amp; (~SELM_7) | SELM_3; <span class="comment">//DCOCLK时钟源</span></span><br><span class="line">UCSCTL4 = UCSCTL4 &amp; (~SELM_7) | SELM_4; <span class="comment">//DCOCLKDIV时钟源</span></span><br><span class="line">UCSCTL4 = UCSCTL4 &amp; (~SELM_7) | SELM_5; <span class="comment">//XT2CLK时钟源</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UCSCTL5 = UCSCTL5 &amp; (~DIVM_7) | DIVM_0; <span class="comment">//MCLK不分频</span></span><br><span class="line">UCSCTL5 = UCSCTL5 &amp; (~DIVM_7) | DIVM_1; <span class="comment">//MCLK 2分频</span></span><br><span class="line">UCSCTL5 = UCSCTL5 &amp; (~DIVM_7) | DIVM_2; <span class="comment">//MCLK 4分频</span></span><br><span class="line">UCSCTL5 = UCSCTL5 &amp; (~DIVM_7) | DIVM_3; <span class="comment">//MCLK 8分频</span></span><br><span class="line">UCSCTL5 = UCSCTL5 &amp; (~DIVM_7) | DIVM_4; <span class="comment">//MCLK 16分频</span></span><br><span class="line">UCSCTL5 = UCSCTL5 &amp; (~DIVM_7) | DIVM_5; <span class="comment">//MCLK 32分频</span></span><br></pre></td></tr></table></figure>

<p><strong>ACLK</strong>：<strong>辅助时钟</strong>，专用来为外围模块提供信号。默认使用XT1CLK时钟源，如果未起振，则使用REFOCLK。配置方法和MCLK完全一致</p>
<p><strong>SMCLK</strong>：<strong>子系统主时钟</strong>，和MCLK基本一致，只是不为CPU提供时钟</p>
<p>上电复位后，UCS默认配置如下：</p>
<ul>
<li>ACLK选择XT1为时钟源，如果未起振则使用REFOCLK并生成时钟故障标志</li>
<li>MCLK选择DCOCLKDIV</li>
<li>SMCLK选择DCOCLKDIV</li>
</ul>
<p>需要注意：msp430f5529的XTIN和XTOUT引脚默认为GPIO功能，并在上电情况下不会启动，需要额外进行软件设置</p>
<p>同时P7.7、P2.2、P1.0分别能够对外输出MCLK、SMCLK、ACLK时钟</p>
<p>这里用最为复杂的DCO配置说明整个时钟系统的配置流程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430f5529.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetVcoreUp</span><span class="params">(<span class="keyword">uint_32_t</span> level)</span></span>; <span class="comment">//提升核心电压以提升工作频率</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">XT1_ON</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//启动XT1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DCO__16MHz</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//使用DCO将XT1倍频到16MHz</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW + WDTHOLD;</span><br><span class="line">    P1SEL |= BIT0; <span class="comment">//P1.0 ACLK输出</span></span><br><span class="line">    P1DIR |= BIT0;</span><br><span class="line">    P2SEL |= BIT2; <span class="comment">//SMCLK输出</span></span><br><span class="line">    P2DIR |= BIT2;</span><br><span class="line">    P7SEL |= BIT7; <span class="comment">//MCLK输出</span></span><br><span class="line">    P7DIR |= BIT7;</span><br><span class="line">    P7DIR |= BIT0; <span class="comment">//P7.0 LED驱动输出</span></span><br><span class="line">    P1OUT |= BIT0;</span><br><span class="line">    </span><br><span class="line">    XT1_ON();</span><br><span class="line">    DCO__16MHz();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        __delay_cycles(<span class="number">8000000</span>); <span class="comment">//每0.5s</span></span><br><span class="line">        P7OUT ^= BIT0 ;<span class="comment">//LED状态翻转一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetVcoreUp</span><span class="params">(<span class="keyword">uint_32_t</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PMMCTL0_H = PMMPW_H; <span class="comment">//解锁PMM寄存器，允许写入</span></span><br><span class="line">    SVSMHCTL = SVSHE + SVSHRVL0 * level + SVMHE + SVSMHRRL0 * level; <span class="comment">//设置SVS/SVM高侧到新的等级</span></span><br><span class="line">    SVSMLCTL = SVSLE + SVMLE + SVSMLRRL0 * level; <span class="comment">//设置SVS低侧到新的等级</span></span><br><span class="line">    <span class="keyword">while</span>((PMMIFG &amp; SVSMLDLYIFG) == <span class="number">0</span>); <span class="comment">//等待SVM稳定</span></span><br><span class="line">    PMMIFG &amp;= ~(SVMLVLRIFG + SVMLIFG); <span class="comment">//清除已经置位的标志</span></span><br><span class="line">    PMMCTL0_L = PMMCOREV0 * level; <span class="comment">//设置VCORE到新的等级</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span>((PMMIFG &amp; SVMLIFG)) <span class="comment">//等待达到新的电压等级</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>((PMMIFG &amp; SVMLVLRIFG) == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置SVS/SVM低侧到新的水平</span></span><br><span class="line">    SVSMLCTL = SVSLE + SVSLRVL0 * level + SVMLE + SVSMLRRL0 * level;</span><br><span class="line">    PMMCTL0_H = <span class="number">0x00</span>; <span class="comment">//锁住PMM的写入路径</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">XT1_ON</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    P5SEL |= BIT4 |BIT5; <span class="comment">//配置XT1引脚</span></span><br><span class="line">    UCSCTL6 |= XCAP_3; <span class="comment">//配置电容为12pF</span></span><br><span class="line">    UCSCTL6 &amp;= ~XT1OFF; <span class="comment">//使能XT1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(SFRIFG1 &amp; OFIFG)</span><br><span class="line">    &#123;</span><br><span class="line">        UCSCTL7 &amp;= ~(XT2OFFG + XT1LFOFFG + DCOFFG); <span class="comment">//清除三类时钟错误标志位</span></span><br><span class="line">        SFRIFG1 &amp;= ~OFIFG; <span class="comment">//清除时钟错误标志位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DCO__16MHz</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SetVcoreUp(<span class="number">1</span>); <span class="comment">//一级一级提升核心电压，不能跨级</span></span><br><span class="line">    SetVcoreUp(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置寄存器使DCOCLK=4.9MHz,DCOCLKDIV=2.45MHz */</span></span><br><span class="line">    __bis_SR_register(SCG0); <span class="comment">//关闭FLL库函数</span></span><br><span class="line">    UCSCTL0 = <span class="number">0x0000</span>; <span class="comment">//清零寄存器值，FLL运行时系统会自动配置该寄存器</span></span><br><span class="line">    UCSCTL1 = DCORSEL_5; <span class="comment">//选择DCOCLK频率范围 6-23.7MHz</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//FLLD=0，则D=1；FLLN=487，则N=487；N在UCSCTL3寄存器，默认值为1，则DCOCLK=1*(487+1)*32768=15.990784MHz</span></span><br><span class="line">    <span class="comment">//DCODIVCLK=(487+1)*32768=15.990784MHz</span></span><br><span class="line">    UCSCTL2 = FLLD_0 + <span class="number">487</span>; </span><br><span class="line">    </span><br><span class="line">    __bic_SR_register(SCG0); <span class="comment">//开启FLL控制回路</span></span><br><span class="line">    __delay_cycles(<span class="number">76563</span>); <span class="comment">//延时等待时钟稳定</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(SFRIFG1 &amp; OFIFG) <span class="comment">//检测时钟错误并等待时钟稳定</span></span><br><span class="line">    &#123;</span><br><span class="line">        UCSCTL7 &amp;= ~(XT2OFFG + XT1LFOFFG + DCOFFG);</span><br><span class="line">        SFRIFG1 &amp;= ~OFIFG;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>低功耗配置</strong></em></p>
<p>msp430一共有8种工作模式</p>
<ul>
<li>活跃模式（AM）</li>
<li>低功耗模式（LPM）0</li>
<li>低功耗模式1</li>
<li>低功耗模式2</li>
<li>低功耗模式3</li>
<li>低功耗模式3.5</li>
<li>低功耗模式4</li>
<li>低功耗模式4.5</li>
</ul>
<p>但是并不是所有系列都支持这些工作模式，对于f5529来说，不支持LPM3.5</p>
<p>使用以下指令来进入和退出低功耗模式0-4</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 开总中断并进入低功耗模式 */</span></span><br><span class="line">__bis_SR_register(LPMn_bits + GIE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 退出低功耗模式 */</span></span><br><span class="line">LPMn_EXIT; <span class="comment">//其中n可以换成数字0-4</span></span><br></pre></td></tr></table></figure>

<p>需要注意：<strong>低功耗模式唤醒都需要使用外部中断</strong>，所以需要在进入低功耗模式同时开启总中断</p>
<p>在最高级别LPM4.5低功耗模式下，RAM中内容会直接丢失，所以在从LPM4.5唤醒后需要重新配置寄存器和相关设置</p>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>低功耗模式唤醒使用的指令实际上是通过直接修改SR寄存器的值，清除休眠标志，它内联到以下函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_bic_SR_register_on_exit(LPM3_bits);<span class="comment">//退出LPM3</span></span><br></pre></td></tr></table></figure>

<p>MSP430和arm一样都具有<em>系统中断</em>、<em>不可屏蔽中断</em>和<em>可屏蔽中断</em>三种，其中系统中断和不可屏蔽中断优先级最高；可屏蔽中断可以通过<strong>状态寄存器SR</strong>中的GIE位来屏蔽和开启</p>
<p>大致的中断作用与arm类似，而使用方式与51类似</p>
<p>下面主要介绍外部中断</p>
<ol>
<li><p>初始化端口时要清空中断标志位</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P1IFG &amp;= ~(BIT0); <span class="comment">//清空中断标志位</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>PIES</code>寄存器选择触发边沿（0为上升沿，1为下降沿）并使用<code>PxIE</code>寄存器使能中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P1IES &amp;= ~BIT0; <span class="comment">//P1.0上升沿触发</span></span><br><span class="line">P1IES |= BIT1; <span class="comment">//P1.1下降沿触发</span></span><br><span class="line">P1IES |= BIT2; <span class="comment">//P1.2下降沿触发</span></span><br><span class="line">    </span><br><span class="line">P1IE |= BIT0; <span class="comment">//使能P1.0中断</span></span><br><span class="line">P1IE |= BIT1; <span class="comment">//使能P1.1中断</span></span><br><span class="line">P1IE |= BIT2; <span class="comment">//使能P1.2中断</span></span><br></pre></td></tr></table></figure></li>
<li><p>开总中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__bis_SR_register(GIE);</span><br></pre></td></tr></table></figure></li>
<li><p>编写中断服务函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector = 中断向量地址</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">ISR_function</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//中断服务函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在中断函数内部清零中断标志位</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__even_in_range(P1IV, <span class="number">16</span>); <span class="comment">//用于查询P1的所有中断标志位并自动清零，使用该函数可以实现将所有P1的外部中断放在同一个函数内解决的功能,如下所示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(__even_in_range(P1IV, <span class="number">16</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//无中断</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//P1IFG.0</span></span><br><span class="line">        <span class="comment">/* 中断处理函数 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">//P1IFG.1</span></span><br><span class="line">        <span class="comment">/* 中断处理函数 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: <span class="comment">//P1IFG.2</span></span><br><span class="line">        <span class="comment">/* 中断处理函数 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>: <span class="comment">//P1IFG.3</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>: <span class="comment">//P1IFG.4</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>: <span class="comment">//P1IFG.5</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">14</span>: <span class="comment">//P1IFG.6</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">16</span>: <span class="comment">//P1IFG.7</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">//出错情况</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>此外，msp430还支持<em>手动的</em>嵌套中断</p>
<p>示例程序如下所示（TI的七段数码管驱动示例程序）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> SEVENSEG_OUTPUT[<span class="number">10</span>] = &#123;<span class="number">0x3f</span>, <span class="number">0x06</span>, <span class="number">0x5b</span>, <span class="number">0x4f</span>, <span class="number">0x66</span>, <span class="number">0x6d</span>, <span class="number">0x7d</span>, <span class="number">0x07</span>, <span class="number">0x7f</span>, <span class="number">0x6f</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> loopCounter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> timeCounter1; </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> timeCounter2;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> timeCounter3;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW | WDTHOLD; <span class="comment">//关闭看门狗</span></span><br><span class="line"></span><br><span class="line">    PADIR = <span class="number">0x03ff</span>; <span class="comment">// P1, P2.0 and P2.1 output, P2.6 and P2.7 input</span></span><br><span class="line">    PAOUT = <span class="number">0xc03f</span>;</span><br><span class="line"></span><br><span class="line">    P2REN = <span class="number">0xc0</span>; <span class="comment">// P2.6 P2.7 上拉电阻使能</span></span><br><span class="line">    P2IES = <span class="number">0x3f</span>; <span class="comment">// P2.6 P2.7 配置中断为上升沿</span></span><br><span class="line">    P2IE = <span class="number">0xc0</span>; <span class="comment">// P2.6 P2.7 interrupt enabled</span></span><br><span class="line"></span><br><span class="line">    PM5CTL0 &amp;= ~LOCKLPM5; <span class="comment">// 关闭GPIO高阻抗模式</span></span><br><span class="line"></span><br><span class="line">    RTCMOD = <span class="number">50</span>; <span class="comment">// 设置RTC重装计数值为50</span></span><br><span class="line">                 <span class="comment">// 64/32768 * 51 = ~0.1 sec.</span></span><br><span class="line">    SYSCFG2 |= RTCCKSEL; <span class="comment">// Source = ACLK = REFO，64分频，选择ACLK作为RTC时钟</span></span><br><span class="line">    RTCCTL = RTCSS_1 | RTCSR | RTCPS__64;</span><br><span class="line"></span><br><span class="line">    P2IFG = <span class="number">0</span>; <span class="comment">// 清除P1.3中断标志位</span></span><br><span class="line">    __bis_SR_register(GIE); <span class="comment">//开全局中断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PAOUT |= (BIT9 | SEVENSEG_OUTPUT[timeCounter3]);  <span class="comment">// 按顺序显示七段数码管数字</span></span><br><span class="line">        __delay_cycles(<span class="number">100</span>);</span><br><span class="line">        PAOUT = <span class="number">0xc000</span>; <span class="comment">// 清除引脚</span></span><br><span class="line"></span><br><span class="line">        PAOUT |= (BIT8 | SEVENSEG_OUTPUT[timeCounter2]);</span><br><span class="line">        __delay_cycles(<span class="number">100</span>);</span><br><span class="line">        PAOUT = <span class="number">0xc000</span>;</span><br><span class="line"></span><br><span class="line">        P1OUT |= (BIT7 | SEVENSEG_OUTPUT[timeCounter1]);</span><br><span class="line">        __delay_cycles(<span class="number">100</span>);</span><br><span class="line">        P1OUT = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RTC中断服务函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=RTC_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">RTC_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __bis_SR_register(GIE); <span class="comment">// 允许嵌套中断</span></span><br><span class="line">    RTCIV = <span class="number">0</span>;</span><br><span class="line">    timeCounter1++; <span class="comment">// timeCounter1代表0.1s, timeCounter2代表1s,timeCounter3代表10s，经典延时操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(timeCounter1 &gt; <span class="number">9</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        timeCounter1 = <span class="number">0</span>;</span><br><span class="line">        timeCounter2++;</span><br><span class="line">        <span class="keyword">if</span>(timeCounter2 &gt; <span class="number">9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            timeCounter3++;</span><br><span class="line">            timeCounter2 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(timeCounter3 &gt; <span class="number">9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            timeCounter3 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P2中断服务函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=PORT2_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">Port_2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __bis_SR_register(GIE); <span class="comment">// 允许嵌套中断</span></span><br><span class="line">    <span class="keyword">if</span>(P2IFG &amp; BIT6)</span><br><span class="line">    &#123;</span><br><span class="line">        P2IFG &amp;= ~BIT6; <span class="comment">// 清除P2.6中断标志位</span></span><br><span class="line">        <span class="comment">// 第一次按下按钮时开启定时器；第二次按下时停止定时器</span></span><br><span class="line">        <span class="keyword">if</span>(loopCounter == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          	loopCounter++; <span class="comment">//开启一轮循环</span></span><br><span class="line">            RTCCTL |= RTCIE; <span class="comment">//开启定时器</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            RTCCTL &amp;= ~RTCIE; <span class="comment">//关闭定时器</span></span><br><span class="line">            loopCounter = <span class="number">0</span>; <span class="comment">//循环清零</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(P2IFG &amp; BIT7)</span><br><span class="line">    &#123;</span><br><span class="line">        P2IFG &amp;= ~BIT7; <span class="comment">// 清除P2.7中断标志位并复位秒表</span></span><br><span class="line">        RTCCTL &amp;= ~RTCIE; <span class="comment">//关闭定时器</span></span><br><span class="line">        </span><br><span class="line">        loopCounter = <span class="number">0</span>; <span class="comment">//复位所有变量</span></span><br><span class="line">        timeCounter3 = <span class="number">0</span>;</span><br><span class="line">        timeCounter2 = <span class="number">0</span>;</span><br><span class="line">        timeCounter1 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现中断嵌套需要注意以下几点：</p>
<p>msp430默认关闭中断嵌套，一定要中断嵌套的话，就必须在中断服务程序中打开总中断</p>
<p>msp430的指令中，_DINT()和_EINT()分别指关和开总中断</p>
<p>当进入中断服务程序时，只要不在中断服务程序中再次开中断，则总中断是关闭的，此时来中断不管是比当前中断的优先级高还是低都不执行</p>
<p><strong>若在中断服务程序A中开了总中断，则可以响应后来的中断B（不管B的优先级比A高还是低），B执行完再继续执行A</strong></p>
<p>注意：进入中断服务程序B后总中断同样也会关闭，如果B中断程序执行时需响应中断C，则此时也要开总中断，若不需响应中断，则不用开中断，B执行完后跳出中断程序进入A程序时，总中断会自动打开</p>
<p><strong>若在中断服务程序中开了总中断，后来的中断同时有多个，则会按优先级来执行，即中断优先级只有在多个中断同时到来时才起作用，中断服务不执行抢先原则</strong></p>
<p>对于单源中断，只要响应中断，系统硬件会自动清除中断标志位。对于TA/TB定时器的比较/捕获中断，只要访问TAIV/TBIV，标志位就会被自动清除；对于多源中断要手动清标志位，比如P1/P2口中断，要手工清除相应的标志。如果在这种中断里用<code>_EINT();</code>开中断,而在打开中断前没有清标志，就会有相同的中断不断嵌入，导致堆栈溢出引起复位，所以在<strong>这类中断中必须先清标志再打开中断开关</strong></p>
<p><strong>常用中断向量表</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASICTIMER_VECTOR   (0 * 2u) <span class="comment">/* 0xFFE0 Basic Timer */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT2_VECTOR        (1 * 2u)  <span class="comment">/* 0xFFE2 Port 2 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USART1TX_VECTOR     (2 * 2u) <span class="comment">/* 0xFFE4 USART 1 Transmit */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USART1RX_VECTOR     (3 * 2u) <span class="comment">/* 0xFFE6 USART 1 Receive */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT1_VECTOR        (4 * 2u)  <span class="comment">/* 0xFFE8 Port 1 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMERA1_VECTOR      (5 * 2u) <span class="comment">/* 0xFFEA Timer A CC1-2, TA */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMERA0_VECTOR      (6 * 2u) <span class="comment">/* 0xFFEC Timer A CC0 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADC12_VECTOR          (7 * 2u)  <span class="comment">/* 0xFFEE ADC */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USART0TX_VECTOR     (8 * 2u) <span class="comment">/* 0xFFF0 USART 0 Transmit */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USART0RX_VECTOR     (9 * 2u) <span class="comment">/* 0xFFF2 USART 0 Receive */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WDT_VECTOR          (10 * 2u) <span class="comment">/* 0xFFF4 Watchdog Timer */</span></span></span><br><span class="line"></span><br><span class="line">#defineCOMPARATORA_VECTOR  (<span class="number">11</span> * <span class="number">2u</span>) <span class="comment">/* 0xFFF6Comparator A */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMERB1_VECTOR      (12 * 2u) <span class="comment">/* 0xFFF8 Timer B CC1-6, TB */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMERB0_VECTOR      (13 * 2u) <span class="comment">/* 0xFFFA Timer B CC0 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NMI_VECTOR          (14 * 2u) <span class="comment">/* 0xFFFC Non-maskable */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RESET_VECTOR        (15 * 2u) <span class="comment">/* 0xFFFE Reset [HighestPriority] */</span></span></span><br></pre></td></tr></table></figure>

<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>msp430有四个基本定时器，外加一个RTC定时器，部分定时器具有PWM输出功能</p>
<p>计数器核心是一个计数寄存器，对输入的时钟信号进行计数，可以配置其捕获跳变沿种类和分频系数，使用寄存器TAxR获取当前计数值。定时器主要分成两部分：主计数器和捕获比较器模块。捕获比较器模块与主计数器模块通过TAxR连通，主计数器会根据输入的信号跳变沿递增/递减寄存器TAxR/TBxR的值，捕获比较器会根据收到的比较值对寄存器的值进行检查，根据当前模式不同做出不同反应，因为计数寄存器被共用，所以可以将其分成多个通道。一般当捕获比较器满足设置的条件时就会产生中断，存储计数值或输出相应的信号。<em>只需要主计数器即可完成定时工作，捕获比较器的作用则在于配合主计数器完成更多扩展功能</em></p>
<ul>
<li><p><strong>Timer_A</strong>：<strong>16位定时器</strong>（最大值65535），具有7个捕获比较器，支持<em>多路捕获比较</em>、<em>PWM输出</em>、<em>间隔定时</em>功能</p>
<p>F5529中包含两个Timer_A模块，记作Timer_A0、Timer_A1、Timer_A2，三个模块的主计数器在结构上完全相同，单捕获比较器的数量不相同：Timer_A0有7个，Timer_A1和Timer_A2各有3个。</p>
</li>
<li><p><strong>Timer_B</strong>：<strong>16位定时器</strong>（最大值65535），具备Timer_A的所有功能，但它还具备<em>双缓冲比较锁存</em>与<em>同步加载</em>功能</p>
</li>
</ul>
<p>定时器的基本模式如下：</p>
<ul>
<li><p>捕获器模式</p>
<p>触发信号到来时捕获器将计数寄存器的值复制到捕获比较器的计数值寄存器TAxCCRn/TBxCCRn，并产生中断请求</p>
</li>
<li><p>比较器模式</p>
<p>需要程序向计数值寄存器TAxCCRn/TBxCCRn中写入初值，当主计数器的计数寄存器TAxR/TBxR计数值达到寄存器中存储的初值后定时器模块就会向CPU请求中断 </p>
</li>
</ul>
<p>通过配置TASSEL可以选择时钟来自ACLK、SMCLK、TAxCLK（外部输入）或INCLK（定时器级联）</p>
<h4 id="定时器A"><a href="#定时器A" class="headerlink" title="定时器A"></a>定时器A</h4><p>msp430的定时器A的主计数器具有以下几个工作模式</p>
<ul>
<li><p>增模式</p>
<p>设备会重复<strong>从0自增到TAxCCRn的值</strong>，溢出时触发中断</p>
<p>最基础的功能</p>
</li>
<li><p>连续模式</p>
<p>设备会重复<strong>从0自增到0FFFFh</strong>，然后从0重新开始计数</p>
<p>一般用于生成独立的时间间隔和输出频率，时间间隔完成时会生成中断</p>
<p>起始设置TAxCCRn的初值，并在中断服务函数中重新设置TAxCCRn的值，使其与初值的计数个数相同即可产生固定的时间间隔，这种操作还可以应用多个通道，因为多通道之间相互独立</p>
<p>最基础的功能</p>
</li>
<li><p>增减模式</p>
<p>定时器从0自增到TAxCCR0，再自减到0，也就是说其定时周期为两倍的TAxCCR0</p>
</li>
</ul>
<p>捕获比较器工作模式如下：</p>
<p>通过设置捕获比较器中的CAP位可以选择捕获比较器的工作模式为比较模式（0）或捕获模式（1），</p>
<ul>
<li><p>捕获模式</p>
<p>当CAP=1时选择捕获模式，用于记录时间时间。</p>
<p>触发信号输入CCIxA/CCIxB连接外部的引脚或内部的信号，通过CCIS位来选择；通过CM位选择触发捕获事件的输入信号触发沿</p>
<p>每当触发信号到来时，捕获比较器会1. 将TAxR的值复制到TAxCCRn寄存器中；2. 将捕获器中断标志CCIFG置位触发中断</p>
</li>
<li><p>比较模式</p>
<p>如果计数器TAxR的值和某个TAxCCRn的值相等时，相应的中断标志位会被置位，产生一个比较中断。一般该模式用于产生PWM信号</p>
</li>
<li><p>输出模式</p>
<p>传统的定时器通过标志位判断来触发事件，但msp430配备了专用的输出模块，使用输出模块寄存器OUTMODEx可以快速输出PWM信号或其他控制信号</p>
</li>
</ul>
<h4 id="定时器中断"><a href="#定时器中断" class="headerlink" title="定时器中断"></a>定时器中断</h4><p>定时器A具有两个中断源，捕获比较器0中断独立，其他所有中断（定时器溢出中断、捕获比较器1中断、捕获比较器2中断等等）共用中断源，通过TAxIV来确定具体触发中断的中断源</p>
<p>使用步骤如下：</p>
<ol>
<li><p>设置主计数器时钟</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TA0CTL = TASSEL_1;</span><br></pre></td></tr></table></figure></li>
<li><p>设置分频</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TA0EX0 = TAIDEX_7 <span class="comment">//8分频</span></span><br></pre></td></tr></table></figure></li>
<li><p>初始化CCR寄存器（设置初值）并使能中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TA0CCR0 = <span class="number">9000</span>; <span class="comment">//设置初值</span></span><br><span class="line">TA0CCTL0 = CCIE; <span class="comment">//使能TA0CCR0中断</span></span><br></pre></td></tr></table></figure></li>
<li><p>设置捕获比较器模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TA0CTL |= MC_2 + TACLR; <span class="comment">//清除TA0R，启动定时器，选择连续计数模式</span></span><br></pre></td></tr></table></figure>

<p>也可以使用下面的代码启用其他模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MC_1 增模式</span><br><span class="line">MC_3 减增模式</span><br></pre></td></tr></table></figure></li>
<li><p>开总中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__bis_SR_register(GIE);</span><br></pre></td></tr></table></figure></li>
<li><p>配置中断服务函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector = TIMER0_A0_VECTOR <span class="comment">//TA0CCR0中断</span></span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">TA0CCR0_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TA0CCR0 += <span class="number">16384</span>; <span class="comment">//添加偏置</span></span><br><span class="line">    <span class="comment">/* 中断处理函数 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="定时器B"><a href="#定时器B" class="headerlink" title="定时器B"></a>定时器B</h4><p>在捕获比较器和比较器之间加入的比较锁存器可以分组控制比较值载入的时刻，实现同步更新数据</p>
<p>在Timer_B中可以通过配置寄存器TBxCCTLn来选择TBxCCRn载入TBxCLn的时刻，在Timer_B中起到比较作用的是比较锁存器TBxCLn而不是CCR寄存器，当TBxR的值达到TBxCLn时，相应的中断标志位置位，产生比较器中断请求，TBxCCRn的值会在寄存器设置的时间点载入TBxCLn，从而实现比较延时更新</p>
<h4 id="输入捕获"><a href="#输入捕获" class="headerlink" title="输入捕获"></a>输入捕获</h4><p>使用定时器的外部计数功能来测量脉冲个数，可用于测速、编码器驱动等场合</p>
<p>基本使用方式和上面的定时器中断类似，但是需要以下额外语句</p>
<ol>
<li><p>配置外部时钟源，使能溢出中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TA0CTL = TASSEL_0 + TAIE;</span><br></pre></td></tr></table></figure></li>
<li><p>清除TAxR、启动定时器并工作于连续模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TA0CTL |= TACLR + MC_2;</span><br></pre></td></tr></table></figure></li>
<li><p>在定时器中断服务函数内递增全局计数变量用于获取输入捕获的脉冲数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> counter;</span><br><span class="line"><span class="keyword">uint8_t</span> loop;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector = TIMER0_A1_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">TA0_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    counter++;</span><br><span class="line">    <span class="keyword">if</span>(counter&gt;<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        loop++;</span><br><span class="line">        counter=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="PWM输出"><a href="#PWM输出" class="headerlink" title="PWM输出"></a>PWM输出</h4><p>msp430可以实现在不占用CPU资源的情况下输出PWM信号，程序如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430f5529.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW | WDTHOLD; <span class="comment">//关闭看门狗</span></span><br><span class="line">    P1DIR |= BIT2 | BIT3;</span><br><span class="line">    P1SEL |= BIT2 | BIT3; <span class="comment">//设置为定时器复用</span></span><br><span class="line">    TA0CCR0 = <span class="number">512</span><span class="number">-1</span>; <span class="comment">//PWM周期，频率=32768/512=64</span></span><br><span class="line">    TA0CCTL1 = OUTMODE_7; <span class="comment">//CCR1输出模式7</span></span><br><span class="line">    TA0CCR1 = <span class="number">384</span>; <span class="comment">//CCR1 PWM占空比设置为384/512=75%</span></span><br><span class="line">    TA0CCTL2 = OUTMODE_7; <span class="comment">//CCR2输出模式7</span></span><br><span class="line">    TA0CCR2 = <span class="number">128</span>; <span class="comment">//CCR2 PWM占空比设置为128/512=25%</span></span><br><span class="line">    <span class="comment">//开启定时器</span></span><br><span class="line">    TA0CTL = TASSEL_1 + MC_1 + TACLR; <span class="comment">//定时器时钟设置为32768Hz的ACLK，配置为增模式，清空TA0R</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 可实现在P1.2上输出75%占空比，在P1.3上输出25%占空比，频率都是64Hz的PWM信号 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总线协议"><a href="#总线协议" class="headerlink" title="总线协议"></a>总线协议</h3><p>msp430f5529中配备了<strong>通用串行通信接口模块USCI</strong>，它支持了多种通信模式，UART、SPI、IIC都可以使用该外设进行处理</p>
<p>使用方法很类似，仅给出示例代码</p>
<h4 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h4><p>串口接收并复读数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430f5529.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW + WDTHOLD;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 初始化UART */</span></span><br><span class="line">    P4SEL |= BIT4 + BIT5; <span class="comment">//配置P4.4、P4.5为USCI_A1 Tx、Rx</span></span><br><span class="line">    UCA1CTL1 |= UCSWRST; <span class="comment">//复位USCI_A1</span></span><br><span class="line">    UCA1CTL1 |= UCSSEL_2; <span class="comment">//SMCLK 无校验位 8字符长度 1个停止位</span></span><br><span class="line">    UCA1BR0 = <span class="number">9</span>; <span class="comment">//低8位=9</span></span><br><span class="line">    UCA1BR1 = <span class="number">0</span>; <span class="comment">//高8位=0，调制后波特率约为115200bps</span></span><br><span class="line">    UCA1MCTL |= UCBRS_1 + UCBRF_0; <span class="comment">//调制器UCBRSx=1,UCBRFx=0</span></span><br><span class="line">    UCA1CTL1 &amp;= ~UCSWRST; <span class="comment">//启动USCI_A1</span></span><br><span class="line">    UCA1IE |= UCRXIE; <span class="comment">//使能USCI_A1接收中断</span></span><br><span class="line">    __bis_SR_register(LPM0_bits + GIE); <span class="comment">//使能全局中断</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=USCI_A1_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">USCI_A1_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(__even_in_range(UCA1IV, <span class="number">4</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//无中断</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//接收中断RXIFG</span></span><br><span class="line">            UCA1TXBUF = UCA1RXBUF; <span class="comment">//复读</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">//发送中断TXIFG</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UCA1TXBUF：串口发送寄存器</p>
<p>UCA1RXBUF：串口接收寄存器</p>
<p>UCA1IE：串口中断控制寄存器，可以选择接收中断、发送中断</p>
<h4 id="IIC"><a href="#IIC" class="headerlink" title="IIC"></a>IIC</h4><p>需要注意，msp430的IIC无法内部上拉，所以必须在外部接入4.7k的上拉电阻到VCC（3.3V）</p>
<p>下面的代码仅说明如何将USCI配置成IIC驱动模式</p>
<ol>
<li><p>包含头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>初始化引脚复用功能</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P4SEL |= BIT1 + BIT2;</span><br></pre></td></tr></table></figure></li>
<li><p>初始化USCI，并配置传输速率</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UCB1CTL1 |= UCSWRST; <span class="comment">//复位USCI_B1</span></span><br><span class="line">UCB1CTL0 |= UCMST + UCMODE_3 + UCSYNC; <span class="comment">//配置为IIC主机，同步模式</span></span><br><span class="line">UCB1CTL1 = UCSSEL_2 + UCSWRST; <span class="comment">//SMCLK，保持UCSWRST置位</span></span><br><span class="line"></span><br><span class="line">UCB1BR0 = <span class="number">12</span>; <span class="comment">//fscl=SMCLK/12=100kHz</span></span><br><span class="line">UCB1BR1 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>设置从机地址</p>
<p>这里假设从机地址是0x48</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UCB1I2CSA = <span class="number">0x48</span>; <span class="comment">//从机地址0x48</span></span><br></pre></td></tr></table></figure></li>
<li><p>启动外设</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UCB1CTL1 &amp;= ~UCSWRST; <span class="comment">//清除复位标志，外设开始运行</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写中断控制函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> IIC_RXByte;</span><br><span class="line"><span class="keyword">uint8_t</span> IIC_TXByte;</span><br><span class="line"><span class="keyword">uint8_t</span> *PRxData; <span class="comment">//接收缓存</span></span><br><span class="line"><span class="keyword">uint8_t</span> *PTxData; <span class="comment">//发送缓存</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=USCI_B1_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">USCI_B1_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(__even_in_range(UCB1IV, <span class="number">12</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//无中断</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//ALIFG</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">//无响应中断NACKIFG</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: <span class="comment">//STTIFG</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>: <span class="comment">//停止位中断STPIFG</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>: <span class="comment">//接收中断RXIFG</span></span><br><span class="line">            IIC_RXByte--; <span class="comment">//递减字节计数变量</span></span><br><span class="line">            <span class="keyword">if</span>(IIC_RXByte) <span class="comment">//如果没有接收完毕</span></span><br><span class="line">            &#123;</span><br><span class="line">                *PRxData++ = UCB1RXBUF; <span class="comment">//接收剩下的数据到缓存区</span></span><br><span class="line">                <span class="keyword">if</span>(IIC_RXByte == <span class="number">1</span>) <span class="comment">//检查是否只剩一个字节未接收</span></span><br><span class="line">                &#123;</span><br><span class="line">                    UCB1CTL1 |= UCTXSTP; <span class="comment">//发送停止条件</span></span><br><span class="line">				&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//已经接收完毕</span></span><br><span class="line">            &#123;</span><br><span class="line">                *PRxData = UCB1RXBUF; <span class="comment">//将最后一字节数据存储到缓存区</span></span><br><span class="line">                UCB1IE &amp;= ~UCRXIE; <span class="comment">//禁用接收中断</span></span><br><span class="line">                __bic_SR_registe_on_exit(LPM0_bits); <span class="comment">//退出LPM0，进入活跃模式</span></span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">12</span>: <span class="comment">//发送中断TXIFG</span></span><br><span class="line">            <span class="keyword">if</span>(IIC_TXByte) <span class="comment">//如果没有发送完毕</span></span><br><span class="line">            &#123;</span><br><span class="line">                UCB1TXBUF = *PTxData; <span class="comment">//IIC发送数据</span></span><br><span class="line">                IIC_TXByte--; <span class="comment">//递减字节计数变量</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//已经接收完毕</span></span><br><span class="line">            &#123;</span><br><span class="line">                UCB1CTL1 |= UCTXSTP; <span class="comment">//置位发送停止条件位</span></span><br><span class="line">                UCB1IFG &amp;= ~UCTTXIFG; <span class="comment">//清除发送中断标志位TXIFG</span></span><br><span class="line">                UCB1IE &amp;= ~UCTXIE; <span class="comment">//禁用发送中断</span></span><br><span class="line">                __bic_SR_registe_on_exit(LPM0_bits); <span class="comment">//退出LPM0，进入活跃模式</span></span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写相关驱动</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TxData[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//发送缓存区</span></span><br><span class="line">RxData[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//接收缓存区</span></span><br><span class="line"><span class="keyword">uint8_t</span> IIC_RXByte;</span><br><span class="line"><span class="keyword">uint8_t</span> IIC_TXByte;</span><br><span class="line"><span class="keyword">uint8_t</span> *PRxData; <span class="comment">//接收缓存</span></span><br><span class="line"><span class="keyword">uint8_t</span> *PTxData; <span class="comment">//发送缓存</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 这里省略初始化部分 */</span></span><br><span class="line">    disable_WDG();</span><br><span class="line">    init_iic();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 发送设置 */</span></span><br><span class="line">        PTxData = TxData;</span><br><span class="line">        IIC_TXByte = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">while</span>(UCB1CTL1 &amp; UCTXSTP); <span class="comment">//确保停止条件已发送，总线空闲</span></span><br><span class="line">        </span><br><span class="line">        UCBCTL1 |= UCTR; <span class="comment">//设置主机工作在发送机模式</span></span><br><span class="line">        UCBCTL1 |= UCTXSTT; <span class="comment">//发送开始条件并发送有“写标志位”的地址</span></span><br><span class="line">        UCB1IE |= UCTXIE; <span class="comment">//使能发送中断</span></span><br><span class="line">        __bis_SR_register(LPM0_bits + GIE); <span class="comment">//进入LPM0，使能全局中断</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 接收设置 */</span></span><br><span class="line">        PRxData = RxData;</span><br><span class="line">        IIC_RXByte = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">while</span>(UCB1CTL1 &amp; UCTXSTP); <span class="comment">//确保停止条件已发送，总线空闲</span></span><br><span class="line">        UCBCTL1 &amp;= ~UCTR;<span class="comment">//设置主机工作在接收机模式</span></span><br><span class="line">        UCBCTL1 |= UCTXSTT; <span class="comment">//发送开始条件并发送有“读标志位”的地址</span></span><br><span class="line">        UCB1IE |= UCRXIE; <span class="comment">//使能接收中断</span></span><br><span class="line">        __bis_SR_register(LPM0_bits + GIE); <span class="comment">//进入LPM0，使能全局中断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h4><p>使用以下代码设置SPI</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这里省略端口复用设置 */</span></span><br><span class="line">UCB0CTL1 |= UCSWrST;</span><br><span class="line">UCB0CTL0 |= UCMST + UCSYNC; <span class="comment">//设置为三线SPI主机模式，8位数据位</span></span><br><span class="line">UCB1CTL1 = UCSSEL_2; <span class="comment">//时钟设置为SMCLK</span></span><br><span class="line">UCB1BR0 = <span class="number">0xFF</span>; <span class="comment">//UCB0CLK = SMCLK / 0xFFF</span></span><br><span class="line">UCB1BR1 = <span class="number">0x0F</span>; <span class="comment">//一般来说可以选择100kHz以上的频率，通常使用4MHz频率</span></span><br><span class="line"></span><br><span class="line">UCB1CTL1 &amp;= ~UCSWRST; <span class="comment">//清除复位标志，外设开始运行</span></span><br></pre></td></tr></table></figure>

<p>中断和驱动编写部分和IIC基本一致，不再赘述</p>
<h3 id="片上模拟外设"><a href="#片上模拟外设" class="headerlink" title="片上模拟外设"></a>片上模拟外设</h3><p>msp430集成了12位ADC/DAC和模拟比较器外设</p>
<h4 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h4><p>f5529配备了SAR架构的ADC12_A模块，支持12位ADC，具有16个模拟输入通道、16个独立的转换和存储单元，可在脱离CPU情况下完成ADC转换，最高200ksp（千次采样/每秒）</p>
<p>基本配置流程如下：</p>
<ol>
<li><p>配置核心控制寄存器，选择时钟、转换模式、启动参考电压生成器</p>
<p>ADC12_A内部具有独立的REF模块，可以提供1.5V、2V、2.5V参考电压。通过REF模块的REFMSTR位选择参考电压：置1时（默认状态）使用REF模块控制参考电压；置0时使用ADC12_A的参考电压模块控制参考电压</p>
<p>使用ADC12REF2_5V控制参考电压大小，ADC12REFON控制是否开启电压生成器，ADC12REFOUT控制是否输出参考电压</p>
<p>ADC使用ADC12CLK时钟用来控制采样和转换的时间和周期，时钟源可选择SMCLK、MCLK、ACLK和ADC12OSC（UCS模块的MODCLK的5MHz内部振荡器），时钟源使用ADC12DIV控制的预分频器和ADC12SSELx控制的分频器进行分频，可选择1-32分频</p>
<p>基本配置程序如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADC12CTL0 = ADC12ON+ADC12SHT0_8+ADC12MSC; <span class="comment">//开启ADC12,设置采样时间,设置采样模式（这里使用了多采样转换）</span></span><br></pre></td></tr></table></figure>

<p>ADC具有4种模式，通过CONSEQx位选择</p>
<ul>
<li><strong>单通道模式</strong>：单通道只采样和转换一次，当ADC12SC置位时触发一次采样转换操作，持续一段时间后自动复位</li>
<li>序列通道（<strong>自动扫描</strong>）<strong>模式</strong>：使用CSTARTADDx位选择开始转换的第一个ADC1MCTLx，指定后序列启动指针会自动递增，被它指向的通道会自动开始转换，转换完成后自动复位，操作一直继续直到处理到ADC12EOS=1的ADC12MCTLx才会停止，ADC12EOS作为序列结束的标志，只在序列转换模式下使用</li>
<li><strong>重复单通道模式</strong>：一个单独的通道会被不断采样转换，可以设置完成中断来读取转换结果</li>
<li><strong>重复序列通道</strong>（自动重复）<strong>模式</strong>：一序列通道会被重复采样和转换，使用CSTARTADDx定义第一个ADC12McTLx，序列再检测到ADC12EOS（序列结束标志）置位后会自动结束，下一个触发信号将重新开始序列</li>
</ul>
</li>
<li><p>保持其处于禁用状态，ADC12ENC=0</p>
</li>
<li><p>配置引脚复用</p>
<p>将GPIO复用为ADC输入引脚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PxSEL |= <span class="number">0x0</span>n; <span class="comment">//选择Px.n引脚复用为ADC输入</span></span><br></pre></td></tr></table></figure>

<p>注意：<strong>只有能接入ADC的对应IO口才能复用</strong></p>
</li>
<li><p>配置采样定时器</p>
<p>一次转换由一个采样信号SHI的上升沿引起，可通过SHSx位来选择，可以选为直接由ADC12SC位控制或使用定时器来控制</p>
<ul>
<li>ADC12SHP=0，使用<strong>扩展采样模式</strong>，SHI信号直接控制SAMPCON并定义采样周期长度；SAMPCON=1时采样活跃，SAMPCON的下降沿会在同步ADC12CLK信号后启动转换</li>
<li>ADC12SHP=1，使用<strong>脉冲采样模式</strong>，SHI信号用于触发采样定时器，采样定时器在同步AD12CLK后将SAMPCON保持在高电平并持续一个可编程的间隔$t_{sample}$，整个采样时间就是$t_{sample}+t_{sync}$</li>
</ul>
</li>
<li><p>可单独配置每个通道的参考电压和输入源</p>
<p>使用ADC12MCTLx（x为0-15）控制转换存储单元，通过ADC12SREF和ADC12INCH分别选择参考电压和模拟信号的输入通道</p>
<p>在单通道单转换模式中，复位ADC12ENC<strong>立刻</strong>停止一个转换且会导致转换结果不可预知，一般来说需要使用以下语句停止单通道转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(ADC12BUSY != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    delay();</span><br><span class="line">&#125;</span><br><span class="line">ADC12ENC = <span class="number">0</span>; <span class="comment">//等待ADC12BUSY = 0后才能停止单通道转换</span></span><br></pre></td></tr></table></figure>

<p>重复单通道模式下，复位ADC12ENC会在<strong>当前转换结束</strong>时停止转换器</p>
<p>序列通道或重复序列通道中，复位ADC12ENC会在<strong>序列结束</strong>时停止转换器</p>
<p><em>任何模式中都可以通过清零ADC12CONSEQ并复位ADC12ENC位来立刻停止，但这样会导致转换结果不可预知</em></p>
</li>
<li><p>可以使能集成温度传感器或配置转换完成中断</p>
<p>ADC可以直接连接内部的温度传感器（这是参考电压生成器的一部分）来获取内部温度，计算公式如下<br>$$<br>T=(ADC_{raw} - CAL_ADC_T30) \times (\frac{85-30}{CAL_ADC_T85 - CAL_ADC_T30}) + 30<br>$$<br>其中T是精确温度值，$ADC_{raw}$是数模转换结果，两个$CAL_ADC_T$为温度矫正参数，需要通过地址进行访问调用，每个设备的矫正参数都不同，该参数会被使用TLV（Tag-Length-Value）的方式写入单片机，地址调用形式如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*((<span class="keyword">unsigned</span> <span class="keyword">int</span>*)<span class="number">0x1A1A</span>) <span class="comment">//具体地址需要根据电压和设备的不同来确定，详细内容参考datasheet即可</span></span><br></pre></td></tr></table></figure>

<p><strong>ADC12_A具有18个中断，共用一个中断源</strong></p>
<p>可单独配置某通道完成中断、ADC12MEMx溢出中断、ADC12_A计时溢出中断，所有中断通过唯一的中断向量寄存器来配置，也就是说只使用一个中断服务函数</p>
<p>注意：任何对于ADC12IV的读写操作都会自动复位ADC12OV或ADC12TOV，如果中断服务函数在访问ADC12IV寄存器时有ADC12OV和ADC12IFGx中断生成，那么ADC12OV中断条件会自动复位，在中断服务函数返回后紧接着处理其他中断，因此应避免中断执行时间过长导致ADC中断占用前台应用</p>
<p>使用下面的程序来开启ADC中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADC12IE = <span class="number">0x01</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>将ADC12ENC=1来使能设备</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADC12CTL0 |= ADC12ENC;</span><br><span class="line">ADC12CTL0 |= ADC12SC;</span><br></pre></td></tr></table></figure></li>
<li><p>通过读取ADC12MCTLx对应的ADC12MEMx来获取转换结果</p>
</li>
</ol>
<p>单通道单次转换示例如下（测量引脚电压高于参考电压则指示灯亮）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	WDTCTL = WDTPW + WDTHOLD;  <span class="comment">//停止WDG</span></span><br><span class="line">  	ADC12CTL0 = ADC12SHT02 + ADC12ON; <span class="comment">//设置采样时间并开启ADC12_A</span></span><br><span class="line"> 	ADC12CTL1 = ADC12SHP; <span class="comment">//使用采样定时器</span></span><br><span class="line">  	ADC12IE = <span class="number">0x01</span>; <span class="comment">//使能中断</span></span><br><span class="line">  	ADC12CTL0 |= ADC12ENC; <span class="comment">//使能转换通道</span></span><br><span class="line">  	P6SEL |= <span class="number">0x01</span>; <span class="comment">//配置P6.1复用为ADC输入</span></span><br><span class="line">  	P1DIR |= <span class="number">0x01</span>; <span class="comment">//配置P1.0信号指示输出</span></span><br><span class="line"></span><br><span class="line">  	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  	&#123;</span><br><span class="line">    	ADC12CTL0 |= ADC12SC; <span class="comment">//开始依次采样</span></span><br><span class="line"></span><br><span class="line">    	__bis_SR_register(LPM0_bits + GIE); <span class="comment">//进入LPM0,开启全局中断</span></span><br><span class="line">    	__no_operation(); <span class="comment">//用于调试器打断点的空指令</span></span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADC中断服务函数 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector = ADC12_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">ADC12_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="keyword">switch</span>(__even_in_range(ADC12IV,<span class="number">34</span>))</span><br><span class="line">  	&#123;</span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">0</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  0:  No interrupt</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">2</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  2:  ADC溢出中断</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">4</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  4:  ADC超时中断</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">6</span>:                                  <span class="comment">// Vector  6:  ADC12IFG0</span></span><br><span class="line">		<span class="comment">/* 测量P1引脚 */</span></span><br><span class="line">    	<span class="keyword">if</span> (ADC12MEM0 &gt;= <span class="number">0x7ff</span>)               <span class="comment">// ADC12MEM = A0 &gt; 0.5AVcc?</span></span><br><span class="line">      		P1OUT |= BIT0;                    <span class="comment">// P1.0 = 1</span></span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">      		P1OUT &amp;= ~BIT0;                   <span class="comment">// P1.0 = 0</span></span><br><span class="line"></span><br><span class="line">    	__bic_SR_register_on_exit(LPM0_bits); <span class="comment">//退出LPM0模式</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">8</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  8:  ADC12IFG1</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">10</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 10:  ADC12IFG2</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">12</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 12:  ADC12IFG3</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">14</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 14:  ADC12IFG4</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">16</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 16:  ADC12IFG5</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">18</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 18:  ADC12IFG6</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">20</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 20:  ADC12IFG7</span></span><br><span class="line"> 	<span class="keyword">case</span> <span class="number">22</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 22:  ADC12IFG8</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">24</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 24:  ADC12IFG9</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">26</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 26:  ADC12IFG10</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">28</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 28:  ADC12IFG11</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">30</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 30:  ADC12IFG12</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">32</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 32:  ADC12IFG13</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">34</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 34:  ADC12IFG14</span></span><br><span class="line">  	<span class="keyword">default</span>: <span class="keyword">break</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>多通道重复转换示例如下（连续读取P6.0、P6.1、P6.2、P6.3的ADC值）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Num_of_Results 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> A0results[Num_of_Results];</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> A1results[Num_of_Results];</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> A2results[Num_of_Results];</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> A3results[Num_of_Results];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	WDTCTL = WDTPW+WDTHOLD;                   <span class="comment">//关闭WDG</span></span><br><span class="line">    </span><br><span class="line">  	P6SEL = <span class="number">0x0F</span>;                             <span class="comment">//使能ADC复用引脚（P6的低四位0、1、2、3进行复用）</span></span><br><span class="line">  	ADC12CTL0 = ADC12ON+ADC12MSC+ADC12SHT0_8; <span class="comment">//开启ADC、扩展采样时间避免结果溢出</span></span><br><span class="line">  	ADC12CTL1 = ADC12SHP+ADC12CONSEQ_3;       <span class="comment">//使用采样定时器，设置为多通道重复采样模式</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置0、1、2、3通道的参数 */</span></span><br><span class="line">  	ADC12MCTL0 = ADC12INCH_0;                 <span class="comment">// ref+=AVcc, channel = A0</span></span><br><span class="line">  	ADC12MCTL1 = ADC12INCH_1;                 <span class="comment">// ref+=AVcc, channel = A1</span></span><br><span class="line">  	ADC12MCTL2 = ADC12INCH_2;                 <span class="comment">// ref+=AVcc, channel = A2</span></span><br><span class="line">  	ADC12MCTL3 = ADC12INCH_3+ADC12EOS;        <span class="comment">// ref+=AVcc, channel = A3 ，设置ADC结束标志</span></span><br><span class="line">    </span><br><span class="line">  	ADC12IE = <span class="number">0x08</span>;                           <span class="comment">//使能ADC12IFG.3中断</span></span><br><span class="line">  	ADC12CTL0 |= ADC12ENC;                    <span class="comment">//使能转换通道</span></span><br><span class="line">  	ADC12CTL0 |= ADC12SC;                     <span class="comment">//开始转换-软件触发</span></span><br><span class="line">  </span><br><span class="line">  	__bis_SR_register(LPM0_bits + GIE);       <span class="comment">//进入LPM0并开启全局中断</span></span><br><span class="line">  	__no_operation();                         <span class="comment">//用于调试器打断点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=ADC12_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">ADC12ISR</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">switch</span>(__even_in_range(ADC12IV,<span class="number">34</span>))</span><br><span class="line">  	&#123;</span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">0</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  0:  No interrupt</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">2</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  2:  ADC overflow</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">4</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  4:  ADC timing overflow</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">6</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  6:  ADC12IFG0</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">8</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  8:  ADC12IFG1</span></span><br><span class="line"> 	<span class="keyword">case</span> <span class="number">10</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 10:  ADC12IFG2</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">12</span>:                                  <span class="comment">// Vector 12:  ADC12IFG3</span></span><br><span class="line">    	A0results[index] = ADC12MEM0;         <span class="comment">// Move A0 results, IFG is cleared</span></span><br><span class="line">    	A1results[index] = ADC12MEM1;         <span class="comment">// Move A1 results, IFG is cleared</span></span><br><span class="line">    	A2results[index] = ADC12MEM2;         <span class="comment">// Move A2 results, IFG is cleared</span></span><br><span class="line">    	A3results[index] = ADC12MEM3;         <span class="comment">// Move A3 results, IFG is cleared</span></span><br><span class="line">    	index++;                              <span class="comment">// 保存到结果缓存区</span></span><br><span class="line">    </span><br><span class="line">    	<span class="keyword">if</span> (index == <span class="number">8</span>)</span><br><span class="line">    	&#123;</span><br><span class="line">      		(index = <span class="number">0</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">  	<span class="keyword">case</span> <span class="number">14</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 14:  ADC12IFG4</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">16</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 16:  ADC12IFG5</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">18</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 18:  ADC12IFG6</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">20</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 20:  ADC12IFG7</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">22</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 22:  ADC12IFG8</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">24</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 24:  ADC12IFG9</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">26</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 26:  ADC12IFG10</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">28</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 28:  ADC12IFG11</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">30</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 30:  ADC12IFG12</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">32</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 32:  ADC12IFG13</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">34</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 34:  ADC12IFG14</span></span><br><span class="line">  	<span class="keyword">default</span>: <span class="keyword">break</span>; </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DAC"><a href="#DAC" class="headerlink" title="DAC"></a>DAC</h4><p>msp430f5529配备了DAC12_A模块，模块组成结构如下：</p>
<ul>
<li><p>核心</p>
<p>可以通过修改DAC12RES的值将DAC12_A配置为8位或12位模式；配置DAC12IR和DAC12OG位可以将满标度输出配置为所选参考电压的1倍、2倍或3倍；配置DAC12DF位选择输入的数据格式是原码还是补码。</p>
</li>
<li><p>端口</p>
<p>大多数DAC复用的端口都有其他复用功能，但是当DAC12AMPx&gt;0时，DAC12_A会忽略PxSEL.y和PxSEL.x的值，自动配置端口为DAC12_A输出复用功能</p>
<p>每个DAC通道都能输出到两个不同的端口，通过DAC122OPS选择，详细参数需要查阅datasheet</p>
</li>
<li><p>参考电压</p>
<p>使用DAC12SREFx选择DAC12_A参考电压，该值从AVCC、外部电压输入、内部1.16V参考电压、内部REF模块提供1.5V、2V、2.5V参考电压之一选择</p>
</li>
<li><p>参考输入和电压输出缓冲区</p>
<p>参考输入和电压输出缓冲区通过寄存器配置来平衡建立时间和功耗，通过配置DAC12AMPx来选择组合，其值越小、建立时间越长、缓冲区上的电流消耗越小</p>
</li>
<li><p>数据格式</p>
<p>使用原码或补码形式都可以设置DAC，使用DAC12_xDAT（取值范围0800h（输出0V）-07ffh（输出标度），另外取值0000h时输出标度的一半）控制</p>
</li>
</ul>
<p>相关示例程序如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 输出固定电压 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW+WDTHOLD; <span class="comment">//关闭WDG</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置无增益，参考电压AVCC，启动DAC校准</span></span><br><span class="line">    DAC12_0CTL0 = DAC12IR + DAC12SREF_1 + DAC12AMP_5 + DAC12CALON;</span><br><span class="line">	DAC12_0CTL0 |= DAC12ENC; <span class="comment">//使能DAC12_A</span></span><br><span class="line">    <span class="comment">//需要注意这里的输出值是12位</span></span><br><span class="line">    DAC12_0DAT = <span class="number">0x000</span>; <span class="comment">//DAC输出0V</span></span><br><span class="line">    <span class="comment">//和上面一样的流程</span></span><br><span class="line">    DAC12_1CTL0 = DAC12IR + DAC12SREF_1 + DAC12AMP_5 + DAC12CALON;</span><br><span class="line">    DAC12_0CTL0 |= DAC12ENC; <span class="comment">//使能DAC12_A</span></span><br><span class="line">    DAC12_0DAT = <span class="number">0x700</span>; <span class="comment">//输出1.4V</span></span><br><span class="line">    __bis_SR_register(LPM4_bits); <span class="comment">//进入LPM4，DAC会自动输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出波形 */</span></span><br><span class="line"><span class="comment">//以FLASH换内存</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> Sin_tab[<span class="number">100</span>] = &#123; </span><br><span class="line"><span class="number">1638</span>,<span class="number">1740</span>,<span class="number">1843</span>,<span class="number">1944</span>,<span class="number">2045</span>,<span class="number">2143</span>,<span class="number">2240</span>,<span class="number">2335</span>,<span class="number">2426</span>,<span class="number">2515</span>,</span><br><span class="line"><span class="number">2600</span>,<span class="number">2681</span>,<span class="number">2758</span>,<span class="number">2831</span>, <span class="number">2899</span>,<span class="number">2962</span>,<span class="number">3020</span>,<span class="number">3072</span>,<span class="number">3119</span>,<span class="number">3160</span>,</span><br><span class="line"><span class="number">3195</span>,<span class="number">3224</span>,<span class="number">3246</span>,<span class="number">3262</span>,<span class="number">3272</span>,<span class="number">3272</span>,<span class="number">3263</span>,<span class="number">3247</span>,<span class="number">3224</span>,<span class="number">3196</span>,</span><br><span class="line"><span class="number">3161</span>,<span class="number">3120</span>,<span class="number">3074</span>,<span class="number">3021</span>,<span class="number">2964</span>,<span class="number">2901</span>,<span class="number">2833</span>,<span class="number">2760</span>,<span class="number">2683</span>,<span class="number">2602</span>,</span><br><span class="line"><span class="number">2517</span>,<span class="number">2429</span>,<span class="number">2337</span>,<span class="number">2243</span>,<span class="number">2146</span>,<span class="number">2047</span>,<span class="number">1947</span>,<span class="number">1845</span>,<span class="number">1743</span>,<span class="number">1640</span>,</span><br><span class="line"><span class="number">1537</span>,<span class="number">1435</span>,<span class="number">1333</span>,<span class="number">1233</span>,<span class="number">1134</span>,<span class="number">1037</span>,<span class="number">943</span>,<span class="number">851</span>,<span class="number">762</span>,<span class="number">677</span>,<span class="number">596</span>,</span><br><span class="line"><span class="number">519</span>,<span class="number">446</span>,<span class="number">378</span>,<span class="number">314</span>,<span class="number">256</span>,<span class="number">204</span>,<span class="number">157</span>,<span class="number">116</span>,<span class="number">81</span>,<span class="number">52</span>,<span class="number">29</span>,<span class="number">13</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>,</span><br><span class="line"><span class="number">12</span>,<span class="number">28</span>,<span class="number">50</span>,<span class="number">78</span>,<span class="number">113</span>,<span class="number">154</span>,<span class="number">200</span>,<span class="number">252</span>,<span class="number">310</span>,<span class="number">373</span>,<span class="number">440</span>,<span class="number">513</span>,<span class="number">590</span>,</span><br><span class="line"><span class="number">671</span>,<span class="number">756</span>,<span class="number">756</span>,<span class="number">844</span>,<span class="number">936</span>,<span class="number">1030</span>,<span class="number">1127</span>,<span class="number">1225</span>,<span class="number">1326</span>,<span class="number">1427</span>,<span class="number">1529</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW + WDTHOLD; <span class="comment">//停看门狗</span></span><br><span class="line"> 	INIT_XT2(); <span class="comment">//开启时钟   </span></span><br><span class="line"></span><br><span class="line"> 	P5SEL = <span class="number">0XFF</span>;</span><br><span class="line"> 	ADC12CTL0 = REFON; <span class="comment">//参考电压为内部2.5v  </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置DMA，直接将Sin_tab数据传输到DAC */</span></span><br><span class="line"> 	DMA0SA = (<span class="keyword">int</span>) Sin_tab; <span class="comment">//源地址寄存器</span></span><br><span class="line"> 	DMA0DA = DAC12_0DAT_; <span class="comment">//目的地址寄存器</span></span><br><span class="line">	DMA0SZ = <span class="number">100</span>; <span class="comment">//传输基本单元的个数</span></span><br><span class="line"> 	DMACTL0 = DMA0TSEL_5; <span class="comment">// DAC12_0CTL的DAC12IFG标志</span></span><br><span class="line"> 	DMA0CTL = DMADT_4 + DMASRCINCR_3 + DMAEN; <span class="comment">//DMADT_4：重复的块传输方式</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使用内部1.5V参考电压，无增益，使能DAC12_A校准并使能DAC12_A */</span></span><br><span class="line">	DAC12_0CTL = DAC12LSEL_2 + DAC12IR + DAC12AMP_5 + DAC12IFG + DAC12ENC; <span class="comment">//配置DAC</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 强制输出第一个中断 */</span></span><br><span class="line"> 	CCTL1 = OUTMOD_3; <span class="comment">//设置并复位</span></span><br><span class="line">	CCR1 = <span class="number">1</span>; <span class="comment">// PWM Duty Cycle   </span></span><br><span class="line">	CCR0 = <span class="number">8</span><span class="number">-1</span>; <span class="comment">//1kHz频率</span></span><br><span class="line">	TACTL = TASSEL_2 + MC_1; <span class="comment">//使用SMCLK时钟源,向上计数模式  </span></span><br><span class="line">	__bis_SR_register(LPM0_bits); <span class="comment">//进入LPM0，DMA和DAC都在工作，会自动输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可编程比较器"><a href="#可编程比较器" class="headerlink" title="可编程比较器"></a>可编程比较器</h4><p>f5529配备了Comp_B模块，支持精密线性数模转换、电源电压监控、外部模拟信号电压监测功能</p>
<p>其中核心是一个精密电压比较器，同相端比反相端电压高，则输出高电平，否则输出低电平，使用CBON位打开/关闭比较器</p>
<p>使用CBCTL0寄存器控制外部输入端口，CBIPEN和CBIMEN分别控制同相端和反相端；使用CBIMSEL和CBIPSEL控制端子连接的GPIO，应选择P6的端口，以这两个寄存器控制端口号</p>
<p>可以使用CBSHORT短路正反相输入，可用来建立简单的采样-保持机制，一般来说设置采样时间为3-10τ，3τ可以将采样电容充电到95%的输入信号电压值，5τ可以将采样电容充电到99%，10τ可以满足12位的精度</p>
<p>使用CBF控制位控制输出信号的输出滤波器</p>
<p>使用参考电压生成器来生成VREF，可以应用于比较器输入端，使用CBREF0x和CBREF1xl来控制</p>
<p>使用CBPWRMD来选择比较器功耗模式，默认为00——最大功耗、最快速度；可以调节到11来使用最低功耗、最低速度</p>
<p>使用CBCTL3来控制比较器的端口是否禁用；使用CBIPSEL或CBIMSEL来控制对应端口的输入缓冲区</p>
<p><strong>比较器也可以开启中断</strong></p>
<p>对于可编程电压比较器而言，一般使用滞后比较来让参考电压根据输出值变化，可以让比较器输出更加稳定，降低噪声</p>
<p>代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW + WDTHOLD; <span class="comment">//停看门狗</span></span><br><span class="line">    P1DIR |= BIT6; <span class="comment">//P1.6作输出</span></span><br><span class="line">    P1SEL |= BIT6; <span class="comment">//复用为比较器输出CBOUT</span></span><br><span class="line">    </span><br><span class="line">    P7DIR |= <span class="number">0xFF</span>; <span class="comment">//P7设置为输出，用来驱动LED显示当前比较器结果</span></span><br><span class="line">    </span><br><span class="line">    CBCTL0 |= CBIPEN + CBIPSEL_0; <span class="comment">//比较器施恩那个，设置输入通道CB0为P6.0</span></span><br><span class="line">    CBCTL1 |= CBPWRMD_0; <span class="comment">//设置为高速模数</span></span><br><span class="line">    CBCTL2 |= CBRSEL; <span class="comment">//使用VREF作为反相端的参考电压</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置高低两个阈值电压 */</span></span><br><span class="line">    CBCTL2 |= CBRS_1 + CBREF13; <span class="comment">//以VCC为参考电压，CBREF1=8，VREF=VCC/4</span></span><br><span class="line">    CBCTL2 |= CBREF04 + CBREF03; <span class="comment">//VREF0=VCC * 3/4</span></span><br><span class="line">    </span><br><span class="line">    CBCTL3 |= BIT0; <span class="comment">//打开Comp_B</span></span><br><span class="line">    CBCTL1 |= CBON; <span class="comment">//使能比较器</span></span><br><span class="line">    __delay_cycles(<span class="number">75</span>); <span class="comment">//等待比较器内部参考电压达到稳定</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(CBCTL1 &amp; CBOUT) <span class="comment">//如果CBOUT为高电平</span></span><br><span class="line">        &#123;</span><br><span class="line">            P7OUT = <span class="number">0x00</span>; <span class="comment">//LED点亮</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            P7OUT = <span class="number">0xFF</span>; <span class="comment">//LED熄灭</span></span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码在输入电压大于VREF0=3/4 VCC时CBOUT输出高电平，LED点亮；输入电压小于VREF0=1/4 VCC时CBOUT输出低电平，LED熄灭；当电压在二者之间时，CBOUT状态不变，起到了稳定输出的作用</p>
<p>同样的比较器也可以产生中断信号，在检测到设定的跳变沿（上升沿或下降沿）后触发中断，进入对应的中断服务函数，可以在其中判断比较器输出的电平，避免了轮询</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CBCTL1 |= CBPWRMD_1 + CBF + CBFDLY_3; <span class="comment">//普通模式，选择中断边压，使用输出滤波</span></span><br><span class="line"><span class="comment">/* 在中间设置其他比较器参数 */</span></span><br><span class="line"><span class="comment">/* 等待一定时间来让参考电压稳定 */</span></span><br><span class="line">CBINT &amp;= ~(CBIFG + CCBIIFG); <span class="comment">//清除错误中断标志</span></span><br><span class="line">CBINT |= CBIE + CBIIE; <span class="comment">//使能比较器输出中断和输出反相中断</span></span><br><span class="line">__bis_SR_register(LPM0_bits + GIE); <span class="comment">//开启全局中断</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=COMP_B_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">Comp_B_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(__even_in_range(CBIV, <span class="number">4</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//无中断</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//中断CBIFG</span></span><br><span class="line">            <span class="keyword">if</span>(CBCTL1 &amp; CBOUT) <span class="comment">//判断是否输出高电平</span></span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">//反相中断CBIIFG</span></span><br><span class="line">            <span class="keyword">if</span>(!(CBCTL1 &amp; CBOUT)) <span class="comment">//反相端需要相反的判断</span></span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里仅列出中断服务函数和其开启方式</p>
<h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><p>msp430的DMA最多有8个通道，但是msp430f5529只有3个通道</p>
<p>基本使用方法和stm32的DMA完全一样，四种模式、单传输、块传输、连续传输都和stm32的传输方法类似，但设置更为简单</p>
<p>一个使用DMA进行UART传输的例子如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> String1[] = &#123;<span class="string">&quot;Hello World\r\n&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW + WDTHOLD; <span class="comment">//停看门狗</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 端口配置 */</span></span><br><span class="line">    P4SEL = BIT4 + BIT5; <span class="comment">//配置P4.4、P4.5为Tx、Rx端口</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* 配置USCI_A1为UART模式 */</span></span><br><span class="line">    UCA1CTL1 = UCSSEL_1; <span class="comment">//使用ACLK为时钟源</span></span><br><span class="line">    <span class="comment">//控制分频器设置波特率为9600</span></span><br><span class="line">	UCA1BR0 = <span class="number">0x03</span>; <span class="comment">//分频器高八位</span></span><br><span class="line">    UCA1BR1 = <span class="number">0x0</span>; <span class="comment">//分频器低八位</span></span><br><span class="line">    UCA1MCTL = UCBRS_3 + UCBRF_0; <span class="comment">//调制器UCBRSx = 3</span></span><br><span class="line">    UCA1CTL1 &amp;= ~UCSWRST; <span class="comment">//启动设备</span></span><br><span class="line">    <span class="comment">/* 配置DMA */</span></span><br><span class="line">    DMACTL0 = DMA0TSEL_1; <span class="comment">//以定时器TA0CCR0 CCIFG为触发源</span></span><br><span class="line">    </span><br><span class="line">    __data16_write_addr((<span class="keyword">uint16_t</span>)&amp;DMA0SA, (<span class="keyword">uint32_t</span>)String1); <span class="comment">//源地址：String1字符串</span></span><br><span class="line">    __data16_write_addr((<span class="keyword">uint16_t</span>)&amp;DMA0DA), (<span class="keyword">uint32_t</span>)&amp;UCA1TXBUF); <span class="comment">//目标地址：UART发送缓存区域</span></span><br><span class="line">	</span><br><span class="line">	DMA0CTL = DMADT_4 + DMASRCINCR_3 + DMASBDB +DMAEN; <span class="comment">//重复单传输，递增模式，字节到字节，并使能DMA</span></span><br><span class="line">    <span class="comment">/* 配置定时器 */</span></span><br><span class="line">    TA0CCR0 = <span class="number">8192</span>; <span class="comment">//字符传输频率=32768/8192=4 字节/s</span></span><br><span class="line">	TA0CTL = TASSEL_1 + MC_1; <span class="comment">//使用ACLK作为时钟源，采用增模式</span></span><br><span class="line">    __bis_SR_register(LPM0_bits); <span class="comment">//进入LPM3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序会连续向外以9600波特率发送串口数据</p>
<h3 id="电源管理"><a href="#电源管理" class="headerlink" title="电源管理"></a>电源管理</h3><p>msp430f5529的电源管理模块PMM由监督器SVS和监视器SVM组成</p>
<p>SVS是强制要求的，用于保障设备稳定运行</p>
<p>SVM是宽松可编程的，用于进行一些低功耗控制和安全保障</p>
<p>可以通过对SVM编程提高VCORE来支持更高的MCLK，也就是所谓的<strong>超频</strong></p>
]]></content>
      <tags>
        <tag>电赛笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>现代C语言2</title>
    <url>/2021/11/14/%E7%8E%B0%E4%BB%A3C%E8%AF%AD%E8%A8%802/</url>
    <content><![CDATA[<h1 id="C语言语法拾遗"><a href="#C语言语法拾遗" class="headerlink" title="C语言语法拾遗"></a>C语言语法拾遗</h1><p>专门总结了一些C语言C99/C11之后的新语法或冷门语法</p>
<h2 id="预处理和宏——灵魂"><a href="#预处理和宏——灵魂" class="headerlink" title="预处理和宏——灵魂"></a>预处理和宏——灵魂</h2><p>预处理器和宏可以说是面向对象语言<em>独有</em>的东西，<strong>这些特性发生在编译这个过程之前</strong>，使得C语言的编译过程变得“可控”，甚至可以说C语言编译本身就是一个开发者可编程的过程——或许这样说比较抽象，举个例子：java的宏并不对一般开发者开放，一般只有OpenJDK的开发者才会面对java宏和相关预编译指令；但是C语言的宏直接出现在hello world程序中：“#include”指令本身就意味着对链接器进行调用——这些宏严格来说并不属于C语言的语法学习范畴，但是如果想靠C语言造轮子，这就是无法避开的</p>
<span id="more"></span>

<p>C预处理器就是C语言的灵魂，上能干涉程序实现，下能检查编译原理</p>
<h3 id="预处理指令的特殊用法"><a href="#预处理指令的特殊用法" class="headerlink" title="预处理指令的特殊用法"></a>预处理指令的特殊用法</h3><ol>
<li><h1 id><a href="#" class="headerlink" title></a></h1><p>预处理器对井号标记<code>#</code>有三种不同的用法：</p>
<ol>
<li><p>标记一个指令</p>
<p>这是最常用的方法，#之前的空白会被忽略，因此各种头文件的格式总是防止重复包含-引用-宏定义-变量定义-函数定义</p>
</li>
<li><p>输入的字符串化</p>
<p><strong>使用#可以将一个变量转义为字符串，并且如果旁边有其它字符串相邻，会将他们合并在一起</strong></p>
<p>这就是很多c程序处理字符串IO的方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Pevel(cmd) printf(#cmd <span class="meta-string">&quot;:%g\n&quot;</span>,cmd);</span></span><br></pre></td></tr></table></figure>

<p>上面的代码会将输入的变量cmd转换成字符串，输出变量名并输出对应的值</p>
</li>
<li><p>把符号连接起来</p>
<p>使用两个##就可以将不是字符串的东西拼接在一起</p>
<p>比如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">name = LL;</span><br><span class="line">name##_list</span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line">LL_list</span><br></pre></td></tr></table></figure>

<p>往往使用这种编程方法实现C语言的键值对（字典）轮子</p>
</li>
</ol>
</li>
<li><p>避免头文件包含</p>
<p>这个用法很重要，懂得都懂。不懂的话自己写两个一模一样的.h文件碰几次报错就懂了</p>
<p>使用方法有两种：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __THIS_DOCUMENT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __THIS_DOCUMENT</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这里是头文件内容 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br></pre></td></tr></table></figure>

<p>这行语句只要加在文件开头即可通知编译器不进行二次包含，它实际上依赖于编译器，但每个主流的编译器都支持该指令</p>
</li>
<li><p>static和extern保护</p>
<p>在.c库文件内的所有函数前使用static，并在.h文件中进行声明，可以对函数和变量进行一定的保护</p>
<p>在含有很多全局变量，会被多处包含的.h头文件中使用extern声明全局变量可以防止多次重复编译；但是要注意：只在其中一个包含了该头文件的.c文件中进行变量定义</p>
</li>
</ol>
<h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><p>使用typedef可以提高代码可读性、化简声明复杂度</p>
<p>还可以把一个结构体封装成一个“类”或封装出一个“方法”</p>
<p>这里要强调的是：<strong>typedef</strong>本身是一个C语言指令，<strong>并不是宏</strong>——它在编译阶段才会执行，并为某个数据类型声明一个别名，并且你也可以继续使用这个数据类型原来的名字。typedef并不会在编译阶段就得到执行，虽然现代的C编译器会对其做出优化，但是它的运行还可能会占据微不足道的一段程序运行时间——特别是在某些优化不好的冷门嵌入式设备编译器中，这也有可能导致一些莫名其妙的底层bug</p>
<h3 id="可变参数宏"><a href="#可变参数宏" class="headerlink" title="可变参数宏"></a>可变参数宏</h3><p>宏用于执行文本替换，但其思路和函数并不相同，并且它最大的特点就是：在预处理阶段完成替换，且遵循相对严格的替换原则</p>
<p>因此如果不仔细地写宏很容易造成错误！</p>
<p>宏一般能分成两类，一类是<strong>表达式展开宏</strong>：可以对这类宏进行求值，或宏干脆就是个数值，如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14159265</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T 2-1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> one_to_ten 1/10</span></span><br></pre></td></tr></table></figure>

<p>另一类是<strong>指令展开宏</strong>：一条甚至一系列指令，有可用的未知量，如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max m&gt;n?m:n</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> u(x) x&gt;0?x:0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> t=t+1</span></span><br></pre></td></tr></table></figure>

<p>为了编写鲁棒性更高（人话：更不容易出bug、易于移植）的宏，应遵循以下三条规则</p>
<ul>
<li><p><strong>多用括号</strong>：把所有容易出bug的东西都括起来，防止重复错误和过度替换错误</p>
</li>
<li><p><strong>代码块两端加入花括号</strong></p>
<p>示例如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> doubleincrement(a, b) \</span></span><br><span class="line"><span class="meta">		(a)++;				  \</span></span><br><span class="line"><span class="meta">		(b)++;</span></span><br><span class="line"><span class="comment">//上面这个例子容易出错，应该如下修改</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> doubleincrement(a, b) \</span></span><br><span class="line"><span class="meta">		&#123;(a)++;				  \</span></span><br><span class="line"><span class="meta">		(b)++;&#125;</span></span><br><span class="line"><span class="comment">//还有另外的方法，可以相当程度上保证代码块的安全</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> doubleincrement(a,b) do&#123;(a)++;(b)++;&#125;while(0)</span></span><br><span class="line"><span class="comment">//但是这种方法并不是万能的，要注意灵活变通！</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>避免重复作用</strong>：使用注释等方法提醒用户不要做出越界的使用方法以免过度替换，并使用较少数量的参数，尽量防止参数过多导致bug</p>
</li>
</ul>
<p>现代编译器中往往都会带有宏替换指示功能，Vim、Emacs甚至提供了一整套插件用于纠错，应该合理应用这些插件</p>
<p>这里要介绍的是一个特殊的宏：<strong>可变参数宏</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__VA_ARGS__</span><br></pre></td></tr></table></figure>

<p>它的展开是给定元素的集合</p>
<p>可以使用这个宏来实现<strong>宏输入任意多的参数</strong></p>
<p>著名的<code>printf</code>函数使用了可变参数表，但是可变参数表并不是万能的，它无法使用在宏中，因此一般使用可变参数宏来实现类似的功能</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> __retval;</span><br><span class="line">  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );</span><br><span class="line">  __retval = __mingw_vfprintf( <span class="built_in">stdout</span>, __format, __local_argv );</span><br><span class="line">  __builtin_va_end( __local_argv );</span><br><span class="line">  <span class="keyword">return</span> __retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(...) printf(__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line">DEBUG(<span class="string">&quot;%d&quot;</span>, a);</span><br><span class="line"><span class="comment">//展开成</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a);</span><br></pre></td></tr></table></figure>

<p>其中省略号表示可变的参数表，使用<code>__VA_ARGS__</code>就可以把参数传递给宏</p>
<p>特别地，C++并不支持这一手段</p>
<p>使用该手段可以构造出某些面向对象语言的遍历语句</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> foreach(__c_object, ...) \</span></span><br><span class="line"><span class="meta">for(char** __c_object = (char* []) &#123;__VA_ARGS__, NULL&#125;; *__c_object; __c_object++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用例</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>** str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    foreach(i, <span class="string">&quot;test&quot;</span>, str, <span class="string">&quot;over&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该函数用于遍历并输出test、hello、over三个字符串，就像是python的for一样!</span></span><br></pre></td></tr></table></figure>

<h2 id="指针与数组——C语言的底层"><a href="#指针与数组——C语言的底层" class="headerlink" title="指针与数组——C语言的底层"></a>指针与数组——C语言的底层</h2><h3 id="内存与变量"><a href="#内存与变量" class="headerlink" title="内存与变量"></a>内存与变量</h3><p>C语言提供了三种内存分配方式：</p>
<ul>
<li><p><strong>自动</strong></p>
<p>一般的变量都是自动类型变量，显式或隐式使用auto标注地变量都使用自动内存分配</p>
<p>在变量作用域中分配得内存，离开作用域后变量对应的内存区域被删除</p>
</li>
<li><p><strong>静态</strong></p>
<p>文件作用域内或函数中使用static声明的变量使用静态分配方式</p>
<p>静态程序在整个生命周期内一直存在</p>
<p>特别地，如果忘记对一个静态变量进行初始化，它会默认初始化为0或NULL</p>
</li>
<li><p><strong>手动</strong></p>
<p>使用free或malloc等C库函数进行手动分配内存</p>
<p>如果手动分配内存出问题，很可能导致<strong>段错误</strong></p>
</li>
</ul>
<h3 id="C程序的底层结构"><a href="#C程序的底层结构" class="headerlink" title="C程序的底层结构"></a>C程序的底层结构</h3><p>C程序经过编译后会形成如下几个结构（注意这几个结构都是C生成目标文件的一部分）进行保存：</p>
<ul>
<li><p>堆栈段</p>
<p>用于存储程序中的局部变量<strong>名</strong>，因此占据空间一般比较小（毕竟只是存名字）</p>
</li>
<li><p>BSS段</p>
<p>用于存储程序中的全局变量和静态变量，包括变量名和变量初值</p>
</li>
<li><p>代码段</p>
<p>用于存储程序中的指令，所有C语句都会被编译成汇编指令再进行汇编得到二进制格式的指令，用于驱动CPU运行（突然想到一个特殊的看待文件的视角：操作系统就是CPU的驱动程序，指令被封装在可执行文件里，操作系统负责驱动CPU执行这些文件描述的指令；对于裸机编程并不需要将指令封装成文件，而是根据CPU的架构分装指令和数据（哈佛架构）或将指令和数据送到CPU之内后再进行区分并执行（冯诺依曼架构），也就是说此时CPU并不需要一个特别的驱动程序）</p>
</li>
</ul>
<p>程序被加载进入内存后则会映射出一个类似的空间，任何函数都会在内存中占据空间中的一部分，称为函数帧，函数帧会独立使用上面的结构保存与这个函数有关的所有信息。</p>
<blockquote>
<p>比如下面这个程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> r=<span class="number">114</span>;</span><br><span class="line"><span class="keyword">int</span> q=<span class="number">514</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">double</span> b=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r;i++)</span><br><span class="line">    	&#123;</span><br><span class="line">        	foo();</span><br><span class="line">    	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> k=<span class="number">1919</span>;</span><br><span class="line">    	k++;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;hello!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会在运行时被分成两个函数帧——main和foo进行保存</p>
<p>其中变量q和r会被作为全局变量保存在BSS段，a、b会被保存在main函数对应的堆栈段，i会被保存在for循环专属的堆栈段或程序堆栈段（根据编译器实现而不同），k会被保存在foo函数对应的堆栈段，两个函数中涉及到的操作指令都会保存在代码段</p>
<p>从main跳转到foo的步骤如下：</p>
<ol>
<li>保护现场，将main函数中属于堆栈段的变量（当前保存在寄存器）都压入main函数栈</li>
<li>在执行for循环时根据条件/分支跳转指令确定跳转到foo，PS指向foo所在的代码段地址</li>
<li>将foo中的变量k的值从foo函数栈中弹出，并加载到寄存器</li>
<li>执行foo中的指令，执行完毕后执行保护现场操作</li>
<li>执行恢复现场，继续执行main函数中的指令</li>
</ol>
</blockquote>
<p>在操作系统进行函数跳转时一般会采用分支跳转指令。更底层的实现可以参考计算机组成原理相关教程</p>
<p><strong>堆栈</strong></p>
<p>要注意：堆栈并不是堆+栈，堆栈就是堆栈</p>
<p>堆栈是内存中一块专门的区域，特点是<em>先入后出</em></p>
<p>长度限制比一般内存小得多，专门用于保存自动变量，也用于临时保存寄存器中的值（保护现场）</p>
<p>堆栈段的内存分配一般由硬件/编译器/操作系统内存分配算法等底层处理系统实现</p>
<p><strong>堆</strong></p>
<p>通过手动方式分配的内存都会保存在堆空间，堆的实现根据操作系统或内存分配算法有所不同</p>
<p>堆是内存分配算法在内存中创建的内存池状数据结构</p>
<p>一般来说堆的大小就是可用内存的剩余大小</p>
<h3 id="C语言中的数据内存分配"><a href="#C语言中的数据内存分配" class="headerlink" title="C语言中的数据内存分配"></a>C语言中的数据内存分配</h3><p>C语言中的数据在进行内存分配时往往会遵循以下原则：</p>
<ul>
<li>在函数外部声明或在函数内部使用static关键字声明一个变量，这个变量就是静态变量</li>
<li>在函数内部使用auto或无额外的关键字声明一个变量，这个变量就是动态变量</li>
<li>声明指针也遵循以上两种原则</li>
</ul>
<p>在声明指针时虽然也遵守基本原则——指针会被保存为“指针变量”（一般的实现中，指针和long long或double具有相同的大小，8字节），但是它指向的东西可以是自动、静态、手动三种类型中的任意一种。这就是为什么需要使用malloc函数对指针指向的内容进行分配内存</p>
<p>这就要谈到指针和数组的不同：指针指向的是需要手工分配的内存区域；数组名则指向已经在数组初始化阶段完成自动分配的内存区域。初始化一个数组的实际过程如下：</p>
<ol>
<li>在栈上分配出一个空间，这个空间就等于数组的大小</li>
<li>将数组名初始化为指针</li>
<li>将该指针指向新分配的地址头部</li>
</ol>
<h3 id="状态机和静态变量"><a href="#状态机和静态变量" class="headerlink" title="状态机和静态变量"></a>状态机和静态变量</h3><p>看如下的经典的递归计算斐波那契数列函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//错误输入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> result = Fibonacci(n - <span class="number">2</span>) + Fibonacci(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它可以被用静态变量的方法替代</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> out = a1 + a2;</span><br><span class="line">    </span><br><span class="line">    a1 = a2;</span><br><span class="line">    a2 = out;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就将一个递归函数转化成了一个<strong>状态机</strong></p>
<p>在C语言中实现状态机的关键就在于静态变量，它可以让一个函数内部的参数保持存在，从而达到多次调用、多次计数的效果</p>
<p>甚至在多线程程序中也可以使用<code>_Thread_local</code>关键字来实现单线程的静态变量</p>
<h3 id="指针定向运算"><a href="#指针定向运算" class="headerlink" title="指针定向运算"></a>指针定向运算</h3><p>声明一个数组实际上就是将指针进行了重定向的运算</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> buf[<span class="number">4</span>];</span><br><span class="line">buf[<span class="number">0</span>]=<span class="number">3</span>;</span><br><span class="line">buf[<span class="number">2</span>]=<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以等价于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *buf = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">4</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">*(buf+<span class="number">0</span>)=<span class="number">3</span>;</span><br><span class="line">*(buf+<span class="number">2</span>)=<span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<p>因此可以使用类似的方法实现数据“重定向”</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bit[<span class="number">0</span>]=*(a);</span><br><span class="line">bit[<span class="number">2</span>]=*(a+<span class="number">2</span>);</span><br><span class="line">bit[<span class="number">3</span>]=<span class="number">0x08</span>;</span><br><span class="line">bit[<span class="number">4</span>]=*(b);</span><br><span class="line">bit[<span class="number">6</span>]=*(b+<span class="number">2</span>);</span><br><span class="line">bit[<span class="number">8</span>]=*(b+<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>使用该方式可以提高代码可读性</p>
<p>同时也可以使用这种方法提高算法效率</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* <span class="built_in">list</span>[] = &#123;</span><br><span class="line">    <span class="string">&quot;first&quot;</span>,</span><br><span class="line">    <span class="string">&quot;second&quot;</span>,</span><br><span class="line">    <span class="string">&quot;third&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">char</span>** p = <span class="built_in">list</span>; *p != <span class="literal">NULL</span>; p++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,p[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用上述方法可以对字符串数组进行快速解析</p>
<p>也可以化简多维数组，这个应该算是老生常谈——<strong>数组的数组就是指向指针的指针</strong></p>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p><strong>回调函数指被传递给另一个函数来进行内部使用的函数</strong></p>
<p>一般使用函数指针来实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">callback1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;callback 1\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">callback2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;callback 2\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">callback3</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;callback 3\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Handle</span><span class="params">(<span class="keyword">int</span> (*callback)())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ENTERING HANDLE FUNC\n&quot;</span>);</span><br><span class="line">	callback(); <span class="comment">//在函数内部执行另一个函数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;LEAVING HANDLE FUNC\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;MAINI\n&quot;</span>);</span><br><span class="line">	Handle(callback1); <span class="comment">//传递回调函数</span></span><br><span class="line">	Handle(callback2);</span><br><span class="line">	Handle(callback3);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;MAINL\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数名本身被视作一个指针，它指向函数程序的首地址，因此可以被当作一般的函数进行传递</p>
<p>下面就是指一个无输入，输出int的函数callback</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*callback)(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure>

<p>对应的也可以创造出各种复杂的回调函数，回调函数本质上只会被输入和输出的数据类型所限定，其名字并没有决定性意义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct <span class="title">ReturnClass</span> <span class="params">(*MyLocalFunction)</span><span class="params">(struct PassClass, <span class="keyword">void</span>* parameter, <span class="keyword">uint8_t</span> nums)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">OS_ReturnState</span> <span class="params">(*TaskFunctionHandle)</span><span class="params">(<span class="keyword">void</span>* parameter)</span></span></span><br></pre></td></tr></table></figure>

<p>习惯上将回调函数的名字称为回调函数<strong>句柄</strong>（Handle）</p>
<h3 id="void指针"><a href="#void指针" class="headerlink" title="void指针"></a>void指针</h3><p>void指针可以指向任何东西，而使用void指针指向一个结构体可以让大型程序的编写中的传参和调用更加容易，这也是C面向对象的一个基础</p>
<p>下面的函数是FreeRTOS中的任务函数（线程）的原型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*TaskFunction_t)</span><span class="params">( <span class="keyword">void</span> * )</span></span>;</span><br></pre></td></tr></table></figure>

<p>它输入一个参数，并没有返回值。<em>其中的输入参数可以是任何数据类型</em>，这正是<code>void*</code>的妙用：将任意类型适配到当前函数或数据</p>
<p>使用void指针还可以写出完备的高可移植性数据结构，并且它也是实现C泛型的基础</p>
<h2 id="变量和数据类型——骨干"><a href="#变量和数据类型——骨干" class="headerlink" title="变量和数据类型——骨干"></a>变量和数据类型——骨干</h2><p>C变量与数据类型完全基于面向过程思想，也正因此C语言可以通过指针对内存进行操作，或是基于顺序存储的数组、结构体、指针等构建出顺序表、链表等数据结构，甚至构建出面向对象的“类”。因为C变量面向过程的性质，导致它们在使用中存在很多误区或不被注意的问题，这里简单梳理一下C变量的常见问题和基于基本数据类型实现的数据结构</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>类型转换常常会导致一些隐蔽的错误，尤其是在缺少编译器自动纠错辅助的情况下（某些逆大天的嵌入式编程IDE就是这样），下面列举一些常常会导致出错的问题和对应的解决方案</p>
<ol>
<li><p>两个整数相除总是返回整数</p>
<p>可以使用“加0”的方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span>/<span class="number">3</span> == <span class="number">2</span>;</span><br><span class="line"><span class="number">4</span>/(<span class="number">3</span>+<span class="number">0.0</span>) == <span class="number">1.3333</span>;</span><br><span class="line"><span class="number">4</span>/<span class="number">3.</span> == <span class="number">1.3333</span>;</span><br></pre></td></tr></table></figure>

<p>或直接显式进行类型转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span>/(<span class="keyword">double</span>)<span class="number">3</span> == <span class="number">1.3333</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>数组的索引必须是整数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>];</span><br><span class="line">a[<span class="number">3.3</span>]; <span class="comment">//错误</span></span><br><span class="line">a[(<span class="keyword">int</span>)<span class="number">3.3</span>] == a[<span class="number">3</span>]; <span class="comment">//避免错误</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="复合常量"><a href="#复合常量" class="headerlink" title="复合常量"></a>复合常量</h3><p>C99标准引入了符合常量</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> double_value = <span class="number">3.7</span>;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">double</span>[]) &#123;</span><br><span class="line">    <span class="number">20.38</span>,</span><br><span class="line">    double_value,</span><br><span class="line">	<span class="number">9.6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是一个典型例子，复合常量就是包含了同类型已赋值变量的常量，它会自动分配内存，<strong>常用来绕过临时变量</strong></p>
<h3 id="指定初始化器"><a href="#指定初始化器" class="headerlink" title="指定初始化器"></a>指定初始化器</h3><p>指定初始化器是C99引入的新特性，可以像以下方式初始化一个结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">gpio</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">uint8_t</span> direction;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">uint8_t</span> pin;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">uint8_t</span> special;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">uint8_t</span> value;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">uint8_t</span> speed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">gpio</span> <span class="title">GPIO_InitStruct</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GPIO_InitStruct MyGPIO;</span><br><span class="line">    MyGPIO = &#123;</span><br><span class="line">        .direction = OUTPUT;</span><br><span class="line">        .pin = <span class="number">5</span>;</span><br><span class="line">        .special = PullUp;</span><br><span class="line">        .value = GPIO_Pin_HIGH;</span><br><span class="line">        .speed = GPIO_Speed_100MHz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比于</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MyGPIO = &#123;OUTPUT, <span class="number">5</span>, PullUp, GPIO_Pin_HIGH, GPIO_Speed_100MHz&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">MyGPIO.direction = OUTPUT;</span><br><span class="line">......</span><br><span class="line">MyGPIO.speed = GPIO_Speed_100MHz;</span><br></pre></td></tr></table></figure>

<p>这种方法可以有效减少劳动量——因为大多数IDE都集成了这种初始化器的代码提示功能，可以只打出一个<code>.</code>，再从待选列表中选出要赋值的量</p>
<h3 id="C面向对象"><a href="#C面向对象" class="headerlink" title="C面向对象"></a>C面向对象</h3><p>在说明C面向对象编程方法之前需要强调几点：</p>
<ul>
<li>typedef是面向对象编程中用于减少代码书写量的重要工具</li>
<li>C使用结构体和回调函数来实现多种功能</li>
<li>不要害怕阅读很长的数据类型</li>
<li><strong>在使用面向对象编写C之前，应该想想你的需求能否用面向过程的方式解决，再想想使用面向对象后获得的开发思路、可移植性提升比起效率损失而言是否值得，如果感觉有些问题，尽早放弃使用面向对象编写C程序的想法</strong></li>
</ul>
<p>C语言的一般库格式如下：</p>
<ul>
<li>一组数据结构，用于代表库所针对领域的关键概念，并对库针对的问题进行代码结构上的描述</li>
<li>一组函数，用于处理数据结构</li>
</ul>
<p>这也就是经典的数据结构+算法</p>
<p>但是面向对象的语言则不这样处理，它们通常：</p>
<ul>
<li>定义一个或多个类，用于描述问题本身</li>
<li>定义这些类的方法，用于处理问题并建立问题之间的联系</li>
</ul>
<p>同时OOP语言（比如C++）还会进行以下扩展来方便用户进行各种处理：</p>
<ul>
<li>继承：用于扩展已有的类结构</li>
<li>虚函数：规定了一个类中所有对象都默认，但对不同对象的实例都有所限制的行为</li>
<li>私有和公有：用于划分类与方法要处理的范围</li>
<li>运算符重载：让一个运算符能够处理不同但有所类似的数据类型/对象</li>
<li>引用计数：用于自动化地分配和回收内存空间</li>
</ul>
<p>下面将从几个不同的方面阐述C语言实现面向对象编程机制的方法</p>
<h3 id="C实现的类"><a href="#C实现的类" class="headerlink" title="C实现的类"></a>C实现的类</h3><p>先从计算机的底层讲起吧——说起来，计算机的底层是哪里？汇编？CPU？逻辑门？晶体管？答案是数学！</p>
<p>图灵机和lambda代数是等价的两种描述计算机原理的模型</p>
<p>图灵机描述了一个可以在纸带上到处移动并修改其中值的读写头模型；lambda代数则描述了一个使用描述来处理参数列表的表达式</p>
<p>这两者分别就是面向过程和面向对象思想的数学原理</p>
<p>c语言使用下面的结构体来描述一个人的信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">bool</span> sex;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">double</span> height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并使用下面的函数来输出一个人的名字</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">output_name</span><span class="params">(struct person)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> person.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些信息被放在内存中，按顺序保存，当函数执行到的时候，CPU寻址到对应的位置，从对应的位置读取数据并输出</p>
<p>而面向对象语言中，使用类似字典（键值对）的方式保存人的数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">person = &#123;<span class="string">&quot;name&quot;</span>:<span class="number">10</span>, <span class="string">&quot;sex&quot;</span>:<span class="string">&quot;?&quot;</span>, <span class="string">&quot;age&quot;</span>:<span class="number">18</span>, <span class="string">&quot;height&quot;</span>:<span class="number">1.7</span>&#125;</span><br></pre></td></tr></table></figure>

<p>更进一步，将其封装成一个<strong>类</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;描述人属性的类&quot;&quot;&quot;</span></span><br><span class="line">    person_number = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, sex, age, height</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.sex = sex</span><br><span class="line">        self.age = age</span><br><span class="line">        self.height = height</span><br><span class="line">   	 	person_number += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">displayName</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self.name)</span><br></pre></td></tr></table></figure>

<p>调用时只需要按照<code>初始化一个对象-对象.方法</code>就可以对数据进行处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Person a_person</span><br><span class="line">a_person.displayName()</span><br></pre></td></tr></table></figure>

<p>C++、Java这些OOP语言都可以快速扩展现有类型，但是处理速度一般没有C快；同样Python更加直接的扩展命名列表思路只需要向其添加成员，就可以扩展当前数据类型，然而很难得到注册功能来检查代码正确性——有得必有失。然而在很多情况下需要我们实现既快速又便于扩展的代码，尤其是在嵌入式设备上，这时候就需要使用到<strong>C面向对象</strong>编程思想了</p>
<p>面向对象基于类；类是结构体的延伸；C面向对象基于结构体</p>
<p>最简单的，使用结构体就可以实现基于C的字典（基于键值对）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">key_value</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* key;</span><br><span class="line">    <span class="keyword">void</span>* value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">key_value</span> <span class="title">key_value</span>;</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">dictionary</span>&#123;</span></span><br><span class="line">    key_value **pairs;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">dictionary</span> <span class="title">dictionary</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> dictionary* Dictionary;</span><br></pre></td></tr></table></figure>

<p>然而附加问题出现了：</p>
<p>这个字典基于C指针实现；C指针需要使用malloc、free来管理内存；字典管理内存会具有很大不便</p>
<p>对于一般的应用实现来说，开发者手动分配内存并将其封装在大的函数里就足够了，但是总有一些特殊的时候（比如操作系统编写）用户会需要使用到大量的字典操作，因此就应该创造“虚函数”用来管理内存</p>
<p>为了安全起见，也应该设置找不到字典的标志来防止溢出/过放问题</p>
<p>最后应该实现添加和遍历字典的方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span>* dictionary_not_found;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 新建键值对 */</span></span><br><span class="line"><span class="function">key_value* <span class="title">new_key_val</span><span class="params">(<span class="keyword">char</span>* key, <span class="keyword">void</span>* value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    key_value* out = (key_value*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(key_value));</span><br><span class="line">    *out = (key_val)&#123;.key = key, .value = value&#125;;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 复制键值对 */</span></span><br><span class="line"><span class="function">key_value* <span class="title">copy_key_val</span><span class="params">(key_value <span class="keyword">const</span>* in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    key_value* out = (key_value*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(key_value));</span><br><span class="line">    *out = *in;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除键值对 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_key_val</span><span class="params">(key_value* in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(in);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断当前键值对的键值是否和给出的键值对应 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match_key_val</span><span class="params">(key_value <span class="keyword">const</span>* in, <span class="keyword">char</span> <span class="keyword">const</span>* key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !(strcasecmp(in-&gt;key, key));    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 为字典添加键值对 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Dictionary_add_key_val</span><span class="params">(Dictionary in,<span class="keyword">char</span>* key, <span class="keyword">void</span>* value key_value kv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    in-&gt;length ++;</span><br><span class="line">    in-&gt;pairs = (key_value *)<span class="built_in">realloc</span>(in-&gt;pairs, <span class="keyword">sizeof</span>(key_value*) * (in-&gt;length));</span><br><span class="line">    in-&gt;pairs[(in-&gt;length) - <span class="number">1</span>] = kv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 新建字典 */</span></span><br><span class="line"><span class="function">Dictionary <span class="title">newDictionary</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> dnf;</span><br><span class="line">    <span class="keyword">if</span>(!dictionary_not_found)</span><br><span class="line">        dictionary_not_found = &amp;dnf; <span class="comment">//处理找不到字典的情况</span></span><br><span class="line">    Dictionary out = (Dictionary)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(dictionary));</span><br><span class="line">    *out = (dictionary)&#123; &#125;;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteDictionary</span><span class="params">(Dictionary in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        deleteDictionary(in-&gt;pairs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(in);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加新键值对到字典 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addDictionary</span><span class="params">(Dictionary in,<span class="keyword">char</span>* key, <span class="keyword">void</span>* value key_value kv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;NULL is no a valid key.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Dictionary_add_key_value(in, new_key_val(key,value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在字典中找到某个键值对，根据健输出对应值 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">findDictionary</span><span class="params">(<span class="keyword">const</span> Dictionary in, <span class="keyword">char</span> <span class="keyword">const</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">if</span>(match_key_val(in-&gt;pairs[i], key))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> in-&gt;pairs[i]-&gt;value; <span class="comment">//遍历字典并找到键值对的值输出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dictionary_not_found; <span class="comment">//未找到字典</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 复制字典 */</span></span><br><span class="line"><span class="function">Dictionary <span class="title">copyDictionary</span><span class="params">(Dictionary in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Dictionary out = newDictionary();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; in-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Dictionary_add_key_val(out, copy_key_val(in-&gt;pais[i]));</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似这样就可以编写一个C实现的“宏”及其实现操作的“方法”了。</p>
<p>但是这种实现方式仅仅是对C结构体的进一步封装，就连C Primer Plus都把这种操作摆在书里（就在最后一章）</p>
<p>最关键的，如何实现继承？</p>
<p>老版本的C使用非常复杂的结构传递机制实现，而C11给出了更简单的答案：<strong>匿名结构体成员</strong></p>
<p>C11允许在结构中包含匿名的成员，gcc和clang通过*-fms-extensions<em>的命令行选项来使用<strong>强模式</strong>：新结构声明中的某处包含另一个结构；如果不使用这个选项，编译器会自动使用<strong>弱模式</strong>，它不允许开发者使用匿名的结构标识符来引用之前定义过的结构，二是要求结构必须在本地定义。这段话很明显不是地球人能说的，所以*<em>直接看例子</em></em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 强模式 */</span></span><br><span class="line"><span class="comment">//可以无缝地实现继承</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">Point</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">three_point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Point; <span class="comment">//匿名的结构体</span></span><br><span class="line">    <span class="keyword">double</span> z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">three_point</span> <span class="title">ThreePoint</span>;</span></span><br><span class="line"><span class="comment">//以上程序将二维的点扩展为三维点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用时和一般的结构体一致</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo_1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreePoint p =&#123;</span><br><span class="line">        .x = <span class="number">1</span>;</span><br><span class="line">        .y = <span class="number">2</span>;</span><br><span class="line">        .z = <span class="number">3</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (p.x)*(p.y)*(p.z));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 弱模式 */</span></span><br><span class="line"><span class="comment">//要求结构在本地定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">double</span> x;</span><br><span class="line">            <span class="keyword">double</span> y;</span><br><span class="line">        &#125;; <span class="comment">//在本地定义的匿名结构体</span></span><br><span class="line">        Point p2; <span class="comment">//上面的匿名结构体就记作p2</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">double</span> z;</span><br><span class="line">&#125; ThreePoint;</span><br></pre></td></tr></table></figure>

<p>弱模式的处理方式不太好易用，所以一般都会使用强模式实现继承</p>
<p>但是一般在处理老旧代码的时候需要整体搬运结构体，这种情况下为了避免“牵一发而动全身”的情况，应保证使用弱模式——因为<strong>远古编译器并不支持强模式</strong></p>
<p>对于一个典型的C<strong>对象句柄</strong>，更适合使用指针而不是基本的结构体。</p>
<p>使用指针能带来以下好处：</p>
<ul>
<li>指针本身的内存空间会被自动管理，它指向的对象可以使用统一的malloc函数来动态管理内存或使用静态数据变量在程序执行之初进行内存初始化</li>
<li>使用<code>=</code>即可完成指针指向对象的复制</li>
<li>操作指针比直接操作完整的结构体更节省时间</li>
<li>表、栈、FIFO、树、图等数据结构都可以通过指针快速构建和管理</li>
<li>永远使用结构指针就不会对使用结构参数-指针参数二者之间造成困扰</li>
<li>使用专用的free函数和malloc函数操作指针可以更安全地处理对象内存</li>
</ul>
<p>对于越庞大的系统，越适合使用指针实现，特别是编译器、操作系统等不得不用C语言完成的东西</p>
<h3 id="C实现的方法"><a href="#C实现的方法" class="headerlink" title="C实现的方法"></a>C实现的方法</h3><p>C面向对象中，使用<strong>回调函数</strong>实现<strong>方法</strong>，回调函数则基于<strong>函数指针</strong></p>
<p>下面是一个包含了方法的C类</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">myclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> name;</span><br><span class="line">    <span class="keyword">double</span> num;</span><br><span class="line">    <span class="keyword">double</span> (*calculateMyClass) (<span class="keyword">int</span> <span class="keyword">const</span> *in);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> _myclass MyClass;</span><br></pre></td></tr></table></figure>

<p>需要注意：在本博文的代码中采用类Qt的方法命名法（或者说比较通用的C++方法命名法），即<code>小写动词+驼峰类名</code>的形式</p>
<p>这种方法的特色就是“简明易懂”，便于写出自解释的代码；不过相较于<code>类名+动词</code>的命名法，它更难以进行检索，哪种方法好就见仁见智吧</p>
<p><code>calculateMyClass</code>就是一个典型的函数指针，初始化时可以通过以下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> <span class="keyword">const</span> *in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4.7</span> * in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass a;</span><br><span class="line"></span><br><span class="line">a.name = <span class="number">3</span>;</span><br><span class="line">a.num = <span class="number">5.5</span>;</span><br><span class="line">a.calculateMyClass = cal;</span><br></pre></td></tr></table></figure>

<p>下面的代码演示了之前所说键值对类对应的方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">key_value</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* key;</span><br><span class="line">    <span class="keyword">void</span>* value; <span class="comment">//这两个都是原有的私有变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//新增的方法</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">key_value</span> * (*<span class="title">copy_key_val</span>) (<span class="title">key_value</span> <span class="title">const</span>* <span class="title">in</span>);</span></span><br><span class="line">    <span class="keyword">void</span> (*free_key_val) (key_value* in);</span><br><span class="line">    <span class="keyword">int</span> (*match_key_val) (key_value <span class="keyword">const</span>* in, <span class="keyword">char</span> <span class="keyword">const</span>* key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">key_value</span> <span class="title">key_value</span>;</span></span><br><span class="line"><span class="function">key_value* <span class="title">new_key_val</span><span class="params">(<span class="keyword">char</span>* key, <span class="keyword">void</span>* value)</span></span>;</span><br></pre></td></tr></table></figure>

<p>能够注意到：new_key_val并没有作为一个方法实现，因为它用于创建一个键值对对象，需要被用户直接调用，这就涉及到了私有变量和公有变量——这些按下不表，急不可耐的读者可以直接跳到下一节</p>
<p>众所周知，C++有个this，Python有个self，这两个变量都可以很方便地定义出函数的默认值；然而C并不提供这些，如果你见到了C22或者C114514里提供了这些东西，请大声呵斥（笑）</p>
<p>不过C提供了更加高级的实现——预编译器</p>
<p>使用预编译器可以像以下代码一样写出代替this的功能</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Typelist_print(in) (in).estimate(&amp;in)</span></span><br></pre></td></tr></table></figure>

<p>这段代码实现了打印一个默认值（in本身）的效果</p>
<h3 id="private和public"><a href="#private和public" class="headerlink" title="private和public"></a>private和public</h3><p>从作用域说起，C语言中只有三条关于变量作用域的准则：</p>
<ul>
<li><p>变量在未被声明前不在作用域内</p>
</li>
<li><p>如果变量在一对花括号内定义，那么结束花括号（<code>&#125;</code>之后），变量就会处于作用域之外</p>
<p>有一个特例：for循环和函数可以有变量定义在开始的花括号前的一对括弧内——在一对括弧内定义的变量，其作用域等同于在花括号内定义</p>
</li>
<li><p>如果一个变量不在任何花括号内，它的作用域就会从它的声明持续到文件结尾</p>
</li>
</ul>
<p>确实，C语言的作用域限制少得可怜——友元、类作用域、原型作用域、动态作用域、扩展作用域、命名空间……全都没有；或许可以强行称使用malloc的作用域为动态作用域</p>
<p>特别需要说明一下#include包含文件的变量作用域——它们也遵循以上三条规则，<strong>在包含头文件时，就相当于将整个头文件复制粘贴到了 源文件里</strong></p>
<p>在OOP中，<strong>私有数据</strong>表示不应被外界直接调用的数据，函数可以通过直接在.c文件内声明、定义，而不是挂在头文件中实现私有——上面所说的<strong>私有方法</strong>也类似，直接把函数指针封在结构体中就可以实现私有方法；如果想要更严格的限制，还可以在函数前使用static关键字；全局变量同理。不过有得必有失，<strong>局部变量</strong>想要实现<strong>私有</strong>的话，就只能在命名上加上<code>_private</code>后缀并祈求你的用户不会瞎用这个变量吧</p>
<h3 id="有限的运算符重载"><a href="#有限的运算符重载" class="headerlink" title="有限的运算符重载"></a>有限的运算符重载</h3><p>虽然说很难用，但C11标准确实提供了一套使用<strong>宏</strong>来处理运算符重载的机制</p>
<p>个人不是很推荐对C语言进行这样的修改——很明显，这完全不是C所擅长的领域！到目前为止也很少有代码使用C11的**_Generic**，就连Linux内核中也没有出现多少这样的语句</p>
<p>这个预编译语句用法比较复杂，但是GLibC中的很多运算符（复数乘法、矩阵乘法）都通过这个语句进行重载，详细内容可以查看官方文档和库的使用说明，这里处于<em>个人能力所限</em>和篇幅所限不再介绍</p>
<h3 id="C面向对象举例"><a href="#C面向对象举例" class="headerlink" title="C面向对象举例"></a>C面向对象举例</h3><p>这里引用RT-Thread实时操作系统的源码作为例子，这是一个使用了典型的C面向对象编写的大型程序</p>
<p>下面摘录的是其内核实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 内核对象接口</span></span><br><span class="line"><span class="comment"> * 这部分方法用于处理内核对象</span></span><br><span class="line"><span class="comment"> * 所谓内核对象就是RT-Thread抽象出的内核组成部分</span></span><br><span class="line"><span class="comment"> * 包括但不限于 线程（进程）结构、信号量、互斥量、消息队列、驱动设备等</span></span><br><span class="line"><span class="comment"> * 这些对象都为上层应用程序提供服务，并且它们都是从内核对象类衍生而来</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_system_object_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function">struct rt_object_information *</span></span><br><span class="line"><span class="function"><span class="title">rt_object_get_information</span><span class="params">(<span class="keyword">enum</span> rt_object_class_type type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_object_init</span><span class="params">(struct rt_object         *object,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">enum</span> rt_object_class_type type,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">const</span> <span class="keyword">char</span>               *name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_object_detach</span><span class="params">(<span class="keyword">rt_object_t</span> object)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">rt_object_t</span> <span class="title">rt_object_allocate</span><span class="params">(<span class="keyword">enum</span> rt_object_class_type type,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">const</span> <span class="keyword">char</span>               *name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_object_delete</span><span class="params">(<span class="keyword">rt_object_t</span> object)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">rt_bool_t</span> <span class="title">rt_object_is_systemobject</span><span class="params">(<span class="keyword">rt_object_t</span> object)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">rt_uint8_t</span> <span class="title">rt_object_get_type</span><span class="params">(<span class="keyword">rt_object_t</span> object)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">rt_object_t</span> <span class="title">rt_object_find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">rt_uint8_t</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相关的方法内容出于篇幅不再列出，如有兴趣可以自行翻阅官方文档</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内核对象结构体</span></span><br><span class="line"><span class="comment"> * 它继承自一个称为内核对象链表的类，内核对象使用这个链表来进行连接</span></span><br><span class="line"><span class="comment"> * 这样遍历内核对象并进行操作就等价于对链表进行遍历</span></span><br><span class="line"><span class="comment"> * 实际上RT-Thread使用的是一种效率更高的跳表，它可以在多个链表（数量可编程）之间跳转</span></span><br><span class="line"><span class="comment"> * 这样做大大提高了操作系统的效率</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>       name[RT_NAME_MAX];                       <span class="comment">/**&lt; name of kernel object */</span></span><br><span class="line">    <span class="keyword">rt_uint8_t</span> type;                                    <span class="comment">/**&lt; type of kernel object */</span></span><br><span class="line">    <span class="keyword">rt_uint8_t</span> flag;                                    <span class="comment">/**&lt; flag of kernel object */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MODULE</span></span><br><span class="line">    <span class="keyword">void</span>      *module_id;                               <span class="comment">/**&lt; id of application module */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">rt_list_t</span>  <span class="built_in">list</span>;                                    <span class="comment">/**&lt; list node of kernel object */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内核对象类</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_object</span> *<span class="title">rt_object_t</span>;</span>                  <span class="comment">/**&lt; Type for kernel objects. */</span></span><br><span class="line"><span class="comment">//可以看到RT-Thread将内核对象结构体指针定义为了一个类，这样便于发挥指针的优势</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内核对象链表类</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双链表结构体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_list_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_list_node</span> *<span class="title">next</span>;</span>                          <span class="comment">/**&lt; point to next node. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_list_node</span> *<span class="title">prev</span>;</span>                          <span class="comment">/**&lt; point to prev node. */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_list_node</span> <span class="title">rt_list_t</span>;</span>                  <span class="comment">/**&lt; Type for lists. */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单链表结构体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_slist_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_slist_node</span> *<span class="title">next</span>;</span>                         <span class="comment">/**&lt; point to next node. */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_slist_node</span> <span class="title">rt_slist_t</span>;</span>                <span class="comment">/**&lt; Type for single list. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//RT-Thread使用枚举对内核对象类型进行标记，这是一种常用的做法，用来提高程序可读性</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">rt_object_class_type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    RT_Object_Class_Null   = <span class="number">0</span>,                         <span class="comment">/**&lt; The object is not used. */</span></span><br><span class="line">    RT_Object_Class_Thread,                             <span class="comment">/**&lt; The object is a thread. */</span></span><br><span class="line">    RT_Object_Class_Semaphore,                          <span class="comment">/**&lt; The object is a semaphore. */</span></span><br><span class="line">    RT_Object_Class_Mutex,                              <span class="comment">/**&lt; The object is a mutex. */</span></span><br><span class="line">    RT_Object_Class_Event,                              <span class="comment">/**&lt; The object is a event. */</span></span><br><span class="line">    RT_Object_Class_MailBox,                            <span class="comment">/**&lt; The object is a mail box. */</span></span><br><span class="line">    RT_Object_Class_MessageQueue,                       <span class="comment">/**&lt; The object is a message queue. */</span></span><br><span class="line">    RT_Object_Class_MemHeap,                            <span class="comment">/**&lt; The object is a memory heap */</span></span><br><span class="line">    RT_Object_Class_MemPool,                            <span class="comment">/**&lt; The object is a memory pool. */</span></span><br><span class="line">    RT_Object_Class_Device,                             <span class="comment">/**&lt; The object is a device */</span></span><br><span class="line">    RT_Object_Class_Timer,                              <span class="comment">/**&lt; The object is a timer. */</span></span><br><span class="line">    RT_Object_Class_Module,                             <span class="comment">/**&lt; The object is a module. */</span></span><br><span class="line">    RT_Object_Class_Unknown,                            <span class="comment">/**&lt; The object is unknown. */</span></span><br><span class="line">    RT_Object_Class_Static = <span class="number">0x80</span>                       <span class="comment">/**&lt; The object is a static object. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 软件定时器类</span></span><br><span class="line"><span class="comment"> * 从内核对象类中继承而来，用于处理线程调度中的时间片轮转</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_timer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_object</span> <span class="title">parent</span>;</span>                            <span class="comment">/**&lt; inherit from rt_object */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_list_t</span>        row[RT_TIMER_SKIP_LIST_LEVEL];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*timeout_func)(<span class="keyword">void</span> *parameter);              <span class="comment">/**&lt; timeout function */</span>  <span class="comment">//这是一个典型的方法</span></span><br><span class="line">    <span class="keyword">void</span>            *parameter;                         <span class="comment">/**&lt; timeout function&#x27;s parameter */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_tick_t</span>        init_tick;                         <span class="comment">/**&lt; timer timeout tick */</span></span><br><span class="line">    <span class="keyword">rt_tick_t</span>        timeout_tick;                      <span class="comment">/**&lt; timeout tick */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_timer</span> *<span class="title">rt_timer_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于处理内核对象初始化的方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param object the specified object to be initialized.</span></span><br><span class="line"><span class="comment"> * @param type the object type.</span></span><br><span class="line"><span class="comment"> * @param name the object name. In system, the object&#x27;s name must be unique.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_object_init</span><span class="params">(struct rt_object         *object,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">enum</span> rt_object_class_type type,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">const</span> <span class="keyword">char</span>               *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> temp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_list_node</span> *<span class="title">node</span> =</span> RT_NULL;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_object_information</span> *<span class="title">information</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MODULE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_dlmodule</span> *<span class="title">module</span> =</span> dlmodule_self();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get object information */</span></span><br><span class="line">    information = rt_object_get_information(type);</span><br><span class="line">    RT_ASSERT(information != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check object type to avoid re-initialization */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enter critical */</span></span><br><span class="line">    rt_enter_critical();</span><br><span class="line">    <span class="comment">/* try to find object */</span></span><br><span class="line">    <span class="keyword">for</span> (node  = information-&gt;object_list.next;</span><br><span class="line">            node != &amp;(information-&gt;object_list);</span><br><span class="line">            node  = node-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rt_object</span> *<span class="title">obj</span>;</span></span><br><span class="line"></span><br><span class="line">        obj = rt_list_entry(node, struct rt_object, <span class="built_in">list</span>);</span><br><span class="line">        <span class="keyword">if</span> (obj) <span class="comment">/* skip warning when disable debug */</span></span><br><span class="line">        &#123;</span><br><span class="line">            RT_ASSERT(obj != object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* leave critical */</span></span><br><span class="line">    rt_exit_critical();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize object&#x27;s parameters */</span></span><br><span class="line">    <span class="comment">/* set object type to static */</span></span><br><span class="line">    object-&gt;type = type | RT_Object_Class_Static;</span><br><span class="line">    <span class="comment">/* copy name */</span></span><br><span class="line">    rt_strncpy(object-&gt;name, name, RT_NAME_MAX);</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_object_attach_hook, (object));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* lock interrupt */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MODULE</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">module</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rt_list_insert_after(&amp;(<span class="keyword">module</span>-&gt;object_list), &amp;(object-&gt;<span class="built_in">list</span>));</span><br><span class="line">        object-&gt;module_id = (<span class="keyword">void</span> *)<span class="keyword">module</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* insert object into information object list */</span></span><br><span class="line">        rt_list_insert_after(&amp;(information-&gt;object_list), &amp;(object-&gt;<span class="built_in">list</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlock interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的这个方法非常典型，它用于完备地初始化一个内核对象，规定它的内存空间占用</span></span><br><span class="line"><span class="comment">//将一个内核对象作为参数传入即可完成初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//能够注意到所有操作到类，并且能够被用户使用的方法都并没有作为一个“私有的”方法放置在结构体内，而是直接放在头文件中</span></span><br><span class="line"><span class="comment">//这就是上文所说通过变量作用域控制私有/公有变量的操作</span></span><br></pre></td></tr></table></figure>

<h3 id="一些经常被遗忘但在嵌入式编程中仍有作用的关键字"><a href="#一些经常被遗忘但在嵌入式编程中仍有作用的关键字" class="headerlink" title="一些经常被遗忘但在嵌入式编程中仍有作用的关键字"></a>一些经常被遗忘但在嵌入式编程中仍有作用的关键字</h3><ul>
<li><p>volatile</p>
<blockquote>
<p>一个定义为volatile的变量是说这变量可能随时会被改变，这样编译器就不会去假设这个变量的值——优化器在用到这个变量时必须每次都会重新读取这个变量的值，而不是使用保存在寄存器里的备份</p>
</blockquote>
<p>这个关键字常被用于下面的场合：</p>
<ul>
<li><p>并行设备的硬件寄存器</p>
<p>说人话就是<strong>MCU的外设控制寄存器地址需要用volatile指明</strong></p>
</li>
<li><p>一个中断服务子程序中会访问到的非自动变量</p>
<p>这个就很明显了，<strong>用于指示中断的全局变量</strong></p>
</li>
<li><p>多线程应用中被几个任务共享的变量</p>
<p>这种情况一般会在SMP设备或多核的高性能嵌入式设备中出现，<strong>多核执行任务中一定将全局变量设为volatile</strong>，否则可能导致跑飞。如果有双核并行化需求且对效率没有极致的需求，尽量使用RTOS甚至嵌入式Linux，并在分配任务的时候尽量使用RTOS自带的信号量或消息队列可以减少出现问题的可能性</p>
</li>
</ul>
<p>事实上volatile应该解释为“<em>直接存取原始内存地址</em>”，正因如此，<strong>volatile是可以和const一起使用的</strong>，这表示对于某个只读变量始终直接存取原始内存地址</p>
<p>下面给一个网上随处可见的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面的函数有什么错误?</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *ptr * *ptr;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>这段代码的目的是用来返回指针ptr指向值的平方，但由于ptr指向一个volatile型参数，这个参数的值随时可能变化，编译器可能会将其优化为以下代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a,b;</span><br><span class="line">	a = *ptr;</span><br><span class="line">	b = *ptr;</span><br><span class="line">	<span class="keyword">return</span> a * b;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>实际上编译器生成的是汇编指令，a、b并不影响存取变量，但是会消耗额外的内存空间、让CPU执行不必要的取址甚至分支跳转指令，并且如果外界因素导致ptr指向的变量变化，就会实实在在地影响函数的返回值——会从理论上的a*a变成a*b</p>
<p>正确的代码应该像下面这样</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	a = *ptr;</span><br><span class="line">	<span class="keyword">return</span> a * a;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>使用一个普通变量a来暂存ptr指向的值，虽然这样看似浪费了内存，但是和上面那段代码的内存占用实际上是一样的，并且能够避免出错</p>
</li>
<li><p>extern</p>
<p>在c语言中最不被重视但确实是最重要的关键字</p>
<p>用于<strong>在头文件中声明已在对应.c库文件中定义过的变量</strong></p>
<p>也常用于<strong>在多任务文件中定义main文件中的全局变量</strong></p>
<p>没有这个关键字，编译器必报错，一改就是半天</p>
</li>
<li><p>static</p>
<p>static在不同作用域中有不同的含义</p>
<ul>
<li><p>全局变量static</p>
<p>用于指示这个全局变量只在单文件中起作用，可以用于在.c文件中声明常量来提高文件的可移植性</p>
</li>
<li><p>局部变量static</p>
<p>用于指示静态局部变量，这个学过C语言的人应该都比较熟悉了</p>
<p>最常见的用法是在MCU的按键扫描函数中使用，如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">KEY_Scan</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;	 </span><br><span class="line">	<span class="keyword">static</span> u8 key_up=<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(mode)</span><br><span class="line">        key_up=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(key_up &amp;&amp; ( KEY0==<span class="number">1</span> || WK_UP==<span class="number">1</span> ))</span><br><span class="line">	&#123;</span><br><span class="line">		delay_ms(<span class="number">10</span>); <span class="comment">//软件消抖</span></span><br><span class="line">		key_up=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(KEY0==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> KEY0_PRES;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(WK_UP==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> WKUP_PRES;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(KEY0==<span class="number">0</span> &amp;&amp; WK_UP==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		key_up=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>函数static</p>
<p>用于声明某个函数是本文件内有效的函数</p>
<p>同样用于在.c文件中声明常量来提高文件的可移植性</p>
<p>一般来说会在.h文件中再写一条extern static标明的函数</p>
<p><strong>static函数在内存中只有一份，普通函数会在每次调用中生成一份拷贝</strong></p>
</li>
</ul>
</li>
<li><p>register</p>
<p>这个关键字确实很少使用，但是一旦用上就十有八九是需要硬优化算法的地方，如果实在需要使用这种方法优化，可以使用内联汇编来进行替代，不仅可以稳定”寄存器命中“，还可以更好地强调代码的执行速度优先</p>
</li>
</ul>
<h2 id="库函数与轮子——顶层"><a href="#库函数与轮子——顶层" class="headerlink" title="库函数与轮子——顶层"></a>库函数与轮子——顶层</h2><p>C库函数可以说是编写C程序的重中之重，从基本的stdio到高级的glibc，这些库中的函数都由大师编写，高效、简洁，而一般的开发者至少要学会使用这些库函数和基于C实现的轮子，它们除了在C程序中发挥作用，还能借助辅助工具和其他语言实现共同编译运行以提升其他语言代码的效率</p>
<h3 id="使用C库函数进行字符串处理"><a href="#使用C库函数进行字符串处理" class="headerlink" title="使用C库函数进行字符串处理"></a>使用C库函数进行字符串处理</h3><ol>
<li><p>将字符串转换为数字</p>
<p>最基本的方法是使用<code>atoi</code>和<code>atof</code></p>
<p>使用方法如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a = <span class="string">&quot;42&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> x = atoi(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> million[] = <span class="string">&quot;1e6&quot;</span>;</span><br><span class="line"><span class="keyword">double</span> m = atof(million);</span><br></pre></td></tr></table></figure>

<p>更安全一点的库函数如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = strtod(<span class="keyword">char</span> <span class="built_in">string</span>[],<span class="keyword">char</span> *p);</span><br><span class="line"><span class="comment">//里面的指针p会被指向第一个不能被解析成数字的字母</span></span><br></pre></td></tr></table></figure></li>
<li><p>asprintf函数</p>
<p>该函数需要使用支持GNU或BSD标准库的系统，但也可以使用vsnprintf函数快速实现asprintf函数</p>
<p>该函数可以让字符串处理更方便</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 一般的字符串处理方法 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_strings</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* cmd;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(<span class="string">&quot;strings &quot;</span>) + <span class="built_in">strlen</span>(in) + <span class="number">1</span>;</span><br><span class="line">    cmd = <span class="built_in">malloc</span>(len);</span><br><span class="line">    <span class="built_in">snprintf</span>(cmd, len, <span class="string">&quot;strings %s&quot;</span>, in);</span><br><span class="line">    <span class="keyword">if</span>(system(cmd))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;something went wrong running %s.\n&quot;</span>, cmd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用asprintf的字符串处理方法 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_strings</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* cmd;</span><br><span class="line">    asprintf(&amp;cmd, <span class="string">&quot;strings %s&quot;</span>, in);</span><br><span class="line">    <span class="keyword">if</span>(system(cmd))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;something went wrong running %s.\n&quot;</span>, cmd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    get_strings(argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>asprintf和sprintf很相似，但是它需要传入的是字符串在内存中的位置而不是字符串本身，因为这个函数会为字符串分配新的空间</p>
<p>可以通过运行两次vsnprintf来实现asprintf</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ASPRINTF_EX_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __ASPRINTF_EX_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">asprintf</span><span class="params">(<span class="keyword">char</span> **str, <span class="keyword">char</span> *format, ...)</span> __<span class="title">attribute__</span> <span class="params">((format(prntf,<span class="number">2</span>,<span class="number">3</span>)))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">asprintf</span><span class="params">(<span class="keyword">char</span> **str, <span class="keyword">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list argp;</span><br><span class="line">    va_start(argp, format);</span><br><span class="line">    <span class="keyword">char</span> one_char[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> len = vanprintf(one_char, <span class="number">1</span>, format, argp); </span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;An encoding error occurred. Setting the input pointer to NULL.\r\n&quot;</span>);</span><br><span class="line">        *str = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(argp);</span><br><span class="line">    </span><br><span class="line">    *str = <span class="built_in">malloc</span>(len + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Couldn&#x27;t allocate %i bytes.\r\n&quot;</span>, len + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    va_start(argp, format);</span><br><span class="line">    vsnprintf(*str, len + <span class="number">1</span>, format, argp);</span><br><span class="line">    va_end(argp);</span><br><span class="line">    <span class="keyword">return</span> len</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>该函数具有防止数据越界、自动分配内存、自动控制内存大小的安全特性，同时可以使用该函数来实现连接字符串的功能</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">asprintf(&amp;q, <span class="string">&quot;%s and another clause %s&quot;</span>, q, add);</span><br></pre></td></tr></table></figure>

<p>这个特性可以用来实现数据库查询的底层</p>
</li>
<li><p>字符串解析</p>
<p>一般的字符串解析需要根据分隔符，配合正则表达式来抽取出子字符串。但是简单情况下只要使用c库函数strtok就可以完成使用分隔符划分字符串的任务：它会对输入的字符串进行迭代，直到遇到第一个分隔符，然后用一个<code>&#39;\0&#39;</code>来覆盖它，并返回一个指向这个子字符串头部的指针；当再次调用时，它会检索到下一个标记的尾部，并以合法的字符串形式返回这个标记。可以使用<code>strto_s</code>版本来实现多线程保护和提高安全性，它支持一个额外的参数：提供输入字符串的长度，并在后续的调用过程中不断缩短，表示每次调用时剩余字符串的长度，示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> len = <span class="built_in">strlen</span>(instring);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//第一次使用</span></span><br><span class="line">txt = strtok_s(instring, &amp;len, delimiter, &amp;scratch);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二次使用</span></span><br><span class="line">txt = strtok_s(<span class="literal">NULL</span>, &amp;len, delimiter, &amp;scratch);</span><br></pre></td></tr></table></figure>

<p><strong>特别注意</strong>：如果有连续的两个或更多分隔符被当作单个分隔符，那么空白标记会被忽略</p>
</li>
<li><p>Unicode解析</p>
<p>ASCII已经不适合这个版本了，大家都在用Unicode：为每个用于人类通信的字符设置一个单独的十六进制数值，一般是从0x0000到0xffff之间。Unicode具有以下几个流行的编码格式，他们之间的区别子啊与设置几个字节作为分析单位</p>
<ul>
<li>UTF-32：指定4字节（32位二进制位）作为基本单位，每个字符都可以用1个单位进行编码，但需要使用很多空白填充</li>
<li>UTF-16：使用2字节（16位二进制位）作为基本单位，有些字符需要使用2个单位来表示，但大多数字符都能用1个单位表示</li>
<li>UTF-8：使用1字节（8位二进制位）作为基本单位，许多字符需要使用多个单位来表示</li>
</ul>
<p>这三种方式中的字符序列不一定相关，特定的用于解析Unicode字符的c函数也应运而生</p>
<p>超过73%的网站使用了UTF-8，Mac和Linux操作系统在默认情况下使用UTF-8表示任何文本。作为程序开发者，需要进行以下操作：</p>
<ul>
<li>确定宿主系统的编码方式</li>
<li>按照合适的编码存储文本</li>
<li>认识到一个字符并不占据固定数量的字节，防止以基地址+偏移量表示的代码不会产生编码点的碎片</li>
<li>用便利的工具函数完成任何类型的文本理解</li>
</ul>
<p>UTF-8的内部编码对于C语言来说可以轻松处理，但是具有一些需要注意的隐患，因为：</p>
<ul>
<li>单位是8个二进制位，即一个char型，因此可以把一个UTF-8字符串写成char*字符串，与ASCII类似</li>
<li>前128个UTF-8和ASCII完全匹配；非ASCII的Unicode字符则无法和ASCII匹配</li>
<li>U+0000是一个合法的编码点，可以写成<code>&#39;\0&#39;</code>；但是这也导致把UTF-16或UTF-32赋值给char*变量时很可能出现一个充满NULL字节的字符串</li>
</ul>
<p>大多数POSIX和c-string库标准函数都可以对UTF-8编码生效</p>
<p>GNU还提供了一个可移植的libiconv函数库，指定了一个命令行的iconv程序，用于c函数上传至shell</p>
<p>对于UTF-16字符，C标准可以使用wchar_t来进行处理（windows将wchar_t置为16位），C11还提供了char16_t和char32_t的类型，分别对应16位和32位字符，但是目前还不太常用</p>
</li>
</ol>
<h3 id="多线程与原子操作"><a href="#多线程与原子操作" class="headerlink" title="多线程与原子操作"></a>多线程与原子操作</h3><p>现在是2201年了，不会有人还在用单核的PC吧——就连MCU都在搭载双核乃至四核处理器，C语言也与时俱进，利用POSIX和现有的C库实现多线程-原子操作！</p>
<p>借助POSIX或者OpenMP编译器命令，可以很轻松的将命令转到多线程执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br></pre></td></tr></table></figure>

<p>使用上面一行语句即可将单线程程序变成多线程的。OpenMP会自动计算系统可用线程数，并将工作拆分</p>
<p>如果你在嵌入式设备上移植了RTOS，应该会很熟悉借助互斥量、消息队列实现的线程（任务）间同步与消息传输，不过要在PC上使用C进行多线程编译，还应该调整编译器指令</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CFLAGS = -g -Wall -O3 -fopenmp -pthread <span class="comment">#同时使用fopenmp pthread atomic支持</span></span><br><span class="line">LDLIBS = -fopenmp -latomic</span><br></pre></td></tr></table></figure>

<p>不过虽然多线程能让任务效率提高，但是也可能会导致代码出现某些玄学bug</p>
<p><strong>多线程Bug比单线程Bug更难处理</strong></p>
<p>这时候就需要利用经验Debug了，加油吧</p>
<p>OpenMP和POSIX还有其他的一些指令，可以提供更完善的多线程支持，可以查看官方文档来了解它们，这里不再介绍</p>
<p><strong>原子操作，即不能被中断的操作</strong>——这是嵌入式编程的专有术语？不，多线程编程中的原子操作也指不能被线程切换打断的操作，使用以下命令高速OpenMP原子操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp atomic read <span class="comment">//原子读数据</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp atomic write seq_cst <span class="comment">//原子写数据（赋值）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp atomic update seq_cst <span class="comment">//原子自增/自减1</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp atomic update <span class="comment">//原子自增/自减一定值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp atomic capture seq_cst <span class="comment">//原子改变自己的值并进行读数据操作</span></span></span><br></pre></td></tr></table></figure>

<p>可以使用高频的原子操作在某种程度上替代互斥操作；然而请不要一直使用它——否则这和单线程编程又有什么区别呢</p>
<p>使用POSIX的pthread机制可以更标准地对Linux程序进行移植/多线程修改</p>
<p>如果你读过C Primer Plus，那么里面简要介绍的<code>_Atomic</code>关键字应该会让你懵一会，这个东西其实也是C11标准为了更好兼容多线程编程而创建的关键字，可以用于保护变量在多线程执行中不被额外的线程改变，各种各样的变量都可以修改成原子的——从int到struct</p>
<h3 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h3><p>SQL即结构化查询语言，这是一个大体上人类可阅读的与数据库交互的语言。一个SQL数据库可以抽取一个数据集合的子集，也可以合并多个数据集合。C程序可以使用<strong>SQLite</strong>提供的接口来实现数据库搭建和使用，而这个东西本体仅包括一个C文件和一个头文件。</p>
<p>这个库使用了多种宏和C预编译指令来实现SQL的操作，并将API封装到了 统一的接口上</p>
<p>相关内容可以参考<a href="www.sqlite.org">SQLite简介</a></p>
<h3 id="cJSON"><a href="#cJSON" class="headerlink" title="cJSON"></a>cJSON</h3><p>c语言中，没有直接的字典、字符串数组等数据结构，所以要借助结构体处理json。cJSON就是一个为json数据解析而生的高效率c库</p>
<p>类似的，也存在用于XML（扩展标记语言）、HTML（超文本标记语言）等数据解析的C库libxml和cURL</p>
<p>cJSON使用称为cJSON的数据结构负责JSON数据的编解码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> &#123;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span> <span class="comment">//链表指针域</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> *<span class="title">child</span>;</span> <span class="comment">//子对象</span></span><br><span class="line">     <span class="keyword">int</span> type; <span class="comment">//类型</span></span><br><span class="line">     <span class="keyword">char</span> *valuestring; <span class="comment">//指向值的字符串</span></span><br><span class="line">     <span class="keyword">int</span> valueint; <span class="comment">//存放整型</span></span><br><span class="line">     <span class="keyword">double</span> valuedouble; <span class="comment">//存放浮点型</span></span><br><span class="line">     <span class="keyword">char</span> *<span class="built_in">string</span>; <span class="comment">//键</span></span><br><span class="line">&#125; cJSON;</span><br></pre></td></tr></table></figure>

<p>使用顺序如下：</p>
<ol>
<li><p>包含头文件</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cJSON.h&quot;</span></span></span><br><span class="line"><span class="comment">//上面是必须的几个头文件</span></span><br></pre></td></tr></table></figure></li>
<li><p>JSON解析</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cJSON *root_json = cJSON_Parse(data); <span class="comment">//将字符串解析成json结构体</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == root_json)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;error:%s\n&quot;</span>, cJSON_GetErrorPtr());</span><br><span class="line">    cJSON_Delete(root_json);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&quot;name&quot;:&quot;EVDI&quot;</span></span><br><span class="line">cJSON *name_json = cJSON_GetObjectItem(root_json, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (name_json != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span> *name = cJSON_Print(name_json); <span class="comment">//将JSON结构体打印到字符串中</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name:%s\n&quot;</span>, name);</span><br><span class="line">	<span class="built_in">free</span>(name); <span class="comment">//自行处理内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>获取JSON数据</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cJSON *data_json = cJSON_GetObjectItem(root_json, <span class="string">&quot;data&quot;</span>); <span class="comment">//获取data键对应的值</span></span><br><span class="line"><span class="keyword">int</span> id = cJSON_GetObjectItem(data_json, <span class="string">&quot;id&quot;</span>)-&gt;valueint;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;id:%d\n&quot;</span>, id); <span class="comment">//输出</span></span><br></pre></td></tr></table></figure></li>
<li><p>输出JSON数据</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *username = cJSON_Print(cJSON_GetObjectItem(data_json, <span class="string">&quot;username&quot;</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;username:%s\n&quot;</span>, username);</span><br><span class="line"><span class="built_in">free</span>(username);</span><br></pre></td></tr></table></figure></li>
<li><p>创建JSON并添加值</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cJSON *root_json = cJSON_CreateObject(); <span class="comment">//创建一个JSON串</span></span><br><span class="line">cJSON_AddItemToObject(data_json, <span class="string">&quot;id&quot;</span>, cJSON_CreateNumber(<span class="number">1</span>)); <span class="comment">//数字值</span></span><br><span class="line">cJSON_AddItemToObject(data_json, <span class="string">&quot;userpass&quot;</span>, cJSON_CreateString(<span class="string">&quot;123456&quot;</span>)); <span class="comment">//字符串值</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>C语言进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>电路设计从入门到弃坑1【基础晶体管】</title>
    <url>/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/</url>
    <content><![CDATA[<h1 id="电路设计从入门到弃坑1【基础晶体管】"><a href="#电路设计从入门到弃坑1【基础晶体管】" class="headerlink" title="电路设计从入门到弃坑1【基础晶体管】"></a>电路设计从入门到弃坑1【基础晶体管】</h1><p>最基础的电路是由无源元件，即电阻、电容、电感三者构成的电路，两端通电后可以产生一个暂时稳定的电信号。不论是机缘巧合还是为了验证实验，曾经的物理学家开始注意到电的特殊性质，并加以研究，他们最先对电的性质进行探寻，从风筝实验到电磁感应定律一点点理解了电磁运作的原理，于是电气工程就出现了。然而到19世纪末为止，一直都只有无源电路的存在，电路的分析理论也仅有基础的电磁感应定律和由麦克斯韦方程组衍生出的基尔霍夫定律——直到20世纪的工程师发明出真空管，开启电子电路的时代。电路从最初使用电能和磁场能来控制、转化其他能量这个单一用途，进一步拓展出使用电信号来描述、控制其他信号，乃至使用电信号进行计算的用途。实现这些功能的基础就是具有控制功能的有源器件，也就是常说的二极管、三极管等元件。现代的半导体晶体管在20世纪中期才被发明出来，在此之前承担电子信号变换作用的元件一直是真空管。</p>
<span id="more"></span>

<h2 id="真空管"><a href="#真空管" class="headerlink" title="真空管"></a>真空管</h2><p>在半导体材料被发明之前，人们都使用电子管或者说真空管对电路进行操控，现代的半导体技术实质上还是在使用半导体达到真空管的用途，只不过因为半导体材料可以在硅片上进行制造，大大缩小了电路体积——但是它们的用途是相似的</p>
<p>现在真空管已经被市场淘汰，剩下的也不过成了爱好者们的玩具，不过理解真空管有助于了解二极管、三极管等基本的晶体管在电路中起到的作用</p>
<p>电子管主要分为：二极管、三极管、五极管、束射管、复合管等，听上去和半导体器件很相似</p>
<p>二极管是其中最简单的，它中间装有两个电极，一个是由金属丝制成用于发射电子的阴极，另一个是接收电子的屏极。给阴极通电，电流会将金属加热，管内已经被抽成了真空，因此金属丝就能发射电子，屏极则负责将这些电子接收。</p>
<p>在屏极接高电势，阴极接低电势时，屏极会主动吸引阴极发出的电子。一般来说二极管的加热部件是独立的，围绕在阴极周围，如下图所示（图b为电路符号，K为阴极，a为屏极，两个f表示加热部件）</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210814022541069.png" alt="image-20210814022541069"></p>
<p>因此实际上会有很多（效率懂得都懂，但是当时能用就行）电子从阴极到达屏极；反之在屏极接低电势，阴极接高电势时，电子的发射会被抑制——这就造成了二极管具有<strong>单向导电性</strong></p>
<p>基于PN结的二极管实际上也是起到单向导电性的作用，只不过由于引入了半导体技术，它的功能更加丰富、复杂了（实际上前人们也使用了很多方法改进真空管让它们做到现在半导体二极管的功能——毕竟第一台电子计算机都是用真空管制造的）</p>
<p>容易看出，这个大二极管具有一个致命的问题：功耗大得离谱，这玩意实际上就是个电灯泡——工作时常常能达到外壳100多度，用手摸一下就能烫熟的那种……这就是真空管的通病了：它们都需要使用额外的电热丝来让金属发出电子，而半导体管则不需要这些</p>
<p>再来看三极管：<img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210814023224226.png" alt="image-20210814023224226"></p>
<p>它中间多了一个栅极g——这个称呼也被保留到了后来的场效应管中——可以通过控制栅极来实现控制阴极-屏极电流，这也是双极结型晶体管和场效应管的共同原理和要达到的目的：<strong>用一个电流/电压控制另一个电流/电压</strong></p>
<p>值得指出的是：真空三极管的很多特性与专有名词被移植到了晶体三级管上，如果学完了三极管/晶体管再来学另一个，会感到很熟悉</p>
<p>真空管中还有一个较三极管更复杂的分支——五极管。他在三极管的栅极和屏极之间插入另外两个电极，于是栅极被分成了<em>控制栅极</em>、<em>帘栅极</em>和<em>抑制栅极</em>，这个器件主要用于减少的真空三极管中超大寄生电容和超量漂移电流的影响，从而能够实现“<strong>高频开关和放大</strong>”（在当时确实是高频）的开关，第一台电子计算机中也大多用了五极管配合继电器进行开关</p>
<p>最后需要提的就是束射管（至于复合管嘛，管如其名），它就是高中物理里面大名鼎鼎示波管的父类——通过将高速电子流打在荧光屏上实现显示功能，使用周边的电磁铁来控制显示的位置</p>
<p>不过束射管还有很多其他变种，辉光管、荧光管等上世纪苏联时代的遗产都是束射管的成员，它们大都利用加热器-金属灯丝-荧光材料/电子射线的原理进行发光显示信息，可以说是现代发光二极管的鼻祖了</p>
<p>利用这些真空管，前人们也制造出了放大器、振荡器、线性电源乃至开关电源等设备，其耐用性甚至能把一部分使用现代技术的设备打趴下。比起教科书中从半导体物理直接讲起，个人认为晶体管这种”朴素“的老古董更能体现模拟电路的本质——<strong>通过支路量操控支路量，从而实现模拟电信号的变换</strong></p>
<p>而真空管中的几个基本元件的性质也会在晶体管元件上得到体现</p>
<ul>
<li>二极管——单向导电与反向击穿</li>
<li>三极管——电流放大与开关控制</li>
</ul>
<h2 id="二极管"><a href="#二极管" class="headerlink" title="二极管"></a>二极管</h2><blockquote>
<p>我再用真空管，诺伊斯就是个伞兵！——肖克利（他没说过）</p>
</blockquote>
<p>简单了解过真空管，我们再来看看现代半导体科技的结晶，<strong>晶体管</strong></p>
<p>首先要谈的就是二极管了。不过要看懂现代半导体科技，就要从它们的基础——半导体材料开始。由于本篇的重点在于半导体器件，所以这里仅进行笼统的概括。我们先从二极管的物理基础<strong>PN结</strong>看起。</p>
<h3 id="二极管就是PN结"><a href="#二极管就是PN结" class="headerlink" title="二极管就是PN结"></a>二极管就是PN结</h3><p>半导体材料（硅/锗）的单质都是很难导电的，因为其中的电子和空穴浓度相等，即使外加电压，也会很快形成电流的动态平衡；然而这种平衡容易随着外界环境改变而改变，通过向纯净的半导体材料中掺入受控量的N型杂质和P型杂质，可以分别得到<strong>N型半导体</strong>和<strong>P型半导体</strong>，这种技术称为<strong>掺杂</strong></p>
<blockquote>
<p>N型杂质就是氮族元素（IVA族），它们的最外层电子数为5；P型杂质则是硼族元素（IIIA族），它们的最外层电子数为3</p>
<p>显而易见，N型杂质的掺杂会导致自由电子数量增多，半导体的载流子为多子，即自由电子，这就是为什么它被称为<strong>N</strong>egative；相反地，P型杂质的掺杂会导致空穴数量增多，半导体的载流子为多子，即空穴，这也是为什么它被称为<strong>P</strong>ositive</p>
<p>使用能带理论可以解释多子导电：导带中的电子就是载流子，能够导电；而空穴作为电子反向移动（跃迁）的等效，也可以等效地导电。相关内容可以参考《半导体物理》教材或本博文的参考书《模拟电子系统设计指南（基础篇）：从半导体、分立元件到TI集成电路》</p>
</blockquote>
<p>幼儿园的小朋友都知道，半导体材料的导电性容易受到外界温度、光照等因素影响。这是因为在特定温度热平衡的条件下，对特定的半导体材料，电子浓度$n_o$和空穴浓度$p_o$的乘积始终为常数，公式如下：$n_o * p_o = n_i^2$</p>
<blockquote>
<p>电子在核外的量子分布状态成为<strong>状态密度</strong>；电子的能量分布称为<strong>费米函数</strong></p>
<p>费米函数可以表明电子占据特定允态能级的概率，而它的值是由当前温度T和<strong>费米能级</strong>$E_F$决定的，表达式如下：<br>$$<br>f(E)=\frac{1}{1+e^{(E-E_F)/kT}}<br>$$<br>当T=0K时，可以发现所有低于费米能级的允态能级会被填充；高于费米能级的允态能级则会空出</p>
<p>当T有一个大于0K的确定值时，上式就存在一个极限值，并且填充态和空态之间出现了过渡，随着温度升高，这个极限值会逐渐降低，这就导致<strong>导带中热平衡的电子浓度会随着导带能级与温度变化而变化</strong>，表达式如下<br>$$<br>n_0=N_Ce^{-(E_C-E_F)/kT}<br>$$<br>参数$N_C$表示导带中的有效态密度函数，它的值仅由半导体材料的有效质量和温度确定</p>
</blockquote>
<p>根据上式不难得出：在温度稳定的条件下，半导体材料的本征浓度为常数</p>
<p>一般地，把两种不同的体系合二为一时，载流子可以互相流动；但是热平衡的时候一定会形成统一的费米能级，这是因为出现了载流子浓度交换，因此可以<strong>把掺杂的过程看作使费米能级变化进而改变导带宽度的过程</strong>；由此也可以推断出光照和温度也会让导带宽度变化，进而影响半导体材料导电性</p>
<p>说完了P型和N型半导体，终于能谈到PN结了——二极管归根结底就是一个封装起来的PN结，通过控制PN结的物理性质就可以制造出不同种类的二极管</p>
<p>PN结的物理性质十分复杂，这里我们只讲<em>简化的PN结模型</em></p>
<p>在一个晶格内，将P型和N型半导体连接在一起就形成了PN结，电子会从N区扩散到P区，空穴会从P区扩散到N区，因此在二者的接触区附近，电子和空穴会复合抵消，将其称为<strong>耗尽区</strong>或<strong>空间电荷区</strong>——在特定温度的热平衡条件下，不施加额外能量，电子或空穴是不能通过PN节的；同时由于在结的两侧存在相反的电荷，这就建立了一个穿越PN结的电场</p>
<p>当没有给PN结施加额外能量时，耗尽区会阻挡电流形成，不过仍然会存在微弱的电流穿过耗尽区，根据方向分为<strong>正向扩散电流</strong>和<strong>反向漂移电流</strong>；如果在外部对PN结两端施加正向电场，使得耗尽区内电场被抵消，空穴和电子就能够自由流动，在此过程中耗尽区越厚，所需要施加的外部能量就越大</p>
<blockquote>
<p>想象一种极端情况，将P型半导体的掺杂浓度提升到极限，甚至将其换成金属，那么电子便会自由地从P区向N区扩散，但是随着扩散，P区的电子浓度会逐渐变低，反而会形成一个从N区到P区的势垒，这一过程是动态平衡，这个势垒就是大名鼎鼎的肖特基势垒，利用贵金属和N型半导体就可以制成<em>肖特基二极管</em>，它的原理和结型二极管十分相似，但是最后的产物完全不一样：加正向电压时肖特基势垒会变窄而导致其内阻减小，这一性质导致它具有正向压降低的优点</p>
</blockquote>
<p>虽然二极管耗尽区的这个电场（一般称为内建势垒或内电场）很强，能抑制多子的运动，但是P区的少子电子会因此漂移到N区；N区的少子空穴也会穿过PN结到达P区，二者引起的电流分别称为正向扩散电流和反向漂移电流，二者大小相等、方向相反</p>
<p>因此，PN结也就是二极管的最根本、最基础特性就是<strong>单向导电性</strong></p>
<h3 id="从伏安特性出发"><a href="#从伏安特性出发" class="headerlink" title="从伏安特性出发"></a>从伏安特性出发</h3><p>回想一下真空管时代我们都用真空二极管干了什么？拿它单向导电和反向稳压！当年肖克利老爷子准备了一份真空管的伏安特性，然后对着面前的硅片就开始研究：怎么让这破玩意弄得像真空管一样？我们也先从伏安特性出发，理解二极管的性质</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210828014723118.png" alt="image-20210828014723118"></p>
<ul>
<li><p>正偏曲线</p>
<p>  二极管的P极接高电势、N极接低电势，即<strong>正偏</strong>，在这个情况下二极管的伏安特性曲线近似于指数函数</p>
<p>  二极管正偏伏安特性曲线如下所示：</p>
<p>  <img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210828014716192.png" alt="image-20210828014716192"></p>
<p>  U<del>ON</del>为<strong>二极管导通电压，硅管约为0.7V，锗管约为0.3V</strong>。因为二极管导通电压相对较低，而导通后电流升高速度很快，在$2 * U_{ON}$后就可以看作是短路状态，因此也常使用二极管的简化模型：当电压&lt;0V（或导通电压）时二极管关断，当电压&gt;0V（或导通电压）时二极管导通且为短路</p>
<blockquote>
<p>顺带一提，锗二极管虽然导通电压更低，但是已经基本被市场淘汰了，因为</p>
<ol>
<li>锗稳定性不好、提炼加工困难导致其一致性难以保证</li>
<li>价格更高</li>
<li>难以在硅片上集成</li>
</ol>
<p>同样遭遇的还有锗三极管，它的结压降也是约为0.3V（甚至视型号不同会更低一些），但是因为制造工艺和品控问题早早停产，只有一些HiFi发烧友在使用锗器件来达到更好的放大性能</p>
<p>特别地，<strong>锗管反向饱和电流为μA级，硅管则为nA级</strong>，显然硅管的截止更彻底</p>
</blockquote>
</li>
<li><p>反偏曲线</p>
<p>  之前没有说二极管PN结<strong>反偏</strong>（P极接低电势，N极接高电势）的结果：当阴极电压比阳极电压高时，会形成一个由阴极到阳极的外电场，电流根本不会产生，但是如果这个电压逐渐增高，甚至能够抵消耗尽区的内电场时，二极管就会被<strong>击穿</strong>，击穿时，整个晶体管内会产生大量电子-空穴对，电流会达到最大，换句话说此时二极管近似于短路，在这个过程中二极管会因为电流而剧烈发热，但是<strong>这并不意味着二极管损坏</strong>，如果再撤销这个反向电压，二极管还是会因为内电场重新建立而恢复原状。</p>
<blockquote>
<p><strong>材料掺杂浓度较低的PN结中</strong>，当PN结反向电压增加时，空间电荷区中的电场随之增强。这样通过空间电荷区的电子和空穴就会在电场作用下，使获得的能量增大。在晶体中运行的电子和空穴将不断与晶体原子发生碰撞，通过这样的碰撞可使被束缚在共价键中的键电子碰撞出来，产生自由电子-空穴对。紧接着新产生的载流子会在电场作用下撞出其他价电子，又产生新的自由电子-空穴对。如此连锁反应，使得空间电荷区中的载流子的数量雪崩式（也可以理解为链式反应）增加，流过PN结的电流就急剧增大击穿PN结，这种碰撞电离导致击穿称为<strong>雪崩击穿</strong></p>
<p>而在<strong>材料掺杂浓度较高的PN结中</strong>，耗尽区本来就比较薄，而在此时反偏一个强电场，这就是的耗尽层内中性原子的价电子会被快速拉出，成为自由电子，同时产生空穴，这个过程被称为<strong>场致激发</strong>。在场致激发的影响下二极管内会产生大量载流子，因此出现反向击穿的现象，这种击穿一般需要的外部能量较雪崩击穿更少，被称为<strong>齐纳击穿</strong></p>
</blockquote>
<p>  事实上能够损坏二极管的只有高温和外部破坏。因为<strong>导带中热平衡的电子浓度会随着导带能级与温度变化而变化</strong>，温度越高，热平衡电子浓度越高，越难以导电，而当反向击穿积聚的热量无法被释放时，二极管会被烧毁。二极管的反偏伏安特性如下所示：</p>
<p>  <img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210828013041349.png" alt="image-20210828013041349"></p>
<p>  U<del>BR</del>表示<strong>击穿电压</strong>（分为<strong>雪崩电压</strong>和<strong>齐纳电压</strong>），I<del>S</del>为漏电流（反向饱和电流），可见当二极管反偏时，在击穿电压范围内电流会达到很小，而超过击穿电压后，通过二极管的电流就会迅速增大（一般雪崩击穿电流增大速率比齐纳击穿更快）</p>
</li>
<li><p>特别的，可以使用公式<br>  $$<br>  i=I_s(e^{\frac{u}{U_T}}-1)<br>  $$<br>  近似表示二极管的伏安特性</p>
</li>
</ul>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol>
<li><p>单向导电性</p>
<p> 二极管的单向导电性应该不用多介绍，大家品鉴的足够多了。一般利用这个性质，可以实现二极管的半桥整流或<strong>全桥整流</strong>（对于三相电可以使用三相桥整流），用于将交流信号变成脉动的直流信号。对于单相交流信号，可以直接在变压器中间抽头，用两个背对背的二极管就可以实现全桥整流</p>
<p> 还可以利用这个性质实现<strong>boost电路</strong>（倍压整流）来进行DC-DC升压；对于高频信号则可以使用类似的电路（二极管后接电阻和并联的电容，前接激励源）实现<strong>包络检测</strong>，从高频调制的信号中提取低频信号</p>
<p> 在一般电路中应用比较多的就是<strong>钳位电路</strong>和<strong>削波电路</strong>，可以通过两个二极管分别连到VCC和GND端防止某个节点的电压偏高/过低，但是应该注意要在二极管同一支路串接保护电阻防止泄放电流过大</p>
<p> 因为二极管可以起到改变高频信号偏置电流的作用（因为它的正向电容可以在一定程度上滤除高频信号），所以可以使用它和分压电阻、电容实现压控衰减器，示例电路如下</p>
<p> <img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210828023423864.png" alt="image-20210828023423864"></p>
</li>
<li><p>反偏稳压性</p>
<p> 如果二极管反向电压超过击穿电压时，它会工作在击穿去，反向电流迅速增加，但电压基本不变，因此可以在保证二极管不过热的情况下让二极管在击穿区实现稳压功能，通过专门设计的，在击穿区内有着陡峭特性曲线（利用齐纳击穿特性）的二极管成为齐纳二极管，也就是俗称的稳压二极管</p>
<blockquote>
<p>一般来说稳压二极管都会有很高的掺杂浓度，这是因为稳压管利用了齐纳击穿而不是雪崩击穿：雪崩击穿所需的外部电压一般相当高，击穿时会很快产生巨大的电流，在这种情况下二极管的结温非常难以控制，因此一般的二极管一旦出现雪崩击穿基本就意味着烧毁；但是齐纳击穿的击穿电压相对较低，而且它的击穿伏安特性更平滑，只要在外接一个电阻用于控制击穿电流就可以相对容易地实现稳压</p>
</blockquote>
</li>
<li><p>反偏变容性</p>
<p> 耗尽层相当于PN两块半导体之间的绝缘体，因此二极管存在寄生电容（<em>结电容</em>）；又因为外加电压时耗尽层厚度会发生变化，因此二极管的寄生电容就会发生变化——通过在某一侧只掺入微量杂质，可以实现一个相当厚的耗尽区，如果此时对二极管反偏，这个耗尽区厚度会很容易变化，由此达到<strong>变容二极管</strong>的作用</p>
</li>
<li><p>温度敏感性</p>
<p> 因为导带中热平衡的电子浓度会随着导带能级与温度变化而变化，所以<strong>反向饱和电流</strong>会对温度敏感——会<strong>随温度增加而快速增加</strong>。其次，<strong>温度升高，二极管正向压降减小，正向工作电流增大，</strong>这是因为温度升高会导致耗尽区的原子共价键不稳定，更容易被外加电场激发出自由电子-空穴对</p>
</li>
<li><p>耗尽电容与扩散电容</p>
<p> 高频交流信号下，二极管中的耗尽层会演变成一个以硅为电介质的平行板电容器，对应的电容被称为<strong>耗尽电容</strong>。它会随二极管反向偏压而变化。</p>
<p> 当二极管正片时，由于耗尽层附近区域会有过量少子电荷聚集，出现电荷存储效应，局部的电荷浓度出现了不平衡，这就相当于又引入了一个电容，被称为<strong>扩散电容</strong>，它的大小与PN结点的横截面积成正比，一般为10-100pF</p>
<p> 利用这两个电容可以推导出二极管的高频小信号模型：正偏时一个小电阻并两个电容；反偏时一个大电阻并一个电容（耗尽电容）</p>
</li>
</ol>
<p>其实还有发光二极管、肖特基二极管等多种结构的二极管，它们都有自己的特点，但是暂且不作介绍</p>
<h3 id="电路应用"><a href="#电路应用" class="headerlink" title="电路应用"></a>电路应用</h3><p>下面给出1n4148二极管（来自安森美）的datasheet</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210828021027904.png" alt="image-20210828021027904"></p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210828021038170.png" alt="image-20210828021038170"></p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210828021047611.png" alt="image-20210828021047611"></p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210828021054300.png" alt="image-20210828021054300"></p>
<p>常见的参数都已给出，1n4148是通用性的开关二极管，电路设计中主要需要参考其击穿电压（100V）、最大正向电流（200mA）、峰值电流（400mA）、工作温度（-55到175）、功率（500mW）、漏电流（0.025uA-5uA）、开关频率（或者说恢复时间）（4ns）</p>
<p>可见它的开关频率比较高，但耐压相对一般，也缺少反向击穿稳压的能力，因此适合用作开关二极管或检波二极管的替代品</p>
<h2 id="三极管"><a href="#三极管" class="headerlink" title="三极管"></a>三极管</h2><blockquote>
<p>一个有源器件可以通过一个电信号控制其他电信号——真空三极管告诉电气工程师的遗言</p>
</blockquote>
<p>三极管又称<strong>双极结型晶体管</strong>，也就是所谓的<strong>BJT</strong>（Bipolar Junction Transistor）</p>
<p>特别地，“晶体管”——Transistor实际上是贝尔实验室对跨导变阻器（Transconductance Varistor）的简称</p>
<h3 id="三极管与二极管"><a href="#三极管与二极管" class="headerlink" title="三极管与二极管"></a>三极管与二极管</h3><p>为了实现电信号的相互控制，三端器件是必须的。对于一个三端器件，我们一般通过双端口网络模型进行分析。对于三极管，更适合使用双端口网络的T参数和H参数矩阵进行描述——但这太学术了！从直观上理解<strong>三极管就是一个水龙头</strong></p>
<p>我们先来看需要三端元件做什么：首先它要使用一端的电压/电流进行控制，就假设这个三端元件有ABC三个端口，要想在A端口产生这个电压/电流，就要找到一个地，因此三端元件一定需要一个接地点，让另外两端到这一端产生电流。暂且假设这个接地点是B——既然有电流产生，根据基尔霍夫电流定律，A端流入和C端流入电流之和就是B端流出的电流。一切都解释的通了：A端通过AC之间的电流/电压控制BC之间的电流/电压，这不就是一个受控源吗！我们将AC之间的电流/电压与BC之间电流/电压的比值记作<strong>增益β</strong>，不难看出<strong>β&lt;1</strong>恒成立，换个角度，这其实就是T参数矩阵中的一个参数</p>
<p>这就能解释三极管是水龙头这个比喻了：通过扭动水龙头把手可以可以控制水流的大小</p>
<p>对于三极管来说，他正是使用电流控制电流，A端被称为<strong>基极</strong>，记为<strong>b</strong>（<strong>B</strong>ase），B端称为<strong>发射极e</strong>极（<strong>E</strong>mitter），C端称为<strong>集电极c</strong>极（<strong>C</strong>ollector）。<strong>be电流控制ce电流</strong>。以下部分都会使用e、b、c三个极的简写形式</p>
<h3 id="一点简单的原理"><a href="#一点简单的原理" class="headerlink" title="一点简单的原理"></a>一点简单的原理</h3><p>三极管有两种大类型：<strong>NPN</strong>和<strong>PNP</strong>。它们的名字来源于其中“结”的排列顺序。它们的大致结构和电路符号如下所示：</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210831003431811.png" alt="image-20210831003431811"></p>
<p>BJT使用c和e极作为电流源端，b作为电流控制端，<strong>电路符号中的箭头表示器件处于正向有源状态时的电流方向</strong></p>
<p>目前PNP和NPN两种晶体管都被大量生产，但是相对而言NPN型生产效果更好——半导体中电子的流动性比空穴流动性更强，NPN的内部具有两个N型半导体区，所以它内部的电子浓度更高，可以达到更高的工作速度和承载更大电流。对于NPN管而言，共e极模式下，c极将基极注入的小电流放大输出；其他条件下，<strong>当E<del>b</del>&gt;E<del>e</del>时，晶体管c、e导通</strong>；PNP管与其相反，共射模式下，c极将离开b极的小电流放大输出，而<strong>当E<del>b</del>&lt;E<del>e</del>时，晶体管c、e导通</strong></p>
<p>实际上三极管的原理比较复杂，但在这里我们主要讨论的是其电气性质，所以只用NPN举例简单解释一下。正如其命名，BJT是由两个PN结构成的，其中电荷载流子穿过两个不同电荷浓度区域PN结时会发生双向扩散，这就导致了BJT的内电流。一个BJT的剖面图如下所示</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210831004908286.png" alt="image-20210831004908286"></p>
<blockquote>
<p>原谅我的灵魂画作</p>
</blockquote>
<p>可以发现<strong>BJT成型于c极底座，面积很大，b极被做得很薄且具有极低的掺杂浓度，e极则被控制在较高的掺杂浓度</strong>。这么做主要有以下几个原因：</p>
<ol>
<li>让e极可以很容易地被be电压激发出电子</li>
<li>让b极容易被穿过</li>
<li>c极可以完整接住来源于e极的电子</li>
</ol>
<p>可以发现整个流程和真空三极管的发射电子-控制电子-接收电子有异曲同工之妙。特别地，e极电子作为多子向b极扩散后，本来是少子的b极电子浓度大增，会自发向电子浓度相对较低的c极扩散，因此BJT被划分为少子载流元件</p>
<blockquote>
<p>顺便一提场效应管FET是多子载流元件，这就是为什么FET能承受相对更大的电流，这个话题按下不表</p>
</blockquote>
<p>当b极和e极加正向电压时，e极高浓度电子被快速激发，直接在电场作用下达到e极，而如果没有其他电源，这些电子会自行穿过b极进入外电路；但是一旦施加了更高（大于E<del>ce</del>）的电压，这些电子中的绝大多数就会进入c极（因为c极的面积比b极大得多），随后进入外电路。生产中为了降低在到达c极之前被空穴中和掉电子的百分比和被b极电压“吸引走”电子的百分比，b区就被做得很薄了</p>
<blockquote>
<p>有些人在学习模电不久后觉得三极管就是两个二极管的简单串联，只不过多加了一个控制功能，这种想法是完全<strong>错误</strong>的！</p>
</blockquote>
<p>一般在模拟电路设计中，认为c极电流是b极电流的线性函数，也就是大名鼎鼎的<strong>β</strong>；但是对于更精确的BJT电路，需要使用电压控制模型，或者说<strong>EM（Ebers-Moll）模型</strong>，需要考虑一个指数函数<br>$$<br>I_C=I_S(e^{\frac{qV_{BE}}{kT}-1})<br>$$<br>这个模型基于三极管的物理模型建立，相对精确。V<del>BE</del>可以被描述为$V_{BE}=\frac{kT}{q} ln \frac{I_C}{I_S}$</p>
<p>使用这个模型的一个优点在于可以将三极管建模成跨导：电压控制，跨导和集电极电流成比例关系，常用于SPICE模型仿真和高频电路的理论计算中</p>
<p>上面提到了<strong>β值</strong>，这可以说是三极管最重要的性能指标了，它的正式名称为<strong>共射极电流增益</strong>，<strong>在正向有源区近似于c极直流电流和b极直流电流的比值</strong>；另一个重要参数是<strong>共基极电流增益α</strong>，<strong>在正向有源区近似于从发射极到集电极的电流增益</strong>，其值一般接近于1。相关公式如下<br>$$<br>\alpha=\frac{I_C}{I_E} \<br>\beta=\frac{I_C}{I_B} \<br>I_E=I_B+I_C \<br>\beta=\frac{\alpha}{1-\alpha} \<br>\alpha=\frac{\beta}{1-\beta}<br>$$</p>
<blockquote>
<p>BJT是非对称器件，因此当把c、e极互换后BJT会工作在反向有源模式，一般不会这样使用BJT，它的内部结构也为正向有源模式进行了优化。在CMOS制造工艺中，常常使用低性能的“横向”对称BJT，这是为了平衡成本（硅片面积）和性能</p>
</blockquote>
<p>在应用方面，可以直接通过三极管的工作电流电压测出其β值：$\beta=\frac{\Delta i_c}{\Delta i_b}$</p>
<p><strong>三极管的be结电阻</strong>也是一个重要参数，它需要使用半导体物理的公式得出：<br>$$<br>R_{BE}=r_{bb’}+\frac{26mV}{I_{BQ}}<br>$$<br>其中r<del>bb’</del>是三极管的基区电阻，这是一个大致在100~200Ω之间的常数，只与三极管的制造工艺有关，它加上PN结电阻，也就是后面那部分就可以得到be结总电阻了</p>
<h3 id="很多复杂的性质"><a href="#很多复杂的性质" class="headerlink" title="很多复杂的性质"></a>很多复杂的性质</h3><p>因为很复杂，所以跳过！</p>
<p>三极管的性质太多了，而这些性质造就了它的多种用途。可以说现代中小功率模拟电路就是建立在三极管之上的；而大功率模拟电路则被场效应管所掌控</p>
<p>下一部分会详细讲述三极管的基本应用。这里先了解一下三极管的基本工作区域和输入输出性质（以NPN为例）</p>
<p>BJT有5个不同的工作区，列举如下：</p>
<ol>
<li><strong>正向有源（正偏）</strong>：V<del>c</del>&gt;V<del>b</del>&gt;V<del>e</del>，$I_C=\beta I_B$，水龙头把手在开合范围内，可以控制水流大小。be结正偏，bc结反偏</li>
<li><strong>饱和（完全导通）</strong>：V<del>b</del>&gt;V<del>e</del>，V<del>c</del>&lt;V<del>b</del>，b极电压超过了c极电压，就像是手把水龙头开到最大，水龙头把手都扭歪了，自然水会喷涌而出，这时三极管c极电流会达到最大。所有PN结正偏，常用于实现逻辑电路中的开关闭合</li>
<li><strong>截止</strong>：V<del>b</del>&lt;V<del>e</del>，水龙头被关上，BJT的c极电流近似于0，属于漏电流；e极电流则近似等于b极电流。所有PN结反偏，可以实现逻辑电路中的开关断开</li>
<li><strong>反向有源（反偏）</strong>：V<del>c</del>&lt;V<del>b</del>&lt;V<del>e</del>，反向电流通过三极管，相当于把c、e极对调。实际中很少使用该模式，因为β值会小得多，相当于三极管内阻被放大了。集成电路中可能会在某些地方用到（大概）</li>
<li><strong>雪崩击穿</strong>：俗称炸管，一般来说三极管被击穿会直接烧毁，因为两个PN结的性质不可能完全一致，这就导致但凡电流过大一点，一个PN结不会被烧毁，另一个一定会被烧掉！三极管的耐压规定了ce、be电压的最大值，选型前一定要注意</li>
</ol>
<p>PNP型三极管的性质和NPN型的性质正好对偶，有兴趣的读者可以自行证明PNP三极管的相关性质</p>
<blockquote>
<p>自证不难</p>
</blockquote>
<p>下面是经典的小信号通用三极管S8050的datasheet</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210831013945373.png" alt="image-20210831013945373"></p>
<p>它使用了经典的TO-92封装，在很多收音机里都能见到这个NPN开关管的身影。</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210831014034027.png" alt="image-20210831014034027"></p>
<p>耐压be 5V；ce 20V；cb 30V。也就是说最好驱动电压不要超过5V，如果使用独立电源为三极管供电，电源也不能超过20V</p>
<p>c极电流700mA，算是开关管里面比较大的，能够驱动一些小型的功率设备了</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210831014222806.png" alt="image-20210831014222806"></p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210831014318634.png" alt="image-20210831014318634"></p>
<p><strong>开关管是指用于充当开关元件的三极管</strong>，也就是说它会工作在截止-导通两个状态下，因此其最重要属性就是开关频率，其次才是增益</p>
<p>而<strong>功率管是指专门用于功率放大的三极管</strong>，它会一直工作在正偏状态下，其最重要属性是增益</p>
<p><strong>通用管是指介于二者之间，能够在一定范围内通用使用的三极管</strong>，在各种各样的电路里都能见到这种三极管，它们的性能指标比较均衡，一般来说两个不同型号的通用管是很有可能相互取代的</p>
<p>可以从output capacitance输出电容看出s8050的开关频率：1MHz下为9pF，一般来说工作在几十kHz可以达到更低的电容量，属于工作在中频的三极管。它的增益在120到400之间，取200的中间值，属于放大性能一般的三极管。s8050就是这样一个中庸的三极管，各种地方都能使用，因此它的出货量很大，价格便宜。生产商也很多。</p>
<p>**DC Current Gain指的就是β值了，在大多数数据手册里面，这个参数被称为$h_{FE}$或$HFE$**，可以看出这个管子的β在120~400，算是性能中庸的</p>
<p>特别提一下current gain bandwidth product电流增益带宽积：放大器带宽和带宽的增益的乘积，在频率足够大时是一个常数，三极管的CGBP其实没有什么用，<em>在高频运算放大器中可以指示放大器的性能</em></p>
<h2 id="场效应管"><a href="#场效应管" class="headerlink" title="场效应管"></a>场效应管</h2><p>场效应管（FET，Field Effet Transistor）和三极管一样，同属于晶体管大家族，其中比较常用的就是MOSFET金属氧化物半导体场效应管（Metal Oxide Semiconductor Field Effect Transistor），它常常以互补金属氧化物半导体（CMOS，Complementary Metal Oxide Semiconductor）的形式出现在数字集成电路中，抑或是以直插功率元件的形式出现在开关电源里。下面对它进行简单的介绍（<em>下面全部使用简称</em>MOSFET或JFET）</p>
<p>由于MOSFET涉及的知识点较多，在这里只进行总体介绍，在后面的博文里会详细谈到MOSFET相关内容</p>
<h3 id="电场效应"><a href="#电场效应" class="headerlink" title="电场效应"></a>电场效应</h3><p>就像四大天王有五个一样，三端元件MOSFET有四个端子，除了<strong>源极s</strong>（<strong>S</strong>ource）、<strong>栅极g</strong>（<strong>G</strong>ate）、<strong>漏极d</strong>（<strong>D</strong>rain）外，还有一个俗称<em>衬底</em>的<strong>体极b</strong>（<strong>B</strong>ody）。一般来说衬底是连接到源极的，因此它表面上和其他三端元件一样。</p>
<p>MOSFET与BJT不同，是电压控制电流器件，它通过施加在栅极上的电压来控制从源极到漏极的电流；同时MOSFET是多子载流器件。BJT需要的开启电流大，开启电压小，能提供给负载的驱动电流也较小；但是MOSFET开启电压大，开启电流小（漏电流也相当小），可以给负载提供很大的电流</p>
<blockquote>
<p>你知道吗？高铁、电磁炮、<del>御坂美琴</del>常用于控制电流的绝缘栅双极型晶体管IGBT就是用三极管和MOSFET复合而成的，其中三极管负责对信号进行放大，通过特制的续流二极管芯片进行隔离，驱动负责导通/关断大电流的MOSFET，兼顾了MOSFET的高输入阻抗和BJT的低导通压降，同时由于是复合管，增益直接爆炸。将其与外围电路封装成模块，常用于控制400V、100A及以上的强电系统！</p>
</blockquote>
<p>MOSFET分为四种：N沟道-P沟道、增强型-耗尽型。这里先不解释它们的含义，我们先来看它的结构：</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901010858481.png" alt="image-20210901010858481"></p>
<p>MOSFET就是一个沿用了真空管三极称呼的器件：因为它本质上就是一个使用电场效应替代电子射线的真空管。解释一下它的名称由来：</p>
<ul>
<li>M代表Metal金属，曾经MOSFET使用金属材料制作栅极，但是现在处于生产便利考虑使用<strong>多晶硅</strong>，因为它能生成自对齐的栅极。现在只有高频MOSFET才会使用金属栅极来提高工作速度（事实上当前速度最快的FINFET工艺采用的仍是硅晶体，在某种程度上说金属应该是个“误解”）</li>
<li>O代表氧化物，目前这也变成了一个“误区”，因为现代的MOSFET会使用各种不同的绝缘材料，目前比较常用的其实是高k绝缘体。这样做的原因只有一个：降低MOSFET的开启电压，提高s-d电流，尽可能降低g极漏电流。<strong>使用xx nm衡量半导体工艺，一般来说这个长度是指MOSFET的沟道宽度</strong>，因为<em>沟道宽度</em>（在之后会解释沟道）减少时，漏电流就会增加；反之，漏电流减少、供电电压降低，意味着MOSFET的性能得到提高</li>
<li>S代表半导体，现代MOSFET的制作工艺就基于半导体材料：在硅衬底顶部生长一层硅氧化物（或其他什么绝缘/半导材料），再沉淀一层金属或多晶硅，就能获得传统的MOSFET了。现在一些厂商开始在MOSFET的沟道中使用硅和锗的化合物，也有一些科研人员在探索新的半导体材料（石墨烯、氮化镓等等），并将其应用在MOSFET上。</li>
<li>FET：场效应，就是所谓的“电场效应”。传统MOSFET等效于一个电容器，一个电极是半导体硅衬底，一个电极是多晶硅。这里先考虑使用的衬底是P型半导体（作为b极），当给金属/多晶硅（作为g极）施加外电压（正电压）时，带有正电荷的空穴就会远离g极和氧化物的中间区域，但是因为整体是个电容，电荷并不会从g极流出。这就创造了一个<strong>耗尽层</strong>，在这个区域里自由载流子无法移动。当g-b电压足够大时，会在靠近半导体和绝缘体之间薄薄一层形成高浓度的负电荷载流子区域，称为<strong>反转层</strong>。将反转层内电子体积密度和体内空穴密度相等的电压称为<strong>阈值电压</strong>。当g-b电压超过阈值电压时，就会形成反转层，此使MOSFET开启，对应的电压称为<strong>开启电压</strong>。而通过外加g-b电压形成反转层导致MOSFET开启的这个过程就称为<strong>电场效应</strong>。</li>
</ul>
<p>真空三极管使用通电的灯丝放出电子流；MOSFET使用场效应开启反转层，在氧化物绝缘层下方生成一个载流子浓度极高可以导电的区域</p>
<p>真空三极管使用栅极（实质上是通过栅极外加电压）控制到达屏极的电子数量，从而控制电流；MOSFET使用栅极电压控制场效应的强度，进而控制反转层的载流子浓度，从而控制s-d电流。</p>
<p>真空三极管的阴极和阳极具有单向导电性；MOSFET的d极和b极（衬底）之间存在一个寄生二极管，某种程度上也存在单向导电性</p>
<p>从上面可以看到MOSFET的性质和真空管的性质十分接近，这也是它沿用了栅极名称的原因之一。</p>
<p>MOSFET的原理就是利用g极的电场效应在绝缘层下方开启一个导电沟道，从而让s-d极能够导电。<strong>增强型MOSFET</strong>就是指随着g极电场增强，进入沟道的载流子增多，导电性增加；<strong>耗尽型MOSFET</strong>则是利用一个<em>表面掺杂层</em>中的载流子构成导电沟道，随着g极电场增强，外电场会抵消掉来自表面掺杂层的载流子，导电性减弱。在g极和衬底之间施加电压时，电场会先导致半导体层中出现电荷分离的情况，根据<strong>衬底中半导体掺杂</strong>的不同，可将MOSFET分为PMOS和NMOS。<strong>NMOS</strong>结构就是上述过程所形容的；而<strong>NMOS</strong>在被施以外部电场时，电子作为少子会被聚集在氧化物底层，但是因为密度太小并不能形成反转层，因此NMOS必须施加<em>b正g负</em>的反向电场，这样多子空穴会聚集并形成反转层。上面的四个MOSFET结构可以组合起来，成为四种基本的MOSFET</p>
<ul>
<li>增强型NMOS</li>
<li>耗尽型NMOS</li>
<li>增强型PMOS</li>
<li>耗尽型PMOS</li>
</ul>
<p>它们的电路符号如下所示：</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901020726001.png" alt="image-20210901020726001"></p>
<p>用一条竖线表示导电沟道，另一条短竖线表示g极的半导体</p>
<p>需要注意的是g极呈现“L”型，它的输入引脚更靠近s极，用来显著地指示方向——如果使用简化的图标，也要用箭头标明s极</p>
<p><strong>b极（s极）上会注明一个箭头，它永远指向从P到N的方向</strong>，因此它用来指示PMOS/NMOS（<strong>PMOS向外指；NMOS向内指</strong>，具体原因留给读者自行考虑）</p>
<blockquote>
<p>思考题答案：因为箭头永远指向N，只要沟道是N，那箭头就会指向沟道，也就是向内指了；P沟道则相反</p>
</blockquote>
<p>一般来说MOSFET会通过一个竖线将衬底和s极连在一起，如下图所示</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901021103401.png" alt="image-20210901021103401"></p>
<p>这就表示衬底和源极连在一起引出。</p>
<p>有的时候MOSFET会在d极和s极之间跨接一个二极管标识，这常用于开关电路或者高频电路中的MOSFET表示</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901021550063.png" alt="image-20210901021550063"></p>
<p>实际上这个二极管指的是MOSFET的<strong>寄生二极管</strong>，正是因为这个二极管，导致大功率下MOSFET具有一定的单向导电性和复杂电气特性</p>
<blockquote>
<p>大功率MOS管d极从硅片衬底底部引出，而s极被放在衬底底部的另一半，d极和s极都由不同种类的半导体材料制成，如下图所示</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901022016180.png" alt="image-20210901022016180"></p>
<p>这就导致了N-P-N之间出现了PN结，上图中左侧的PN结由于b-s短接而无效，右侧的b-&gt;d的PN结则相当于一个从b极接到d极的二极管，对于NMOS来说也是如此，<strong>总会存在一个与箭头方向（箭头指示P-&gt;N）相同的寄生二极管</strong></p>
</blockquote>
<p>寄生二极管并不是大功率MOSFET独有的，只要是NPN或PNP型的MOSFET都会存在PN结，只要有PN结就会或多或少存在寄生二极管。上图中s、d区是由不同于衬底的掺杂半导体制成的，这个工艺的原理在下面讲述</p>
<h3 id="增强型MOSFET"><a href="#增强型MOSFET" class="headerlink" title="增强型MOSFET"></a>增强型MOSFET</h3><p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901231358388.png" alt="image-20210901231358388"></p>
<p>上图是增强型N沟道MOS的结构，将N和P型半导体调换，即可得到增强型P沟道MOS的结构</p>
<p>一般使用W表示栅极宽度，使用L表示栅极长度，因为绝缘层非常薄，所以栅极长度和沟道长度近似相等，它也称为沟道宽度。<strong>栅极、源极、漏极之间的重叠区域要求保证反转层可以在源极和漏极之间形成连续的导电通道，为了减少寄生电容，这个重叠区域要尽量小</strong>。现代的NMOS与传统MOSFET的最大不同就是通过引入两个P型半导体电极降低了沟道开启所需电压。</p>
<p>需要注意：一般N型半导体上方引出电极使用金属铝</p>
<p>PMOS和NMOS结构大同小异，二者最大的不同在于形成的导电沟道方向和寄生二极管方向——由于MOSFET内部N-P型半导体交界耗尽区而形成的沟道外延被称为<strong>诱生沟道</strong></p>
<p>增强型MOSFET的工作模式有以下几种：</p>
<ol>
<li><p><strong>截止模式</strong></p>
<p> V<del>GS</del>&lt;V<del>th</del>（阈值电压）。此时不会形成s-d之间的导电通路，也就是<strong>导电沟道无法开启</strong>。但是由于电子能量的玻尔兹曼分布，s极的一些高能量电子可以进入沟道并扩散到d极。同样的，理想情况下d-s电流应为0，但是存在<strong>弱反转电流</strong>，它与V<del>GS</del>-V<del>th</del>成正指数关系，与斜率因子n=1+耗尽层电容/氧化物层电容成负指数关系。在集成电路中，还需要考虑短沟道的<strong>漏极势垒降低</strong>（Drain Induced Barrier Lowering，<strong>DIBL</strong>）效应，这个效应的强弱和器件的几何形状、PN结掺杂等有关，这个效应既有利也有弊：微功耗模拟电路利用低于阈值条件的优势，使得MOSFET可以尽可能提供较高的跨导-电流比值，甚至能和BJT一较高下。但是一般情况下，低于阈值的伏安特性会导致产品一致性难以保证</p>
</li>
<li><p><strong>欧姆模式</strong>（线性模式、线性区）</p>
<p> 当$V_{GS}&gt;V_{th}$且$V_{DS}&lt;(V_{GS}-V_{th})$时，MOS闭合，<strong>导电沟道开启，但是没有完全开启</strong>。<em><strong>此时MOSFET就像一个电阻</strong></em>：s-d电流可以使用以下公式表述<br> $$<br> I_D=\mu_n C_{ox} \frac{W}{L} [(V_{GS}-V_{th})V_{DS} - \frac{V^2_{DS}}{2}]<br> $$<br> μ<del>n</del>表示电荷载流子有效迁移率，其他参数就是字面意思（请读者翻看上文并理解各个符号的含义）</p>
<p> 可以看出s-d电流和ds电压具有相关性，进一步推到可以发现这个曲线相当接近直线，也就是说在欧姆模式，MOSFET可以起到类似电阻的作用，从而实现电流-电压控制</p>
</li>
<li><p><strong>饱和模式</strong></p>
<p> 当$V_{GS}&gt;V_{th}$且$V_DS&gt;(V_{GS}-V_{th})$，生成一条沟道以允许在d极和s极之间流过电流，也就是<strong>导电沟道完全开启</strong>。由于d极电压大于g极电压，电子会顺势扩散，<em>在该工作模式下，MOSFET的d-s极近乎短路</em></p>
</li>
</ol>
<p>增强型MOSFET还有几个性质：</p>
<ol>
<li><p>转移特性    </p>
<p> s-d电压恒定时，测量g-s两端电压和d极电流之间的关系</p>
<p> 实际上就是二端口网络的转移特性矩阵实例</p>
<p> <img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901235023213.png" alt="image-20210901235023213"></p>
</li>
<li><p>输出特性</p>
<p> g-s电压恒定时，s-d电压和d极电流之间的关系（输出特性矩阵实例）</p>
<p> <img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901235011715.png" alt="image-20210901235011715"></p>
</li>
<li><p>温度特性</p>
<p> 随温度升高，流经d极的电流会逐渐下降</p>
</li>
</ol>
<h3 id="耗尽型MOSFET"><a href="#耗尽型MOSFET" class="headerlink" title="耗尽型MOSFET"></a>耗尽型MOSFET</h3><p>耗尽型MOSFET与增强型MOSFET原理上最大的不同就是它使用了实实在在的“沟道”</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901235247565.png" alt="image-20210901235247565"></p>
<p>如上图，耗尽型PMOS的两个P型半导体之间额外沉积了一层薄薄的P半导体沟道，因此PN结的耗尽层在沟道下方出现，当V<del>GS</del>&lt;0时，沟道中的空穴会被排斥出沟道进入耗尽层，并与其中的电子中和，这样使得P型半导体沟道中的载流子浓度大减，沟道会变窄——如果更进一步，沟道附近的衬底会称为缺P型，导电能力增强，但<strong>沟道的导电能力会变得近乎没有</strong>。这就实现了“耗尽”的目的。沟道失去导电性的瞬间称为“<strong>沟道夹断</strong>”</p>
<p>从应用上看，耗尽型MOSFET相当于对增强型MOSFET进行了“非运算”，高V<del>GS</del>会开启增强型MOS，但是会夹断耗尽型MOSFET</p>
<blockquote>
<p>利用增强型-耗尽型MOSFET的互补性可以实现MOSFET图腾柱电路：两个MOSFET的d-s极首尾相连，最上面的MOSFET的s极引出到电源，下面的MOSFET则引到地，这样使用一个“不高不低”的电压就能够实现放大作用；使用高/低电平则会让二者之一导通，实现最大的开关性能。该电路也可以使用NPN-PNP三极管对管或者NMOS-PMOS对管实现</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210902000134796.png" alt="image-20210902000134796"></p>
<p>这个电路常常被用来作为电机、功率设备的驱动电路，三个相同的电路接到三相电上还可以实现H桥架构，进而驱动三相电机</p>
</blockquote>
<h3 id="小号继电器"><a href="#小号继电器" class="headerlink" title="小号继电器"></a>小号继电器</h3><p>MOSFET因为较低的启动电压和高输入阻抗，常常被用来<strong>作为继电器在非隔离情形下的替代品</strong></p>
<p>但是由于MOSFET的导通电压一般比数字IC能提供的更高，所以在使用之前也应该在IO处接入一个光耦-三极管放大电路或者直接接入一个三极管推完结构进行电流、电压放大，从而让弱输出能够驱动MOSFET</p>
<p>使用方法还挺像继电器的，但是二者的性能、功耗可不一样——MOSFET的开关频率比继电器高出两个数量级，功耗也比继电器低多了，同时还不会造成太大的电路噪声干扰，如果遇到需要隔离但是功率不大的情况，应该优先选择MOSFET而不是继电器</p>
<h3 id="功率半导体器件"><a href="#功率半导体器件" class="headerlink" title="功率半导体器件"></a>功率半导体器件</h3><p>简单说一下达林顿管和IGBT吧</p>
<p><strong>达林顿管=叠在一起的三极管</strong></p>
<p><strong>IGBT=叠在一起的三极管和MOSFET</strong></p>
<p>实际上的达林顿管是使用集成电路工艺制造的，将多个三极管制造在同一片晶圆上。但是还会针对PN结的性能进行优化。比较特殊的就是<strong>达林顿管的极性和前面三极管的极性保持一致</strong>，而不管后续接入的三极管是什么极性。因此前面的小管被称为达林顿<strong>基管</strong>；后面的小管被称为达林顿<strong>放大管</strong>。达林顿管以最前面小管的基极为整管基极，以最后接入的三极管发射极为整管发射极，<strong>最后的放大倍数是所有叠加的三极管放大倍数的乘积</strong><br>$$<br>\beta = \beta_1 \beta_2<br>$$<br>因此，达林顿管的功率、发热都会非常大，常用于驱动小型继电器、舵机、直流电机等等</p>
<p>IGBT则是典型的模拟集成电路结晶。博采众长，结合了三极管的低导通压降和MOS管的高输入阻抗，在不超过限制电压电流的情况下可以直接作为继电器使用——不过还是要注意，它的输出和输入之间还是存在耦合电阻的！</p>
<p>IGBT的结构就是一个三极管和一个MOSFET竖向叠起来，从MOSFET最上层两个隔开的栅极上引出IGBT的E极，MOSFET的P区同时作为三极管的B极P区，但是在三极管基础上多增加了一层B极N区和N缓冲区，主要用于存储电子，最下面一层是P+层，从它上面引出IGBT的C极</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210930000527652.png" alt="image-20210930000527652"></p>
<p>如上图所示（N沟道增强型IGBT），MOSFET部分的N+区称为<strong>源区</strong>，附于其上的电极称为源极，被引出作为IGBT的发射极E；N基极又称<strong>漏区</strong>D。为了区分IGBT和MOSFET，将同位置引出的G极翻译成<strong>门极</strong>，与MOSFET不同，IGBT的门极是悬浮在绝缘介质中的，并直接引出。沟道会在紧靠门极的边界形成。C、E两极之间的P型区（包括P+和P-区）被称为亚沟道区，事实上的沟道在这个区域形成。在漏区另一侧的P+区称为<strong>漏注入区</strong>，它是IGBT特有的功能区，与漏区和亚沟道区一起形成PNP双极型晶体管，起到其中发射极E的作用，向漏极注入空穴，进行导电调制，以降低器件的导通电压。最后，附于漏注入区上的电极称为漏极（也就是对应三极管的集电极C）。</p>
<p>IGBT的开关作用是通过<strong>加正向栅极电压形成沟道</strong>，<strong>给PNP</strong>（原来为NPN，但经过与IGBT耦合后，极性反转）<strong>晶体管提供基极电流，使IGBT导通</strong>。反之，可以加反向门极电压消除沟道，切断基极电流，使IGBT关断。IGBT的驱动方法和MOSFET基本相同，只需控制输入极N-沟道MOSFET即可，毕竟它控制的电流的第一步就是驱动一个栅极,所以IGBT具有高输入阻抗特性。当MOSFET的沟道形成后，从P+基极注入到N-层的空穴（少子）对N-层进行电导调制，减小N-层的电阻，使IGBT在高电压时也具有相对较低的导通电压</p>
]]></content>
      <tags>
        <tag>电路设计</tag>
      </tags>
  </entry>
</search>
