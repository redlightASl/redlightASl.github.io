<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Markdown基本语法</title>
    <url>/2021/11/14/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Markdown-基础语法"><a href="#Markdown-基础语法" class="headerlink" title="Markdown 基础语法"></a>Markdown 基础语法</h1><p>简单介绍一下Markdown的语法</p>
<p>可能需要一些latex基础来理解后面的Markdown内嵌LaTeX公式</p>
<p>部分hexo默认不支持的语法使用截图予以呈现</p>
<span id="more"></span>

<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>

<p>例：</p>
<h1 id="你好"><a href="#你好" class="headerlink" title="你好"></a>你好</h1><h2 id="你好-1"><a href="#你好-1" class="headerlink" title="你好"></a>你好</h2><h3 id="你好-2"><a href="#你好-2" class="headerlink" title="你好"></a>你好</h3><h4 id="你好-3"><a href="#你好-3" class="headerlink" title="你好"></a>你好</h4><h5 id="你好-4"><a href="#你好-4" class="headerlink" title="你好"></a>你好</h5><h6 id="你不好"><a href="#你不好" class="headerlink" title="你不好"></a>你不好</h6><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>Markdown 可以使用以下几种字体：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*斜体*</span><br><span class="line">_斜体_</span><br><span class="line">**粗体**</span><br><span class="line">__粗体__</span><br><span class="line">***粗斜体***</span><br><span class="line">___粗斜体___</span><br></pre></td></tr></table></figure>

<p>为了方便可以统一记为*是强调符号，一对为斜体，两对为更加强调的粗体，三对是非常强调的粗斜体</p>
<p>例：<br><em>苍茫的天涯是我的爱</em><br><em>月亮之上</em><br><strong>无他，唯手熟耳</strong><br><strong>1d100=100【大失败】</strong><br><em><strong>提桶跑路</strong></em><br><em><strong>讲个笑话，钓鱼佬今天没空军</strong></em></p>
<h2 id="高亮强调"><a href="#高亮强调" class="headerlink" title="高亮强调"></a>高亮强调</h2><p>用四个等于号=包围需要强调的内容即可实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==独轮车 tskk 独轮车==</span><br></pre></td></tr></table></figure>

<p>例：</p>
<p>==独轮车 tskk 独轮车==</p>
<p>注意：Hexo暂不支持高亮强调功能，所以上面的内容会显示错误，实际内容应该是下图所示</p>
<p><img src="/2021/11/14/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/image-20211114175616156.png" alt="image-20211114175616156"></p>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>用三个或以上*号单独成行表示分割线</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">***</span><br></pre></td></tr></table></figure>
<p>例：</p>
<hr>
<p>下面是【数据删除】个星号*写的，猜猜有什么特殊的地方？</p>
<hr>
<p>显然 用很多*写出分割线可以在代码层面增加你文章的气势，具体原因留给读者自行证明</p>
<h2 id="上标与下标"><a href="#上标与下标" class="headerlink" title="上标与下标"></a>上标与下标</h2><p>用两个^表示上标<br>用两个~表示下标</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1919^114514^</span><br><span class="line"> 今天~也是好天气~</span><br></pre></td></tr></table></figure>
<p>例：<br><img src="/2021/11/14/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/image-20211114180249618.png" alt="image-20211114180249618"></p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--注释内容--&gt;</span><br></pre></td></tr></table></figure>
<p>表示注释<br>例：</p>
<!--肖战必糊-->
<p>虽然什么也没有显示<br>但这里确实有注释，我也并没有在注释里骂人</p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>Markdown 支持有序列表和无序列表。</p>
<p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 第一项</span><br><span class="line">* 第二项</span><br><span class="line">* 第三项</span><br><span class="line"></span><br><span class="line">+ 第一项</span><br><span class="line">+ 第二项</span><br><span class="line">+ 第三项</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 第一项</span><br><span class="line">- 第二项</span><br><span class="line">- 第三项</span><br></pre></td></tr></table></figure>
<p>例：</p>
<ul>
<li>第一项</li>
</ul>
<ul>
<li>第二项</li>
</ul>
<ul>
<li>第三项</li>
</ul>
<p>为了记忆简单，可统一记为*后面接空格意味着一个无序列表项</p>
<hr>
<p>有序列表使用数字并加上 . 号来表示，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 第一项</span><br><span class="line">2. 第二项</span><br><span class="line">3. 第三项</span><br></pre></td></tr></table></figure>
<p>例：</p>
<ol>
<li>amdyes!</li>
<li>nvidia!fxxkyou!</li>
<li>intel还在做cpu？</li>
</ol>
<h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个<strong>空格</strong>符号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 区块引用</span><br><span class="line">&gt; 衬衫的价格是9镑15便士</span><br><span class="line">&gt; 下面你将听到</span><br></pre></td></tr></table></figure>

<p>另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 最外层</span><br><span class="line">&gt;&gt; 第一层嵌套</span><br><span class="line">&gt;&gt;&gt; 第二层嵌套</span><br></pre></td></tr></table></figure>

<h3 id="列表中使用区块"><a href="#列表中使用区块" class="headerlink" title="列表中使用区块"></a>列表中使用区块</h3><p>如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 第一项</span><br><span class="line">    &gt; 传统markdown要讲码德</span><br><span class="line">    &gt; 在这里劝这位年轻码农耗子尾汁</span><br><span class="line">* 第二项</span><br><span class="line">	&gt; 芜湖</span><br><span class="line">	&gt; &gt; 起飞 &lt;!--中间加不加空格都行--&gt;</span><br><span class="line">	&gt;&gt;&gt; 飞飞飞</span><br></pre></td></tr></table></figure>

<ul>
<li>第一项<blockquote>
<p>传统markdown要讲码德<br>在这里劝这位年轻码农耗子尾汁</p>
</blockquote>
</li>
<li>第二项<blockquote>
<p>芜湖</p>
<blockquote>
<p>起飞<!--中间加不加空格都行--><br>are u good 马来西亚</p>
<blockquote>
<p>飞飞飞</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`printf()` 函数</span><br></pre></td></tr></table></figure>

<h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><p>代码区块使用 <strong>4 个空格</strong>或者一个<strong>制表符（Tab 键）</strong>。</p>
<p>也可以用 ```包裹一段代码，并指定一种语言（也可以不指定）：</p>
<p>在大多数Markdown编辑器中，```旁边可以加语言名字添加对应的语法高亮</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```javascript</span><br><span class="line">$(document).ready(function () &#123;</span><br><span class="line">    alert(&#x27;RUNOOB&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 链接</span><br><span class="line"></span><br><span class="line">链接使用方法如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80">链接名称</a></p>
<p>或者</p>
<p>&lt;链接地址&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">例如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 哦我的老伙计，瞧瞧这条链接<br>  <a href="https://www.runoob.com/">感谢菜鸟教程提供部分资料（其实是大部分）</a><br> 或<a href="https://wosuibianzhaogewangzhan.com/">https://wosuibianzhaogewangzhan.com</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[感谢菜鸟教程提供部分资料（其实是大部分）](https://www.runoob.com)</span><br><span class="line"></span><br><span class="line">或&lt;https://wosuibianzhaogewangzhan.com&gt;</span><br><span class="line"></span><br><span class="line">### 高级链接</span><br><span class="line"></span><br><span class="line">可以通过变量来设置一个链接，变量赋值在文档末尾进行：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>用 1 作为网址变量 <a href="http://www.pornhub.com/">pxxnhub</a><br>用 rua 作为网址变量 <a href="https://space.bilibili.com/15810">Rua</a><br>然后在文档的结尾为变量赋值（网址）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[pxxnhub][1]</span><br><span class="line">[Rua][rua]</span><br><span class="line"></span><br><span class="line">[1]: http://www.pornhub.com/</span><br><span class="line">[rua]: https://space.bilibili.com/15810</span><br><span class="line">## 图片</span><br><span class="line"></span><br><span class="line">Markdown 图片语法格式如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/14/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/%E6%88%91%E4%B9%9F%E4%B8%8D%E7%9F%A5%E9%81%93%E8%AF%A5%E6%94%BE%E4%BB%80%E4%B9%88%EF%BC%8C%E7%9E%8E%E5%86%99%E5%90%A7" alt="介写了个嘛玩意"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 开头一个感叹号 !</span><br><span class="line">- 接着一个方括号，里面放上图片的替代文字</span><br><span class="line">- 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 &#x27;title&#x27; 属性的文字。</span><br><span class="line"></span><br><span class="line">//抱歉没有例子，奇怪的图片发出来的话，人生就要结束了（悲）</span><br><span class="line"></span><br><span class="line">Markdown 还没有办法指定图片的高度与宽度，如果需要的话，可以使用普通的 \&lt;img\&gt; 标签。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img src="/2021/11/14/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/原文这里是runoob的一张图" width="50%">
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 表格</span><br><span class="line"></span><br><span class="line">Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。</span><br><span class="line"></span><br><span class="line">语法格式如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
![image-20211114180218183](Markdown基本语法.assets/image-20211114180218183.png)

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 对齐方式</span><br><span class="line"></span><br><span class="line">**我们可以设置表格的对齐方式：**</span><br><span class="line"></span><br><span class="line">* -: 设置内容和标题栏居右对齐。</span><br><span class="line">* :- 设置内容和标题栏居左对齐。</span><br><span class="line">* :-: 设置内容和标题栏居中对齐。</span><br><span class="line">例：</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/14/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/image-20211114180140933.png" alt="image-20211114180140933"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## HTML 元素</span><br><span class="line"></span><br><span class="line">不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</span><br><span class="line"></span><br><span class="line">目前支持的 HTML 元素有：`&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;`等 ，如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑</span><br><span class="line"></span><br><span class="line">## 转义</span><br><span class="line"></span><br><span class="line">Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>文本加粗</strong><br>** 正常显示星号 **</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>\   反斜线<br>`   反引号</p>
<ul>
<li>  星号<br>_   下划线<br>{}  花括号<br>[]  方括号<br>()  小括号<h1 id="井字号"><a href="#井字号" class="headerlink" title="井字号"></a>井字号</h1></li>
</ul>
<ul>
<li>  加号</li>
</ul>
<ul>
<li>  减号<br>.   英文句点<br>!   感叹号<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 公式</span><br><span class="line"></span><br><span class="line">当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。</span><br><span class="line"></span><br><span class="line">不过这个东西和渲染器有关，对于不同编辑器可能会不支持某些latex特性</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
$$<br>思考题：\lim_{x\rarr 0}\frac{tanx}{x+sinx} =?<br>$$</li>
</ul>
<p>$$<br>\frac{dx}{dt}=v<br>\mathbf{V}_1 \times \mathbf{V}_2<br>$$</p>
<pre><code>
$$
思考题：\lim_&#123;x\rarr 0&#125;\frac&#123;tanx&#125;&#123;x+sinx&#125; =?
$$

$$
\frac&#123;dx&#125;&#123;dt&#125;=v
\mathbf&#123;V&#125;_1 \times \mathbf&#123;V&#125;_2
$$

## 非常感谢菜鸟教程runoob.com提供了好多代码，本人也是在这学的markdown
 链接如下：

[菜鸟教程](https://www.runoob.com)
 十分适合新手学习各种语言和开发技巧，虽然讲解思路比较跳跃，但胜在详细
</code></pre>
]]></content>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>Tcl脚本基础</title>
    <url>/2021/11/14/Tcl%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Tcl脚本在IC领域的主要用途"><a href="#Tcl脚本在IC领域的主要用途" class="headerlink" title="Tcl脚本在IC领域的主要用途"></a>Tcl脚本在IC领域的主要用途</h1><h2 id="复杂文本处理"><a href="#复杂文本处理" class="headerlink" title="复杂文本处理"></a>复杂文本处理</h2><p>Tcl可以把文本中的每一行变为一个<strong>列表</strong>，最简单的列表就是包含由任意个空格、制表符、换行符分隔开的任意多个元素的字符串，可以直接根据元素编号来获取字符串内容</p>
<p>Tcl也支持正则表达式</p>
<span id="more"></span>

<h2 id="自动化执行flow"><a href="#自动化执行flow" class="headerlink" title="自动化执行flow"></a>自动化执行flow</h2><p>对于一些流程化的flow，可以编写Tcl脚本来自动执行，一键得到结果和report</p>
<h2 id="辅助EDA开发"><a href="#辅助EDA开发" class="headerlink" title="辅助EDA开发"></a>辅助EDA开发</h2><p>Tcl易上手、使用简便，可以简便地设计图形化界面；也可以针对大型项目设计EDA辅助工具</p>
<h1 id="Tcl脚本简介"><a href="#Tcl脚本简介" class="headerlink" title="Tcl脚本简介"></a>Tcl脚本简介</h1><p>Tcl即Tool command language工具控制语言，读作Tickle</p>
<p>Tcl包含了一个脚本语言和一个库包：Tcl脚本主要用于发布命令给交互程序，语法简单、扩展性强；Tcl库可以被嵌入应用程序，它包含了一个分析器、用于执行内建命令的例程和一个可以允许用户扩充的库函数。使用Tcl库，应用程序可以产生Tcl命令并执行，命令可以由用户产生，也可以从用户接口的输入中读取，Tcl库收到命令后将他分解并执行内建的命令。</p>
<p>目前大部分EDA工具都支持Tcl语言，如Design Complier、quartus、Synplify、modesim、finesim等，Tcl在IC设计中非常常用</p>
<p>Tcl程序有两种运行方式，一种是将程序写入脚本中，通常以.tcl命名；另一种是在tcl命令行中直接执行</p>
<h2 id="Tcl解释器"><a href="#Tcl解释器" class="headerlink" title="Tcl解释器"></a>Tcl解释器</h2><p>Tcl是解释型语言，与Python、Perl等类似，它依靠Tcl脚本语言解释器工作，逐行执行Tcl命令，遇到错误时它会停止运行</p>
<p>helloworld程序如下：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/tclsh</span></span><br><span class="line"><span class="keyword">puts</span> <span class="string">&quot;helloworld&quot;</span></span><br></pre></td></tr></table></figure>

<p>在shell中如下执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tclsh hello.tcl <span class="comment"># Unix</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> tclsh hello.tcl <span class="comment"># Windows</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Tcl数据类型"><a href="#Tcl数据类型" class="headerlink" title="Tcl数据类型"></a>Tcl数据类型</h2><p>Tcl只支持<strong>字符串</strong>数据类型：所有命令、参数、命令结果、变量等都是字符串</p>
<p><strong>字符串的实际解释依赖于上下文</strong></p>
<p>Tcl允许使用字符串组合出多种高级数据类型</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/tclsh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> a hello</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$a</span></span><br><span class="line"><span class="keyword">set</span> b <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="keyword">set</span> c &#123;hello world&#125;</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$b</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$c</span> # 这里b和c打印的值都是 hello world</span><br></pre></td></tr></table></figure>

<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p><strong>使用一组单词与双引号、中括号或者大括号的组合表示列表</strong>，如下所示：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/tclsh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> myVariable &#123;red green blue&#125; # <span class="keyword">set</span> listName [<span class="keyword">list</span> item1 item2 item3] 中括号、大括号都可以</span><br><span class="line"><span class="keyword">puts</span> [<span class="keyword">lindex</span> <span class="variable">$myVariable</span> <span class="number">2</span>]</span><br><span class="line"><span class="keyword">set</span> myVariable <span class="string">&quot;red green blue&quot;</span></span><br><span class="line"><span class="keyword">puts</span> [<span class="keyword">lindex</span> <span class="variable">$myVariable</span> <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>注意：<strong>Tcl的列表以0为第一个元素的坐标</strong>，所以以上输出为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> blue</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> green</span></span><br></pre></td></tr></table></figure>

<p>使用<code>append</code>或<code>lappend</code>命令追加项目到列表</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">append</span> 列表名 原来的项目 追加项目 # 或 <span class="keyword">lappend</span> 列表名 追加项目</span><br></pre></td></tr></table></figure>

<p>使用<code>llength</code>变量控制列表的长度</p>
<p>使用<code>lsort</code>命令排序列表</p>
<p>使用<code>lreplace</code>替换列表项，如下所示</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/tclsh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> var &#123;orange blue red green&#125;</span><br><span class="line"><span class="keyword">set</span> var [<span class="keyword">lreplace</span> <span class="variable">$var</span> <span class="number">2</span> <span class="number">3</span> black white]</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$var</span> # 输出 orange blue black white （第<span class="number">3</span>、<span class="number">4</span>个列表项被替换为了black、white）</span><br></pre></td></tr></table></figure>

<p>使用<code>lassign</code>将列表的值赋值给变量，如下所示</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/tclsh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> var &#123;orange blue red green&#125;</span><br><span class="line"><span class="keyword">lassign</span> <span class="variable">$var</span> colour1 colour2</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$colour1</span> # 输出 orange</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$colour2</span> # 输出 blue</span><br></pre></td></tr></table></figure>

<h3 id="关联数组（字典）"><a href="#关联数组（字典）" class="headerlink" title="关联数组（字典）"></a>关联数组（字典）</h3><p>可以使用以下形式创建关联数组，或者说<strong>键值对（字典）</strong></p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/tclsh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>  marks(english) <span class="number">80</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$marks</span>(english) # 输出 <span class="number">80</span></span><br><span class="line"><span class="keyword">set</span>  marks(mathematics) <span class="number">90</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$marks</span>(mathematics) # 输出 <span class="number">90</span></span><br></pre></td></tr></table></figure>

<p>特别地，<strong>Tcl的键值对不要求索引（键）是整数</strong></p>
<p>使用<code>dict set 字典名 键 值</code>来格式化创建字典</p>
<p>使用<code>dict size</code>获取字典的大小</p>
<p>使用以下方法遍历字典</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/tclsh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> colours [<span class="keyword">dict</span> create colour1 <span class="string">&quot;black&quot;</span> colour2 <span class="string">&quot;white&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> item [<span class="keyword">dict</span> keys <span class="variable">$colours</span>] &#123;</span><br><span class="line">    <span class="keyword">set</span> value [<span class="keyword">dict</span> get <span class="variable">$colours</span> <span class="variable">$item</span>]</span><br><span class="line">    <span class="keyword">puts</span> <span class="variable">$value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或以下方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/tclsh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> colours [<span class="keyword">dict</span> create colour1 <span class="string">&quot;black&quot;</span> colour2 <span class="string">&quot;white&quot;</span>]</span><br><span class="line"><span class="keyword">set</span> values [<span class="keyword">dict</span> values <span class="variable">$colours</span>]</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$values</span></span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> black</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> white</span></span><br></pre></td></tr></table></figure>

<p>使用以下方法(<code>dict exists</code>)检索字典</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/tclsh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> colours [<span class="keyword">dict</span> create colour1 <span class="string">&quot;black&quot;</span> colour2 <span class="string">&quot;white&quot;</span>]</span><br><span class="line"><span class="keyword">set</span> result [<span class="keyword">dict</span> exists <span class="variable">$colours</span> colour1]</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$result</span> # 输出 <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h3><p>TCL句柄通常用于表示文件和图形对象，也可以包括句柄网络请求以及其它流设备，如串口、套接字或I/O设备</p>
<p>使用例如下</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> myfile [<span class="keyword">open</span> <span class="string">&quot;filename&quot;</span> r]</span><br></pre></td></tr></table></figure>

<h2 id="Tcl基本语法"><a href="#Tcl基本语法" class="headerlink" title="Tcl基本语法"></a>Tcl基本语法</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>使用<code>#</code>作为单行注释</p>
<p>如果第一个非空字符是<code>#</code>，这一行的所有东西都是注释</p>
<p>特别地，可以使用条件判断语句作为多行注释，不过这样会影响代码可读性</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下面是多行注释</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">0</span> &#123;</span><br><span class="line">这里是注释</span><br><span class="line">这里也是注释</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">puts</span> <span class="string">&quot;test&quot;</span> <span class="comment">;# 这里是行内注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是单行注释</span></span><br></pre></td></tr></table></figure>

<h3 id="标示符"><a href="#标示符" class="headerlink" title="标示符"></a>标示符</h3><p>Tcl标识符是用来标识变量，函数，或任何其它用户定义的项目的名称。标识符开始以字母A到Z或a〜z或后跟零个或多个字母下划线（_），下划线，美元（$）和数字（0〜9），Tcl不允许标点字符，如@和％标识符，但可以使用转义或<code>&#123;&#125;</code>括起来使用标点字符；<strong>Tcl大小写敏感</strong></p>
<p><strong>Tcl的保留字不能用做变量名</strong></p>
<h3 id="空格与分隔"><a href="#空格与分隔" class="headerlink" title="空格与分隔"></a>空格与分隔</h3><p>Tcl解释器会忽略多余的<strong>空白格</strong>与注释行</p>
<p>Tcl中将<strong>空格、制表符</strong>、换行符、注释统称为<strong>空白格</strong>。空格分开声明中的一个组成部分，使解释器来识别</p>
<p>总体与shell脚本类似，格式自由</p>
<p><strong>Tcl中句与句之间以换行或分号分隔。如果每行只有一个语句，则分号不是必须的；如果一行中只包含空白格、注释，解释器则会忽略该行；在一个语句中，通过空格来分隔语句的不同部分</strong></p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>Tcl命令实际上是词语的列表。使用要执行表示该命令的第一个字</p>
<p>Tcl命令有以下特点：</p>
<ul>
<li>一个命令就是一个字符串</li>
<li><strong>命令用换行符或分号来分隔</strong></li>
<li>一个命令由许多的<strong>域</strong>组成，第一个域是命令名，剩下的域作为参数</li>
<li><strong>域通常由空格或制表符分割</strong></li>
</ul>
<h3 id="引用与替换"><a href="#引用与替换" class="headerlink" title="引用与替换"></a>引用与替换</h3><p>如下方法引用变量：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">$变量名</span><br></pre></td></tr></table></figure>

<p>如下方法展开命令或调用过程的值</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">[命令或调用过程]</span><br></pre></td></tr></table></figure>

<p>使用<code>\</code>将特殊字符转义</p>
<p>使用如下方法展开<code>[]</code>、<code>$</code>、<code>\</code>语句的内容</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;要展开使用内容&quot;</span></span><br></pre></td></tr></table></figure>

<p>使用如下方法将内容作为一个整体使用（但内部的特殊字符不会被展开或转义）</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">&#123;作为整体使用的内容&#125;</span><br></pre></td></tr></table></figure>

<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>使用<code>expr</code>表示后面的式子是数学表达式</p>
<p><strong>Tcl默认精度是12位</strong>，可以使用<code>tcl_precision</code>改变精度</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/tclsh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> variableA <span class="string">&quot;10&quot;</span></span><br><span class="line"><span class="keyword">set</span> tcl_precision <span class="number">5</span></span><br><span class="line"><span class="keyword">set</span> result [<span class="keyword">expr</span> <span class="variable">$variableA</span> / <span class="number">9.0</span>];</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$result</span> # 输出 <span class="number">1.1111</span></span><br></pre></td></tr></table></figure>

<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>使用<code>set</code>对变量进行赋值，使用<code>$</code>引用变量</p>
<p>综合示例如下：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/tclsh</span></span><br><span class="line"><span class="keyword">set</span> a <span class="number">114514</span><span class="comment">; # 把114514赋值给a</span></span><br><span class="line"><span class="keyword">set</span> b &#123;<span class="variable">$a</span>&#125;<span class="comment">; # 把$a赋值给b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">puts</span> <span class="string">&quot;test!&quot;</span><span class="comment">; # 打印出test!</span></span><br><span class="line"><span class="keyword">puts</span> a<span class="comment">; # 打印出字符a</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$a</span><span class="comment">; # 打印出114514</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$b</span><span class="comment">; #打印出$a 注意并不是114514</span></span><br></pre></td></tr></table></figure>

<p>字符串赋值见Tcl数据类型</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ol>
<li>算术运算符</li>
</ol>
<p>支持+ - * / %</p>
<p>与c一样</p>
<ol start="2">
<li>关系运算符</li>
</ol>
<p>与c一样</p>
<ol start="3">
<li>逻辑运算符</li>
</ol>
<p>与c一样</p>
<ol start="4">
<li>位运算符</li>
</ol>
<p>与c一样</p>
<ol start="5">
<li>三元运算符</li>
</ol>
<p>与c一样</p>
<ol start="6">
<li>运算符优先级</li>
</ol>
<table>
<thead>
<tr>
<th>分类</th>
<th>运算符</th>
<th>结合性</th>
</tr>
</thead>
<tbody><tr>
<td>正负号</td>
<td>+ -</td>
<td>Right to left</td>
</tr>
<tr>
<td>乘除法</td>
<td>* / %</td>
<td>Left to right</td>
</tr>
<tr>
<td>加减法</td>
<td>+ -</td>
<td>Left to right</td>
</tr>
<tr>
<td>移位</td>
<td>&lt;&lt; &gt;&gt;</td>
<td>Left to right</td>
</tr>
<tr>
<td>关系</td>
<td>&lt; &lt;= &gt; &gt;=</td>
<td>Left to right</td>
</tr>
<tr>
<td>位与</td>
<td>&amp;</td>
<td>Left to right</td>
</tr>
<tr>
<td>位异或</td>
<td>^</td>
<td>Left to right</td>
</tr>
<tr>
<td>位或</td>
<td>|</td>
<td>Left to right</td>
</tr>
<tr>
<td>Logical AND</td>
<td>&amp;&amp;</td>
<td>Left to right</td>
</tr>
<tr>
<td>逻辑或</td>
<td>||</td>
<td>Left to right</td>
</tr>
<tr>
<td>三元</td>
<td>?:</td>
<td>Right to left</td>
</tr>
</tbody></table>
<p>总体上来说和c语言运算符一致</p>
<h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><p>Tcl的if语法如下：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> &#123;布尔表达式&#125; &#123;</span><br><span class="line"><span class="comment">	# 表达式</span></span><br><span class="line">&#125; else <span class="keyword">if</span> &#123;布尔表达式&#125; &#123;</span><br><span class="line"><span class="comment">	# 表达式</span></span><br><span class="line">&#125; else <span class="keyword">if</span> &#123;布尔表达式&#125; &#123;</span><br><span class="line"><span class="comment">	# 表达式</span></span><br><span class="line">&#125; else <span class="keyword">if</span> &#123;布尔表达式&#125; &#123;</span><br><span class="line"><span class="comment">	# 表达式</span></span><br><span class="line">&#125; else &#123;</span><br><span class="line"><span class="comment">	# 表达式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和c语言不能说差别不大，只能说完全一样</p>
<p>甚至也可以使用switch语句</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> switchingString &#123;</span><br><span class="line">   matchString1 &#123;</span><br><span class="line">      body1</span><br><span class="line">   &#125;</span><br><span class="line">   matchString2 &#123;</span><br><span class="line">      body2</span><br><span class="line">   &#125;</span><br><span class="line">...</span><br><span class="line">   matchStringn &#123;</span><br><span class="line">      bodyn</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch语句也可以嵌套</p>
<p>循环语句则分成2种，和c语言一样的for与while，但是没有do while</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> &#123;condition&#125; &#123;</span><br><span class="line">   statement(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;initialization&#125; &#123;condition&#125; &#123;increment&#125; &#123;</span><br><span class="line">   statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>Tcl支持自定义函数，称为<strong>过程</strong>，语法如下</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">proc</span> 过程名 &#123;参数<span class="number">1</span> 参数<span class="number">2</span> ...&#125;</span><br><span class="line">&#123;	过程体</span><br><span class="line"><span class="keyword">return</span> 返回值&#125;</span><br></pre></td></tr></table></figure>

<p>参数之间用空白格分开</p>
<p>函数支持递归调用</p>
<p>不支持在函数内部定义函数</p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>Tcl支持内嵌正则表达式，<strong>正则表达式以命令形式使用</strong></p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/tclsh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">regexp</span> &#123;([A-Z,a-z]*)&#125; <span class="string">&quot;Tcl Tutorial&quot;</span> a b </span><br><span class="line"><span class="keyword">puts</span> <span class="string">&quot;Full Match: $a&quot;</span></span><br><span class="line"><span class="keyword">puts</span> <span class="string">&quot;Sub Match1: $b&quot;</span></span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line">Full Match:Tcl</span><br><span class="line">Sub Match1:Tcl</span><br></pre></td></tr></table></figure>

<p>Tcl提供了一些参数用于简便使用正则表达式</p>
<ul>
<li>-nocase 忽略大小写</li>
<li>-indices 匹配子模式，而不是匹配字符存储的位置</li>
<li>-line 新行敏感匹配。换行后忽略字符</li>
<li>-start index 搜索模式开始设置偏移</li>
</ul>
]]></content>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>《可定制计算》阅读笔记</title>
    <url>/2021/11/14/%E3%80%8A%E5%8F%AF%E5%AE%9A%E5%88%B6%E8%AE%A1%E7%AE%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="《可定制计算》阅读笔记"><a href="#《可定制计算》阅读笔记" class="headerlink" title="《可定制计算》阅读笔记"></a>《可定制计算》阅读笔记</h1><p>本笔记以基础概念为线索编写，黑体部分是关键字</p>
<span id="more"></span>

<ul>
<li><p><strong>登纳德缩放定律</strong>：晶体管在满足内电场恒定（即每代芯片的供电电压降低30%）条件下，晶体管尺寸每代（约两年）减少30%。</p>
<p>  结合该定律和摩尔定律可得推论：晶体管密度每代翻倍，同时晶体管延时降低30%，功耗降低50%，能耗降低65%</p>
<p>  换句话说，同面积下能集成晶体管的数目翻倍，带来功耗和频率的翻倍，就好像同面积的电路被缩放到原来的1/4</p>
<p>  但是到21世纪早期，由于量子效应，晶体管漏电功耗显著增加，登纳德定律逐渐失效</p>
</li>
<li><p><strong>定制计算</strong>：调整处理器结构以使其适应于某种特定应用领域的技术</p>
<p>  面对登纳德缩放定律失效、摩尔定律放缓，定制计算技术成为提高计算效率的关键技术之一</p>
<p>  往往可重构的定制计算电路可以使得能效得到1~2个数量级提升；而专用于某个领域的定制计算电路有时能够实现数百万倍的能效提升；同时引入<em>可重构性</em>并利用<em>可整合</em>的硬件加速其可以解决适用范围过窄的问题，现在常见的DSA（异构计算）就是这个思路的延伸</p>
</li>
<li><p><strong>暗硅</strong>：在多核cpu中并不是所有核心都会被使用，往往同时工作的只有其中小部分核心，其他核心因为功耗、发热等问题往往得不到应用，这部分电路被称为暗硅</p>
</li>
<li><p><strong>通用片上多处理器</strong>（Chip MultProcessor，CMP）：具有通用性的计算处理器，常见的CPU，如i9 11900k、r5 5600x等具有多核心的桌面级cpu都属于这个类型</p>
</li>
<li><p><strong>可定制异构平台</strong>（Customizable Heterogeneous Platform，CHP）：用于提供定制化计算服务的可定制的SoC</p>
<p>  一般CHP中包含四个部件：</p>
<ul>
<li>用于通用计算和控制逻辑的<strong>处理器核</strong></li>
<li>用于定制计算的硬件<strong>加速器</strong></li>
<li>用于辅助计算和低功耗控制的<strong>协处理器</strong></li>
<li>存储数据和程序的<strong>片上存储部件</strong></li>
</ul>
</li>
<li><p><strong>可重构硬件</strong>：流片之后依然可以被灵活调整的硬件</p>
<p>  硬件可以被重构的程度取决于重构的粒度，越小的重构粒度灵活性越大，但一般会造成性能下降和能效降低等额外开销</p>
<p>  传统的可重构硬件只有FPGA一种，它算作可细粒度重构的硬件，因此会比同算法的ASIC实现有更低的速率和更高的开销</p>
</li>
<li><p><strong>专用加速器</strong>：针对特定领域内有限的一组应用或算法进行优化的硬件</p>
<p>  早期的GPU、图像数据编解码器、加解密加速器等都属于加速器</p>
</li>
<li><p><strong>动态处理器核缩放和去特征化</strong>：选择性停用处理器核中的部件来节省能耗</p>
<p>  通用的做法是在内核中引入特定机器的寄存器，用来指示特定部件是否激活</p>
<p>  stm32f4的dsp和fpu就使用了这样的技术</p>
</li>
<li><p><strong>处理器核融合</strong>：使一个大核能够像真正的许多小核叠加工作一样的体系结构，可以动态适应不同数量的线程级或指令级的并行处理</p>
<p>  通过将处理器核拆成两部分实现：一个是窄发射宽度的常规处理器核，但是它的取指模块（Fetch Module）会被舍弃；另一部分是充当模块化的取指/译码/派发模块的额外部件，负责为每个处理器核心执行取指指令，或统一为多个处理器核提供指令。取指模块会使用宽读取引擎读取整个指令块并将它们分发给各个核心，流水线结束后，通过一个排序流水线步骤来让指令顺序写回</p>
</li>
<li><p><strong>定制指令集扩展</strong>：用特定工作负载中的新指令来让处理器快速分派任务到计算模块</p>
<p>  intel的AVX-512指令集就是这样增强CPU性能的（可惜并不怎么实用）</p>
<p>  商用处理器常使用的就是像SSE和AVX这种专用<em>向量指令</em>形式，允许简单的指令操作大量数据。现代高性能处理器一般都采用超标量架构，它能够实现指令集层面的并行化处理，利用的是<strong>单指令多数据流</strong>（SIMD）指令，也就是所谓的向量指令。为了通过一个指令控制多个数据的处理，需要引入一组新的寄存器和一组用于执行向量并行计算的ALU。x86指令集中，向量指令在4~16个元素的小向量上运行，主要用于执行浮点运算。超标量处理器还引入了基于通道的设计：多个小型计算引擎和寄存器元素并行参与计算，发出一条向量指令，所有通道都会接收该指令，因此可以并行化地执行大量重复计算的任务</p>
<p>  定制扩展指令集还可以通过<em>定制计算引擎</em>实现——一般的ALU只有乘法、加法、移位等功能，但是可以通过改变流水线的方式塞进乘除法器乃至专用的矩阵点乘叉乘电路</p>
<p>  <em>可重构指令集</em>也是其中一个解决方案，它允许程序编写自己的指令，但是往往需要编译器对定制指令支持才可行</p>
</li>
<li><p><strong>松耦合加速器</strong>：独立于处理器内核运行的粗粒度加速器，是与核心交互但是不固定在核上的粗粒度计算引擎，简称LCA</p>
<p>  LCA可以部署在片上或片外，PC上的cpu+显卡组合就是一个广义上的LCA架构；片上LCA没有物理邻接某个特定核心，但是可以被系统中所有核心共享，LCA通过一个简单快速的控制逻辑电路（最常见的就是DMA）拉控制数据输入输出。但是LCA只能使用ASIC方式实现，这就导致LCA必须具有以下特性：1. 算法足够成熟；2. 算法需要算力较大或比较重要。DPU、APU等针对AIoT领域的SoC就可以理解成采用了LCA架构</p>
<p>  多核共享的LCA需要加入仲裁开销，一般存在软件和硬件两种仲裁方法。</p>
<p>  特别地，LCA不依赖编译器，而依赖开放给开发者的API，比如OpenCL就是一种面向通用计算的API架构；而Cuda-C++是NVidia开发的针对自家GPU的API接口；其他的硬件加速设备也会有针对性的接口，最大的阻碍就是它们往往不兼容</p>
<p>  LCA最大的缺点不在于因为不耦合于内核，往往存在较大延时；而在于只能使用ASIC形式实现，导致它的功能固定。</p>
<p>  IBM推出的线速处理器（WSP）就是一种含有LCA的处理器</p>
</li>
<li><p><strong>现场可编程硬件</strong>：为通用性牺牲一些效率和性能的超细粒度可重构电路</p>
<p>  使用FPGA可以实现类似LCA的功能，但它们往往更加灵活，但相对应的性能和效率有所损失。因为HLS技术的成熟，现在FPGA硬件加速的开发变得相对快捷不少。Zynq平台上的高带宽硬件加速也是当前发展方向之一</p>
</li>
<li><p><strong>粗粒度可重构阵列</strong>：具有接近ASIC性能和具有一定可重构性的组合加速器，也就是CGRA组合加速器</p>
<p>  它试图中和LCA和FPGA，通过一组粗粒度部件及其互联机制，能够使得CGRA在可编程的基础上实现接近LCA的效率和开销。从概念上说，CGRA是含有小型加速器，而不是LUT（查找表）的FPGA</p>
<p>  许多CGRA的工作聚焦于资源的<em>静态映射</em>：计算单元之间的互联通信通过离线计算完成，或作为编译过程的一部分，这样可以尽可能提高运行效率；同时CGRA还具有硬件加速器资源虚拟化的特点——在编写程序时可以直接使用高级语言，编译器负责将其直接映射到具体器件的连接。从程序映射的角度，CGRA是一个全连接的计算引擎集，将计算映射到这样的一个体系架构上非常简单</p>
<p>  不过这也使得它难以用Cuda或Verilog的思路编程——电路是不能修改的，开发者只能通过配置CGRA中加速引擎的互联逻辑实现编程；反过来讲，它可以高效实现算法加速，并且由于组成加速器的部件较少，这些部件到硬件按资源的映射过成也相对容易，更可贵的是内部空间利用率达到较高的程度。<em>动态映射</em>可以在运算时实现较高的效率——计算引擎根据需要实现的算法动态更改计算模块之间的连接拓扑，这是基于CGRA具有<em>全连接特性</em></p>
<blockquote>
<p>CGRA计算架构通过空域硬件结构组织不同粒度和不同功能的计算资源，通过硬件运行时配置，调整硬件功能，根据数据流的特点，让功能配置好的硬件资源互连形成相对固定的计算通路，从而以接近“专用电路”的方式进行数据驱动下的计算</p>
<p>CGRA的全连接特性是指计算模块可以在任意邻接模块之间建立动态连接</p>
</blockquote>
<p>  CGRA的实现还处在起步阶段，现在的开发主要依靠实验室，主要原因在于比起FPGA，CGRA更加依赖生态和编译器。目前一个典型的CGRA架构被称为CHARM，它使用一种称为加速器块设计（ABC）的硬件资源管理机制，它管理一些小的计算模块，被称为ABB（加速器构建模块），ABB以类似FPGA的岛形分布在片上，每个岛内部包含DMA、便签式存储器SPM、实现岛内互联的内部网络和实现岛间通信的网络接口。传统核心通过将描述ABB非循环通信图的配置写入普通共享内存中以调用加速器，然后ABC会根据ABB图最大限度提高新实例化的加速器性能，并为每个参与的ABB分配一些任务。为了进一步提升性能，ABB会继续调度加速器的其他实例直到资源用完或任务完成</p>
</li>
<li><p><strong>高速缓存</strong>：现代处理器中往往使用高速缓存（cache）来降低数据访问延时，并通过数据重用提高系统存储带宽。具有较高空间/时间局部性的数据块可以保存在高速缓存中，它通常使用硬件自动管理。高速缓存主要由两个块构成：<em>标签阵列</em>和<em>数据阵列</em>。</p>
<p>  标签阵列用于检查请求的数据块是否位于数据阵列中，数据阵列用于存储具体数据。</p>
</li>
<li><p><strong>便签式存储器</strong>：由软件管理的缓冲区（buffer），缓冲区是指能够使用硬件或软件进行管理的FIFO、堆栈或RAM组</p>
<p>  便签式存储器具有高速缓存不具有的以下优势：</p>
<ul>
<li><em>可编程性</em>：方便软件开发者使用，可以作为处理器核的近存储器（near memory）进行软件编程；也可作为专用处理器核或者硬件加速器的近存储器，使得程序员不需要担心底层的管理策略（由硬件状态机完成），只需要通过软件进行性能优化就可以提供更高自由度的缓冲区管理策略</li>
<li>可预测的访问延迟：由于高速缓存块是由通用的替换策略管理的，因此高速缓存的访问延迟很难预测，以至于经常出现<code>cache miss</code>的情况；但是便签式存储器可以保证在编译器优化下实现优化的数据重用来避免下一级存储器访问造成的性能下降</li>
<li>低功耗、小面积：高速缓存所使用的标签阵列和比较逻辑电路往往需要更大的面积；但便签式存储器只需要一个状态机进行控制，因此它能够减小使用的面积并减小动态功耗</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>机器学习与机器视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>多级放大器简介</title>
    <url>/2021/11/14/%E5%A4%9A%E7%BA%A7%E6%94%BE%E5%A4%A7%E5%99%A8%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="多级放大器"><a href="#多级放大器" class="headerlink" title="多级放大器"></a>多级放大器</h1><p>常见的共射放大电路放大系数$\beta_V=-\frac{\beta R_{C}}{R_{b1}}$</p>
<span id="more"></span>

<h2 id="耦合方式"><a href="#耦合方式" class="headerlink" title="耦合方式"></a>耦合方式</h2><p>将多个单级基本放大电路合理连接即构成多级放大电路</p>
<p>组成多级放大电路的每个基本电路称为一<strong>级</strong>，级与级之间的连接称为<strong>级间耦合</strong></p>
<p>有下列四种常见的耦合方式</p>
<ul>
<li><p>直接耦合</p>
<p>  可以放大交流和缓慢变化的直流信号，便于集成化</p>
<p>  但是各级静态工作点会互相影响——基极和集电极电位会随着级数增加而上升；并且存在<strong>零点漂移</strong></p>
<p>  改进方法：</p>
<ol>
<li>在后级的射极接入电阻，提高后级基极电位，但是会导致第二级的放大倍数下降</li>
<li>在后级的射极接入稳压二极管并上拉电阻（启动电阻）到Vcc，可以使后级的放大倍数损失减小，但是会导致集电极电压的变化范围减小</li>
<li>在前级和后级之间使用反接的稳压二极管耦合，并在后级的基极接入下拉电阻到地，可以做到不损失放大倍数，但是稳压管噪声较大，会对输出信号造成影响</li>
<li>混合使用NPN管和PNP管（对管）直接耦合，可以较完美地实现需求，实际经常使用的电路就是这种</li>
</ol>
</li>
<li><p>阻容耦合</p>
<p>  在前级和后级之间使用电容进行耦合</p>
<p>  静态工作点相互独立，在分立元件电路中广泛使用；但集成电路中难以制造大容量电容，不便于集成化</p>
</li>
<li><p>变压器耦合</p>
<p>  过去广泛采用的耦合方式，利用变压器的阻抗变换功能，但是难以高频工作，过去经常使用这种方式实现收音机放大电路</p>
</li>
<li><p>光电耦合</p>
<p>  使用光耦器件进行前后级耦合，耦合效果好、抗干扰能力强，但是难以做到良好的线性放大</p>
</li>
</ul>
<h2 id="多级放大器动态分析"><a href="#多级放大器动态分析" class="headerlink" title="多级放大器动态分析"></a>多级放大器动态分析</h2><h3 id="性能参数"><a href="#性能参数" class="headerlink" title="性能参数"></a>性能参数</h3><ol>
<li><p>电压放大倍数</p>
<p> 总电压放大倍数等于各级电压放大倍数的乘积</p>
<p> $\beta_A=\beta_1\times\beta_2\times\cdots\times\beta_n$</p>
<p> 各级的放大倍数、静态值等可以独立计算</p>
</li>
<li><p>输入电阻、输出电阻等同于从输入端口、输出端口分别看入电路的总电阻</p>
</li>
</ol>
<h3 id="直接耦合放大电路的零点漂移问题"><a href="#直接耦合放大电路的零点漂移问题" class="headerlink" title="直接耦合放大电路的零点漂移问题"></a>直接耦合放大电路的零点漂移问题</h3><p><strong>零点漂移</strong>：直接耦合时，输入电压为0，但输出电压离开零点，并缓慢地发生不规则变化的现象</p>
<p>原因：放大器件的参数受温度影响而使Q点不稳定，所以零点漂移也称为温度漂移</p>
<p><em>多级放大器会使零点漂移更加严重</em></p>
<p>抑制零点漂移的方法：</p>
<ol>
<li>引入直流负反馈</li>
<li>利用热敏元件补偿放大器零漂</li>
<li>使用差分放大电路，放大差分信号（只有这种方法可以达到完美抑制零点漂移）</li>
</ol>
<h2 id="差分放大电路"><a href="#差分放大电路" class="headerlink" title="差分放大电路"></a>差分放大电路</h2><p>核心思想：构造电压源补偿由于零点漂移带来的电压不稳定</p>
<p>差分放大电路也称为差动放大电路，电路以两只并联的三极管集电极电位差为输出，以共模或差模信号为输入，其中共模信号会被直接忽略，由于零点漂移造成的信号也是一种共模信号，所以会被去除</p>
<p>差分放大电路中构造了两个“虚地”——负载电阻的中点电位在差模信号作用下不变，相当于“接地”；对管射极相连节点的电位由于差分信号而不变，构造了另一个“接地点”</p>
<p>差分放大器具有四种接法</p>
<ul>
<li>双入双出</li>
<li>双入单出</li>
<li>单入双出</li>
<li>单入单出</li>
</ul>
<p>单端情况下还是具有一定的共模抑制比，但是不如双端效果好</p>
<p>差模电压放大倍数、共模电压放大倍数与单端输入或双端输入无关，只与输出方式有关</p>
<p>双端输出时，共模电压放大倍数$A_{VC}=0$</p>
<p>差模输入电阻始终是基本放大电路的两倍</p>
<p>输出电阻双端输出时为$2R_C$，单端输出时为$R_C$</p>
<p>双端输出时共模抑制比K<del>CMR</del>可认为等于无穷大，单端输出时为有限值</p>
<p>可搭配恒流源电路构造改进的差分放大电路</p>
<h2 id="互补放大电路"><a href="#互补放大电路" class="headerlink" title="互补放大电路"></a>互补放大电路</h2><p>基本要求：输出电阻低、最大不失真输出电压尽可能大</p>
<p>使用NPN、PNP对管采用图腾柱连接，实现推挽输出，一个三极管放大正半周信号，另一个放大负半周信号；但这种方案存在<strong>交越失真</strong></p>
<p>解决方案如下：</p>
<ol>
<li>使用两个二极管钳位输入，并使用射极-基极并联电阻给三极管提供静态电压</li>
<li>使用压敏电阻、NPN-PNP对管、构建U<del>BE</del>倍增电路等方式为对管提供静态电压</li>
<li>使用复合管结构，增大对管电流放大倍数，减小前级驱动电流</li>
</ol>
]]></content>
      <tags>
        <tag>电路设计</tag>
      </tags>
  </entry>
  <entry>
    <title>我的新博客</title>
    <url>/2021/11/13/%E6%88%91%E7%9A%84%E6%96%B0%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="搬家了！"><a href="#搬家了！" class="headerlink" title="搬家了！"></a>搬家了！</h1><p>准备逐步把博客写作从CSDN换到基于Github Pages和Hexo的自建站上（笑）</p>
<p>CSDN😅</p>
<p>顺便以后推广公众号恰烂钱（？）</p>
<p>总之，不定期更新</p>
<p>保障一个月两次的保底更新（大概）</p>
<p><strong>Hexo还没用熟</strong></p>
<p>支持Markdown和$\LaTeX$公式，至少比b乎那个好多了</p>
<p>以后应该会再多整点活</p>
<p>欢迎dalao们指出博文的问题，同时欢迎大家提供整活思路</p>
<h3 id="活跃平台"><a href="#活跃平台" class="headerlink" title="活跃平台"></a>活跃平台</h3><ul>
<li>Github：有空就上去看两眼，一般会及时回复</li>
<li>知乎：平常刷一刷，不看私信，可以加一波好友但是不要指望用它联系我</li>
<li>b站：日常在线娱乐平台，不看私信</li>
<li>邮箱：秒回！</li>
<li>QQ：日常水群，一般会及时回复</li>
<li>微信公众号：日常不看，大概一两个月会发一次公众号推送，以最近沙雕图和技术博文（搬运）为主</li>
<li>神秘网站：一个月可能会上去看一看，正经人谁看推啊（</li>
</ul>
<p>推荐使用QQ或邮箱<code>dddbbbdd@foxmail.com</code>联系我</p>
]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>数模转换原理</title>
    <url>/2021/11/14/%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="数模转换与模数转换"><a href="#数模转换与模数转换" class="headerlink" title="数模转换与模数转换"></a>数模转换与模数转换</h1><p>这里以STM32G474为例来介绍STM32中的ADC与DAC编程</p>
<p>主要作为电赛的笔记</p>
<h2 id="模数转换ADC"><a href="#模数转换ADC" class="headerlink" title="模数转换ADC"></a>模数转换ADC</h2><span id="more"></span>

<h3 id="四个基本部分"><a href="#四个基本部分" class="headerlink" title="四个基本部分"></a>四个基本部分</h3><ul>
<li>采样：定时对连续变化的模拟信号进行测量得到的瞬时值</li>
<li>保持：采样结束后将得到信号保持一段时间，使ADC有充分时间进行ADC转换。一般采样脉冲频率越高、采样越密，采样值就越多，采样保持电路的输出信号就越接近输入信号的波形。对采样频率要求（满足采样定理）：采样频率F<del>s</del> &gt;= 2*输入模拟信号频谱中最高频率F<del>max</del></li>
<li>量化：将采样电压转换为某个最小单位电压的整数倍</li>
<li>编码：用二进制代码表示量化后的量化电平</li>
</ul>
<p>量化级越细，量化误差就越小，所用二进制代码的位数就越多，电路也越复杂</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>常见的ADC主要分成三种：</p>
<ul>
<li><p>积分型：将输入电压转换成脉冲宽度信号或脉冲频率，使用定时器/计数器获取数字值</p>
<ul>
<li>优点：电路简单、分辨率高</li>
<li>缺点：转换精度依赖于积分时间，转换速率较低</li>
</ul>
</li>
<li><p>逐次比较型：由一个比较器和DAC转换器通过逐次比较逻辑构成，从最高位开始顺序地对每一位将输入电压与内置DAC转换器的输出进行比较，经过n次比较来输出数字值</p>
<p>  这个类型的ADC可以看作使用快速逼近-快速排序的方法来让DAC输出值靠近模拟值来实现ADC</p>
<ul>
<li>优点：速度高，功耗低，在低分辨率（12位）式具有性价比优势</li>
<li>缺点：转换速率一般，电路规模中等</li>
</ul>
</li>
<li><p>Σ-Δ调制型：使用积分器、比较器、1位DAC转换器和数字滤波器等构成，将输入电压转换成脉冲宽度信号，使用数字滤波器处理后得到数字值</p>
<ul>
<li>优点：可以容易地做到高分辨率测量</li>
<li>缺点：转换速率低、电路规模大</li>
</ul>
</li>
</ul>
<h3 id="主要参数"><a href="#主要参数" class="headerlink" title="主要参数"></a>主要参数</h3><ol>
<li>分辨率：输出数字量变化一个相邻数值所需输入模拟电压的变化量，一般用二进制的位数表示，分辨率为n表示是满刻度F<del>s</del>的2的n次方分之一</li>
<li>量化误差：ADC的有限位数对模拟量进行量化而引起的误差。要准确表示模拟量，ADC的位数需要很大甚至无穷大，所以ADC器件都有量化误差。一个分辨率有限的ADC的阶梯状转换特性曲线与具有无限分辨率的ADC转化特性曲线之间的最大偏差就是量化误差</li>
<li>转换速率：每秒进行转换的次数</li>
<li>转换量程：ADC所能测量的最大电压，一般等于参考电压，超过此电压有可能损毁ADC。当信号较小时可以考虑降低参考电压来提高分辨率，<strong>改变参考电压后，对应的转换值也会改变，计算实际电压时需要将参考电压考虑进去</strong>，所以说一般参考电压都要做到很稳定且不带有高次谐波</li>
<li>偏移误差：ADC输入信号为0时，但ADC转换输出信号不为0的值</li>
<li>满刻度误差：ADC满刻度输出时对应的输入信号与理想输入信号值之差</li>
<li>线性度：实际ADC的转移函数和理想直线的最大偏移</li>
</ol>
<h3 id="STM32G4中的ADC"><a href="#STM32G4中的ADC" class="headerlink" title="STM32G4中的ADC"></a>STM32G4中的ADC</h3><p>基本特性：</p>
<ul>
<li>五路12/10/8/6位可编程分辨率ADC，内置自动校准</li>
<li><strong>ADC转换时间与AHB总线时钟频率无关，只能通过降低分辨率加快转换时间</strong></li>
<li>4Msps最大转化率与全分辨率</li>
<li>每个ADC有多达19路通道，各通道AD转换可以以单一、连续、扫描或不连续方式进行，ADC结果存储在左对齐/右对齐的16位数据寄存器中</li>
<li>有外部参考引脚，允许输入电压范围独立于电源</li>
<li>可调的单端和差分模式输入</li>
<li>ADC1和ADC2紧密耦合，ADC3和ADC4紧密耦合，可以分别以ADC1、ADC3作master模式进行双模式运行；ADC5独立控制</li>
<li>允许DMA控制</li>
</ul>
<p>程序可以通过轮询、中断、定时器中断、同步、DMA等等方式来获取ADC值</p>
<p>使用函数<code>HAL_ADC_Start()</code>启动一次ADC转换，同理可使用<code>HAL_ADC_Start_IT()</code>和<code>HAL_ADC_Start_DMA()</code>来以中断或DMA的方式使用ADC</p>
<p>使用函数<code>HAL_ADC_GetValue()</code>在启动ADC转换一定延时时间后获取上次转换得到的ADC值</p>
<p>使用<code>HAL_ADC_Stop()</code>、<code>HAL_ADC_Stop_IT()</code>、<code>HAL_ADC_Stop_DMA()</code>停止使用ADC</p>
<h2 id="数模转换DAC"><a href="#数模转换DAC" class="headerlink" title="数模转换DAC"></a>数模转换DAC</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>数字寄存器：寄存输入的数字量和控制信号</p>
<p>模拟开关和转换网络：转换网络一般由一列电阻构成，模拟开关和对应的电阻按位加权</p>
<p>参考电压源：用于确定转换系数</p>
<p>求和放大器：对来自转换网络的模拟量进行相加</p>
<p>DAC的操作过程类似积分</p>
<h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><ul>
<li><p>电压输出型：从电阻网络直接输出电压，通常会在输出端加放大器来降低输出阻抗。</p>
</li>
<li><p>在输出端不加放大器的电压输出型：减少了输出端部分的延迟，常用于高速场合</p>
</li>
<li><p>电流输出型：一般很少直接利用电流输出，大多数会外接电流-电压转换电路得到电压输出。根据如何进行电流-电压转换又分成两类：</p>
<ul>
<li>在输出引脚上接负载电阻<ul>
<li>缺点：输出阻抗高、必须在规定的输出电流范围内使用，否则可能损坏DAC</li>
</ul>
</li>
<li>外接运算放大器<ul>
<li>缺点：加入了外接运放和导线的延迟，响应变慢</li>
</ul>
</li>
</ul>
<p>  电流输出型很少用，一般使用电压输出型</p>
</li>
</ul>
<h3 id="主要参数-1"><a href="#主要参数-1" class="headerlink" title="主要参数"></a>主要参数</h3><ol>
<li>分辨率：最小输出电压（也就是输入数字量为1时的电压）与最大输出电压（也就是输入数字量为最大（每一位都是1）时的电压）之比。一般通过输入数字量的位数来表示</li>
<li>转换量程：DAC能输出的最大电压，一般的关于参考电压或其倍数</li>
<li>建立时间：从输入数字量到输出模拟量之间的延时时间</li>
<li>转换精度：与ADC的转换精度类似</li>
</ol>
<h3 id="STM32G4中的DAC"><a href="#STM32G4中的DAC" class="headerlink" title="STM32G4中的DAC"></a>STM32G4中的DAC</h3><p>基本特性：</p>
<ul>
<li>4路配置为8位/12位的电压输出DAC，3个1MHz速率的DAC外部输出通道；4个15MHz速率的DAC内部输出通道</li>
<li>可生成噪声、三角波、锯齿波</li>
<li>可实现双DAC通道，两个通道组合在一起进行同步更新操作，转换可以独立或同步地完成</li>
<li>可通过设置独立的输入参考电压VREF+来获得更好的分辨率（注意该引脚和其他模拟外设如ADC、OPAMP等共用）</li>
<li>DAC1、DAC2引脚由GPIO复用；DAC3、DAC4仅用于内部输出</li>
<li>可开启输出缓冲</li>
<li>可单独启用的DAC输出缓冲器来输出高电流</li>
<li>支持低功耗模式、采样模式、保持模式，支持独立校准</li>
</ul>
<p>可直接使用<code>HAL_DAC_SetValue()</code>来设置DAC输出值</p>
<p>一般将某个波形的所有输出值保存在一个数组中并传给函数来输出特定波形；可以配合定时器来输出方波、三角波等</p>
]]></content>
      <tags>
        <tag>电赛笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>电机控制简介</title>
    <url>/2021/11/14/%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>本篇博文主要使用HAL库和CubeMX进行代码示例，毕竟电赛时间那么紧张，写STP库的时间都够CubeMX重开一局了</p>
<h1 id="直流电机控制"><a href="#直流电机控制" class="headerlink" title="直流电机控制"></a>直流电机控制</h1><p>根据电机学，直流电机转速<br>$$<br>n=\frac{U-IR}{K\phi}<br>$$<br>其中U为电枢端电压，I为电枢电流，R为电枢电路总电阻，Φ为每极磁通量，K为电机结构参数</p>
<p>直流电动机的转速控制方法有两种</p>
<ul>
<li>励磁控制法：对励磁磁通进行控制</li>
<li>电枢控制法：对电枢电压进行控制</li>
</ul>
<span id="more"></span>

<p>励磁控制阀在低速状态下收到磁极饱和限制，在高速时受换向火花和换向器结构强度的限制，动态响应较差，因此很少使用；大多数应用场合都使用电枢电压控制法，在保证励磁恒定的情况下使用单片机或相关电子器件输出<strong>PWM</strong>来直接实现直流电动机调速</p>
<h2 id="直流电机调速"><a href="#直流电机调速" class="headerlink" title="直流电机调速"></a>直流电机调速</h2><p>直流电机的调速思路就是“力大砖飞”，在电机控制线两端加适当电压，电压越高转速越快。可以通过功率半导体器件产生恒定的电压供给电机；对于数字器件而言很难控制电压精准保持在某一模拟值，因此使用PWM进行调速。</p>
<p>无论是模拟方法还是数字方法，都需要使用功率半导体器件，只不过使用方式有所不同。模拟电路通过线性放大的驱动方式，输出波动小、线性好，对临近电路干扰小，但存在效率低和散热问题；而数字电路通过耦合器件发出PWM使功率器件输出方波加在电机两端，通过改变方波的占空比来实现调节电机转速，往往对临近电路存在干扰，但是更易于实现。</p>
<p>基于PWM调速的电路往往包含三个部分</p>
<!-- more -->

<h3 id="驱动电路"><a href="#驱动电路" class="headerlink" title="驱动电路"></a>驱动电路</h3><p>一般使用晶体管或场效应管构成的半桥、全桥、三相桥电路，或直接使用护照那用的电机驱动功率IC。</p>
<p>常见的电机驱动芯片有L298N、ULN2003等</p>
<p>半桥拓扑采用推挽输出，<strong>需要保证两晶体管不同时开合</strong></p>
<p>全桥拓扑又称H桥，需要确定一个死区时间，在同一时间只有两个对称的桥臂晶体管导通，<strong>绝对不能让四路晶体管同时导通</strong></p>
<p>三相桥需要更严谨的时间控制，如果出现桥臂同时导通的情况很可能导致炸管</p>
<p>三者适用的功率逐次增大</p>
<p>还要注意电机两端应跨接续流二极管</p>
<h3 id="隔离电路"><a href="#隔离电路" class="headerlink" title="隔离电路"></a>隔离电路</h3><p>一般来说直流电机的驱动电压都在6V及以上，而常见的MCU供电、输出电压都在3.3V-5V，因此二者之间通常需要隔离</p>
<p>隔离器件可以是光耦、数字隔离器等</p>
<p>通常由于隔离设备的驱动能力不足，还需要在输出端加入三极管、场效应管放大电路或图腾柱推挽输出电路。比较方便的解决方案是直接使用达林顿管对电机进行控制，但是需要考虑达林顿管的耐压和发热</p>
<h3 id="控制电路"><a href="#控制电路" class="headerlink" title="控制电路"></a>控制电路</h3><p>大多数MCU都具有PWM输出功能，高性能的MCU往往还会配备控制死区时间、可以快速调节占空比、实现多路PWM同步/反相的高级控制功能；低端MCU也往往可以通过延时程序配合GPIO输出实现不精确的PWM功能</p>
<p>改变占空比的基本控制方法有：</p>
<ul>
<li>定宽调频法：保持PWM占空比不变，改变输出频率</li>
<li>定频调宽法：保持PWM频率不变，改变占空比</li>
<li>调频调宽法：不常用，同时改变频率和占空比</li>
</ul>
<h3 id="基于stm32f407的HAL库实现"><a href="#基于stm32f407的HAL库实现" class="headerlink" title="基于stm32f407的HAL库实现"></a>基于stm32f407的HAL库实现</h3><p>首先需要设置CubeMX或自己编写的外设初始化代码，配置好PSC寄存器和ARR寄存器，保证恒定的PWM频率</p>
<p>如果使用CubeMX只要可视化地调节选项即可；如果自己编写可以参考如下代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">htim1.Instance = TIM1; <span class="comment">//选择定时器实例</span></span><br><span class="line">htim1.Init.Prescaler = <span class="number">0</span>; <span class="comment">//这里设置PSC寄存器值</span></span><br><span class="line">htim1.Init.CounterMode = TIM_COUNTERMODE_UP; <span class="comment">//这里设置定时器模式</span></span><br><span class="line">htim1.Init.Period = <span class="number">65535</span>; <span class="comment">//这里设置ARR寄存器值</span></span><br><span class="line">htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1; <span class="comment">//这里设置分频值</span></span><br><span class="line">htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE; <span class="comment">//这里设置是否使能自动重装计数器</span></span><br></pre></td></tr></table></figure>

<p>使用定时器前需要先开启PWM通道</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_TIM_PWM_Start(&amp;htimx, TIM_CHANNEL_x);</span><br><span class="line"><span class="comment">//函数原型如下</span></span><br><span class="line"><span class="function">HAL_StatusTypeDef <span class="title">HAL_TIM_PWM_Start</span><span class="params">(TIM_HandleTypeDef *htim, <span class="keyword">uint32_t</span> Channel)</span></span></span><br></pre></td></tr></table></figure>

<p>然后通过在应用程序内修改比较值来实现定频调宽法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__HAL_TIM_SetCompare(&amp;htimx, TIM_CHANNEL_x, PWM_CompareValue);</span><br><span class="line"><span class="comment">//宏函数原型如下</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAL_TIM_SetCompare            __HAL_TIM_SET_COMPARE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAL_TIM_SET_COMPARE(__HANDLE__, __CHANNEL__, __COMPARE__) \</span></span><br><span class="line"><span class="meta">  (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)-&gt;Instance-&gt;CCR1 = (__COMPARE__)) :\</span></span><br><span class="line"><span class="meta">   ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)-&gt;Instance-&gt;CCR2 = (__COMPARE__)) :\</span></span><br><span class="line"><span class="meta">   ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)-&gt;Instance-&gt;CCR3 = (__COMPARE__)) :\</span></span><br><span class="line"><span class="meta">   ((__HANDLE__)-&gt;Instance-&gt;CCR4 = (__COMPARE__)))</span></span><br><span class="line"><span class="comment">//__HAL_TIM_SetCompare是老版本HAL库用法，新版本里为了统一宏函数，使用了lagency.h文件来对__HAL_TIM_SetCompare进行重定向，它和新版本的函数__HAL_TIM_SET_COMPARE等效</span></span><br></pre></td></tr></table></figure>

<p>特别地，HAL库允许直接修改CCR来改变定时器比较值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">htimx.Instance-&gt;CCRn = PWM_CompareValue;</span><br></pre></td></tr></table></figure>

<h1 id="步进电机控制"><a href="#步进电机控制" class="headerlink" title="步进电机控制"></a>步进电机控制</h1><p>步进电机是一种将电脉冲转化为角位移的电机机构。当它收到一个脉冲信号，就会按照设定的方向转动一个固定的角度，该角度称为电机的<strong>步距角</strong>。可以通过控制脉冲个数来控制角位移量；可以通过控制脉冲频率实现步进电机的调速</p>
<p>步进电机的转子一般为多极分布，定子上嵌有多相星形连接的控制绕组，每输入一次电脉冲信号，转子就旋转一步。步进电机的种类很多，可大致分成：</p>
<ul>
<li>反应式</li>
<li>永磁式</li>
<li>混合式</li>
</ul>
<p>还可以按相数分为单相、两相、三相三种</p>
<p><strong>如果给处于错齿状态的相通电</strong>，则转子会向磁导率最大、磁阻最小的位置转动，也就是<strong>趋于齿运动</strong></p>
<p>一个步进电机中往往还会加入减速装置来让其达到更高的精度，获得更高的转动力矩。</p>
<h3 id="基于stm32f407的HAL库实现-1"><a href="#基于stm32f407的HAL库实现-1" class="headerlink" title="基于stm32f407的HAL库实现"></a>基于stm32f407的HAL库实现</h3><p>首先使用CubeMX或自行编写初始化代码对外设进行配置 ，主要配置的参数如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">htim8.Instance = TIM8; <span class="comment">//选择合适的定时器</span></span><br><span class="line">htim8.Init.Prescaler = <span class="number">500</span>; <span class="comment">//配置预分频器</span></span><br><span class="line">htim8.Init.CounterMode = TIM_COUNTERMODE_UP; <span class="comment">//设置计数模式</span></span><br><span class="line">htim8.Init.Period = <span class="number">2000</span>; <span class="comment">//配置重装载值</span></span><br><span class="line">htim8.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;</span><br><span class="line">htim8.Init.RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">htim8.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;</span><br><span class="line"></span><br><span class="line">sConfigOC.Pulse = <span class="number">1000</span>; <span class="comment">//设置预定频数</span></span><br></pre></td></tr></table></figure>

<p>使用以下函数开启PWM输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_TIM_PWM_Start(&amp;htimx, TIM_CHANNEL_x);</span><br></pre></td></tr></table></figure>

<p>一般来说使用步进电机的基本方式是精准控制其行进步数，可以通过中断回调函数实现功能</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_TIM_PWM_Start_IT(&amp;htim8, TIM_CHANNEL_1); <span class="comment">//初始化时开启中断</span></span><br><span class="line"></span><br><span class="line">HAL_TIM_PWM_Stop_IT(&amp;htim8, TIM_CHANNEL_1); <span class="comment">//要设置频率参数前必须关闭中断</span></span><br><span class="line">TIM8-&gt;PSC = <span class="number">71</span>; <span class="comment">//将目标定时器8修改为72分频</span></span><br><span class="line"><span class="comment">//在之后的回调函数里再次打开中断</span></span><br></pre></td></tr></table></figure>

<p>通过定义中断回调函数即可实现步数控制功能</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_TIM_PWM_PulseFinishedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(htim-&gt;Instance == TIM8)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(count &lt; <span class="number">100</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			count++; <span class="comment">//计算步数</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">			HAL_TIM_PWM_Stop_IT(&amp;htim8, TIM_CHANNEL_1); <span class="comment">//再次打开中断</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过输出不同引脚的信号到电机控制器来控制步进电机的正反转</p>
<h3 id="基于步进电机专用控制IC的实现"><a href="#基于步进电机专用控制IC的实现" class="headerlink" title="基于步进电机专用控制IC的实现"></a>基于步进电机专用控制IC的实现</h3><p>为了更简便、精准地控制步进电机，常使用MCU搭配专用的电机控制IC来驱动电机——TI生产的DRV8824/8825以及更为常见的A4988都可以用来驱动常见的两相步进电机。一般根据datasheet中的典型应用设计出专用于控制步进电机的模块电路来实现控制功能。除了一般的正反转外，模块还提供了步进细分功能。下面分别以<strong>DRV8825</strong>和<strong>A4988</strong>步进电机驱动模块为例说明</p>
<p>步进电机的<strong>步进细分</strong>控制是由驱动器精确控制步进电机的相电流来实现的，细分会让电机运转更加平滑；换句话说，细分控制就是让驱动电路在输出脉冲的同时控制输出电压来实现电机的平滑启动和步进停止</p>
<ul>
<li><p>DRV8825模块</p>
<p>  DRV8825是TI的集成步进电机驱动芯片。芯片内部集成了2个H桥和1/32微步进分度器，可以驱动一个双极型电机或两个直流有刷电机。输入电压范围8.2~45V，可以提供1.75A的驱动电流， 芯片在24V、25°C的工作状态下可提供2.5A的峰值电流。芯片还集成了短路、过热、欠压及交叉传导保护电路，能够检测故障状况并迅速切断H桥，从而保护电机</p>
<p>  适用的电机类型：DRV8825驱动电机的类型主要与电机工作电流有关，理论上工作电流小于2A的步进电机都可以驱动。基于安全考虑，芯片上不加散热片，电流最好控制在1.5A以下；如果加散热片，电流峰值可到2.5A。</p>
<p>  模块接线如下：</p>
<p>  <img src="/2021/11/14/%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E7%AE%80%E4%BB%8B/DRV8824_DRV8825_pinout.png" alt="DRV8824_DRV8825_pinout"></p>
<p>  其中需要<strong>数字、模拟部分分别接地</strong>，一般来说VMOT旁边的GND是功率地，另一个GND则是数字地。同时<strong>功率电源需要接入100uF的旁路电容</strong>来减轻对数字部分的影响</p>
<p>  <strong>ENABLE引脚用于控制该模块是否启用，默认该引脚拉低，模块始终启用；RESET负责复位模块；SLEEP用于控制进入低功耗睡眠模式，当不使用电机时可以下拉该引脚来将功耗降到最低；三个引脚都是低电平有效，所以正常使用时都应接VCC（数字电源）</strong></p>
<p>  <strong>FAULT引脚（FLT）用于指示故障，一旦由于过电流保护或热关断，IC内部禁用H桥FET时，该引脚就会输出低电平，一般来说该引脚会在模块内部与SLEEP引脚短路，起到自动故障复位的效果</strong></p>
<p>  <strong>STEP引脚用于驱动电机转动，需要输入PWM波，频率越高，电机转动越快</strong></p>
<p>  <strong>DIR引脚用于控制电机转动方向，高电平正转，低电平反转</strong></p>
<p>  步进电机可以对应连接1B-1A-2A-2B、2B-2A-1A-1B、1A-1B-2B-2A、2A-2B-1B-1A，主要取决于需要的转动方向，总之只要<strong>同一相的两根线接到对应相的驱动引脚</strong>即可；特别地，如果电机不能正常运行，抖动严重，有可能是驱动板没有焊接好或某一相断开或两相接错导致缺相、错相；如果步进电机没有按照正确的顺序进行连接，可能导致无法工作或转动方向异常；如果步进电机扭力不足乃至丢步，可以尝试加大DRV8825的输出电流。驱动板上一般会搭配一个精密电位器用于调节输出电流，尝试调节该电位器来获取更好的输出效果，精密电位器与输出电流限制的计算公式为：<em>限制电流 = 电位器电压 * 2</em>，单位A</p>
<p>  <strong>通过控制M0、M1、M2的接地和接VCC（数字电源），可以根据下表来实现不同精密度的步进细分控制</strong></p>
<table>
<thead>
<tr>
<th>M0</th>
<th>M1</th>
<th>M2</th>
<th>细分类型</th>
</tr>
</thead>
<tbody><tr>
<td>Low</td>
<td>Low</td>
<td>Low</td>
<td>Full step</td>
</tr>
<tr>
<td>High</td>
<td>Low</td>
<td>Low</td>
<td>1/2 step</td>
</tr>
<tr>
<td>Low</td>
<td>High</td>
<td>Low</td>
<td>1/4 step</td>
</tr>
<tr>
<td>High</td>
<td>High</td>
<td>Low</td>
<td>1/8 step</td>
</tr>
<tr>
<td>Low</td>
<td>Low</td>
<td>High</td>
<td>1/16 step</td>
</tr>
<tr>
<td>High</td>
<td>Low</td>
<td>High</td>
<td>1/32 step</td>
</tr>
<tr>
<td>Low</td>
<td>High</td>
<td>High</td>
<td>1/32 step</td>
</tr>
<tr>
<td>High</td>
<td>High</td>
<td>High</td>
<td>1/32 step</td>
</tr>
</tbody></table>
</li>
<li><p>A4988模块</p>
<p>  相关控制方法与DRV8825基本一致，引脚也同理，两者最大的差别在于驱动电流和价格</p>
<p>  A4988价格更低，但是峰值驱动电流只有2A，内阻典型值为320Ω，最大耐压35V，所以DRV8825可以用来取代A4988，但是A4988不能取代DRV8825</p>
</li>
</ul>
<h1 id="舵机控制"><a href="#舵机控制" class="headerlink" title="舵机控制"></a>舵机控制</h1><p>舵机也称伺服电机、伺服驱动器，它接受一定的控制信号，输出一定的角度，适用于需要角度不断变化并可以保持的控制系统</p>
<p>舵机实际上是一个独立的闭环控制系统，通过其内部的机械或电路反馈控制其角度</p>
<p>工作过程如下：</p>
<ol>
<li>控制器向舵机发出控制信号</li>
<li>内部电路判断转动方向</li>
<li>驱动电路控制无核心马达转动</li>
<li>动力通过减速齿轮传送到摆臂</li>
<li>位置检测器回传摆臂数据</li>
<li>如果未达到指定位置则继续运动，否则停止</li>
</ol>
<p>其中位置检测器一般使用可变电阻，当舵机转动时电阻值会跟着改变，由此可以判断舵机是否达到指定位置</p>
<h2 id="舵机控制方法"><a href="#舵机控制方法" class="headerlink" title="舵机控制方法"></a>舵机控制方法</h2><p>标准舵机由电源、地线、控制线三条连接线，电源电压通常为4-6V，一般使用5V供电即可，但是需要电源带载能力够强。控制线一般输入方波信号，周期一般为20ms（频率50Hz）即可，具体情况应查看舵机生产商的说明。<strong>通过改变方波的占空比来改变舵机的角度</strong>，舵机角度和脉冲宽度成正比</p>
<p>舵机一般可以提供相当强的扭力，所以可以选择大扭力舵机用在机械臂等需要高强度的地方</p>
<h3 id="基于stm32f407的HAL库实现-2"><a href="#基于stm32f407的HAL库实现-2" class="headerlink" title="基于stm32f407的HAL库实现"></a>基于stm32f407的HAL库实现</h3><p>数字舵机依靠PWM进行控制。<strong>对于180°的舵机，一般周期为20ms（频率为50Hz）</strong>，脉宽为500–2500us。其中为1500us使得舵机转轮处于中间位置，即90°位置，如果在500-1500us和1500–2500us之间则分别会朝着0–90°和90–180°的方向旋转。给定固定占空比，舵机则会转到相应的角度，计算公式如下：</p>
<p>$$<br>占空比D =\frac{1}{90} *角度\theta + 0.5<br>$$<br>对应HAL库实现如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Servo_Control</span><span class="params">(<span class="keyword">uint16_t</span> angle)</span> <span class="comment">//angle为角度值，0~180</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> temp;</span><br><span class="line">	temp = (<span class="number">1.0</span> / <span class="number">90.0</span>) * angle + <span class="number">0.5</span>;<span class="comment">//占空比值 = 1/9 * 角度 + 5</span></span><br><span class="line">	__HAL_TIM_SET_COMPARE(&amp;htimx, TIM_CHANNEL_n, (<span class="keyword">uint16_t</span>)temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用下面的代码使能定时器时基单元和PWM输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_TIM_Base_Start(&amp;htimx);</span><br><span class="line">HAL_TIM_PWM_Start(&amp;htimx, TIM_CHANNEL_n);</span><br></pre></td></tr></table></figure>

<p>使用下面的代码关闭定时器时基单元和PWM输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_TIM_Base_Stop(&amp;htimx);</span><br><span class="line">HAL_TIM_PWM_Stop(&amp;htimx, TIM_CHANNEL_n);</span><br></pre></td></tr></table></figure>

<p>还可以直接通过改变CCR寄存器的值来控制舵机</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIMx-&gt;CCRn = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>电赛笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>电路设计从入门到弃坑0【电路概论】</title>
    <url>/2021/11/13/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E7%94%B5%E8%B7%AF%E6%A6%82%E8%AE%BA%E3%80%91/</url>
    <content><![CDATA[<h1 id="电路设计从入门到弃坑0【电路概论】"><a href="#电路设计从入门到弃坑0【电路概论】" class="headerlink" title="电路设计从入门到弃坑0【电路概论】"></a>电路设计从入门到弃坑0【电路概论】</h1><p>在本系列博客中，将遵循以下缩写/简写</p>
<ul>
<li>电路原理：电子线路、电子线路分析基础等基础电路课</li>
<li>模电：模拟电子电路、模拟电路、模拟电子技术、模拟电子线路等模拟电路课</li>
<li>数电：数字电子电路、数字电路、数字电子技术、数字电子线路等数字电路课</li>
<li>通信原理：通信原理、通信电子线路、通信电子电路、高频电子电路、高频电子线路等高频电路及通信理论课</li>
<li>强电：功率电子电路、功率电子线路、电力电子电路、电力电路等电力电子系统及理论课</li>
</ul>
<p>电路原理阐述了电路运行的基本规律：使用抽象电路模型、电磁学、图论、高等数学、线性代数、拉普拉斯变换等基础学科知识描述电路，提供一般的电路分析方法</p>
<p>模电则是从半导体器件的性质介绍如何使用这些器件构建能够对电信号或功率电压电流进行处理的电路</p>
<p>数电针对逻辑电路进行分析，结合布尔代数引入了晶体管在导通、截至两状态下的应用，并提炼出使用硬件描述语言对数字电路进行设计、分析、仿真的基本方法</p>
<p>通信原理则从分布参数电路与谐振、傅里叶分析角度解释模拟电路工作在高频情况下的状态与应用，并根据电磁场与电磁波理论介绍如何对通信信号进行调制-解调，以实现远距离电通信</p>
<p>强电则结合电机学、电工学相关知识，阐明功率半导体器件的工作原理和应用，主要关注功率、效率、质量三个要素</p>
<span id="more"></span>

<h3 id="专有名词解释"><a href="#专有名词解释" class="headerlink" title="专有名词解释"></a>专有名词解释</h3><p>本教程中使用的专有名词是更贴近直观的解释，和专业参考书籍存在一定差异，请以专业参考书为准</p>
<ul>
<li>电路拓扑：就是电路图的“形式”——把具体元件抽离出电路图，把实际电路图变换成理想电路模型，抽象出节点、支路后剩下的一个图就称为电路拓扑。可以形象理解成电路的套路或者说格式</li>
<li>系统：电路实现其功能过程的抽象。可以形象理解成电路功能框图</li>
<li>信息：就是信息论里面的信息</li>
<li>信号：从系统角度看，每个支路量都承载了信息，因此支路量可以称为信号</li>
<li>激励-响应：从系统的角度看电路时，系统中某个功能框的输入称为激励，系统某个功能框的输出称为响应</li>
<li>反馈：把某个响应引入到激励部分或功能框内部的过程称为反馈，对应的信号称为反馈信号</li>
</ul>
<h2 id="模电"><a href="#模电" class="headerlink" title="模电"></a>模电</h2><p>模电的知识结构是自下而上的</p>
<h3 id="半导体物理与半导体器件"><a href="#半导体物理与半导体器件" class="headerlink" title="半导体物理与半导体器件"></a>半导体物理与半导体器件</h3><p>讲述掺杂与导电性、PN结、双结型晶体管、场效应管等的基本物理原理和制造工艺对器件性能的影响</p>
<p>这一部分内容更偏重理论，和电路原理一样属于帮助理解模电、数电等工程应用的理论基础</p>
<h3 id="常见的半导体器件"><a href="#常见的半导体器件" class="headerlink" title="常见的半导体器件"></a>常见的半导体器件</h3><p>二极管、三极管、场效应管等基本的半导体器件，连同它们的变种器件，共同组成了模拟电子电路，经由开关频率特殊优化的开关管器件则构成了数字电路的基础——逻辑门和触发器</p>
<h4 id="二极管"><a href="#二极管" class="headerlink" title="二极管"></a>二极管</h4><p>由一个PN结封装成器件，就得到了具有单向导电性的二极管</p>
<p>生产中用到的不仅有二极管的单向导电性，还有击穿电压、漏电流等等一系列特性</p>
<h4 id="三极管和场效应管"><a href="#三极管和场效应管" class="headerlink" title="三极管和场效应管"></a>三极管和场效应管</h4><p>两个PN结封装成一个器件，就得到了三极管；而利用金属-氧化物绝缘层-半导体形式封装产生的电场效应，可以生产出场效应管。</p>
<p>三极管一般是电流控制电流型器件；而场效应管一般是电压控制电压型器件，二者可以互补——于是出现了结合二者，能够实现高功率输出的晶闸管（可控硅）和IGBT（绝缘栅双极型晶体管），以及复合单一器件的达林顿管</p>
<p>早期设备中使用真空管（电子管），正是因为半导体技术的发展才让三极管取代了真空管，但是二者的功能是一致的：<strong>对电信号加以控制</strong></p>
<h3 id="晶体管信号放大电路"><a href="#晶体管信号放大电路" class="headerlink" title="晶体管信号放大电路"></a>晶体管信号放大电路</h3><p>这里的晶体管是BJT（双结型晶体管，也就是三极管）和FET（场效应管）的统称</p>
<p>晶体管通过某些组合，可以最大限度发挥其控制信号的作用，而这种电路一般用于放大某些小信号，所以被称为晶体管信号放大电路。</p>
<p>放大电路并不是指输入1V，凭空就能输出3V，而是指<em>输入信号1V，通过外加2V的供电，能输出为2V的信号</em></p>
<p>信号放大电路往往看重信号的保真程度和信号的放大倍数，然而晶体管往往很容易受到门限电压、温度升高、电源变化等影响造成信号失真，为了避免这些问题，人们就对普通放大电路进行改进；同时为了获取更高的放大倍数，常常采用前级-输入级-驱动级-输出级这样的多级放大模式，从而提高信号放大倍数</p>
<p>主要参考的性能参数就是电压增益和电流增益：$A_v=\frac{v_o}{v_i}$ $A_i=\frac{i_o}{i_i}$</p>
<h3 id="晶体管功率放大电路"><a href="#晶体管功率放大电路" class="headerlink" title="晶体管功率放大电路"></a>晶体管功率放大电路</h3><p>对于一些特殊的应用（比如音响），信号放大电路无法驱动后级输出设备（扬声器）</p>
<p>于是出现了晶体管功率放大电路</p>
<p>这类电路一般使用特殊设计的能经受大电流、高电压的晶体管作为放大器件，于是可以在电源部分加大功率</p>
<p>通常需要注意功率放大电路的效率：$\eta=\frac{P_L}{P_S}$</p>
<h3 id="晶体管振荡电路"><a href="#晶体管振荡电路" class="headerlink" title="晶体管振荡电路"></a>晶体管振荡电路</h3><p>为了控制或产生周期性的激励，人们还设计出了能够产生振荡信号的晶体管电路</p>
<p>这种电路建立在放大电路和闭环控制理论的基础上，利用反馈进行工作</p>
<p>一般分立式元件难以产生高精度的信号输出，现在一般使用单片机（微控制器）或专用的集成电路生成振荡信号</p>
<h3 id="集成运算放大器"><a href="#集成运算放大器" class="headerlink" title="集成运算放大器"></a>集成运算放大器</h3><p>随着集成电路技术的发展，可以将多个二极管和晶体管集成在单个芯片中，内部大多为模拟电路的芯片被称为模拟集成电路，内部结构中多数字电路的芯片则是数字集成电路。其中通过将晶体管信号放大电路集成在一个芯片上，可以实现良好的放大性能，这种模拟集成电路就是集成运算放大器</p>
<p>集成运算放大器具有虚短、虚短、高输入阻抗、低输出阻抗等特征，利用这些特征可以组合出模拟运算电路和其他特殊的放大电路</p>
<p>集成运放工作在晶体管的基础上</p>
<h3 id="集成功率放大器"><a href="#集成功率放大器" class="headerlink" title="集成功率放大器"></a>集成功率放大器</h3><p>集成功率放大器即集成功放，是分立式晶体管功率放大器在功率半导体器件发展的基础上形成的一套新型集成电路</p>
<p>现代模拟电路具有集成化、小型化的趋势，集成功率电路正是舍弃了一部分高功率特性换来了更高的转换效率和更小的体积</p>
<h3 id="电源管理芯片和功率电源电路"><a href="#电源管理芯片和功率电源电路" class="headerlink" title="电源管理芯片和功率电源电路"></a>电源管理芯片和功率电源电路</h3><p>模拟电路的另一作用就是基于变压器、二极管、晶体管、基本电抗元件等构建稳压或恒流电源</p>
<p>在此基础上伴随半导体技术的发展，氮化镓、氮化砷等新型功率半导体器件为实现小型化、大功率、高效率的电源电路提供了可能</p>
<h2 id="数电"><a href="#数电" class="headerlink" title="数电"></a>数电</h2><p>数电的知识结构是从抽象到具体的</p>
<h3 id="布尔代数"><a href="#布尔代数" class="headerlink" title="布尔代数"></a>布尔代数</h3><p>布尔代数就是逻辑代数，使用布尔代数可以化简很多代数运算，并让电路得以实现</p>
<p>数电的基础是数学，数电的所有器件都是为了解决数学计算问题而设计</p>
<p>所以布尔代数是数字电路的基础</p>
<h3 id="开关管与逻辑门"><a href="#开关管与逻辑门" class="headerlink" title="开关管与逻辑门"></a>开关管与逻辑门</h3><p>电路可以使用高电平或低电平表示布尔代数中的0和1，进而实现数学计算</p>
<p>为了对数字信号进行处理，前人设计出了三种基本的逻辑门——与门、或门、非门</p>
<p>使用MOSFET（金属氧化物半导体场效应管）可以实现这三种逻辑门，进而实现更多复杂功能</p>
<p>在现代集成电路技术中，多采用CMOS工艺，将两个MOSFET制造在一起，并通过两个成对的MOSFET实现基础的逻辑门</p>
<p>只使用逻辑门构成的数字电路称为<strong>组合逻辑电路</strong></p>
<p>组合逻辑电路只能“瞬时”（由于寄生电容的存在，实际的组合逻辑电路存在延迟）地反映当前输入对应的输出，换句话说，它可以描述函数关系，但不能描述状态关系</p>
<h3 id="触发器与锁存器"><a href="#触发器与锁存器" class="headerlink" title="触发器与锁存器"></a>触发器与锁存器</h3><p>使用CMOS器件还可以制造具有“记忆”功能的器件——锁存器</p>
<p>锁存器可以暂时地保存输入的电平，通过再次加入一对MOSFET便可以让锁存器“滴答”（Tik-Tok）起来，这就是所谓的触发器</p>
<p>触发器是一种在外部信号输入后输出之前保存过电平的器件</p>
<p>使用触发器就可以实现随状态变化的数字电路，我们一般将其称为<strong>状态机</strong></p>
<h2 id="数电模电混合电路"><a href="#数电模电混合电路" class="headerlink" title="数电模电混合电路"></a>数电模电混合电路</h2><p>在生活中的任何一个角落，都有数模混合电路的存在——模拟电路负责供能、处理信号；数字电路负责对电信号进行计算、控制。</p>
<p>本系列博客将结合个人所学，以模电-数电-数模混合电路的逻辑讲述电路设计中的一些基础知识与技巧，同步进行开关电源、MCU板级外设电路等成体系电路的设计方法说明</p>
<p><strong>长期维护更新</strong></p>
<p>作者水平有限，如有错误疏漏，敬请谅解。</p>
]]></content>
      <tags>
        <tag>电路设计</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔</title>
    <url>/2021/11/13/%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<h1 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h1><p>所有的随笔都会放在这里OvO</p>
<p>可能还会扔些沙雕图……</p>
<h2 id="随笔1-2021-11-23"><a href="#随笔1-2021-11-23" class="headerlink" title="随笔1 @2021.11.23"></a>随笔1 @2021.11.23</h2><p>早操签到</p>
<p>不去就不发奖学金</p>
<p>大二了搞这些东西属于是【数据删除】</p>
<h2 id="随笔2-2021-11-28"><a href="#随笔2-2021-11-28" class="headerlink" title="随笔2 @2021.11.28"></a>随笔2 @2021.11.28</h2><p>好像推号被gank力（悲）</p>
<p>不知道是因为hs看多了还是被魔怔壬骚扰到惹</p>
<p>推特号一般只用来ghs……不接受魔怔/建政讨论</p>
<p>求求你们不搞康米至少搞搞资吧，别再来什么地主、鸡舍了（悲）</p>
<p>另外新加的畅言评论在火狐上会出现无法显示的情况…….</p>
<p>怎么大家都在欺负火狐啊T_T</p>
<h2 id="随笔3-2021-11-30"><a href="#随笔3-2021-11-30" class="headerlink" title="随笔3 @2021.11.30"></a>随笔3 @2021.11.30</h2><p>准备把重心全面转到新系列博文《电路设计从入门到弃坑》</p>
<p>因为快期末了，得好好复习一下模电数电</p>
<p>模电写得磕磕巴巴可不行啊！</p>
<p>这个系列就是要把数模电教材结合自己的观点重写一遍</p>
<p>如果有时间的话肯定会加入很多自己的电路设计经验，包括看datasheet、电路的改进思路等等</p>
<p>也应该会记录一些做题技巧</p>
<p>不被量力和数学物理方程橄榄就是胜利！</p>
<h2 id="随笔4-2021-12-10"><a href="#随笔4-2021-12-10" class="headerlink" title="随笔4 @2021.12.10"></a>随笔4 @2021.12.10</h2><p>好像量力结束了（及格就行，这玩意太难了……），但是数物方程有点难顶</p>
<p>希望能早日脱离物理数学苦海</p>
<p>我就一码电路的为什么要学物理系数学系的专业课（</p>
<p>模电数电在写了，寒假以后会整理完一口气发上去</p>
<p>CSDN同步更新（没办法，它的Typora兼容太好了）</p>
<h2 id="随笔5-2021-12-21"><a href="#随笔5-2021-12-21" class="headerlink" title="随笔5 @2021.12.21"></a>随笔5 @2021.12.21</h2><p>数物方程和模电都结束了（希望能过）</p>
<p>简单整理一下原来的笔记，决定先传一部分到博客上。后面的数电部分还在写，可能会被热统复习占据一些时间</p>
<p>所有笔记都记录在我的github repo：Notes里面</p>
<p>如果有人看到这不妨进去看看=_=</p>
<p>CSDN的更新先等一等，真没时间往上折腾这堆文档</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>集成运放简介</title>
    <url>/2021/11/14/%E9%9B%86%E6%88%90%E8%BF%90%E6%94%BE%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="集成运放概述"><a href="#集成运放概述" class="headerlink" title="集成运放概述"></a>集成运放概述</h1><p>常见的模拟集成电路类型</p>
<ul>
<li>集成运算放大器OP</li>
<li>集成功率放大器</li>
<li>集成高频放大器</li>
<li>集成中频放大器</li>
<li>集成比较器</li>
<li>集成乘法器</li>
<li>集成稳压器</li>
<li>集成数模/模数转换器ADC/DAC</li>
</ul>
<h3 id="模拟集成电路的特性"><a href="#模拟集成电路的特性" class="headerlink" title="模拟集成电路的特性"></a>模拟集成电路的特性</h3><p>集成电路中一般使用三极管组成恒流源电路来部分替代电阻</p>
<p>硅片上难以制作大电容、大电感，因此电路常常使用直接耦合的方式</p>
<p>常采用复合管的方式制作较大放大倍数的三极管</p>
<span id="more"></span>

<h2 id="集成运放的基本组成"><a href="#集成运放的基本组成" class="headerlink" title="集成运放的基本组成"></a>集成运放的基本组成</h2><h3 id="输入级"><a href="#输入级" class="headerlink" title="输入级"></a>输入级</h3><p>输入级要求高阻抗，常使用射随器与差分放大器减少温漂和增大输入电阻</p>
<p>一般使用复合管构成差分放大器，配合共集-共基放大器，用额外三极管的基极输出信号，可以实现很大的输入电阻和很大的共模抑制比</p>
<p>将复合管共基接法可以改善频率响应</p>
<p>使用<strong>共模负反馈</strong>减小温漂、提高共模抑制比</p>
<h3 id="中间级"><a href="#中间级" class="headerlink" title="中间级"></a>中间级</h3><p>常采用共射放大器配合复合管获得高增益</p>
<p>使用互补放大电路实现高放大倍数并提高带载能力</p>
<p>也存在放大器两端外接矫正电容来提高电路容性，防止自激振荡的措施（抑制过高的放大倍数、抑制正反馈）</p>
<h3 id="输出级"><a href="#输出级" class="headerlink" title="输出级"></a>输出级</h3><p>要求低阻抗，常使用射随器减小输出电阻</p>
<p>可以使用准互补OCD电路来提高带载能力，并引入电阻-二极管<strong>过载保护电路</strong></p>
<h3 id="偏置电路"><a href="#偏置电路" class="headerlink" title="偏置电路"></a>偏置电路</h3><p>使用恒流源电路给予三极管合适的偏置电压电流</p>
<p>多使用<strong>镜像恒流源</strong>配合跨接在VCC、VEE之间的电阻来提供标准偏置电流</p>
<h2 id="集成运放的特性"><a href="#集成运放的特性" class="headerlink" title="集成运放的特性"></a>集成运放的特性</h2><p>集成运放的开环放大倍数$A_{od}$非常大，一般使用负反馈的方式构造可控倍数的放大器或使用深度正反馈构造自激振荡电路</p>
<h3 id="开环差模电压增益"><a href="#开环差模电压增益" class="headerlink" title="开环差模电压增益"></a>开环差模电压增益</h3><p>直观上的运放开环情况下对差模信号的电压增益</p>
<p>用$A_{od}$表示，一般用对数表示，单位分贝</p>
<p>实际情况下运放A<del>od</del>在100到140之间</p>
<h3 id="输入失调电压、电流"><a href="#输入失调电压、电流" class="headerlink" title="输入失调电压、电流"></a>输入失调电压、电流</h3><p>为了使输出电压为0，在输入端需要加的补偿电压</p>
<p>一般运放在1-10mV</p>
<p>高端运放要保证在1mV以下</p>
<h3 id="输入失调电压、电流温漂"><a href="#输入失调电压、电流温漂" class="headerlink" title="输入失调电压、电流温漂"></a>输入失调电压、电流温漂</h3><p>由于温漂导致的输入失调电压增高情况</p>
<h3 id="输入偏置电流"><a href="#输入偏置电流" class="headerlink" title="输入偏置电流"></a>输入偏置电流</h3><p>输出电压为0时，两个输入端偏置电流的平均值</p>
<h3 id="差模输入电阻"><a href="#差模输入电阻" class="headerlink" title="差模输入电阻"></a>差模输入电阻</h3><p>一般要求很大，在几十MΩ</p>
<h3 id="共模抑制比"><a href="#共模抑制比" class="headerlink" title="共模抑制比"></a>共模抑制比</h3><p>多数运放在80-160dB之间</p>
<h3 id="最大共模、差模输入电压"><a href="#最大共模、差模输入电压" class="headerlink" title="最大共模、差模输入电压"></a>最大共模、差模输入电压</h3><p>直观上就是集成运放的耐压</p>
<p>一定程度上表征运放的耐静电程度</p>
<h3 id="3dB带宽fH"><a href="#3dB带宽fH" class="headerlink" title="-3dB带宽fH"></a>-3dB带宽f<del>H</del></h3><p>表示A<del>od</del>下降3dB时的频率。一般集成运放的f<del>H</del>在几H到几千Hz</p>
<h3 id="单位增益带宽"><a href="#单位增益带宽" class="headerlink" title="单位增益带宽"></a>单位增益带宽</h3><p>A<del>od</del>降低到0时的频率，此时运放开环差模电压放大倍数=1</p>
<h3 id="转换速率"><a href="#转换速率" class="headerlink" title="转换速率"></a>转换速率</h3><p>集成运放对输入-输入信号的转换速率</p>
<h2 id="单极型集成运放"><a href="#单极型集成运放" class="headerlink" title="单极型集成运放"></a>单极型集成运放</h2><p>三极管又称为BJT（双结型晶体管），组成双极型集成运放；也可以使用MOSFET组成单极型集成运放</p>
<p>采用耗尽型NMOS组成双入双出差分放大电路、使用增强型NMOS组成有源负载，并使用电流源组成偏置电路</p>
]]></content>
      <tags>
        <tag>电赛笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32深入学习【GPIO】</title>
    <url>/2021/11/14/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90GPIO%E3%80%91/</url>
    <content><![CDATA[<p>本文章根据stm32f4xx中文参考手册整理，可供学习其他arm内核单片机/stm32系列单片机参考</p>
<p>如果对其中的内容有疑问，可以参考RCC、定时器、中断相关部分的解析</p>
<p>以下内容使用SPL库（标准库）作为代码示例，HAL库是更高层的封装，想HAL库的使用可以查看其他教程</p>
<span id="more"></span>

<h1 id="GPIO电路"><a href="#GPIO电路" class="headerlink" title="GPIO电路"></a>GPIO电路</h1><p>每个GPIO端口包括4个32位配置寄存器、2个32位数据寄存器、1个32位置位/复位寄存器、1个32位锁定寄存器和2个32位复用功能寄存器。每个IO端口位均可自由编程，但IO端口寄存器必须按32位字、半字或字节进行访问</p>
<p>基本电路图如下所示：</p>
<p><img src="/2021/11/14/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90GPIO%E3%80%91/image-20210415214054864.png" alt="image-20210415214054864"></p>
<p>主要分为以下几个部分</p>
<h2 id="输入电路"><a href="#输入电路" class="headerlink" title="输入电路"></a>输入电路</h2><p>输入部分通过两个<strong>保护二极管</strong>进行钳位，保证GPIO容忍电压对V<del>SS</del>为5V，注意这里的V<del>SS</del>指的是电源地，而不是V<del>DD</del>信号地</p>
<p>输入信号经过可编程的<strong>上拉/下拉电阻</strong>后进入<strong>输入驱动器</strong>。</p>
<ul>
<li>如果使能了ADC等接入外部模拟信号的片上外设，就能从GPIO直接读取模拟信号</li>
<li>如果使能了复用功能，外部信号则会通过一个TTL<strong>施密特触发器</strong>，直接缓冲进入相关数字信号外设</li>
<li>如果正常使用GPIO的读功能，外部信号会在被施密特触发器变为数字信号后进入<strong>输入数据寄存器</strong></li>
</ul>
<p>这里的施密特触发器相当于一个FIFO，能够保存外部模拟信号的快照，以此作为数字量供给片上外设</p>
<p><strong>引脚配置为输入模式后，输入数据寄存器会每1个AHB1时钟周期捕获以此GPIO外部数据</strong></p>
<h2 id="输出电路"><a href="#输出电路" class="headerlink" title="输出电路"></a>输出电路</h2><p>输出部分通过两个MOSFET控制，PMOS、NMOS以图腾柱方式组合，形成<strong>推挽输出</strong>结构。为了保证输出的速度，使用专用的驱动电路控制MOSFET，输出速率就由该驱动电路决定</p>
<ul>
<li>如果正常使用GPIO的写功能，来自CPU的配置数据会先保存在<strong>置位/复位寄存器</strong>，之后转换保存在<strong>输出数据寄存器</strong>中，驱动电路根据输出数据寄存器的值实时控制输出，这就起到了内部时钟和外设操作频率的退耦</li>
<li>如果使用了其他能读写GPIO的外设，会由外设直接向输出数据寄存器中写值，这样就简轻了CPU的控制负担</li>
<li>如果使能了复用功能，来自复用外设的控制信号会直接绕过输出数据寄存器，直接通过一个两路选择器操作输出控制电路</li>
</ul>
<p>所有来自MOSFET输出的信号会经过<strong>上/下拉电路</strong>，这就能将片内CMOS电压转换为片外TTL电压进行输出</p>
<p>同样输出也经过钳位二极管保护，防止出现电流倒灌等问题</p>
<p><strong>引脚配置为输出模式后，写入到输出数据寄存器的值会在GPIO上输出</strong></p>
<h2 id="时序控制电路"><a href="#时序控制电路" class="headerlink" title="时序控制电路"></a>时序控制电路</h2><p>大多数GPIO的寄存器都是基于时序电路实现（D触发器、锁存器等）</p>
<p>最重要的就是置位复位寄存器 (GPIOx_BSRR)：这是一个32位寄存器，它允许应用程序在输出数据寄存器(GPIOx_ODR) 中对各个单独的数据位执行置位和复位操作。</p>
<blockquote>
<p>置位复位寄存器的大小是GPIOx_ODR的二倍，所以GPIOx_ODR中的每个数据位都能对应于GPIOx_BSRR中的两个控制位：BSRR(i) 和<br>BSRR(i+SIZE)。当写入1时，BSRR(i)位会置位对应的ODR(i) 位；同时BSRR(i+SIZE) 位会清零ODR(i)对应的位；在GPIOx_BSRR中向任何位写入0都不会对GPIOx_ODR中的对应位产生任何影响。如果在GPIOx_BSRR中同时尝试对某个位执行置位和清零操作，则<strong>置位操作优先</strong>。</p>
<p>注意使用GPIOx_BSRR寄存器更改GPIOx_ODR中各个位的值是一个“单次”操作，不会锁定GPIOx_ODR位。用户随时都可以直接访问GPIOx_ODR位</p>
<p>特别地，对GPIOx_ODR进行位操作是原子操作，软件无需禁止中断，且在一次原子AHB1写访问中，可以修改一个或多个位</p>
</blockquote>
<h2 id="GPIO复位"><a href="#GPIO复位" class="headerlink" title="GPIO复位"></a>GPIO复位</h2><h3 id="调试引脚复位"><a href="#调试引脚复位" class="headerlink" title="调试引脚复位"></a>调试引脚复位</h3><p>复位后调试引脚处于复位功能上拉/下拉状态：</p>
<ul>
<li>PA15-JTDI上拉</li>
<li>PA14-JTCK/SWCLK下拉</li>
<li>PA13-JTMS/SWDAT下拉</li>
<li>PB4-NJTRST上拉</li>
<li>PB3-JTDO浮空</li>
</ul>
<h3 id="其他复位"><a href="#其他复位" class="headerlink" title="其他复位"></a>其他复位</h3><p>在复位期间及复位刚刚完成后，复用功能尚未激活，GPIO端口被配置为输入浮空模式</p>
<p>完成复位后，所有GPIO都会连接到系统的复用功能 0 (AF0)</p>
<h1 id="GPIO外设控制寄存器及配置"><a href="#GPIO外设控制寄存器及配置" class="headerlink" title="GPIO外设控制寄存器及配置"></a>GPIO外设控制寄存器及配置</h1><p>可通过字节（8 位）、半字（16 位）或字（32 位）对 GPIO 寄存器进行访问</p>
<p><strong>寄存器地址见参考手册</strong></p>
<p>GPIOx_MODER模式控制寄存器：选择 I/O 方向与模式</p>
<p>GPIOx_PUPDR上下拉数据寄存器：控制内部上拉/下拉电阻</p>
<p>GPIOx_OTYPER输出类型寄存器：选择输出类型</p>
<p>GPIOx_OSPEEDR输出速度寄存器：选择输出速度</p>
<p>GPIOx_IDR输入数据寄存器：通过 I/O 输入的数据存储到该寄存器，这是个只读寄存器</p>
<p>GPIOx_ODR输出数据寄存器：存储待输出数据，可对其进行读写访问</p>
<p>GPIOx_AFRL复用功能寄存器低8位：根据应用程序的要求将某个复用功能连接到其它某个引脚</p>
<p>GPIOx_AFRH复用功能寄存器高8位：根据应用程序的要求将某个复用功能连接到其它某个引脚</p>
<p>通过将特定的写序列应用到GPIOx_LCKR寄存器，可以冻结GPIO外设控制寄存器</p>
<h2 id="配置输入"><a href="#配置输入" class="headerlink" title="配置输入"></a>配置输入</h2><p>输入数据寄存器GPIOx_IDR是一个只读的寄存器，在使用时只要将GPIO通过GPIOx_MODER设置为输入模式后访问该寄存器就可以读取到当前采样值，输入数据寄存器会在每个时钟频率对外界信号进行一次采样</p>
<p>所有端口都具有外部中断功能。<strong>要使用外部中断线，必须将端口配置为输入模式</strong></p>
<p>使用库函数配置如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PA4_PE0_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;<span class="comment">//这里是stm32库定义的外设初始化结构体，在此进行“例化”</span></span><br><span class="line">	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA|RCC_AHB1Periph_GPIOE, ENABLE);<span class="comment">//使能GPIOA,GPIOE时钟</span></span><br><span class="line"></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;<span class="comment">//配置P4</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;<span class="comment">//配置为普通输入模式</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;<span class="comment">//速度设置为100M</span></span><br><span class="line">	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;<span class="comment">//配置为内部下拉</span></span><br><span class="line">    </span><br><span class="line">	GPIO_Init(GPIOE, &amp;GPIO_InitStructure);<span class="comment">//初始化GPIOE4</span></span><br><span class="line">	 </span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;<span class="comment">//修改为Pin0</span></span><br><span class="line">	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;<span class="comment">//内部下拉</span></span><br><span class="line">    </span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<span class="comment">//初始化GPIOE0</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>外部中断的配置可以参考【NVIC中断控制】相关文章，这里不列出</p>
<p>使用下面的函数读取GPIO输入值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">GPIO_ReadInputDataBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="keyword">uint16_t</span> GPIO_Pin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="keyword">uint8_t</span> bitstatus = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">/* Check the parameters */</span></span><br><span class="line">  	assert_param(IS_GPIO_ALL_PERIPH(GPIOx));</span><br><span class="line">  	assert_param(IS_GET_GPIO_PIN(GPIO_Pin));</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">if</span> ((GPIOx-&gt;IDR &amp; GPIO_Pin) != (<span class="keyword">uint32_t</span>)Bit_RESET)</span><br><span class="line">  	&#123;</span><br><span class="line">   	 	bitstatus = (<span class="keyword">uint8_t</span>)Bit_SET;<span class="comment">//通过读取判断寄存器的值来获取当前输入值</span></span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">else</span></span><br><span class="line">  	&#123;</span><br><span class="line">    	bitstatus = (<span class="keyword">uint8_t</span>)Bit_RESET;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> bitstatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置输出"><a href="#配置输出" class="headerlink" title="配置输出"></a>配置输出</h2><p>输出数据寄存器 GPIOx_ODR</p>
<p>使用库函数配置如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PF9_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;    	 </span><br><span class="line">  	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">  	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF, ENABLE);<span class="comment">//使能GPIOF时钟</span></span><br><span class="line"></span><br><span class="line">  	<span class="comment">//GPIOF9初始化设置</span></span><br><span class="line">  	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;<span class="comment">//要配置的位是第9位</span></span><br><span class="line">  	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;<span class="comment">//普通输出模式</span></span><br><span class="line">  	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;<span class="comment">//推挽输出</span></span><br><span class="line">  	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;<span class="comment">//速度配置位100MHz</span></span><br><span class="line">  	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;<span class="comment">//配置上拉</span></span><br><span class="line">    </span><br><span class="line">  	GPIO_Init(GPIOF, &amp;GPIO_InitStructure);<span class="comment">//对GPIOF按照上面的配置进行初始化</span></span><br><span class="line">	</span><br><span class="line">    GPIO_SetBits(GPIOF,GPIO_Pin_9 | GPIO_Pin_10);<span class="comment">//GPIOF9,F10设置高，灯灭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>库函数的底层都是对寄存器的操作，摘录如下：</p>
<p>时钟控制库函数是对RCC寄存器进行操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RCC_APB2PeriphClockCmd</span><span class="params">(<span class="keyword">uint32_t</span> RCC_APB2Periph, FunctionalState NewState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));<span class="comment">//这里检查是否使用了正确的参数</span></span><br><span class="line">  	assert_param(IS_FUNCTIONAL_STATE(NewState));</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">if</span> (NewState != DISABLE)</span><br><span class="line">  	&#123;</span><br><span class="line">    	RCC-&gt;APB2ENR |= RCC_APB2Periph;</span><br><span class="line">        <span class="comment">//参数设置为ENABLE时就使用上面提供的参数开启RCC寄存器下属APB2使能寄存器中的相关外设时钟控制位</span></span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">else</span></span><br><span class="line">  	&#123;</span><br><span class="line">    	RCC-&gt;APB2ENR &amp;= ~RCC_APB2Periph;</span><br><span class="line">        <span class="comment">//否则关闭相对应的控制位</span></span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化结构体是对GPIO控制寄存器的封装</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  	<span class="keyword">uint32_t</span> GPIO_Pin;</span><br><span class="line">  	GPIOMode_TypeDef GPIO_Mode;</span><br><span class="line">  	GPIOSpeed_TypeDef GPIO_Speed;</span><br><span class="line">  	GPIOOType_TypeDef GPIO_OType;</span><br><span class="line">  	GPIOPuPd_TypeDef GPIO_PuPd;</span><br><span class="line">&#125;GPIO_InitTypeDef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">  	GPIO_Mode_IN   = <span class="number">0x00</span>, <span class="comment">/*!&lt; GPIO Input Mode */</span></span><br><span class="line">  	GPIO_Mode_OUT  = <span class="number">0x01</span>, <span class="comment">/*!&lt; GPIO Output Mode */</span></span><br><span class="line">  	GPIO_Mode_AF   = <span class="number">0x02</span>, <span class="comment">/*!&lt; GPIO Alternate function Mode */</span></span><br><span class="line">  	GPIO_Mode_AN   = <span class="number">0x03</span>  <span class="comment">/*!&lt; GPIO Analog Mode */</span></span><br><span class="line">&#125;GPIOMode_TypeDef;<span class="comment">//对应GPIO_Mode的枚举量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">  	GPIO_OType_PP = <span class="number">0x00</span>,</span><br><span class="line">  	GPIO_OType_OD = <span class="number">0x01</span></span><br><span class="line">&#125;GPIOOType_TypeDef;<span class="comment">//对应GPIO_OType的枚举量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">  	GPIO_Low_Speed     = <span class="number">0x00</span>, <span class="comment">/*!&lt; Low speed    */</span></span><br><span class="line">  	GPIO_Medium_Speed  = <span class="number">0x01</span>, <span class="comment">/*!&lt; Medium speed */</span></span><br><span class="line">  	GPIO_Fast_Speed    = <span class="number">0x02</span>, <span class="comment">/*!&lt; Fast speed   */</span></span><br><span class="line">  	GPIO_High_Speed    = <span class="number">0x03</span>  <span class="comment">/*!&lt; High speed   */</span></span><br><span class="line">&#125;GPIOSpeed_TypeDef;<span class="comment">//对应GPIO_Speed的枚举量</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  GPIO_Speed_2MHz    GPIO_Low_Speed    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  GPIO_Speed_25MHz   GPIO_Medium_Speed </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  GPIO_Speed_50MHz   GPIO_Fast_Speed </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  GPIO_Speed_100MHz  GPIO_High_Speed</span></span><br><span class="line"><span class="comment">//再对枚举量封装一遍，便于直观设置GPIO速度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">  	GPIO_PuPd_NOPULL = <span class="number">0x00</span>,</span><br><span class="line">  	GPIO_PuPd_UP     = <span class="number">0x01</span>,</span><br><span class="line">  	GPIO_PuPd_DOWN   = <span class="number">0x02</span></span><br><span class="line">&#125;GPIOPuPd_TypeDef;</span><br><span class="line"><span class="comment">//对应GPIO_PuPd的枚举量</span></span><br></pre></td></tr></table></figure>

<p>GPIO初始化函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_Init</span><span class="params">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> pinpos = <span class="number">0x00</span>, pos = <span class="number">0x00</span> , currentpin = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));</span><br><span class="line">  assert_param(IS_GPIO_PIN(GPIO_InitStruct-&gt;GPIO_Pin));</span><br><span class="line">  assert_param(IS_GPIO_MODE(GPIO_InitStruct-&gt;GPIO_Mode));</span><br><span class="line">  assert_param(IS_GPIO_PUPD(GPIO_InitStruct-&gt;GPIO_PuPd));</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">for</span> (pinpos = <span class="number">0x00</span>; pinpos &lt; <span class="number">0x10</span>; pinpos++)</span><br><span class="line">  	&#123;</span><br><span class="line">    	pos = ((<span class="keyword">uint32_t</span>)<span class="number">0x01</span>) &lt;&lt; pinpos;</span><br><span class="line">    	<span class="comment">//从参数获取GPIO引脚位</span></span><br><span class="line">    	currentpin = (GPIO_InitStruct-&gt;GPIO_Pin) &amp; pos;</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">if</span> (currentpin == pos)</span><br><span class="line">    	&#123;</span><br><span class="line">            <span class="comment">//配置输入/输出模式参数</span></span><br><span class="line">      		GPIOx-&gt;MODER  &amp;= ~(GPIO_MODER_MODER0 &lt;&lt; (pinpos * <span class="number">2</span>));</span><br><span class="line">      		GPIOx-&gt;MODER |= (((<span class="keyword">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_Mode) &lt;&lt; (pinpos * <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果是输出或复用模式，则可以配置下面几个参数，否则在初始化结构体中无论怎么配置都不会生效</span></span><br><span class="line">      <span class="keyword">if</span> ((GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_AF))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* Check Speed mode parameters */</span></span><br><span class="line">        assert_param(IS_GPIO_SPEED(GPIO_InitStruct-&gt;GPIO_Speed));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//配置速度参数</span></span><br><span class="line">        GPIOx-&gt;OSPEEDR &amp;= ~(GPIO_OSPEEDER_OSPEEDR0 &lt;&lt; (pinpos * <span class="number">2</span>));</span><br><span class="line">        GPIOx-&gt;OSPEEDR |= ((<span class="keyword">uint32_t</span>)(GPIO_InitStruct-&gt;GPIO_Speed) &lt;&lt; (pinpos * <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check Output mode parameters */</span></span><br><span class="line">        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct-&gt;GPIO_OType));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//配置输出方式参数</span></span><br><span class="line">        GPIOx-&gt;OTYPER  &amp;= ~((GPIO_OTYPER_OT_0) &lt;&lt; ((<span class="keyword">uint16_t</span>)pinpos)) ;</span><br><span class="line">        GPIOx-&gt;OTYPER |= (<span class="keyword">uint16_t</span>)(((<span class="keyword">uint16_t</span>)GPIO_InitStruct-&gt;GPIO_OType) &lt;&lt; ((<span class="keyword">uint16_t</span>)pinpos));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      	<span class="comment">//上拉/下拉寄存器设置</span></span><br><span class="line">      	GPIOx-&gt;PUPDR &amp;= ~(GPIO_PUPDR_PUPDR0 &lt;&lt; ((<span class="keyword">uint16_t</span>)pinpos * <span class="number">2</span>));</span><br><span class="line">      	GPIOx-&gt;PUPDR |= (((<span class="keyword">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_PuPd) &lt;&lt; (pinpos * <span class="number">2</span>));</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GPIO输出控制函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_SetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="keyword">uint16_t</span> GPIO_Pin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="comment">/* Check the parameters */</span></span><br><span class="line">  	assert_param(IS_GPIO_ALL_PERIPH(GPIOx));</span><br><span class="line">  	assert_param(IS_GPIO_PIN(GPIO_Pin));</span><br><span class="line"></span><br><span class="line">  	GPIOx-&gt;BSRRL = GPIO_Pin;<span class="comment">//直接对GPIO引脚置位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_ResetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="keyword">uint16_t</span> GPIO_Pin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="comment">/* Check the parameters */</span></span><br><span class="line">  	assert_param(IS_GPIO_ALL_PERIPH(GPIOx));</span><br><span class="line">  	assert_param(IS_GPIO_PIN(GPIO_Pin));</span><br><span class="line"></span><br><span class="line">  	GPIOx-&gt;BSRRH = GPIO_Pin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_WriteBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="keyword">uint16_t</span> GPIO_Pin, BitAction BitVal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="comment">/* Check the parameters */</span></span><br><span class="line">  	assert_param(IS_GPIO_ALL_PERIPH(GPIOx));</span><br><span class="line">  	assert_param(IS_GET_GPIO_PIN(GPIO_Pin));</span><br><span class="line">  	assert_param(IS_GPIO_BIT_ACTION(BitVal));</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">if</span> (BitVal != Bit_RESET)</span><br><span class="line">  	&#123;</span><br><span class="line">    	GPIOx-&gt;BSRRL = GPIO_Pin;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">else</span></span><br><span class="line">  	&#123;</span><br><span class="line">    	GPIOx-&gt;BSRRH = GPIO_Pin ;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">  	Bit_RESET = <span class="number">0</span>,</span><br><span class="line">  	Bit_SET</span><br><span class="line">&#125;BitAction;</span><br><span class="line"><span class="comment">//对应BitVal的枚举量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//还有一个比较方便的翻转输出值函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_ToggleBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="keyword">uint16_t</span> GPIO_Pin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="comment">/* Check the parameters */</span></span><br><span class="line">  	assert_param(IS_GPIO_ALL_PERIPH(GPIOx));</span><br><span class="line"></span><br><span class="line">  	GPIOx-&gt;ODR ^= GPIO_Pin;<span class="comment">//异或运算，如果和之前的值相同，则反转；可以通过多次使用该函数反转输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//很莽的一个函数，直接设置GPIO端口值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_Write</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="keyword">uint16_t</span> PortVal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="comment">/* Check the parameters */</span></span><br><span class="line">  	assert_param(IS_GPIO_ALL_PERIPH(GPIOx));</span><br><span class="line"></span><br><span class="line">  	GPIOx-&gt;ODR = PortVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="开漏模式与推挽模式"><a href="#开漏模式与推挽模式" class="headerlink" title="开漏模式与推挽模式"></a>开漏模式与推挽模式</h3><p>开漏模式：输出寄存器中置0位可激活连接到V<del>SS</del>的N-MOS，而输出寄存器中置1会使端口保持高阻态z，连接到V<del>DD</del>的P-MOS始终不会开启，也就是说配置寄存器只会控制GPIO的开漏<br>推挽模式：输出寄存器中置0位可激活N-MOS，而输出寄存器中置1可激活P-MOS，达到推挽输出的效果</p>
<h2 id="模拟配置"><a href="#模拟配置" class="headerlink" title="模拟配置"></a>模拟配置</h2><p>一下内容摘自参考手册原文</p>
<blockquote>
<p>对 I/O 端口进行编程作为模拟配置时</p>
<p>● 输出缓冲器被禁止</p>
<p>● 施密特触发器输入停用，I/O 引脚的每个模拟输入的功耗变为零。施密特触发器的输出被强制处理为恒定值 (0)</p>
<p>● 弱上拉和下拉电阻被关闭</p>
<p>● 对输入数据寄存器的读访问值为“0”</p>
</blockquote>
<p>注意：<strong>在模拟配置中，I/O引脚不能为5V容忍</strong></p>
<h2 id="振荡器引脚和RTC引脚作为GPIO"><a href="#振荡器引脚和RTC引脚作为GPIO" class="headerlink" title="振荡器引脚和RTC引脚作为GPIO"></a>振荡器引脚和RTC引脚作为GPIO</h2><p>当LSE振荡器处于关闭状态时，可分别将LSE引脚OSC32_IN和OSC32_OUT用作普通的PC14和PC15引脚</p>
<p>但当LSE开启时，两个引脚只能作为LSE引脚，LSE的优先级是高于GPIO配置的，所以程序中对这两个引脚的GPIO配置会被无效</p>
<p>当HSE振荡器处于关闭状态时，可分别将HSE振荡器引脚OSC_IN和OSC_OUT用作PH0和PH1引脚</p>
<p>但当HSE振荡器处于开启状态时，PH0/PH1只能被配置为OSC_IN/OSC_OUT HSE振荡器引脚，也是优先于GPIO配置</p>
<p>另外还有RTC_AF1和RTC_AF2两个引脚，可以用来检测入侵或时间戳时间、RTC_ALARM或RTC_CALIB RTC输出</p>
<p>设置为RTC_ALARM输出时可用于两个RTC输出或RTC的唤醒，有RTC_CR寄存器中的OSEL[1:0]位配置</p>
<p>其他功能查看参数手册即可</p>
<h2 id="锁定GPIO"><a href="#锁定GPIO" class="headerlink" title="锁定GPIO"></a>锁定GPIO</h2><p>在库函数中提供了锁定GPIO的函数，摘录如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_PinLockConfig</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="keyword">uint16_t</span> GPIO_Pin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __IO <span class="keyword">uint32_t</span> tmp = <span class="number">0x00010000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));</span><br><span class="line">  assert_param(IS_GPIO_PIN(GPIO_Pin));</span><br><span class="line"></span><br><span class="line">  tmp |= GPIO_Pin;</span><br><span class="line">  <span class="comment">/* Set LCKK bit */</span></span><br><span class="line">  GPIOx-&gt;LCKR = tmp;</span><br><span class="line">  <span class="comment">/* Reset LCKK bit */</span></span><br><span class="line">  GPIOx-&gt;LCKR =  GPIO_Pin;</span><br><span class="line">  <span class="comment">/* Set LCKK bit */</span></span><br><span class="line">  GPIOx-&gt;LCKR = tmp;</span><br><span class="line">  <span class="comment">/* Read LCKK bit*/</span></span><br><span class="line">  tmp = GPIOx-&gt;LCKR;</span><br><span class="line">  <span class="comment">/* Read LCKK bit*/</span></span><br><span class="line">  tmp = GPIOx-&gt;LCKR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接输入GPIOx和要锁定的引脚就可以进行锁定</p>
<h1 id="GPIO复用"><a href="#GPIO复用" class="headerlink" title="GPIO复用"></a>GPIO复用</h1><h2 id="GPIO复用器"><a href="#GPIO复用器" class="headerlink" title="GPIO复用器"></a>GPIO复用器</h2><p><strong>每个GPIO引脚都有一个采用16路复用功能输入的复用器</strong>，GPIO通过这些复用器连接到片上外设，这个复用器一次仅允许一个外设的复用功能连接到GPIO引脚，确保共用同一个GPIO引脚的外设之间不会发生冲突</p>
<p>复用器输入从AF0到AF15，通过引脚复用寄存器的低8位GPIOx_AFRL和高8位GPIOx_AFRH分别设置</p>
<p>外设的复用功能映射到AF1至AF13，AF0是悬空状态，AF15则是系统的EVENTOUT接入</p>
<h3 id="EVENTOUT"><a href="#EVENTOUT" class="headerlink" title="EVENTOUT"></a>EVENTOUT</h3><p>参考ARM内核部分内容</p>
<h2 id="GPIO复用输入输出"><a href="#GPIO复用输入输出" class="headerlink" title="GPIO复用输入输出"></a>GPIO复用输入输出</h2><p>在库函数中使用以下方式设置GPIO连接到复用器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_PinAFConfig(GPIOF,GPIO_PinSource9,GPIO_AF_TIM14);<span class="comment">//GPIOF9通过复用器连接到定时器14</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;<span class="comment">//在初始化结构体中配置为复用</span></span><br><span class="line"><span class="comment">//开启GPIO时钟同时也要开启所要复用外设的时钟</span></span><br><span class="line"><span class="comment">//不要忘记使能外设</span></span><br><span class="line"><span class="comment">//GPIO的其他功能按照正常配置即可</span></span><br></pre></td></tr></table></figure>

<p>复用功能设置库函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_PinAFConfig</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="keyword">uint16_t</span> GPIO_PinSource, <span class="keyword">uint8_t</span> GPIO_AF)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="keyword">uint32_t</span> temp = <span class="number">0x00</span>;</span><br><span class="line">  	<span class="keyword">uint32_t</span> temp_2 = <span class="number">0x00</span>;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">/* Check the parameters */</span></span><br><span class="line">  	assert_param(IS_GPIO_ALL_PERIPH(GPIOx));</span><br><span class="line">  	assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));</span><br><span class="line">  	assert_param(IS_GPIO_AF(GPIO_AF));</span><br><span class="line">  </span><br><span class="line">  	temp = ((<span class="keyword">uint32_t</span>)(GPIO_AF) &lt;&lt; ((<span class="keyword">uint32_t</span>)((<span class="keyword">uint32_t</span>)GPIO_PinSource &amp; (<span class="keyword">uint32_t</span>)<span class="number">0x07</span>) * <span class="number">4</span>)) ;</span><br><span class="line">  	GPIOx-&gt;AFR[GPIO_PinSource &gt;&gt; <span class="number">0x03</span>] &amp;= ~((<span class="keyword">uint32_t</span>)<span class="number">0xF</span> &lt;&lt; ((<span class="keyword">uint32_t</span>)((<span class="keyword">uint32_t</span>)GPIO_PinSource &amp; (<span class="keyword">uint32_t</span>)<span class="number">0x07</span>) * <span class="number">4</span>)) ;</span><br><span class="line">    <span class="comment">//设置复用寄存器</span></span><br><span class="line">    </span><br><span class="line">  	temp_2 = GPIOx-&gt;AFR[GPIO_PinSource &gt;&gt; <span class="number">0x03</span>] | temp;</span><br><span class="line">  	GPIOx-&gt;AFR[GPIO_PinSource &gt;&gt; <span class="number">0x03</span>] = temp_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在库函数中提供的参考表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* GPIO_AFSelection: 选择被用于复用的引脚</span></span><br><span class="line"><span class="comment">  *          This parameter can be one of the following values:</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_RTC_50Hz: Connect RTC_50Hz pin to AF0 (default after reset) </span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_MCO: Connect MCO pin (MCO1 and MCO2) to AF0 (default after reset) </span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_TAMPER: Connect TAMPER pins (TAMPER_1 and TAMPER_2) to AF0 (default after reset) </span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_SWJ: Connect SWJ pins (SWD and JTAG)to AF0 (default after reset) </span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_TRACE: Connect TRACE pins to AF0 (default after reset)</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_TIM1: Connect TIM1 pins to AF1</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_TIM2: Connect TIM2 pins to AF1</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_TIM3: Connect TIM3 pins to AF2</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_TIM4: Connect TIM4 pins to AF2</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_TIM5: Connect TIM5 pins to AF2</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_TIM8: Connect TIM8 pins to AF3</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_TIM9: Connect TIM9 pins to AF3</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_TIM10: Connect TIM10 pins to AF3</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_TIM11: Connect TIM11 pins to AF3</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_I2C1: Connect I2C1 pins to AF4</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_I2C2: Connect I2C2 pins to AF4</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_I2C3: Connect I2C3 pins to AF4</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_SPI1: Connect SPI1 pins to AF5</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_SPI2: Connect SPI2/I2S2 pins to AF5</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_SPI4: Connect SPI4 pins to AF5 </span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_SPI5: Connect SPI5 pins to AF5 </span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_SPI6: Connect SPI6 pins to AF5</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_SAI1: Connect SAI1 pins to AF6 for STM32F42xxx/43xxx devices.       </span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_SPI3: Connect SPI3/I2S3 pins to AF6</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_I2S3ext: Connect I2S3ext pins to AF7</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_USART1: Connect USART1 pins to AF7</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_USART2: Connect USART2 pins to AF7</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_USART3: Connect USART3 pins to AF7</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_UART4: Connect UART4 pins to AF8</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_UART5: Connect UART5 pins to AF8</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_USART6: Connect USART6 pins to AF8</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_UART7: Connect UART7 pins to AF8</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_UART8: Connect UART8 pins to AF8</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_CAN1: Connect CAN1 pins to AF9</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_CAN2: Connect CAN2 pins to AF9</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_TIM12: Connect TIM12 pins to AF9</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_TIM13: Connect TIM13 pins to AF9</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_TIM14: Connect TIM14 pins to AF9</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_OTG_FS: Connect OTG_FS pins to AF10</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_OTG_HS: Connect OTG_HS pins to AF10</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_ETH: Connect ETHERNET pins to AF11</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_FSMC: Connect FSMC pins to AF12 </span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_FMC: Connect FMC pins to AF12 for STM32F42xxx/43xxx devices.   </span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_OTG_HS_FS: Connect OTG HS (configured in FS) pins to AF12</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_SDIO: Connect SDIO pins to AF12</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_DCMI: Connect DCMI pins to AF13</span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_LTDC: Connect LTDC pins to AF14 for STM32F429xx/439xx devices. </span></span><br><span class="line"><span class="comment">  *            @arg GPIO_AF_EVENTOUT: Connect EVENTOUT pins to AF15</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="使用GPIO的步骤"><a href="#使用GPIO的步骤" class="headerlink" title="使用GPIO的步骤"></a>使用GPIO的步骤</h1><ol>
<li><p>系统功能</p>
<p>复位后GPIO自动连接AF0，然后会根据寄存器配置进行初始化，在这个阶段会进行JTAG/SWD、RTC参考输入、MCO1、MCO2等系统功能的引脚初始化</p>
</li>
<li><p>GPIO输入输出配置</p>
<p>在GPIOx_MODER寄存器中将所需 I/O 配置为输出或输入即可进行独立的输入输出</p>
<p>注意需要打开GPIO时钟！</p>
</li>
<li><p>外设复用使能</p>
<p>对于ADC和DAC，需要在GPIOx_MODER寄存器中将所需 I/O 配置为模拟输入/输出</p>
<p>对其他外设则需要在GPIOx_MODER寄存器中使能复用</p>
</li>
<li><p>其他选项</p>
<p>通过GPIOx_OTYPER、GPIOx_PUPDR和GPIOx_OSPEEDER寄存器，分别选择类型、上拉/下拉以及输出速度</p>
<p>在GPIOx_AFRL或GPIOx_AFRH寄存器中选择连接的具体复用外设</p>
<p>外设能复用的GPIO是唯一的，应该使用CubeMX或查阅芯片参考手册来设置</p>
</li>
<li><p>配置EVENTOUT</p>
<p>通过将复用器连接到AF15来配置用于输出Cortex-M4内核EVENTOUT信号的GPIO引脚</p>
<p>注意：对于stm32f407，EVENTOUT不会映射到PC13、PC14、PC15、PH0、PH1、PI8引脚</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title>常用控制算法</title>
    <url>/2021/11/14/%E5%B8%B8%E7%94%A8%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="硬件控制算法"><a href="#硬件控制算法" class="headerlink" title="硬件控制算法"></a>硬件控制算法</h1><p>可应用的电路系统一般由模拟电路和数字电路组成。模拟电路用于电信号的处理和提供电源；数字电路则用于采集非电信号数据和控制系统。一般来说系统控制使用MCU、DSP或FPGA通过软件编程实现，在其中常使用用于控制系统的各种算法。</p>
<span id="more"></span>

<h2 id="PID算法"><a href="#PID算法" class="headerlink" title="PID算法"></a>PID算法</h2><h3 id="PID算法简介"><a href="#PID算法简介" class="headerlink" title="PID算法简介"></a>PID算法简介</h3><p>PID算法是一种很成熟、应用广泛的连续时间控制系统算法，最突出优点在于：</p>
<ul>
<li>结构典型</li>
<li>方便参数整定</li>
<li>可以灵活更改结构</li>
</ul>
<p>除了数字PID，还存在使用电阻、电容反馈与集成运放配合实现的模拟PID，但是因为其不便于修改和调参，适用范围不广</p>
<p>PID是一种典型的闭环控制算法，使用PID控制器<em>D(s)<em>来完成控制，该控制器读取输出量</em>y(t)<em>和给定量</em>r(t)<em>，计算得到二者之间的误差</em>e(t)=r(t)-t(t)<em>，并获取其比例、积分、微分的线性组合来构成控制量</em>u(t)<em>，通过改变调节器参数</em>K<del>p</del>，K<del>i</del>，K<del>d</del><em>来实现控制，计算公式如下<br>$$<br>u(t)=K_P[e(t)+\frac{1}{T_I} \int_0^t e(t)dt+T_D \frac{de(t)}{dt}]<br>$$<br>或者可以采用变形公式<br>$$<br>u(t)=K_P\ e(t)+K_I \int_0^t e(t)dt+K_D \frac{de(t)}{dt}<br>$$<br>其中**三个参数P、I、D分别表示比例、积分、微分</em></em></p>
<p>实际应用中最常使用PI甚至只使用P参数来进行控制。因为D参数常常会引入不确定性，增大调参的难度。</p>
<p>三个参数的特性如下：</p>
<ul>
<li><p>比例调节参数K<del>P</del></p>
<p>  按比例反映系统的误差，一旦系统出现偏差比例调节就会进行，<strong>比例调节是主要的控制部分</strong>。但是过大的比例会使系统稳定性下降，系统反应更灵敏、速度加快、稳态误差更小，但是震荡次数会显著增多，调节时间也会加长；过小的比例则会导致系统很难回到稳态</p>
</li>
<li><p>积分调节参数K<del>I</del></p>
<p>  这个参数本质上是通过给定量和输出量之间稳态值的差来消除系统稳态误差，<strong>用于提高系统的控制精度</strong>。但过高的调节参数会导致系统稳定性下降，动态响应变慢，超调增大，该参数一般不单独作用，至少需要和P参数共用</p>
</li>
<li><p>微分调节参数K<del>D</del></p>
<p>  用于反映系统偏差信号的变化率，可以一定程度上预测偏差的变化趋势，<strong>起到超前控制作用</strong>。但是该参数难以整定，且过强的微分调节会使系统剧烈震荡，且对噪声干扰有放大作用，对抗干扰不利</p>
</li>
</ul>
<h3 id="数字PID控制"><a href="#数字PID控制" class="headerlink" title="数字PID控制"></a>数字PID控制</h3><p>数字控制系统大多数是采样数据控制系统，进入系统的连续时间信号必须经过采样和量化后转换为数字量才能进行相应的计算和处理，所以其中的参数需要使用数字计算去逼近，当采样周期短时可以使用求和代替积分，使用差商代替微商，<strong>将描述连续时间的PID算法微分方程变成描述离散时间的差分方程</strong></p>
<p>实际使用时有两种思路：</p>
<ol>
<li><p>位置式PID</p>
<p> 差分方程为<br> $$<br> u_n=K_P+[e_n+\frac{T_S}{T_I} \sum_{i=0}^n e_i+\frac{T_D}{T_S} (e_n - e_{n-1})]+u_0=K_P e_n +K_I \sum_{i=0}^n e_i+K_D(e_n - e_{n-1})+u_0<br> $$<br> 此式即数字PID算法的非递推形式——全量算法，$u_0$为控制量基准值，n=0时将会采用该值；$u_n$是第n个采样时刻的控制量；$T_S$为采样周期，在算法中为了实现求和，必须存储系统偏差的全部值$e_i$，该式求得全量输出$u_n$是控制量的绝对数值，决定了执行机构在控制系统中的位置</p>
<p> 因此称这种算法为位置算法</p>
</li>
<li><p>增量式PID</p>
<p> 当驱动步进电机这样需要控制量的增量的执行机构时，需要用增量算法，差分方程为<br> $$<br> \Delta u_n=u_n-u_{n-1}=K_P[e_n - e_{n-1}+\frac{T_S}{T_I}e_n +\frac{T_D}{T_S}(e_n -2e_{n-1}+e_{n-2})]<br> $$<br> 这时的输出值能体现各次误差量对控制作用的影响，计算时只需要存储最近的三个误差采样值$e_n,e_{n-1},e_{n-2}$</p>
</li>
</ol>
<h3 id="PID算法的饱和特性"><a href="#PID算法的饱和特性" class="headerlink" title="PID算法的饱和特性"></a>PID算法的饱和特性</h3><p>实际的控制系统存在这样的特性：当控制变量达到一定值后，系统的输出变量便不再增长，系统进入饱和区，称为<strong>饱和特性</strong>，这就要求系统的控制变量必须限制在某个范围之内$u_{min}\le u\le u_{max}$。有时对于控制量的变化率也有限制$|\frac{du}{dt}|\le|\frac{du_{max}}{dt}| $，为了能让控制系统更加稳定，需要对位置算法进行改进；虽然增量算法中没有累加和项，不会出现积分饱和，但是可能出现比例和微分饱和，需要使用积累补偿法，将因为饱和而未能执行的控制增量信息累积起来，一旦可能时再补充执行</p>
<p>位置算法的饱和主要由积分项引起，称为<strong>积分饱和</strong>，可以使用三种方法必免积分积累过大</p>
<ol>
<li><p>积分分离法</p>
<p> 在误差量较大时不进行积分，直到误差在一定值之内时才在控制量的计算中加入积分累积，差分方程为<br> $$<br> u_n=K_P e_n + K_I \sum_{i=0}^n K_i e_i +K_D(e_n -e_{n-1})<br> $$<br> 其中K<del>i</del>在$e_x\le \epsilon$时为1，在$e_x\ge \epsilon$时为0，以$\epsilon$作为门限值可以有效削减积分饱和</p>
</li>
<li><p>遇限削弱积分法</p>
<p> 当<strong>控制进入饱和区后便不再进行积分项的累加</strong>，只执行削弱积分的运算，使用该算法可以避免控制量长时间停留在饱和区</p>
</li>
<li><p>有效偏差法</p>
<p> 将<strong>实际执行的控制量对应的误差值</strong>作为有效误差值进行积分累加，而不是使用实际的误差值进行积分累加</p>
</li>
</ol>
<h3 id="PID调参（参数整定）"><a href="#PID调参（参数整定）" class="headerlink" title="PID调参（参数整定）"></a>PID调参（参数整定）</h3><ol>
<li><p>确定PID控制器结构</p>
<ul>
<li>控制结果比较宽松且要求稳定性的控制系统：P或PD控制器</li>
<li>必须消除稳态误差且要求精度的控制系统：PI或PID控制器</li>
<li>存在滞后的对象：PI控制器或PID控制器</li>
</ul>
<p> 一般情况下，P、PI、PID控制器应用较多，ID控制器可以说根本不用</p>
</li>
<li><p>调参</p>
<p> 参数选择要根据受控对象的具体特性和对控制系统的性能要求进行，工程上一般要求整个闭环系统是稳定的，对给定量的变化能迅速响应并平滑跟踪，超调量小；要求抗干扰性较高；总体上遵循解决主要问题，统筹兼顾其他方面，适量折中的思路</p>
<p> PID三个参数一般通过玄学调参或者经验公式确定</p>
<p> 采样周期选择可以通过以下方面进行确定：</p>
<ol>
<li>香农采样定理：$T_S \le \frac{\pi}{\omega_{max}}$（ω为被采样信号的上限角频率），用于确定采样周期的上限</li>
<li>有跟踪要求的闭环系统要适量减小采样周期</li>
<li>要求采样周期有一定宽度来确定计算精度，减少系统算力成本</li>
<li>通过经验公式和玄学调参来确定</li>
</ol>
<p> PID参数的基本调整方法如下：</p>
<ol>
<li>比例项逐次独立实验，取其中反应最快、超调最小的曲线</li>
<li>加入积分项，将之前选择的比例系数减小为50%到80%，再将积分时间置为较大值，观测响应曲线，再逐次减小积分时间，选择其中响应震荡次数较少、能快速趋近结果的参数</li>
<li>加入微分项减小超调和震荡，先设置T<del>D</del>=0，再逐渐加大微分项，在此基础上维持比例项80%到120%调节范围，积分项50%到150%调节范围</li>
<li>如果出现玄学问题可以直接随机调参，运气是实力的一部分</li>
</ol>
</li>
<li><p>特殊调参方法</p>
<ol>
<li><p>选足够短的采样周期，先使用P控制器，逐渐加大比例放大系数逐次实验直到系统对输入的阶跃信号响应出现稳定边缘的临界震荡，将此时的比例放大系数记为$K_r$，临界震荡周期记为$T_r$</p>
</li>
<li><p>以连续时间PID控制器为基准，使用误差平方积分作为评价函数，控制度<br> $$<br> \frac{min \int_0^{\inf} e^2(t)dt（数字控制）}{min\int_0^\inf e^2(t)dt（模拟控制）}<br> $$<br> 保证其必定大于1的前提下，选定一个合适的控制度</p>
</li>
<li><p>查经验公式表获取对应参数</p>
</li>
<li><p>实际检验参数并进行微调</p>
</li>
</ol>
</li>
</ol>
<h2 id="运动调节算法"><a href="#运动调节算法" class="headerlink" title="运动调节算法"></a>运动调节算法</h2><h3 id="大林算法"><a href="#大林算法" class="headerlink" title="大林算法"></a>大林算法</h3><p>许多工程中会遇到纯滞后调节系统，要求系统具有以下特征：</p>
<ul>
<li>滞后时间长</li>
<li>系统动态特性和稳定性高</li>
<li>没有或很少超调量</li>
</ul>
<p>一般使用大林算法处理这类问题。该算法由IBM的大林（Dahlin）设计，专用于处理带有纯滞后的一阶或二阶惯性环节，其传递函数分别为<br>$$<br>G_c(s)=\frac{Ke^{-\theta s}}{\tau_1 s +1}<br>$$<br>或<br>$$<br>G_c(s)=\frac{Ke^{-\theta s}}{(\tau_1 s+1)(\tau_2 s +1)}<br>$$<br>其中τ1和2都是对象的时间常数，θ=Nτ是对象的纯滞后时间，N为正整数，K为对象的放大倍数</p>
<p>该算法适合对ADC、DAC等需要一定时间的转换器或带有硬件运算电路的设备进行控制，使得整个闭环系统的传递参数为带有纯滞后时间的一阶惯性环节，即<br>$$<br>\Phi(s)=\frac{e^{-\theta s}}{\tau_1 s +1}<br>$$<br>算法数字控制器的最终表达式：<br>$$<br>U(k)=a_1 E(k)-a_2E(k-1)+b_1 U(k-1) +(1-b_1)U(k-N-1)<br>$$<br>U(k)为k时刻的输出值，E(k)是k时刻的误差值，E(k-1)是k-1时刻的误差值，U(k-N-1)是k-N-1时刻的输出值</p>
<p>该算法调参依旧很玄学，但是没有PID那么玄学，只要根据系统飞升曲线确定对象的纯滞后时间θ和系统时间常数τ，微调选取采样周期再不断调整τ值一般就能获得理想效果</p>
<p>该算法最大的优势就是消除了由于超调引起的系统不稳定因素</p>
<h3 id="模糊控制算法"><a href="#模糊控制算法" class="headerlink" title="模糊控制算法"></a>模糊控制算法</h3><p>当系统影响因素极度复杂，难以建立数学模型时，需要使用模糊控制算法。这是一种鲁棒性强、抗干扰、抗参数变化的非线性控制算法，适用于非线性、动态特征不易掌握及纯滞后系统的控制。模糊控制不受数学模型的束缚，采用模糊控制表，在调试过程中反复经过人工修正，建立模糊控制算法、确立模糊规则是设计模糊控制系统中最重要的环节。模糊控制算法的问题在于稳态精度低、易饱和、适应能力有限、没有形成完整的理论体系。</p>
<p>这一算法需要以下步骤实现建模：</p>
<ol>
<li><p>归纳实验经验：将经验公式归结为一组条件语句，称为<strong>模糊控制规则</strong>或模糊控制模型</p>
</li>
<li><p>将误差e和误差变化率de/dt进行模糊化处理：将输入变量映射到一个合适的响应领域或模糊集合的标识符</p>
<p> 本人接盘的一个项目代码里存在以下代码（关键数据已经模糊替换处理）</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	u8 AFlag = (RotateNum &gt; StraightNum);</span><br><span class="line">	u8 BFlag = ((RotateNum + StraightNum) &gt; Magicnumber);</span><br><span class="line">	u8 CFlag = (RotateNum &gt; Magicnumber);</span><br><span class="line">	u8 DFlag = (StraightNum &gt; Magicnumber);</span><br><span class="line">	u8 SFlag = AFlag * Magicnumber + BFlag * Magicnumber + CFlag * Magicnumber + DFlag;</span><br><span class="line">	<span class="keyword">switch</span> (condition)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> Magicnumber:</span><br><span class="line">	<span class="keyword">case</span> Magicnumber:</span><br><span class="line">		*MoveThruster[<span class="number">0</span>] = (u32) (RotateNum);</span><br><span class="line">		*MoveThruster[<span class="number">1</span>] = (u32) (RotateNum);</span><br><span class="line">		*MoveThruster[<span class="number">2</span>] = (u32) ((Magicnumber - RotateNum + StraightNum));</span><br><span class="line">		*MoveThruster[<span class="number">3</span>] = (u32) ((Magicnumber - RotateNum + StraightNum));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> Magicnumber:</span><br><span class="line">	<span class="keyword">case</span> Magicnumber:</span><br><span class="line">		*MoveThruster[<span class="number">0</span>] = (u32) (StraightNum);</span><br><span class="line">		*MoveThruster[<span class="number">1</span>] = (u32) (StraightNum);</span><br><span class="line">		*MoveThruster[<span class="number">2</span>] = (u32) ((Magicnumber - RotateNum + StraightNum));</span><br><span class="line">		*MoveThruster[<span class="number">3</span>] = (u32) ((Magicnumber - RotateNum + StraightNum));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> Magicnumber:</span><br><span class="line">	<span class="keyword">case</span> Magicnumber:</span><br><span class="line">		*MoveThruster[<span class="number">0</span>] = (u32) ((RotateNum + StraightNum - Magicnumber));</span><br><span class="line">		*MoveThruster[<span class="number">1</span>] = (u32) ((RotateNum + StraightNum - Magicnumber));</span><br><span class="line">		*MoveThruster[<span class="number">2</span>] = (u32) (StraightNum);</span><br><span class="line">		*MoveThruster[<span class="number">3</span>] = (u32) (StraightNum);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> Magicnumber:</span><br><span class="line">	<span class="keyword">case</span> Magicnumber:</span><br><span class="line">		*MoveThruster[<span class="number">0</span>] = (u32) ((RotateNum + StraightNum - Magicnumber));</span><br><span class="line">		*MoveThruster[<span class="number">1</span>] = (u32) ((RotateNum + StraightNum - Magicnumber));</span><br><span class="line">		*MoveThruster[<span class="number">2</span>] = (u32) ((Magicnumber - RotateNum));</span><br><span class="line">		*MoveThruster[<span class="number">3</span>] = (u32) ((Magicnumber - RotateNum));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*MoveThruster[<span class="number">4</span>] = (u32) (VerticalNum);</span><br><span class="line">	*MoveThruster[<span class="number">5</span>] = (u32) (VerticalNum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (condition == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	*MoveThruster[<span class="number">0</span>] = (u32) (*PDRotate);</span><br><span class="line">	*MoveThruster[<span class="number">1</span>] = (u32) ((Magicnumber - *PDRotate));</span><br><span class="line">	*MoveThruster[<span class="number">2</span>] = (u32) (*PDRotate);</span><br><span class="line">	*MoveThruster[<span class="number">3</span>] = (u32) (Magicnumber - *PDRotate);</span><br><span class="line">	*MoveThruster[<span class="number">4</span>] = (u32) (VerticalNum);</span><br><span class="line">	*MoveThruster[<span class="number">5</span>] = (u32) (VerticalNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 就是一个模糊控制算法的例子，其中的Magicnumber都是经过大量实验确定的控制数据。使用python自带的map函数可以很好地对数据进行映射。</p>
</li>
<li><p>应用模糊算法：根据控制规则计算出模糊控制量C，之后通过多次实验校准模糊控制规则</p>
</li>
<li><p>构造基本模糊控制器查询表：将之前的一整套控制方法写成库或表</p>
</li>
</ol>
<p>其中确定控制数据的步骤最为关键，称为<strong>解模糊化</strong></p>
<h3 id="神经网络算法"><a href="#神经网络算法" class="headerlink" title="神经网络算法"></a>神经网络算法</h3><p>自动调准控制模型，适应性极强，但算法较复杂，需求算力高，一般的MCU难以实现，一般使用专门的硬件加速单元配合高性能嵌入式处理器实现</p>
<p>算法原理比较复杂，我一个辣鸡电工的也不是很懂（悲）</p>
<h2 id="运动姿态控制算法"><a href="#运动姿态控制算法" class="headerlink" title="运动姿态控制算法"></a>运动姿态控制算法</h2><p>Bresenhan算法是常用的图形扫描算法，只使用整数加法和乘2运算即可实现，可以在低算力水平的MCU中搭载，实现控制物体按规律运动的效果</p>
<h3 id="产生线段的整数Bresenham算法"><a href="#产生线段的整数Bresenham算法" class="headerlink" title="产生线段的整数Bresenham算法"></a>产生线段的整数Bresenham算法</h3><p>直线方程$y=mx+b$，在现实中位于(x0,y0)的物体运动可能有多种趋势，但总体上可以分为以下两种：</p>
<ul>
<li>靠近(x0+1,y0)</li>
<li>靠近(x0+1,y0+1)</li>
</ul>
<p>根据这两种趋势分别计算他们到直线$y=mx+b$的距离d1、d2，在求出两距离之差$\Delta d=d_1-d_2=2m(x_i +1)-2y_i +2b-1$</p>
<p>根据Δd&gt;0，直线上点离(x0+1,y0+1)较近；Δd&lt;0，直线上点离(x0+1,y0)较近，再用该式乘Δx即可得到一般的判别式<br>$$<br>p_1=2\Delta y-\Delta x，x_{i+1}=x_i+1 \<br>y_{i+1}=y_i +1,p_{i+1}=p_i +2(\Delta y-\Delta x)，当p_i\ge 0 \<br>y_{i+1}=y_i,p_{i+1}=p_i +2\Delta y，当p_i&lt; 0<br>$$<br>只需将原公式适当修正，用$|\Delta y|$、$|\Delta x|$替换$\Delta y$、$\Delta x$就能轻易得到向后方运动的线段</p>
<h3 id="产生圆的整数Bresenham算法"><a href="#产生圆的整数Bresenham算法" class="headerlink" title="产生圆的整数Bresenham算法"></a>产生圆的整数Bresenham算法</h3><p>对于圆来说需要用尽可能多的点表示出控制对象需要经过的轨迹点，Bresenham算法也有与上面求直线类似的公式<br>$$<br>p_i=2(x_i+1)^2 +2y_i^2 -2y_i -2R^2 +1 \<br>x_{i+1}=x_i +1 \<br>y_{i+1}=y_i,p_{i+1}=p_i+4x_i+6，若p_i&lt;0 \<br>y_{i+1}=y_i-1,p_{i+1}=p_i +4(x_i-y_i)+10 ，若p_i\ge 0<br>$$<br>将圆分成八个方位，将上式镜像对称即可获得其他七个方位的公式，显而易见计算它需要消耗大量算力资源有两种解决方案：</p>
<ol>
<li>使用RAM存储前1/8的坐标数据，然后通过镜像对称求出剩下的1/8坐标，然后调整顺序输出。这种方法可以节省算力，但是需要耗费大量RAM空间，可能还需要扩展片外RAM</li>
<li>按顺时针求出8组1/8圆的Bresenham算法表达式，在接下来的控制过程中依次切换使用。这种方法不需要额外扩充RAM，但是需要花费经历处理控制-运算衔接问题。在一些性能足够的MCU上可以使用RTOS来减少需要的处理精力，因此这种方法可以有效平衡硬件和需求</li>
</ol>
<h2 id="数字滤波"><a href="#数字滤波" class="headerlink" title="数字滤波"></a>数字滤波</h2><p>数字滤波指使用数值运算达到改变输入信号中所含频率分量的相对比例，或滤除某些频率分量的目的。常用于处理坏点数据、对信号进行平滑处理、消除毛刺等用途</p>
<p>最简单的滤波其实就是按钮软件消抖</p>
<h3 id="限幅滤波"><a href="#限幅滤波" class="headerlink" title="限幅滤波"></a>限幅滤波</h3><p>又叫程序判断滤波，根据多次采集到的数据，如果当前采集值和前一次采集值维持在一定偏差ΔD之内，则将每次采集到的数据和前一次数据进行比较，如果它们差的绝对值小于ΔD，则本次采集到的数据有效，否则舍弃</p>
<p>这种滤波器可以克服偶然因素引入的脉冲干扰和波形上的尖峰毛刺，但是难以抑制周期性干扰且对于波形处理的平滑度较差，只能算作一种最简单的基本滤波</p>
<h3 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h3><p>将原来的采样间隔进行细分，在原有基础上采样N次，然后把N次采样值按照大小排序，取中位数为本次采样值。</p>
<p>能够有效克服偶然因素带来的干扰，对于变化缓慢的被测参数有良好的滤波效果，但对于快速变化的信号则不太适用。算法实现方面，一般采用冒泡排序、选择排序、快速排序等算法，由于引入了排序算法，该方法不能处理速度要求很高的信号，算法的运算速度和占用RAM直接受所选择的N值决定</p>
<h3 id="算术平均滤波"><a href="#算术平均滤波" class="headerlink" title="算术平均滤波"></a>算术平均滤波</h3><p>和中值滤波的实现思路类似，但是需要取N次采样的算术平均值。</p>
<p>该算法难以对高速信号使用（除非搭配死贵的高速FPGA和烦到爆炸的等长走线进行硬件级别的算法滤波）</p>
<h3 id="递推平均滤波"><a href="#递推平均滤波" class="headerlink" title="递推平均滤波"></a>递推平均滤波</h3><p>又称为滑动平均滤波，将连续的N个采样值设为一个FIFO（先入先出队列），队长就为N，将队列中的N个数据进行算术平均滤波</p>
<p>这种方法对于周期性干扰具有非常好的抑制作用，具有很高的平滑度，但是灵敏度较低，对于偶然出现的脉冲干扰抑制作用较差，不适用于脉冲干扰较严重的场合。</p>
<p>该算法原理也可以应用在<strong>软件陷波器</strong>上。取N=S/f。其中S是美妙的采样次数，即采样率；f是要消除的谐波的频率，S、N都要取整数，这样最终就能实现对于f频率谐波的定向消除（采样平均值Y=Σ1/N，最终获得Y-C）</p>
<h3 id="中值平均滤波"><a href="#中值平均滤波" class="headerlink" title="中值平均滤波"></a>中值平均滤波</h3><p>选取N个采样，去掉其中最大值和最小值，再进行算术平均滤波，融合了中值滤波和平均滤波的特点，但也继承了二者的缺点</p>
<h3 id="限幅平均滤波"><a href="#限幅平均滤波" class="headerlink" title="限幅平均滤波"></a>限幅平均滤波</h3><p>先限幅滤波，再进行算术平均滤波</p>
<p>可以有效抑制偶然出现的脉冲干扰并消除采样偏差，但仍旧不适合高速信号处理</p>
<h3 id="一阶滞后滤波"><a href="#一阶滞后滤波" class="headerlink" title="一阶滞后滤波"></a>一阶滞后滤波</h3><p>取用一个比例常数0&lt;k&lt;1，使用以下公式计算本次输出结果：<br>$$<br>Output=k*T_n +(1-k)*T_{n-1}<br>$$<br>其中T<del>n</del>为本次采样值，T<del>n-1</del>为上次输出值</p>
<p>该方法类似PID，但是会造成相位滞后，灵敏度较低，难以消除频率高于采样频率一半的干扰信号</p>
<p>不过对于周期性干扰具有良好的抑制作用且运算量不大，适用于频率较高、相位要求不高的场合</p>
<h3 id="加权递推平均滤波"><a href="#加权递推平均滤波" class="headerlink" title="加权递推平均滤波"></a>加权递推平均滤波</h3><p>赋予不同时刻的FIFO采样值不同的权重，在对其进行递推平均滤波</p>
<p>适合在有较大纯滞后时间常数的对象和采样周期短的情况；难以反映变化较慢、采样周期长的情况，且占用RAM较多</p>
<h3 id="消抖滤波"><a href="#消抖滤波" class="headerlink" title="消抖滤波"></a>消抖滤波</h3><p>又称为数字消抖，通过设置一个滤波计数器，将每次采样值与当前有效值比较，如果采样值和有效值相等则清零，否则计数器+1并判断计数器是否达到上限，如果计数器溢出则将本次值替换为当前有效值，再清零计数器</p>
<p>常用于对变化缓慢的被测参数进行滤波，可避免系统在临界值附近时的波动跳变，但并不适用于快速变化的参数测量控制</p>
<h3 id="限幅消抖滤波"><a href="#限幅消抖滤波" class="headerlink" title="限幅消抖滤波"></a>限幅消抖滤波</h3><p>先使用限幅滤波，再进行消抖滤波</p>
<p>避免将干扰值导入系统，但不适用于快速变化的参数</p>
<h3 id="复杂数字滤波"><a href="#复杂数字滤波" class="headerlink" title="复杂数字滤波"></a>复杂数字滤波</h3><p>卡尔曼滤波、IIR滤波、高阶滤波等都需要复杂的运算过程，经常需要使用浮点运算，因此需要搭载的MCU具有一定的算力才能使用</p>
]]></content>
      <tags>
        <tag>电赛笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>现代C语言1</title>
    <url>/2021/11/14/%E7%8E%B0%E4%BB%A3C%E8%AF%AD%E8%A8%801/</url>
    <content><![CDATA[<p>本篇内容根据《C程序设计新思维》编写，作者水平有限，难免存在疏漏和错误，有问题请指出</p>
<h1 id="C与POSIX的历史"><a href="#C与POSIX的历史" class="headerlink" title="C与POSIX的历史"></a>C与POSIX的历史</h1><p><strong>C、UNIX、POSIX的存在是紧密相连的</strong></p>
<p>C和UNIX都是在20世纪70年代由贝尔实验室的设计，而贝尔有一项与美国政府达成的协议：贝尔将不会把自身的研究扩张到软件领域，所以UNIX被免费发放给学者进行研究、重建；UNIX商标则被在数家公司之间专卖。在这个过程中，一些黑客们改进了UNIX，并增加了很多变体，于是在<strong>1988年IEEE建立了POSIX标准</strong>，提供了一个类UNIX操作系统的公共基础</p>
<h3 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h3><p>规定了shell script如何工作、常用的命令行工具如何工作、能够提供哪些C库等等</p>
<p>除了微软的Windows系列操作系统，<strong>几乎所有操作系统都建立在POSIX兼容的基础上</strong></p>
<p>特别地，加州大学伯克利分校的一些黑客们对UNIX进行了几乎翻天覆地的改进（重写UNIX的基础代码），产生了伯克利软件发行版（Berkeley Software istribution）BSD——苹果的MacOS正建立在这一发行版上</p>
<h3 id="GNU"><a href="#GNU" class="headerlink" title="GNU"></a>GNU</h3><p>GNU工程即GNU’s Not UNIX工程，由笔者很敬佩的理查德斯托曼主持开工，大多数的Linux发行版都使用了GNU工具（这就是为什么Linux的全称是GNU/Linux），GNU工程下所有软件都是“自由软件”（想了解自由软件或“Free Software”的详情，推荐阅读理查德斯托曼传记《若为自由故》），这就意味着GPL！</p>
<p>GNU工程下属的GNU C Compiler就是为大家所熟知的C编译器gcc</p>
<span id="more"></span>

<h2 id="K-amp-R-C"><a href="#K-amp-R-C" class="headerlink" title="K&amp;R C"></a>K&amp;R C</h2><p>由Dennis Ritchie和Ken Thompson以及其他的开发者共同发明的<strong>最原始的C标准</strong></p>
<h2 id="ANSI-C89"><a href="#ANSI-C89" class="headerlink" title="ANSI C89"></a>ANSI C89</h2><p>更被人所熟知的名字是简称“<strong>ANSI C</strong>”，这个版本是C的第一个成熟、统一的版本</p>
<p>在ANSI C成为主流这段时间内，分离出了C++</p>
<p>当下的POSIX规定了必须通过提供C99命令来提供C编译器</p>
<h2 id="ANSI-C99"><a href="#ANSI-C99" class="headerlink" title="ANSI C99"></a>ANSI C99</h2><p>吸收了<strong>单行注释、for(int i=0;i&lt;N;i++)格式</strong>等源自C++特性的ISO标准化版本</p>
<h2 id="C11"><a href="#C11" class="headerlink" title="C11"></a>C11</h2><p>在2011年新定义的版本，做出了泛型函数、安全性提升等<strong>“离经叛道”的改变</strong></p>
<p>GCC以光速支持了这个标准</p>
<h1 id="C开发环境搭建"><a href="#C开发环境搭建" class="headerlink" title="C开发环境搭建"></a>C开发环境搭建</h1><p>C开发环境=包管理器+C库+C编译器+调试器+代码编辑器+C编译器辅助工具+打包工具+shell脚本控制工具+版本控制工具+C接口</p>
<p>看上去很复杂，实际上也很复杂=)</p>
<p>为什么不用IDE呢？当你用C开发某些小众嵌入式设备程序时就明白了（包括但不仅限于目前的MIPS、xtensa、RISC-V、你自己花三年用verilog写出来的CPU（可能还莫名其妙移植了一个操作系统和对应的C编译器，也许会有这样的dalao吧）），IDE？TMD！</p>
<h2 id="包管理器与编译环境"><a href="#包管理器与编译环境" class="headerlink" title="包管理器与编译环境"></a>包管理器与编译环境</h2><blockquote>
<p>IDE？狗都不用！真男人都是记事本+编译器！</p>
</blockquote>
<h3 id="包管理器"><a href="#包管理器" class="headerlink" title="包管理器"></a>包管理器</h3><p>每个系统都具有不同的软件包组织方式，所以你的软件很可能被安装在某个犄角旮旯，这就需要包管理器来帮助安装软件；虽然说很奇怪，但windows下也有包管理器</p>
<p>安装完包管理器后，就能用它安装gcc或clang这种编译器、GDB调试器、Valgrind内存使用错误检测器、Gprof（一个运行效率评测软件）、make工具、（如果你很nb还可以安装cmake工具）、Pkg-config（查找库的工具）、Doxygen（用于生成程序文档的工具）、你喜欢的文本编辑器（包括但不仅限于Emacs、Vim、VSCode、Sublime、记事本），除此之外，还能安装一些跨平台的IDE（虽然不太推荐，但eclipse就是最大众的选择，XCode需要有钱人才能买得起（指苹果电脑），Code::blocks在win下工作有点拉跨），还有必要的git工具、autoconf、automake、libtool，以及最重要的增加程序猿B格的Z shell、oh-my-zsh</p>
<p>包管理器还能管理C库，用一些新C库（libcURL、libGLib、libGSL、libSQLite3、libXML2），你可以实现很炫酷的现代C语言开发以及防止重新造轮子</p>
<p>对于一个包管理器，常会提供供用户使用的包和供开发者使用的包，在安装时应该选择带有-dev或-devel的包</p>
<h3 id="包管理器的安装"><a href="#包管理器的安装" class="headerlink" title="包管理器的安装"></a>包管理器的安装</h3><p>在Linux下，包管理器分为两大阵营：</p>
<ul>
<li>Debian系的apt</li>
<li>Red hat系的yum</li>
</ul>
<p>目前而言，两边其实都很好用、易上手，不过根据程序猿的性格不同，选择yum的程序猿多少沾点（我使用apt，就是要引战！），另外还有一个叫的Arch的发行版，因为我一直没有能把它安装上，所以不知道那个<code>pacman -S</code>是什么东西</p>
<p>在Windows下，微软很nt（逆天，指微软很厉害）地提供了方便的软件安装方式：让你的C盘变红。不过Windows还是勉为其难地提供了一个POSIX兼容的东西——Cygwin是许多自由软件的集合，最初由Cygnus Solutions开发，用于各种版本的Microsoft  Windows上，运行UNIX类系统。Cygwin的主要目的是通过重新编译，将POSIX系统（例如Linux、BSD，以及其他Unix系统）上的软件移植到Windows上，可以在Cygwin网站上下载包管理工具，配合一个终端（Terminal）即可实现在Win下进行Linux开发（虽然很蛋疼）。安装方法参考百度（笑）</p>
<p>微软最近还开发了一个叫WSL（Windows Subsystem of Linux，最新版本是跑在windows自带虚拟机Hyper-V上的WSL2）的东西，这个东西可以让你在windows下进行不完全的linux使用（用的发行版是ubuntu），笔者目前使用的就是这个软件，安装很方便——开启Hyper-V和虚拟化、打开Microsoft应用商店搜索WSL点击下载安装即可，不过所有东西就被塞进了C盘。</p>
<h3 id="搭建C编译器并执行编译"><a href="#搭建C编译器并执行编译" class="headerlink" title="搭建C编译器并执行编译"></a>搭建C编译器并执行编译</h3><p>在POSIX环境下，一切都很方便，apt install能解决一切问题，想安装什么就<code>sudo apt install xxx</code></p>
<p>非POSIX环境下，可以使用MinGW来实现标准C编译器和一些基础工具，或者使用很好用的WSL</p>
<p>可以使用命令行下的编译器执行编译：</p>
<ol>
<li>设置一个变量，代表编译器使用的编译选项</li>
<li>设置变量代表要链接的库，一般要分开指出编译时和运行时链接的库</li>
<li>设置一个使用这些变量来协调编译的系统</li>
</ol>
<p>完整的gcc编译器命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc test.c -o test -lm -g -Wall -O3 -std=gnu11</span><br></pre></td></tr></table></figure>

<p>该命令告诉编译器通过程序中的#include包含库函数，并告诉链接器通过命令行中的-lm链接库文件</p>
<p>-o用于指定输出文件的名字，否则会得到一个默认的a.out作为可执行文件名</p>
<p>-g表示加入调试负好，如果没有这个选项，调试器就不会显示变量或者函数的名字</p>
<p>-std=gnu11是gcc的特有选项，允许使用c11和POSIX标准的代码；同理可以使用-std=gnu99来使用c99标准</p>
<p>-O3表示优化等级为3级，尝试已知的所有方法去建立更快的代码</p>
<p>-Wall用于添加编译器警告</p>
<h4 id="Windows下的编译"><a href="#Windows下的编译" class="headerlink" title="Windows下的编译"></a>Windows下的编译</h4><p>微软顽强地抗拒C语言，所以一般在Windows下编译c程序都使用MinGW或cygwin环境，在这些环境中编译后可以得到Windows本地的二进制代码（当然也可以使用宇宙第一IDE VS，在此不讨论）</p>
<p>但伴随的缺点就是缺少使用体验很爽的C库！</p>
<h3 id="链接函数库"><a href="#链接函数库" class="headerlink" title="链接函数库"></a>链接函数库</h3><p>安装编译器后，链接工具会被自动安装好</p>
<p>GCC可以自动完成优化-编译-链接一条龙</p>
<p>连接函数库之前需要注意的就是路径：编译器需要知道在哪个目录去查找正确的头文件和目标文件。典型的库存放位置可能有三种：</p>
<ul>
<li>由操作系统预定义某个目录来安装操作系统需要的库文件</li>
<li>本地系统管理员可能会准备一个用于安装包的目录</li>
<li>用户从操作系统给出路径中查询到库并具有使用权限</li>
</ul>
<p>使用以下命令行来指定头文件搜索目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -I 头文件所在目录 需要链接的.c文件名 -o 生成的.o文件名 -L 某个库所在的目录</span><br></pre></td></tr></table></figure>

<p>参数-I用于添加指定的路径到头文件的搜索路径范围内，编译器会在这个路径范围内搜索放在代码中用<code>#include</code>指定的头文件</p>
<p>参数-L用于添加指定的路径到库的搜索路径范围内</p>
<p>注意：<strong>最原始的依赖库放在参数最后面，引用了很多库且被当前编译文件引用的子库紧跟在-L之后</strong></p>
<p>因为链接器的工作方式是：</p>
<ol>
<li>查看-L参数后的第一个目标，将其中无法解析的函数、结构体、变量记入一个列表，然后查看下一个目标</li>
<li>在下一个目标中寻找未知元素列表中的项目并删去已经得知的项目或继续添加未知元素</li>
<li>重复上述过程，直到搜索完最后的文件</li>
<li>如果仍存在为解析的符号，则终止运行并报错</li>
</ol>
<p>正是因为这种工作方式，很多时候安装依赖库的顺序和编译的顺序不当就会导致“玄学错误”</p>
<p>以上方式就是常规的静态库链接方式，当然现在的软件没什么用静态库的了，嵌入式软件倒是个例外（不过也有些RTOS在嵌入式设备上应用了动态链接极制）。共享库用于动态链接，使用以下Makefile参数来告诉编译器从哪里寻找共享库来进行动态链接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">LDADD=-L libpath: xxxxxx -Wl,-R libpath: xxxxxx</span><br></pre></td></tr></table></figure>

<p>-L参数告诉编译器到哪里找到库来解析符号</p>
<p>-Wl参数从编译器传递后面的路径到链接器，链接器会将给定的-R嵌入到所连接的库的运行时搜索路径</p>
<h2 id="Makefile简介"><a href="#Makefile简介" class="headerlink" title="Makefile简介"></a>Makefile简介</h2><blockquote>
<p>Make工具就是天！——沃·兹基硕德</p>
</blockquote>
<p>Make工具是一个可以自动执行编译、链接等工作的程序，它也有POSIX标准化，需要通过读入Makefile作为指令和变量，很多嵌入式开发（包括交叉编译和底层软件编译）都要和它打交道</p>
<p>一般来说使用gcc编译一个文件需要像下面这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc hello.c -o hello.o</span><br></pre></td></tr></table></figure>

<p>对于几个文件的编译还算简单，但是如果是一个很大的工程，包含了数不清的文件，每个文件都互相依赖，那么写shell script就会很绝望了；使用makefile就会让编译工作轻松一点</p>
<p>最小的Makefile如下所示</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">P=helloworld</span><br><span class="line">OBJECTS=</span><br><span class="line">CFLAGS = -g -Wall -O3</span><br><span class="line">LDLIBS=</span><br><span class="line">CC=c99</span><br><span class="line"></span><br><span class="line"><span class="variable">$(P)</span>:<span class="variable">$(OBJECTS)</span></span><br></pre></td></tr></table></figure>

<p>现在一般都使用GNU Make工具（GNU：没错还是我），需要将编写的Makefile命名为<code>Makefile</code>并将其与.c文件放在同一目录下，在命令行中输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<p>就可以进行自动化编译了</p>
<p>当然可以在后面添加参数<code>-jn</code>其中n表示你使用的cpu线程数——这就是多线程编译，可以提高编译速度；但是相对应的就不会生成每个.c文件对应的warning，并且会自动在第一个error处停下，并且不会告诉你error发生在哪里，所以如果是第一次编译请不要使用这个参数</p>
<h3 id="make语法"><a href="#make语法" class="headerlink" title="make语法"></a>make语法</h3><p>makefile的语法有两种流派：POSIX型和C shell型，现在的makefile大多使用POSIX型或其近似的语法；而CMake工具的cmakelist则选择了类似C shell的语法</p>
<p>make和shell一样使用$指代变量的值，但shell要求使用<code>$var</code>，make则要求使用<code>$(var)</code>形式</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(P)</span>:<span class="variable">$(OBJECTS)</span> <span class="comment">#相当于program_name=</span></span><br></pre></td></tr></table></figure>

<p>有以下几种方法让make工具识别变量：</p>
<ul>
<li>调用make之前在shell中设定变量并使用export命令导出</li>
<li>将export命令写入shell启动脚本中，就可以在启动shell时自动完成变量加载</li>
<li>在一个命令前放置赋值操作，这将把变量设置为一个环境变量</li>
<li>在Makefile的头部设定变量</li>
<li>在命令行中使用make指令后接要设置的变量，这些变量会独立于shell作为make工具的变量存在</li>
</ul>
<p>在C代码中可以使用getenv函数获取环境变量信息，这需要调用stdlib.h库</p>
<p>make工具也提供了一些内置的变量，如下所示：</p>
<ul>
<li><p>$@</p>
<p>返回完整的目标文件名（目标文件就是从.c文件中编译得到的.o文件）</p>
</li>
<li><p>$*</p>
<p>返回不带文件名后缀的目标文件</p>
</li>
<li><p>$&lt;</p>
<p>返回触发和制作该目标文件的文件的名称</p>
</li>
</ul>
<p>Makefile的标准形式如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">target:dependencies</span></span><br><span class="line">	script</span><br></pre></td></tr></table></figure>

<p>输入命令<code>make target</code>时，对应的target就会被调用，检查dependencies是否是较早（target文件比dependencies更新）的文件，如果检查通过则运行所有的dependencies，结束后再运行target部分的脚本；如果检查不通过则对script的处理会被暂停</p>
<p>Makefile基本上就是目标target、依赖dependencies、脚本script三者所组成的一系列规则。make工具就是根据Makefile的规则决定如何编译和链接程序或者执行其它操作（包括但不仅限于自动下载远程程序、解压缩包、打补丁、设定参数、编译并将软件安装到系统中指定位置等）</p>
<h3 id="Make的本质"><a href="#Make的本质" class="headerlink" title="Make的本质"></a>Make的本质</h3><p>在编写小工程，特别是只有不多文件的情况下，在shell里使用gcc就可以了，如果工程数量继续增长，自行编写Shell Script也很简单；但是如果是依赖条件复杂的大工程，直接使用编译器就会很繁琐，这时候通常使用<strong>构建工具</strong>来辅助</p>
<blockquote>
<p>构建工具 (software construction tool)  是一种软件，它可以根据一定的规则或指令，将源代码编译成可执行的二进制程序。这是构建工具最基本也是最重要的功能。实际上构建工具的功能不止于此，通常这些规则有一定的语法，并组织成文件。这些文件用来控制构建工具的行为，在完成软件构建之外，也可以做其他事情。</p>
</blockquote>
<p>Linux的内核、Linux上运行的大多数Qt软件、洗衣机的主控、ESP32的底层文件……都是用Make工具完成构建的，这是历史最为悠久的开源构建工具，但是正因如此它的语法比较混乱，且不被Windows支持（除非使用上文提到的Cygwin环境）。除此之外，只要外部条件稍微变化一些，就需要修改软件的Makefile。为了让安装软件更加容易，程序员开发出了几个神奇的生成工具：Ninja、Automake、SCons、CMake。利用这些改善过的工具，编程者只需要写一些预先定义好的宏，提交给程序自动处理，就会生成一个可以供Make工具使用的Makefile文件，再配合使用工具产生的自动配置文件configure即可产生一份符合GNU-Makefile规定的Makefile；或者直接通过自己独有的软件编译方式对工程进行生成。</p>
<h2 id="Ninja简介"><a href="#Ninja简介" class="headerlink" title="Ninja简介"></a>Ninja简介</h2><p>除了Make工具外，Ninja也是一个自动化编译的构建工具。它由Google的一名程序员开发，通过将编译任务并行化大大提高编译速度</p>
<p>它并不使用Makefile，而是用一套自己组织的<code>.ninja</code>脚本</p>
<p>现在Android Studio等都选用了Ninja作为编译工具，也有许多嵌入式设备厂商自己的SDK使用了ninja</p>
<p>ninja的安装方法和make一样</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install ninja</span><br></pre></td></tr></table></figure>

<p>或者可以从github上拉取最新版本的ninja源码，然后自行编译安装</p>
<p>只不过make支持POSIX标准，可以直接在linux上运行；但是ninja需要事先安装一些依赖，具体情况可以参考<a href="https://ninja-build.org/">官网</a></p>
<p>这里不多介绍ninja的使用方法</p>
<h2 id="SCons简介"><a href="#SCons简介" class="headerlink" title="SCons简介"></a>SCons简介</h2><p>SCons是另一套由Python编写的开源构建系统，它和Make、Ninja一样可以生成脚本进行快速编译，但是SCons有一个最厉害的地方：<strong>它使用的是python脚本，能够使用标准的Python语法编写构建工程</strong></p>
<p>详情可以参考<a href="https://www.scons.org/">官网</a></p>
<p>SCons的脚本称为<em>SConscript</em>，支持多种编译器，包括但不仅限于gcc、clang，甚至支持很多公司专有的交叉编译工具</p>
<p>它的安装也比较简单：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install python #安装依赖——这玩意是用python写的</span><br><span class="line">sudo apt install scons</span><br></pre></td></tr></table></figure>

<p>直接在程序目录使用下面的指令就可以轻松完成很多原本需要Makefile写很多才能完成的任务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scons #相当于make</span><br><span class="line">scons -c #相当于make clean</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面的就是个开胃菜，和make没差很多；下面才是scons的神奇之处</span></span><br><span class="line">touch SConstruct</span><br><span class="line">vim SConstruct #新建一个SCons脚本</span><br><span class="line">Program(&#x27;testPro1&#x27;, Glob(&#x27;*.cpp&#x27;)) #写完以后直接保存退出</span><br><span class="line">scons #直接回到shell来一个执的行，testPro1就构建完毕了</span><br></pre></td></tr></table></figure>

<p>除了直接使用<code>scons</code>命令生成外，SCons还支持一些扩展功能</p>
<p>RT-Thread就将它扩展为了keil MDK/IAR/VS/CubeIDE工程生成器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scons --target=xxx #生成某个IDE的工程</span><br></pre></td></tr></table></figure>

<p>SConscript还能执行一些方便的内置函数</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">GetCurrentDir() <span class="comment">#获取当前路径</span></span><br><span class="line">Glob() <span class="comment">#获取当前目录下的所有文件，支持在里面使用表达式匹配</span></span><br><span class="line">Glob(&#x27;*.c&#x27;) <span class="comment">#获取当前目录下的.c文件</span></span><br><span class="line">Split(str) <span class="comment">#将字符串str分割成一个列表</span></span><br></pre></td></tr></table></figure>

<p>具体的SCons使用还要更复杂一些，所有使用方法都可以参考官网或者使用到SCons的SDK说明，即用即查，不需要特意学习</p>
<h2 id="Automake简介"><a href="#Automake简介" class="headerlink" title="Automake简介"></a>Automake简介</h2><p>Automake是正统的GNU软件，它用来生成Make构建系统。</p>
<p>这是一个套娃：gcc/clang是编译器，或者说构建工具；Make/Ninja/SCons是构建系统；Automake/CMake则是<strong>生成构建系统的系统</strong></p>
<h2 id="CMake简介"><a href="#CMake简介" class="headerlink" title="CMake简介"></a>CMake简介</h2><p>CMake是比Automake更常用一些的系统，它通过读取<code>CMakeLists.txt</code>中的规则来构建编译系统</p>
<p>它的脚本格式大致如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.9</span>) <span class="comment">#注明需要的cmake工具版本</span></span><br><span class="line"><span class="keyword">project</span>(HelloWorld) <span class="comment">#工程名</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>) <span class="comment">#设置要使用编译器版本</span></span><br><span class="line"><span class="keyword">add_executable</span>(HelloWorld main.cpp) <span class="comment">#指定源文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#下面是负责程序安装的指令</span></span><br><span class="line"><span class="keyword">install</span>(TARGETS HelloWorld DESTINATION bin) <span class="comment">#指定将生成的程序文件安装到/usr/local/bin</span></span><br><span class="line"><span class="keyword">install</span>(FILES HelloWorld.h DESTINATION <span class="keyword">include</span>) <span class="comment">#指定将库文件保存到/usr/local/include</span></span><br></pre></td></tr></table></figure>

<p>在shell中使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir build #惯用方式，将所有生成的文件保存至build目录</span><br><span class="line">cd build</span><br><span class="line">cmake .. #对上一级也就是工程项目主目录执行cmake，前提是CMakeLists.txt保存在工程项目主目录</span><br><span class="line"><span class="meta">#</span><span class="bash">所有生成的文件会被保存到build目录，包括Makefile</span></span><br><span class="line">make #执行make</span><br></pre></td></tr></table></figure>

<p>就可以完成所有编译任务</p>
<p><strong>它可以将Makefile的编写完全转化成CMakeLists的编写</strong>，虽然看上去多此一举，但实际上增强了编译时的可靠性和程序的可移植性</p>
<h2 id="Kconfig简介"><a href="#Kconfig简介" class="headerlink" title="Kconfig简介"></a>Kconfig简介</h2><blockquote>
<p>半个可视化也是可视化——伽利略（？）</p>
</blockquote>
<p>一般来说一个工程完全可以依靠CMake-Make-GCC的工具链完成编译，但实际上很多与c语言打交道的底层程序需要适配各种不同的情况，这就需要使用<strong>代码模块化</strong>思想：将一套代码分成多个模块以适应不同情景</p>
<p>最典型的就是Linux内核了：有的设备是嵌入式的，有的设备是高性能的，有的设备带摄像头、网口，有的设备只有WiFi，有的设备自带一堆硬件加速器，有的设备使用RISC-V架构——而Linux内核需要针对这些情况进行优化，因此它使用了“宏内核”思想，内核接管一切驱动程序的管理，将底层所有设备归类交给不同的驱动程序管理。这时Linux的内核编译就需要事先确定目标设备上都有什么，预先选好要加入工程的组件再生成源代码（这也使用了C预编译器的一部分功能）</p>
<p>负责灵活配置编译单元——说人话就是从一堆预先写好的代码里挑选出合适的代码的工具就是<strong>Kconfig</strong></p>
<p>Kconfig工具生成CMakeList的设置参数；之后调用<code>make menuconfig</code>配置<code>.cmake</code>文件用于将Kconfig生成的参数赋值给CMake变量、<code>.mk</code>配置文件用于保存make工具的编译变量、<code>.h</code>文件用于提供C语言的编译基础；再然后使用CMake工具生成Makefile；最后使用Make工具进行编译，就可以生成一个bin文件了</p>
<p>这里着重强调一下Kconfig的使用——因为它是Linux内核编译的最重要辅助工具之一——在编译内核时，需要用到<code>make menuconfig</code>指令，而这个指令并没有直接调用make、cmake工具，而是先借助Kconfig工具打开一个蓝色的配置菜单界面，如下所示</p>
<p><img src="/2021/11/14/%E7%8E%B0%E4%BB%A3C%E8%AF%AD%E8%A8%801/image-20210820192752213.png" alt="image-20210820192752213"></p>
<p>这个蓝色的菜单可以说是最经典的多级菜单程序，但这里我们不说多级菜单的实现，仅仅谈它使用的脚本工具<strong>Kconfig</strong></p>
<p>使用<strong>config</strong>语句定义一组新的配置选项</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">config CONFIG_A</span><br><span class="line">    <span class="keyword">bool</span> <span class="string">&quot;Enable MyConfig&quot;</span></span><br><span class="line">    select SELECTED</span><br><span class="line">    <span class="keyword">default</span> y</span><br><span class="line">    help</span><br><span class="line">    My Config</span><br></pre></td></tr></table></figure>

<p><strong>bool</strong>表示配置<strong>选项的类型</strong>，每个config菜单项都要有类型定义，变量有5种类型：<code>bool</code>布尔，也就是二选一（y或n）、<code>tristate</code>三态，也就是三选一、<code>string</code>字符串，也就是用户从给出的一堆字符串里选择一个、<code>hex</code>十六进制，也就是用户要选择一个十六进制数、<code>int</code>整型，也就是用户需要选择一个整数，需要注意：这里的<em>用户选择</em>是不严谨的，实际上<strong>选项类型决定了Kconfig会生成什么样的#define语句提供给C源代码</strong>；**”Enable MyConfig”<strong>表示该</strong>选项的名称<strong>；</strong>select<strong>表示如果当前配置选项被</strong>选中<strong>，则SELECTED就会被选中；</strong>default<strong>后面跟的参数表示配置选项的</strong>默认值**；help后面跟的语句会作为帮助信息提供给用户</p>
<p>使用<strong>menu/endmenu块</strong>来生成一个菜单，这个菜单里面可以包含复数个config语句，也可以包含子菜单</p>
<p>使用<strong>if/endif块</strong>来实现条件判断</p>
<p>使用<strong>menuconfig</strong>语句表示带菜单的配置项，也就是可展开的菜单</p>
<p>使用<strong>choice/endchoice</strong>语句将多个类似的配置选项组合在一起，供用户选择一组配置项，也就是“弹窗”子菜单</p>
<p>使用<strong>comment</strong>语句定义帮助信息，这些东西会出现在界面第一行</p>
<p>使用<strong>source</strong>语句读取另一个文件中的Kconfig文件</p>
<h2 id="以上软件的组织架构"><a href="#以上软件的组织架构" class="headerlink" title="以上软件的组织架构"></a>以上软件的组织架构</h2><h3 id="半可视化编译配置工具"><a href="#半可视化编译配置工具" class="headerlink" title="半可视化编译配置工具"></a>半可视化编译配置工具</h3><p>Kconfig</p>
<h4 id="构建工具生成器"><a href="#构建工具生成器" class="headerlink" title="构建工具生成器"></a>构建工具生成器</h4><p>CMake</p>
<p>Automake</p>
<h5 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h5><p>Make</p>
<p>Ninja</p>
<p>SCons</p>
<h2 id="调试器GDB"><a href="#调试器GDB" class="headerlink" title="调试器GDB"></a>调试器GDB</h2><p>GDB是目前最常用的调试器（没有之一），它支持多平台、多目标的调试过程。</p>
<p>调试器，顾名思义就是用于调试程序的软件。它能够给出底层的变量变化和回溯的信息，同时可以追踪内存和寄存器中数值的变化，一般的调试器可以提供<strong>断点</strong>功能和<strong>追踪</strong>功能。编译时，在gcc指令后加入-g参数即可启用调试功能，不过这会导致程序变大一些</p>
<p>gdb可以直接在命令行模式中使用，但是一般来说各种代码编辑器和IDE会将gdb嵌入，并提供可视化的调试功能，下面是一些使用命令行模式gdb时会用到的指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb &lt;file&gt; # 使用gdb调试文件</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">--下面会进入gdb命令行--</span></span><br><span class="line">(gdb) r # 正常执行程序直到遇到错误或断点</span><br><span class="line">(gdb) l # 显示运行到的那一行代码</span><br><span class="line">(gdb) l &lt;部分代码&gt; # 显示以某行为中心的部分代码</span><br><span class="line">(gdb) b &lt;部分代码&gt; # 在某行代码处打断点</span><br><span class="line">(gdb) p &lt;变量/指针&gt; # 输出某变量/指针的值</span><br><span class="line">(gdb) bt # 列举出堆栈帧</span><br><span class="line">(gdb) info threads # 获取程序使用线程列表</span><br><span class="line">(gdb) n # 重复单步运行程序</span><br><span class="line">(gdb) b &lt;行号&gt; # 在某一行打断点</span><br><span class="line">(gdb) r # 重新开始一个循环</span><br><span class="line">(gdb) c # 继续运行程序直到完成当前循环或运行到return</span><br><span class="line">(gdb) disp &lt;变量&gt; # 将某变量的变化在调试过程中自动显示</span><br><span class="line">(gdb) &lt;Enter&gt; # 重复上一步命令</span><br><span class="line">(gdb) f &lt;帧号&gt; # 查看某一帧</span><br></pre></td></tr></table></figure>

<p>任何函数都会在内存中占据一个空间，称为函数<strong>帧</strong>，函数帧会使用特殊的数据结构保存与这个函数有关的所有信息，gdb则可以直接查阅堆栈帧并获取信息。</p>
<p>现在的调试过程已经基本不需要使用gdb的命令行模式了（除非是对跑在某些极少有人使用的、没有开源社区提供gdb调试工具的莫名其妙的cpu上的程序），VSCode、Sublime、Vim、Emacs里面都内置了gdb的（半）图形化调试只需要知道如何打断点、单步调试、查看汇编等基本操作就可以进行有效调试了</p>
]]></content>
      <tags>
        <tag>C语言进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>MSP430简介</title>
    <url>/2021/11/13/msp430%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="MSP430"><a href="#MSP430" class="headerlink" title="MSP430"></a>MSP430</h1><p>该MCU是由德州仪器TI生产的16位低功耗单片机</p>
<span id="more"></span>

<p>主要分以下型号：</p>
<ul>
<li>专注低功耗的<strong>1xx</strong>通用型，配备1KB-60KB FLASH、512B-10KB RAM，工作时耗电仅达200uA/MIPS，RAM保持模式耗电0.1uA，RTC模式耗电0.7uA；可在6us之内快速唤醒。搭载10/12位斜率SAR ADC，集成模拟比较器、DMA、硬件乘法器、BOR、SVS、12位DAC</li>
<li>能耗比高的<strong>F2xx</strong>通用型，性能<a href="mailto:&#49;&#x36;&#77;&#x49;&#80;&#x53;&#64;&#51;&#46;&#x33;&#x56;">&#49;&#x36;&#77;&#x49;&#80;&#x53;&#64;&#51;&#46;&#x33;&#x56;</a>，配备1-120KB FLASH，8-128KB RAM，工作耗电220uA，配备10/12位斜率SAR ADC，集成16位Σ-ΔADC，基本上等于1xx的升级版</li>
<li><strong>性价比</strong>高的<strong>G2xx</strong>经济型，性能<a href="mailto:&#49;&#54;&#77;&#73;&#80;&#x53;&#x40;&#x33;&#x2e;&#x33;&#x56;">&#49;&#54;&#77;&#73;&#80;&#x53;&#x40;&#x33;&#x2e;&#x33;&#x56;</a>，对标友商stm32l，主打模拟外设和低功耗</li>
<li>面向计量和智能电网的AFE2xx专用型：性能略低于以上两个2xx系列，但是集成了1-3个独立的24位Σ-ΔADC，一个16位定时器、一个16位硬件乘法器、USART控制器、看门狗和GPIO</li>
<li>停产的老型号3xx</li>
<li>面向低功耗<strong>多媒体</strong>的<strong>4xx</strong>控制型，8-16MIPS处理性能，<strong>配备LCD控制器</strong>、<strong>FLL、SVS</strong>，针对低功耗测量和医疗应用，功耗和1xx相近，4-120KB FLASH、8-256KB RAM，引脚丰富最多可达80Pin，配备10/12位斜率SAR、16位Σ-ΔADC，同样集成了12位ADC、DMA、硬件乘法器、运放、USCI模块等</li>
<li><strong>超高能耗比的5xx超低功耗型</strong>，能达到<a href="mailto:&#x32;&#53;&#77;&#73;&#x50;&#x53;&#x40;&#51;&#x2e;&#x33;&#x56;">&#x32;&#53;&#77;&#73;&#x50;&#x53;&#x40;&#51;&#x2e;&#x33;&#x56;</a>，工作模式功耗165uA/MIPS，RTC模式2.5uA，RAM保持模式可达1uA，待机唤醒时间极短，小于5ms，配备256KB FLASH、18KB RAM，额外集成了USB、模拟比较器</li>
<li>高性能、低功耗的6xx系列旗舰型，达到<a href="mailto:&#50;&#53;&#x4d;&#x49;&#80;&#83;&#x40;&#51;&#46;&#x33;&#86;">&#50;&#53;&#x4d;&#x49;&#80;&#83;&#x40;&#51;&#46;&#x33;&#86;</a>，配备功耗优化的创新电源管理模块和USB控制器，配备LCD控制器，有256KB FLASH、18KB RAM，74Pin引脚，功耗与5xx系列相同，还额外集成了电压管理模块</li>
<li>基于<strong>FRAM</strong>技术的<strong>FRxx</strong>系列，和主要的F系列差别在于使用了FRAM存储技术，能够达到更快的FLASH访问速度并在所有功率模式下实现零功率状态保持，即使发生功率损耗的情况也可以保证写入操作，写入寿命能达到100M个周期，不再需要EEPROM</li>
<li>低电压C、L系列，两个谢列都可以在0.9-1.65V电压范围内工作并提供4MIPS的性能</li>
<li>集成射频基带的CC无线系列，具有低于1GHz的片上射频收发器，工作电压为1.8-3.3V，处理性能20MIPS</li>
<li>特殊系列：面对车规应用、电容触摸、超声波测量、DSP等等特殊用途的系列设备</li>
</ul>
<p>综合来看MSP430具有以下特点：</p>
<ol>
<li><p>超低功耗</p>
<p>使用1.8-3.6V低电压供电，RAM数据保持方式下耗电仅为0.1μA/MIPS，活动模式下耗电也仅仅为250μA/MIPS，IO输入端口漏电流仅为50mA，相比之下只有stm8和stm32l0系列能够达到同等级的低功耗水准。普通的8051则远远落后</p>
</li>
<li><p>能效比高，针对算法加速</p>
<p>MSP430基于RISC架构，采用了一般DSP才有的16位多功能硬件乘法器、硬件乘-加功能、DMA等架构，可以高效实现如FFT、DFT、FIR滤波等数字信号处理算法</p>
</li>
<li><p>模拟外设技术高</p>
<p>MSP430片内集成多种模拟外设，包括液晶驱动器和ADC、DAC等，具体外设由型号决定</p>
</li>
<li><p>外设寄存器直接按位寻址</p>
<p>外设寄存器可以直接进行赋值、按位操作</p>
</li>
</ol>
<p>msp430系列使用了冯诺依曼架构，并构建了MAB（存储器地址总线）、MDB（存储器数据总线）两个总线协议，其中RAM、FLASH共用同一个地址空间，程序被下载到FLASH，设备复位后自动读取并执行程序指令，局部变量存储在RAM，BSS段变量存储在FLASH，FLASH掉电不丢失</p>
<p>设备内部时钟至少具有3套时钟源：</p>
<ol>
<li>LFXT1CLK：低频时钟，32.768kHz</li>
<li>XT2CLK：高频时钟，8MHz</li>
<li>DCOCLK：片内数字控制RC振荡器，经常用作系统和外设时钟信号，其稳定性由FLL与硬件控制</li>
</ol>
<p>三套时钟源可以被设备单独选用，时钟通过片内总线提供给设备；有些型号还具有更多类型的时钟源</p>
<p>DMA可以直接接管总线以提高传输效率（不同于AMBA总线的仲裁，MAB、MDB总线只采用主控设备-从设备的方式）</p>
<p>CPU则采用了双总线位宽的灵活处理方式，分为<strong>16位寻址的CPU</strong>和<strong>20位寻址的CPUX</strong>。CPU采用RISC架构，配备27条指令和7种统一的寻址模式，寻址空间64KB；CPUX寻址空间为1MB，采用面向控制的结构和指令系统，集成了计算分支、表处理等特性，可以在不分页的情况下处理1MB的地址范围，属于RISC正交指令集（正交：指令集的绝大多数指令格式相同、长度相同，所有寄存器的寻址可以替换；而指令的操作码、寻址方式、操作数寄存器字段的取值相互独立），可以实现MTM（内存到内存）传输，不需要经过中间寄存器，一并对16位CPU实现了兼容</p>
<p>在电赛中最常用的就是==<strong>MSP430F5529</strong>==，下面均以F5529为例说明</p>
<h2 id="外围电路设计"><a href="#外围电路设计" class="headerlink" title="外围电路设计"></a>外围电路设计</h2><h3 id="供电"><a href="#供电" class="headerlink" title="供电"></a>供电</h3><p>MCU部分模拟外设和FLASH、RAM对于电源要求较高，但是MCU数字部分对于电源要求较低，因此采用双电源——模拟/数字的方式为MCU供电。模拟-数字电源之间采用磁珠跨接3.3V和地除杂波，同时需要使用10uF、100nF电容并联进行滤波，10uF用于滤除低频杂波，100nF则用于旁路</p>
<h3 id="复位"><a href="#复位" class="headerlink" title="复位"></a>复位</h3><p>RST引脚低电平有效，因此和一般单片机的复位电路一样即可</p>
<h3 id="晶振"><a href="#晶振" class="headerlink" title="晶振"></a>晶振</h3><p>需要使用两个晶振接入来保证电源稳定，<strong>XT1接低频32.768kHz</strong>，<strong>XT2接高频晶振，一般为4MHz</strong>，因为内部电容不足以起振，所以同时需要单独配备20-30pF的匹配电容，一般使用22pF电容</p>
<h3 id="USB"><a href="#USB" class="headerlink" title="USB"></a>USB</h3><p>f5529具有USB控制器，能够使用4芯电缆：5V、D+、D-、GND，并可以兼容USB OTG的ID线。</p>
<h2 id="编译烧录"><a href="#编译烧录" class="headerlink" title="编译烧录"></a>编译烧录</h2><p>MSP430支持JTAG和SBW（Spy-Bi-Wire，TI指定的两线调试接口，信号叫为SBWTCK和SBWTDIO）</p>
<p>同时也支持BSL（BootStrap Loader），或者说BootLoader加载程序烧录可以通过USB、UART等对单片机进行ISP烧录，在PUR引脚和USB D+之间跨接1.4k电阻，下连1M电阻到地，并通过一个加了限流电阻（一般为100Ω）的微动开关连接到VCC即可实现USB的BSL烧录</p>
<p>MSP430的开发环境是TI基于eclipse开发的Code Composer Studio，简称<strong>CCS</strong>，在其中使用专用的MSP430 Compile与Linker即可实现C程序编译链接</p>
<h3 id="关键字和内联函数"><a href="#关键字和内联函数" class="headerlink" title="关键字和内联函数"></a>关键字和内联函数</h3><p>同时CCS支持了一些扩展关键字，列举如下：</p>
<ul>
<li><p><code>__asm</code>用于C语言内嵌汇编，这个和keil一样</p>
</li>
<li><p><code>__interrupt</code>放在函数前指示中断函数，一般和#pragma指令共用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=UART0RX_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">UART_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>上例指示了一个串口0接收中断，#pragma指令让中断向量表中的地址位重定向了</p>
</li>
<li><p><code>__monitor</code>放在函数前，在执行到函数时自动关闭全局中断，类似__atom指令</p>
</li>
<li><p><code>__no_init</code>放在全局变量钱让程序启动时不被变量赋初值</p>
</li>
<li><p><code>__raw</code>关闭中断服务函数的恢复现场能力，这会导致中断服务函数无法返回</p>
</li>
<li><p><code>__regvar</code>声明变量为寄存器变量，注意不能使用指针指向寄存器变量，并且必须搭配使用__no_init禁止初始化</p>
</li>
<li><p><code>sfrb</code>用于声明单字节IO数据类型对象，和51一样用于定义寄存器地址</p>
</li>
</ul>
<p>除了关键字外，CCS还包含了许多内联函数，常见的几个摘录如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__no_operation();<span class="comment">//空指令，相当于NOP</span></span><br><span class="line">__enable_interrupt();<span class="comment">//打开全局中断</span></span><br><span class="line">__disable_interrupt();<span class="comment">//关闭全局中断</span></span><br><span class="line">__delay_cycles(<span class="keyword">unsigned</span> <span class="keyword">long</span> __cycles);<span class="comment">//延时__cycles个主时钟（MCLK）周期</span></span><br><span class="line">__set_SP_register(<span class="keyword">unsigned</span> <span class="keyword">short</span>);<span class="comment">//为堆栈指针寄存器SP赋值</span></span><br></pre></td></tr></table></figure>

<h3 id="预定义寄存器"><a href="#预定义寄存器" class="headerlink" title="预定义寄存器"></a>预定义寄存器</h3><p>CCS中还预置了一些单片机常用的寄存器和配置，如下所示</p>
<ol>
<li><p>端口定义，其中x表示端口号</p>
<p>PxIN：端口输入寄存器</p>
<p>PxOUT：端口输出寄存器</p>
<p>PxDIR：端口方向控制寄存器</p>
<p>PxSEL：端口复用寄存器</p>
<p>注意：<strong>MSP430不支持位操作，一般通过屏蔽位的方法实现位操作，这是它和51开发方面最大的不同</strong>，如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT0 00000001b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT1 00000010b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT2 00000100b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT3 00001000b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT4 00010000b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT5 00100000b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT6 01000000b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT7 10000000b</span></span><br><span class="line"></span><br><span class="line">P1OUT |= BIT0;</span><br><span class="line"><span class="comment">//这样可以实现P1.0输出</span></span><br><span class="line"></span><br><span class="line">P1OUT |= BIT4;</span><br><span class="line"><span class="comment">//这样可以实现P1.0和P1.3同时输出</span></span><br><span class="line"></span><br><span class="line">P1OUT &amp;= ~BIT1;</span><br><span class="line"><span class="comment">//这样可以取消P1.0的输出</span></span><br></pre></td></tr></table></figure></li>
<li><p>低功耗模式的进入和退出</p>
<p>CCS预定义了一些宏指令用来实现低功耗模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LPM3;<span class="comment">//进入低功耗模式</span></span><br><span class="line">LPM3_EXIT;<span class="comment">//退出低功耗模式</span></span><br></pre></td></tr></table></figure>

<p>其中数字可以写0-4，分别对应四种低功耗模式</p>
</li>
<li><p>外设寄存器</p>
<p>各种片上外设的寄存器都被定义为了宏，可以通过<code>|=</code>与<code>&amp;=~</code>的方式进行按位控制</p>
</li>
<li><p>部分常用代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_dint(); <span class="comment">//等效于__disable_interrupt</span></span><br><span class="line">_EINT(); <span class="comment">//等效于__enable_interrupt</span></span><br><span class="line">_NOP(); <span class="comment">//空指令</span></span><br><span class="line">_OPC(x); <span class="comment">//在指令流中插入一个常熟，对与参数对应的任何指令进行编码</span></span><br><span class="line">_SWAP_BYTES(x); <span class="comment">//将无符号16位整数的高8位和低8位交换</span></span><br><span class="line">monitor <span class="comment">//关键字__monitor的宏定义</span></span><br><span class="line">no_init <span class="comment">//关键字__no_init的宏定义</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>综上所述，MSP430的开发和8051的开发非常类似，并没有stm32的库封装，而是直接操作寄存器。这不仅仅是由于MSP430的性能较低，也是由于这样的编程方式写出的代码更加简洁、指令量更少，能突出体现MSP430低功耗的优势</p>
<h2 id="片上外设开发"><a href="#片上外设开发" class="headerlink" title="片上外设开发"></a>片上外设开发</h2><p>MSP430的片上外设寄存器具体配置和51单片机的很像，但是有一些功能更加复杂，和stm32的寄存器接近，同时也提供了简化操作的库函数</p>
<h3 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h3><p>f5529一共有80个引脚，和stm32的<strong>gpio</strong>结构类似，并且也具有<strong>复用功能</strong>。除此之外某些引脚具备基本的<strong>电源功能</strong>，分别能够为MCU的片上数字电路和模拟电路供电，一般情况下可以共用一个电源，但在某些高精度测量场合需要双电源隔离供电。msp430还具有一个USB电源，可以直接输出5V供电，经过片上LDO后能在端口VBUS处输出稳定的3.3V电压供单片机和外设使用，最大驱动电流60mA</p>
<p>其中P1、P2端口IO都具有外部中断能力，分别对应P1IV中断向量和P2IV中断向量。端口可单独配置强驱动和弱驱动模式，<strong>强驱动模式下全片最大输出电流100mA，单端口最大电流15mA；弱驱动模式下全片最大输出电流48mA，单端口最大电流6mA</strong></p>
<p>寄存器操作可以通过上面介绍过的屏蔽位法，也可以通过分别操作寄存器高8位和低8位的方法实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用三种方法将P1.1和P2.2配置为输出功能</span></span><br><span class="line">P1DIR |= <span class="number">0x02</span>; <span class="comment">//0x02 == 00000010b</span></span><br><span class="line">P2DIR |= <span class="number">0x04</span>; <span class="comment">//0x04 == 00000100b</span></span><br><span class="line"></span><br><span class="line">PADIR_L |= <span class="number">0x02</span>; <span class="comment">//DIR寄存器低8位，代表P1</span></span><br><span class="line">PADIR_H |= <span class="number">0x04</span>; <span class="comment">//DIR寄存器高8位，代表P2</span></span><br><span class="line"></span><br><span class="line">PADIR |= <span class="number">0x0402</span>; <span class="comment">//直接操作DIR寄存器，将其视作uint16_t</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>端口配置</p>
<p>如下配置端口为输入状态并配置内部上拉</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P1DIR &amp;= ~BIT1; <span class="comment">//BIT1 == 0x00000010b，设置P1.1为输入模式</span></span><br><span class="line">P1REN |= BIT1; <span class="comment">//使能上下拉电阻</span></span><br><span class="line">P1OUT |= BIT1; <span class="comment">//P1.1配置上拉电阻</span></span><br></pre></td></tr></table></figure>

<p>通过配置PxDIR.n |= 1可以将相应的IO口配置为输出状态，在输出状态下，PxREN、PxIN无效。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P1OUT |= BIT1; <span class="comment">//P1.1输出高电平</span></span><br><span class="line">P1OUT &amp;= ~BIT1; <span class="comment">//P1.1输出低电平</span></span><br><span class="line"></span><br><span class="line">P1DS<span class="number">.1</span> &amp;= ~BIT1; <span class="comment">//配置P1.1为弱驱动输出</span></span><br><span class="line">P1DS<span class="number">.1</span> |= BIT1; <span class="comment">//配置P1.1为强驱动输出</span></span><br></pre></td></tr></table></figure></li>
<li><p>端口复用配置</p>
<p>基本每个IO都有端口复用功能，通过配置PxSEL.n把对应的IO口配置为复用功能</p>
<p>使用以下代码配置P1.0为定时器A0时钟输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P1DIR &amp;= ~BIT0; <span class="comment">//设置P1.0为输入状态</span></span><br><span class="line">P1SEL |= BIT0; <span class="comment">//将P1.0复用为定时器A0时钟输入</span></span><br></pre></td></tr></table></figure>

<p>相关配置需要按照datasheet中的端口复用表选择</p>
</li>
</ol>
<h3 id="时钟系统与低功耗"><a href="#时钟系统与低功耗" class="headerlink" title="时钟系统与低功耗"></a>时钟系统与低功耗</h3><p>msp430f5529具有<strong>5种时钟源</strong>（XT1CLK、XT2CLK、VLOCLK、REFOCLK、DCOCLK）和<strong>3种时钟信号</strong>（MCLK、SMCLK、ACLK）</p>
<p>时钟系统可以软件配置成不需要外部晶振、需要一个外部晶振、需要两个外部晶振、外部时钟输入等方式，最极端的情况下单片机内部具有自身振荡器可以为CPU及片上外设提供系统时钟</p>
<p>时钟系统的安全性比较重要，msp430配备了紧急保护系统，在外部时钟故障时会自动选择内部时钟源REFOCLK或VLOCLK作为时钟信号，并产生响应故障信号（可选中断）</p>
<p>系统时钟大致分为两级，<em>信号生成级</em>和<em>信号分配级</em>，中间通过MUX连接。信号生成级别分为三个模块基本的OSC模块可以通过晶振旁路、内部REFO或VLO直接输出XT1CLK、VLOCLK、REFOCLK三种信号；可选的XT2模块直接输出XT2晶振的4MHz时钟作为XT2CLK；可以通过晶振旁路和FLL（Frequency Locked Loop锁频环）进行晶振时钟倍频和分频，信号源（即FLLREFCLK反馈时钟）通过MUX直接引用XT1CLK、REFOCLK、XT2CLK之一，经过多个倍频分频器后输出为DCOCLK和DCOCLKDIV。所有信号分别输出到信号分配级，通过MUX分配给ACLK、MCLK、SMCLK</p>
<p><strong>XT1CLK</strong>：<strong>外部低频或高频时钟源</strong>，默认关闭，需要接入外部晶振并通过软件使晶振起振后再使用，一般使用32.768kHz的低频晶振，但是也可以使用4-32MHz的外部高频时钟源，<strong>端口P5.4、P5.5</strong></p>
<p>使用下面的代码对时钟源进行配置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P5SEL |= BIT4 | BIT5; <span class="comment">//配置P5.4、P5.5为XT1复用功能</span></span><br><span class="line">UCSCTL6 |= XCAP_3; <span class="comment">//配置匹配电容为12pF</span></span><br><span class="line">UCSCTL6 &amp;= ~XT1OFF; <span class="comment">//使能XT1，使外部晶振起振</span></span><br><span class="line"><span class="keyword">while</span>(SFRIFG1 &amp; OFIFG)</span><br><span class="line">&#123;</span><br><span class="line">    UCSCTL7 &amp;= ~(XT2OFFG + XT1LFOFFG + DCOFFG); <span class="comment">//清除三类时钟故障标志位，等待起振</span></span><br><span class="line">    SFRIFG1 &amp;= ~OFIFG; <span class="comment">//清除震荡器故障标志位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>XT2CLK</strong>：和XT1CLK类似，但只能接4-32MHz的<strong>高频晶振</strong>，一般接入4MHz晶振，需要额外加匹配电容方便起振。<strong>端口P5.2、P5.3</strong></p>
<p>需要注意的是在配置SMCLK和MCLK为XT2CLK时钟源之前需要先修改ACLK和REFCLK的时钟源，因为它们的时钟源默认为XT1CLK，但这里并没有启动，所以会导致没有必要的XT1CLK始终故障，会影响判断XT2是否起振，实现代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P5SEL |= BIT2 | BIT3; <span class="comment">//配置P5.2、P5.3为XT2复用功能</span></span><br><span class="line">UCSCTL6 &amp;= ~XT2OFF; <span class="comment">//使能XT2</span></span><br><span class="line">UCSCTL4 = UCSCTL4 &amp; (~(SELA_7)) | SELA_1; <span class="comment">//将ACLK配置为VLOCLK</span></span><br><span class="line">UCSCTL3 |= SELREF_2; <span class="comment">//将REFCLK配置为REFOCLK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(SFRIFG1 &amp; OFIFG)</span><br><span class="line">&#123;</span><br><span class="line">    UCSCTL7 &amp;= ~(XT2OFFG + XT1LFOFFG + DCOFFG); <span class="comment">//清除三类时钟故障标志位，等待起振</span></span><br><span class="line">    SFRIFG1 &amp;= ~OFIFG; <span class="comment">//清除震荡器故障标志位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>VLOCLK</strong>：<strong>内部低功耗、低频时钟源</strong>，<strong>频率10kHz</strong>，精度较低，会随电源电压和温度产生较大漂移，用于不需要精准时钟基准的系统控制，被使用时自动开启、不使用时自动关闭，低功耗唤醒模式下回优先使用该时钟源作为系统和看门狗时钟</p>
<p>配置UCSCTL4选择</p>
<p><strong>REFOCLK</strong>：<strong>内部修整低频参考时钟源，精度较高，32.768kHz</strong>，和VLOCLK一样不需要配置寄存器进行起振，若未使用外部晶振，系统会自动选择该时钟源作为ACLK和DCOCLK锁频环参考时钟源</p>
<p>通过UCSCTL4选择</p>
<p><strong>DCOCLK</strong>：内部数字控制时钟源，具有宽工作频率，<strong>最高可产生25MHz时钟频率</strong>，可以和FLL配合控制参考时钟，也可以引入其他时钟源反馈进行时钟分频/倍频，但是需要额外配置</p>
<p>这是f5xx中<strong>最常用的时钟源</strong>，类似于stm32的PLL时钟（它的内部也是类似的PLL）</p>
<p>其频率计算公式如下<br>$$<br>DCOCLK = D \times (N+1) \times \frac{REFCLK}{n} \<br>DCOCLKDIV = (N+1) \times \frac{REFCLK}{n}<br>$$<br>REFCLK来源见上文</p>
<p>n为输入时钟分频，通过UCSCTL3中的FLLCLKDIV设定，查找该寄存器介绍可知其取值0-7，对应n取值2^p^，默认为0，不分频</p>
<p>D通过UCSCTL2中的FLLD设对，可取值0-7，对应D取值2^p^，默认为1，即D=2，二分频</p>
<p>N可以通过UCSCTL2中的FLLN设定，取值0-1023，当FLLN=0时，N=1，除此之外N=FLLN，默认为31，即N=31</p>
<p>如果系统复位后不进行任何设置，DCOCLK=2097152Hz，DCOCLKDIV=1048576Hz</p>
<p><strong>MCLK和SMCLK都默认选择DCOCLKDIV作为时钟源</strong>。</p>
<p>通过配置DCORSEL、DCOx、MOD来选择DCO的频率设置范围（最小值和最大值）</p>
<p>详细内容参考datasheet</p>
<p><strong>MODOSC</strong>：内部模块振荡器，是<strong>UCS时钟模块下属的振荡器</strong>，能产生<strong>4.8MHz的MODCLK时钟</strong>，用于FLASH、ADC等片上外设</p>
<p><strong>MCLK</strong>：为CPU和片上外设提供<strong>主时钟</strong>，默认使用DCOCLKDIV</p>
<p>通过配置DIVM选择MCLK分频系数为1、2、4、8、16、32</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UCSCTL4 = UCSCTL4 &amp; (~SELM_7) | SELM_0; <span class="comment">//XT1CLK时钟源</span></span><br><span class="line">UCSCTL4 = UCSCTL4 &amp; (~SELM_7) | SELM_1; <span class="comment">//VLOCLK时钟源</span></span><br><span class="line">UCSCTL4 = UCSCTL4 &amp; (~SELM_7) | SELM_2; <span class="comment">//REFOCLK时钟源</span></span><br><span class="line">UCSCTL4 = UCSCTL4 &amp; (~SELM_7) | SELM_3; <span class="comment">//DCOCLK时钟源</span></span><br><span class="line">UCSCTL4 = UCSCTL4 &amp; (~SELM_7) | SELM_4; <span class="comment">//DCOCLKDIV时钟源</span></span><br><span class="line">UCSCTL4 = UCSCTL4 &amp; (~SELM_7) | SELM_5; <span class="comment">//XT2CLK时钟源</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UCSCTL5 = UCSCTL5 &amp; (~DIVM_7) | DIVM_0; <span class="comment">//MCLK不分频</span></span><br><span class="line">UCSCTL5 = UCSCTL5 &amp; (~DIVM_7) | DIVM_1; <span class="comment">//MCLK 2分频</span></span><br><span class="line">UCSCTL5 = UCSCTL5 &amp; (~DIVM_7) | DIVM_2; <span class="comment">//MCLK 4分频</span></span><br><span class="line">UCSCTL5 = UCSCTL5 &amp; (~DIVM_7) | DIVM_3; <span class="comment">//MCLK 8分频</span></span><br><span class="line">UCSCTL5 = UCSCTL5 &amp; (~DIVM_7) | DIVM_4; <span class="comment">//MCLK 16分频</span></span><br><span class="line">UCSCTL5 = UCSCTL5 &amp; (~DIVM_7) | DIVM_5; <span class="comment">//MCLK 32分频</span></span><br></pre></td></tr></table></figure>

<p><strong>ACLK</strong>：<strong>辅助时钟</strong>，专用来为外围模块提供信号。默认使用XT1CLK时钟源，如果未起振，则使用REFOCLK。配置方法和MCLK完全一致</p>
<p><strong>SMCLK</strong>：<strong>子系统主时钟</strong>，和MCLK基本一致，只是不为CPU提供时钟</p>
<p>上电复位后，UCS默认配置如下：</p>
<ul>
<li>ACLK选择XT1为时钟源，如果未起振则使用REFOCLK并生成时钟故障标志</li>
<li>MCLK选择DCOCLKDIV</li>
<li>SMCLK选择DCOCLKDIV</li>
</ul>
<p>需要注意：msp430f5529的XTIN和XTOUT引脚默认为GPIO功能，并在上电情况下不会启动，需要额外进行软件设置</p>
<p>同时P7.7、P2.2、P1.0分别能够对外输出MCLK、SMCLK、ACLK时钟</p>
<p>这里用最为复杂的DCO配置说明整个时钟系统的配置流程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430f5529.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetVcoreUp</span><span class="params">(<span class="keyword">uint_32_t</span> level)</span></span>; <span class="comment">//提升核心电压以提升工作频率</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">XT1_ON</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//启动XT1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DCO__16MHz</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//使用DCO将XT1倍频到16MHz</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW + WDTHOLD;</span><br><span class="line">    P1SEL |= BIT0; <span class="comment">//P1.0 ACLK输出</span></span><br><span class="line">    P1DIR |= BIT0;</span><br><span class="line">    P2SEL |= BIT2; <span class="comment">//SMCLK输出</span></span><br><span class="line">    P2DIR |= BIT2;</span><br><span class="line">    P7SEL |= BIT7; <span class="comment">//MCLK输出</span></span><br><span class="line">    P7DIR |= BIT7;</span><br><span class="line">    P7DIR |= BIT0; <span class="comment">//P7.0 LED驱动输出</span></span><br><span class="line">    P1OUT |= BIT0;</span><br><span class="line">    </span><br><span class="line">    XT1_ON();</span><br><span class="line">    DCO__16MHz();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        __delay_cycles(<span class="number">8000000</span>); <span class="comment">//每0.5s</span></span><br><span class="line">        P7OUT ^= BIT0 ;<span class="comment">//LED状态翻转一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetVcoreUp</span><span class="params">(<span class="keyword">uint_32_t</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PMMCTL0_H = PMMPW_H; <span class="comment">//解锁PMM寄存器，允许写入</span></span><br><span class="line">    SVSMHCTL = SVSHE + SVSHRVL0 * level + SVMHE + SVSMHRRL0 * level; <span class="comment">//设置SVS/SVM高侧到新的等级</span></span><br><span class="line">    SVSMLCTL = SVSLE + SVMLE + SVSMLRRL0 * level; <span class="comment">//设置SVS低侧到新的等级</span></span><br><span class="line">    <span class="keyword">while</span>((PMMIFG &amp; SVSMLDLYIFG) == <span class="number">0</span>); <span class="comment">//等待SVM稳定</span></span><br><span class="line">    PMMIFG &amp;= ~(SVMLVLRIFG + SVMLIFG); <span class="comment">//清除已经置位的标志</span></span><br><span class="line">    PMMCTL0_L = PMMCOREV0 * level; <span class="comment">//设置VCORE到新的等级</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span>((PMMIFG &amp; SVMLIFG)) <span class="comment">//等待达到新的电压等级</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>((PMMIFG &amp; SVMLVLRIFG) == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置SVS/SVM低侧到新的水平</span></span><br><span class="line">    SVSMLCTL = SVSLE + SVSLRVL0 * level + SVMLE + SVSMLRRL0 * level;</span><br><span class="line">    PMMCTL0_H = <span class="number">0x00</span>; <span class="comment">//锁住PMM的写入路径</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">XT1_ON</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    P5SEL |= BIT4 |BIT5; <span class="comment">//配置XT1引脚</span></span><br><span class="line">    UCSCTL6 |= XCAP_3; <span class="comment">//配置电容为12pF</span></span><br><span class="line">    UCSCTL6 &amp;= ~XT1OFF; <span class="comment">//使能XT1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(SFRIFG1 &amp; OFIFG)</span><br><span class="line">    &#123;</span><br><span class="line">        UCSCTL7 &amp;= ~(XT2OFFG + XT1LFOFFG + DCOFFG); <span class="comment">//清除三类时钟错误标志位</span></span><br><span class="line">        SFRIFG1 &amp;= ~OFIFG; <span class="comment">//清除时钟错误标志位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DCO__16MHz</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SetVcoreUp(<span class="number">1</span>); <span class="comment">//一级一级提升核心电压，不能跨级</span></span><br><span class="line">    SetVcoreUp(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置寄存器使DCOCLK=4.9MHz,DCOCLKDIV=2.45MHz */</span></span><br><span class="line">    __bis_SR_register(SCG0); <span class="comment">//关闭FLL库函数</span></span><br><span class="line">    UCSCTL0 = <span class="number">0x0000</span>; <span class="comment">//清零寄存器值，FLL运行时系统会自动配置该寄存器</span></span><br><span class="line">    UCSCTL1 = DCORSEL_5; <span class="comment">//选择DCOCLK频率范围 6-23.7MHz</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//FLLD=0，则D=1；FLLN=487，则N=487；N在UCSCTL3寄存器，默认值为1，则DCOCLK=1*(487+1)*32768=15.990784MHz</span></span><br><span class="line">    <span class="comment">//DCODIVCLK=(487+1)*32768=15.990784MHz</span></span><br><span class="line">    UCSCTL2 = FLLD_0 + <span class="number">487</span>; </span><br><span class="line">    </span><br><span class="line">    __bic_SR_register(SCG0); <span class="comment">//开启FLL控制回路</span></span><br><span class="line">    __delay_cycles(<span class="number">76563</span>); <span class="comment">//延时等待时钟稳定</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(SFRIFG1 &amp; OFIFG) <span class="comment">//检测时钟错误并等待时钟稳定</span></span><br><span class="line">    &#123;</span><br><span class="line">        UCSCTL7 &amp;= ~(XT2OFFG + XT1LFOFFG + DCOFFG);</span><br><span class="line">        SFRIFG1 &amp;= ~OFIFG;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>低功耗配置</strong></em></p>
<p>msp430一共有8种工作模式</p>
<ul>
<li>活跃模式（AM）</li>
<li>低功耗模式（LPM）0</li>
<li>低功耗模式1</li>
<li>低功耗模式2</li>
<li>低功耗模式3</li>
<li>低功耗模式3.5</li>
<li>低功耗模式4</li>
<li>低功耗模式4.5</li>
</ul>
<p>但是并不是所有系列都支持这些工作模式，对于f5529来说，不支持LPM3.5</p>
<p>使用以下指令来进入和退出低功耗模式0-4</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 开总中断并进入低功耗模式 */</span></span><br><span class="line">__bis_SR_register(LPMn_bits + GIE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 退出低功耗模式 */</span></span><br><span class="line">LPMn_EXIT; <span class="comment">//其中n可以换成数字0-4</span></span><br></pre></td></tr></table></figure>

<p>需要注意：<strong>低功耗模式唤醒都需要使用外部中断</strong>，所以需要在进入低功耗模式同时开启总中断</p>
<p>在最高级别LPM4.5低功耗模式下，RAM中内容会直接丢失，所以在从LPM4.5唤醒后需要重新配置寄存器和相关设置</p>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>低功耗模式唤醒使用的指令实际上是通过直接修改SR寄存器的值，清除休眠标志，它内联到以下函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_bic_SR_register_on_exit(LPM3_bits);<span class="comment">//退出LPM3</span></span><br></pre></td></tr></table></figure>

<p>MSP430和arm一样都具有<em>系统中断</em>、<em>不可屏蔽中断</em>和<em>可屏蔽中断</em>三种，其中系统中断和不可屏蔽中断优先级最高；可屏蔽中断可以通过<strong>状态寄存器SR</strong>中的GIE位来屏蔽和开启</p>
<p>大致的中断作用与arm类似，而使用方式与51类似</p>
<p>下面主要介绍外部中断</p>
<ol>
<li><p>初始化端口时要清空中断标志位</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P1IFG &amp;= ~(BIT0); <span class="comment">//清空中断标志位</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>PIES</code>寄存器选择触发边沿（0为上升沿，1为下降沿）并使用<code>PxIE</code>寄存器使能中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P1IES &amp;= ~BIT0; <span class="comment">//P1.0上升沿触发</span></span><br><span class="line">P1IES |= BIT1; <span class="comment">//P1.1下降沿触发</span></span><br><span class="line">P1IES |= BIT2; <span class="comment">//P1.2下降沿触发</span></span><br><span class="line">    </span><br><span class="line">P1IE |= BIT0; <span class="comment">//使能P1.0中断</span></span><br><span class="line">P1IE |= BIT1; <span class="comment">//使能P1.1中断</span></span><br><span class="line">P1IE |= BIT2; <span class="comment">//使能P1.2中断</span></span><br></pre></td></tr></table></figure></li>
<li><p>开总中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__bis_SR_register(GIE);</span><br></pre></td></tr></table></figure></li>
<li><p>编写中断服务函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector = 中断向量地址</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">ISR_function</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//中断服务函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在中断函数内部清零中断标志位</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__even_in_range(P1IV, <span class="number">16</span>); <span class="comment">//用于查询P1的所有中断标志位并自动清零，使用该函数可以实现将所有P1的外部中断放在同一个函数内解决的功能,如下所示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(__even_in_range(P1IV, <span class="number">16</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//无中断</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//P1IFG.0</span></span><br><span class="line">        <span class="comment">/* 中断处理函数 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">//P1IFG.1</span></span><br><span class="line">        <span class="comment">/* 中断处理函数 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: <span class="comment">//P1IFG.2</span></span><br><span class="line">        <span class="comment">/* 中断处理函数 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>: <span class="comment">//P1IFG.3</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>: <span class="comment">//P1IFG.4</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>: <span class="comment">//P1IFG.5</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">14</span>: <span class="comment">//P1IFG.6</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">16</span>: <span class="comment">//P1IFG.7</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">//出错情况</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>此外，msp430还支持<em>手动的</em>嵌套中断</p>
<p>示例程序如下所示（TI的七段数码管驱动示例程序）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> SEVENSEG_OUTPUT[<span class="number">10</span>] = &#123;<span class="number">0x3f</span>, <span class="number">0x06</span>, <span class="number">0x5b</span>, <span class="number">0x4f</span>, <span class="number">0x66</span>, <span class="number">0x6d</span>, <span class="number">0x7d</span>, <span class="number">0x07</span>, <span class="number">0x7f</span>, <span class="number">0x6f</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> loopCounter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> timeCounter1; </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> timeCounter2;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> timeCounter3;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW | WDTHOLD; <span class="comment">//关闭看门狗</span></span><br><span class="line"></span><br><span class="line">    PADIR = <span class="number">0x03ff</span>; <span class="comment">// P1, P2.0 and P2.1 output, P2.6 and P2.7 input</span></span><br><span class="line">    PAOUT = <span class="number">0xc03f</span>;</span><br><span class="line"></span><br><span class="line">    P2REN = <span class="number">0xc0</span>; <span class="comment">// P2.6 P2.7 上拉电阻使能</span></span><br><span class="line">    P2IES = <span class="number">0x3f</span>; <span class="comment">// P2.6 P2.7 配置中断为上升沿</span></span><br><span class="line">    P2IE = <span class="number">0xc0</span>; <span class="comment">// P2.6 P2.7 interrupt enabled</span></span><br><span class="line"></span><br><span class="line">    PM5CTL0 &amp;= ~LOCKLPM5; <span class="comment">// 关闭GPIO高阻抗模式</span></span><br><span class="line"></span><br><span class="line">    RTCMOD = <span class="number">50</span>; <span class="comment">// 设置RTC重装计数值为50</span></span><br><span class="line">                 <span class="comment">// 64/32768 * 51 = ~0.1 sec.</span></span><br><span class="line">    SYSCFG2 |= RTCCKSEL; <span class="comment">// Source = ACLK = REFO，64分频，选择ACLK作为RTC时钟</span></span><br><span class="line">    RTCCTL = RTCSS_1 | RTCSR | RTCPS__64;</span><br><span class="line"></span><br><span class="line">    P2IFG = <span class="number">0</span>; <span class="comment">// 清除P1.3中断标志位</span></span><br><span class="line">    __bis_SR_register(GIE); <span class="comment">//开全局中断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PAOUT |= (BIT9 | SEVENSEG_OUTPUT[timeCounter3]);  <span class="comment">// 按顺序显示七段数码管数字</span></span><br><span class="line">        __delay_cycles(<span class="number">100</span>);</span><br><span class="line">        PAOUT = <span class="number">0xc000</span>; <span class="comment">// 清除引脚</span></span><br><span class="line"></span><br><span class="line">        PAOUT |= (BIT8 | SEVENSEG_OUTPUT[timeCounter2]);</span><br><span class="line">        __delay_cycles(<span class="number">100</span>);</span><br><span class="line">        PAOUT = <span class="number">0xc000</span>;</span><br><span class="line"></span><br><span class="line">        P1OUT |= (BIT7 | SEVENSEG_OUTPUT[timeCounter1]);</span><br><span class="line">        __delay_cycles(<span class="number">100</span>);</span><br><span class="line">        P1OUT = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RTC中断服务函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=RTC_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">RTC_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __bis_SR_register(GIE); <span class="comment">// 允许嵌套中断</span></span><br><span class="line">    RTCIV = <span class="number">0</span>;</span><br><span class="line">    timeCounter1++; <span class="comment">// timeCounter1代表0.1s, timeCounter2代表1s,timeCounter3代表10s，经典延时操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(timeCounter1 &gt; <span class="number">9</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        timeCounter1 = <span class="number">0</span>;</span><br><span class="line">        timeCounter2++;</span><br><span class="line">        <span class="keyword">if</span>(timeCounter2 &gt; <span class="number">9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            timeCounter3++;</span><br><span class="line">            timeCounter2 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(timeCounter3 &gt; <span class="number">9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            timeCounter3 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P2中断服务函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=PORT2_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">Port_2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __bis_SR_register(GIE); <span class="comment">// 允许嵌套中断</span></span><br><span class="line">    <span class="keyword">if</span>(P2IFG &amp; BIT6)</span><br><span class="line">    &#123;</span><br><span class="line">        P2IFG &amp;= ~BIT6; <span class="comment">// 清除P2.6中断标志位</span></span><br><span class="line">        <span class="comment">// 第一次按下按钮时开启定时器；第二次按下时停止定时器</span></span><br><span class="line">        <span class="keyword">if</span>(loopCounter == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          	loopCounter++; <span class="comment">//开启一轮循环</span></span><br><span class="line">            RTCCTL |= RTCIE; <span class="comment">//开启定时器</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            RTCCTL &amp;= ~RTCIE; <span class="comment">//关闭定时器</span></span><br><span class="line">            loopCounter = <span class="number">0</span>; <span class="comment">//循环清零</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(P2IFG &amp; BIT7)</span><br><span class="line">    &#123;</span><br><span class="line">        P2IFG &amp;= ~BIT7; <span class="comment">// 清除P2.7中断标志位并复位秒表</span></span><br><span class="line">        RTCCTL &amp;= ~RTCIE; <span class="comment">//关闭定时器</span></span><br><span class="line">        </span><br><span class="line">        loopCounter = <span class="number">0</span>; <span class="comment">//复位所有变量</span></span><br><span class="line">        timeCounter3 = <span class="number">0</span>;</span><br><span class="line">        timeCounter2 = <span class="number">0</span>;</span><br><span class="line">        timeCounter1 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现中断嵌套需要注意以下几点：</p>
<p>msp430默认关闭中断嵌套，一定要中断嵌套的话，就必须在中断服务程序中打开总中断</p>
<p>msp430的指令中，_DINT()和_EINT()分别指关和开总中断</p>
<p>当进入中断服务程序时，只要不在中断服务程序中再次开中断，则总中断是关闭的，此时来中断不管是比当前中断的优先级高还是低都不执行</p>
<p><strong>若在中断服务程序A中开了总中断，则可以响应后来的中断B（不管B的优先级比A高还是低），B执行完再继续执行A</strong></p>
<p>注意：进入中断服务程序B后总中断同样也会关闭，如果B中断程序执行时需响应中断C，则此时也要开总中断，若不需响应中断，则不用开中断，B执行完后跳出中断程序进入A程序时，总中断会自动打开</p>
<p><strong>若在中断服务程序中开了总中断，后来的中断同时有多个，则会按优先级来执行，即中断优先级只有在多个中断同时到来时才起作用，中断服务不执行抢先原则</strong></p>
<p>对于单源中断，只要响应中断，系统硬件会自动清除中断标志位。对于TA/TB定时器的比较/捕获中断，只要访问TAIV/TBIV，标志位就会被自动清除；对于多源中断要手动清标志位，比如P1/P2口中断，要手工清除相应的标志。如果在这种中断里用<code>_EINT();</code>开中断,而在打开中断前没有清标志，就会有相同的中断不断嵌入，导致堆栈溢出引起复位，所以在<strong>这类中断中必须先清标志再打开中断开关</strong></p>
<p><strong>常用中断向量表</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASICTIMER_VECTOR   (0 * 2u) <span class="comment">/* 0xFFE0 Basic Timer */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT2_VECTOR        (1 * 2u)  <span class="comment">/* 0xFFE2 Port 2 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USART1TX_VECTOR     (2 * 2u) <span class="comment">/* 0xFFE4 USART 1 Transmit */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USART1RX_VECTOR     (3 * 2u) <span class="comment">/* 0xFFE6 USART 1 Receive */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT1_VECTOR        (4 * 2u)  <span class="comment">/* 0xFFE8 Port 1 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMERA1_VECTOR      (5 * 2u) <span class="comment">/* 0xFFEA Timer A CC1-2, TA */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMERA0_VECTOR      (6 * 2u) <span class="comment">/* 0xFFEC Timer A CC0 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADC12_VECTOR          (7 * 2u)  <span class="comment">/* 0xFFEE ADC */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USART0TX_VECTOR     (8 * 2u) <span class="comment">/* 0xFFF0 USART 0 Transmit */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USART0RX_VECTOR     (9 * 2u) <span class="comment">/* 0xFFF2 USART 0 Receive */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WDT_VECTOR          (10 * 2u) <span class="comment">/* 0xFFF4 Watchdog Timer */</span></span></span><br><span class="line"></span><br><span class="line">#defineCOMPARATORA_VECTOR  (<span class="number">11</span> * <span class="number">2u</span>) <span class="comment">/* 0xFFF6Comparator A */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMERB1_VECTOR      (12 * 2u) <span class="comment">/* 0xFFF8 Timer B CC1-6, TB */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMERB0_VECTOR      (13 * 2u) <span class="comment">/* 0xFFFA Timer B CC0 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NMI_VECTOR          (14 * 2u) <span class="comment">/* 0xFFFC Non-maskable */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RESET_VECTOR        (15 * 2u) <span class="comment">/* 0xFFFE Reset [HighestPriority] */</span></span></span><br></pre></td></tr></table></figure>

<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>msp430有四个基本定时器，外加一个RTC定时器，部分定时器具有PWM输出功能</p>
<p>计数器核心是一个计数寄存器，对输入的时钟信号进行计数，可以配置其捕获跳变沿种类和分频系数，使用寄存器TAxR获取当前计数值。定时器主要分成两部分：主计数器和捕获比较器模块。捕获比较器模块与主计数器模块通过TAxR连通，主计数器会根据输入的信号跳变沿递增/递减寄存器TAxR/TBxR的值，捕获比较器会根据收到的比较值对寄存器的值进行检查，根据当前模式不同做出不同反应，因为计数寄存器被共用，所以可以将其分成多个通道。一般当捕获比较器满足设置的条件时就会产生中断，存储计数值或输出相应的信号。<em>只需要主计数器即可完成定时工作，捕获比较器的作用则在于配合主计数器完成更多扩展功能</em></p>
<ul>
<li><p><strong>Timer_A</strong>：<strong>16位定时器</strong>（最大值65535），具有7个捕获比较器，支持<em>多路捕获比较</em>、<em>PWM输出</em>、<em>间隔定时</em>功能</p>
<p>F5529中包含两个Timer_A模块，记作Timer_A0、Timer_A1、Timer_A2，三个模块的主计数器在结构上完全相同，单捕获比较器的数量不相同：Timer_A0有7个，Timer_A1和Timer_A2各有3个。</p>
</li>
<li><p><strong>Timer_B</strong>：<strong>16位定时器</strong>（最大值65535），具备Timer_A的所有功能，但它还具备<em>双缓冲比较锁存</em>与<em>同步加载</em>功能</p>
</li>
</ul>
<p>定时器的基本模式如下：</p>
<ul>
<li><p>捕获器模式</p>
<p>触发信号到来时捕获器将计数寄存器的值复制到捕获比较器的计数值寄存器TAxCCRn/TBxCCRn，并产生中断请求</p>
</li>
<li><p>比较器模式</p>
<p>需要程序向计数值寄存器TAxCCRn/TBxCCRn中写入初值，当主计数器的计数寄存器TAxR/TBxR计数值达到寄存器中存储的初值后定时器模块就会向CPU请求中断 </p>
</li>
</ul>
<p>通过配置TASSEL可以选择时钟来自ACLK、SMCLK、TAxCLK（外部输入）或INCLK（定时器级联）</p>
<h4 id="定时器A"><a href="#定时器A" class="headerlink" title="定时器A"></a>定时器A</h4><p>msp430的定时器A的主计数器具有以下几个工作模式</p>
<ul>
<li><p>增模式</p>
<p>设备会重复<strong>从0自增到TAxCCRn的值</strong>，溢出时触发中断</p>
<p>最基础的功能</p>
</li>
<li><p>连续模式</p>
<p>设备会重复<strong>从0自增到0FFFFh</strong>，然后从0重新开始计数</p>
<p>一般用于生成独立的时间间隔和输出频率，时间间隔完成时会生成中断</p>
<p>起始设置TAxCCRn的初值，并在中断服务函数中重新设置TAxCCRn的值，使其与初值的计数个数相同即可产生固定的时间间隔，这种操作还可以应用多个通道，因为多通道之间相互独立</p>
<p>最基础的功能</p>
</li>
<li><p>增减模式</p>
<p>定时器从0自增到TAxCCR0，再自减到0，也就是说其定时周期为两倍的TAxCCR0</p>
</li>
</ul>
<p>捕获比较器工作模式如下：</p>
<p>通过设置捕获比较器中的CAP位可以选择捕获比较器的工作模式为比较模式（0）或捕获模式（1），</p>
<ul>
<li><p>捕获模式</p>
<p>当CAP=1时选择捕获模式，用于记录时间时间。</p>
<p>触发信号输入CCIxA/CCIxB连接外部的引脚或内部的信号，通过CCIS位来选择；通过CM位选择触发捕获事件的输入信号触发沿</p>
<p>每当触发信号到来时，捕获比较器会1. 将TAxR的值复制到TAxCCRn寄存器中；2. 将捕获器中断标志CCIFG置位触发中断</p>
</li>
<li><p>比较模式</p>
<p>如果计数器TAxR的值和某个TAxCCRn的值相等时，相应的中断标志位会被置位，产生一个比较中断。一般该模式用于产生PWM信号</p>
</li>
<li><p>输出模式</p>
<p>传统的定时器通过标志位判断来触发事件，但msp430配备了专用的输出模块，使用输出模块寄存器OUTMODEx可以快速输出PWM信号或其他控制信号</p>
</li>
</ul>
<h4 id="定时器中断"><a href="#定时器中断" class="headerlink" title="定时器中断"></a>定时器中断</h4><p>定时器A具有两个中断源，捕获比较器0中断独立，其他所有中断（定时器溢出中断、捕获比较器1中断、捕获比较器2中断等等）共用中断源，通过TAxIV来确定具体触发中断的中断源</p>
<p>使用步骤如下：</p>
<ol>
<li><p>设置主计数器时钟</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TA0CTL = TASSEL_1;</span><br></pre></td></tr></table></figure></li>
<li><p>设置分频</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TA0EX0 = TAIDEX_7 <span class="comment">//8分频</span></span><br></pre></td></tr></table></figure></li>
<li><p>初始化CCR寄存器（设置初值）并使能中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TA0CCR0 = <span class="number">9000</span>; <span class="comment">//设置初值</span></span><br><span class="line">TA0CCTL0 = CCIE; <span class="comment">//使能TA0CCR0中断</span></span><br></pre></td></tr></table></figure></li>
<li><p>设置捕获比较器模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TA0CTL |= MC_2 + TACLR; <span class="comment">//清除TA0R，启动定时器，选择连续计数模式</span></span><br></pre></td></tr></table></figure>

<p>也可以使用下面的代码启用其他模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MC_1 增模式</span><br><span class="line">MC_3 减增模式</span><br></pre></td></tr></table></figure></li>
<li><p>开总中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__bis_SR_register(GIE);</span><br></pre></td></tr></table></figure></li>
<li><p>配置中断服务函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector = TIMER0_A0_VECTOR <span class="comment">//TA0CCR0中断</span></span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">TA0CCR0_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TA0CCR0 += <span class="number">16384</span>; <span class="comment">//添加偏置</span></span><br><span class="line">    <span class="comment">/* 中断处理函数 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="定时器B"><a href="#定时器B" class="headerlink" title="定时器B"></a>定时器B</h4><p>在捕获比较器和比较器之间加入的比较锁存器可以分组控制比较值载入的时刻，实现同步更新数据</p>
<p>在Timer_B中可以通过配置寄存器TBxCCTLn来选择TBxCCRn载入TBxCLn的时刻，在Timer_B中起到比较作用的是比较锁存器TBxCLn而不是CCR寄存器，当TBxR的值达到TBxCLn时，相应的中断标志位置位，产生比较器中断请求，TBxCCRn的值会在寄存器设置的时间点载入TBxCLn，从而实现比较延时更新</p>
<h4 id="输入捕获"><a href="#输入捕获" class="headerlink" title="输入捕获"></a>输入捕获</h4><p>使用定时器的外部计数功能来测量脉冲个数，可用于测速、编码器驱动等场合</p>
<p>基本使用方式和上面的定时器中断类似，但是需要以下额外语句</p>
<ol>
<li><p>配置外部时钟源，使能溢出中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TA0CTL = TASSEL_0 + TAIE;</span><br></pre></td></tr></table></figure></li>
<li><p>清除TAxR、启动定时器并工作于连续模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TA0CTL |= TACLR + MC_2;</span><br></pre></td></tr></table></figure></li>
<li><p>在定时器中断服务函数内递增全局计数变量用于获取输入捕获的脉冲数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> counter;</span><br><span class="line"><span class="keyword">uint8_t</span> loop;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector = TIMER0_A1_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">TA0_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    counter++;</span><br><span class="line">    <span class="keyword">if</span>(counter&gt;<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        loop++;</span><br><span class="line">        counter=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="PWM输出"><a href="#PWM输出" class="headerlink" title="PWM输出"></a>PWM输出</h4><p>msp430可以实现在不占用CPU资源的情况下输出PWM信号，程序如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430f5529.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW | WDTHOLD; <span class="comment">//关闭看门狗</span></span><br><span class="line">    P1DIR |= BIT2 | BIT3;</span><br><span class="line">    P1SEL |= BIT2 | BIT3; <span class="comment">//设置为定时器复用</span></span><br><span class="line">    TA0CCR0 = <span class="number">512</span><span class="number">-1</span>; <span class="comment">//PWM周期，频率=32768/512=64</span></span><br><span class="line">    TA0CCTL1 = OUTMODE_7; <span class="comment">//CCR1输出模式7</span></span><br><span class="line">    TA0CCR1 = <span class="number">384</span>; <span class="comment">//CCR1 PWM占空比设置为384/512=75%</span></span><br><span class="line">    TA0CCTL2 = OUTMODE_7; <span class="comment">//CCR2输出模式7</span></span><br><span class="line">    TA0CCR2 = <span class="number">128</span>; <span class="comment">//CCR2 PWM占空比设置为128/512=25%</span></span><br><span class="line">    <span class="comment">//开启定时器</span></span><br><span class="line">    TA0CTL = TASSEL_1 + MC_1 + TACLR; <span class="comment">//定时器时钟设置为32768Hz的ACLK，配置为增模式，清空TA0R</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 可实现在P1.2上输出75%占空比，在P1.3上输出25%占空比，频率都是64Hz的PWM信号 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总线协议"><a href="#总线协议" class="headerlink" title="总线协议"></a>总线协议</h3><p>msp430f5529中配备了<strong>通用串行通信接口模块USCI</strong>，它支持了多种通信模式，UART、SPI、IIC都可以使用该外设进行处理</p>
<p>使用方法很类似，仅给出示例代码</p>
<h4 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h4><p>串口接收并复读数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430f5529.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW + WDTHOLD;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 初始化UART */</span></span><br><span class="line">    P4SEL |= BIT4 + BIT5; <span class="comment">//配置P4.4、P4.5为USCI_A1 Tx、Rx</span></span><br><span class="line">    UCA1CTL1 |= UCSWRST; <span class="comment">//复位USCI_A1</span></span><br><span class="line">    UCA1CTL1 |= UCSSEL_2; <span class="comment">//SMCLK 无校验位 8字符长度 1个停止位</span></span><br><span class="line">    UCA1BR0 = <span class="number">9</span>; <span class="comment">//低8位=9</span></span><br><span class="line">    UCA1BR1 = <span class="number">0</span>; <span class="comment">//高8位=0，调制后波特率约为115200bps</span></span><br><span class="line">    UCA1MCTL |= UCBRS_1 + UCBRF_0; <span class="comment">//调制器UCBRSx=1,UCBRFx=0</span></span><br><span class="line">    UCA1CTL1 &amp;= ~UCSWRST; <span class="comment">//启动USCI_A1</span></span><br><span class="line">    UCA1IE |= UCRXIE; <span class="comment">//使能USCI_A1接收中断</span></span><br><span class="line">    __bis_SR_register(LPM0_bits + GIE); <span class="comment">//使能全局中断</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=USCI_A1_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">USCI_A1_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(__even_in_range(UCA1IV, <span class="number">4</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//无中断</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//接收中断RXIFG</span></span><br><span class="line">            UCA1TXBUF = UCA1RXBUF; <span class="comment">//复读</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">//发送中断TXIFG</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UCA1TXBUF：串口发送寄存器</p>
<p>UCA1RXBUF：串口接收寄存器</p>
<p>UCA1IE：串口中断控制寄存器，可以选择接收中断、发送中断</p>
<h4 id="IIC"><a href="#IIC" class="headerlink" title="IIC"></a>IIC</h4><p>需要注意，msp430的IIC无法内部上拉，所以必须在外部接入4.7k的上拉电阻到VCC（3.3V）</p>
<p>下面的代码仅说明如何将USCI配置成IIC驱动模式</p>
<ol>
<li><p>包含头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>初始化引脚复用功能</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P4SEL |= BIT1 + BIT2;</span><br></pre></td></tr></table></figure></li>
<li><p>初始化USCI，并配置传输速率</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UCB1CTL1 |= UCSWRST; <span class="comment">//复位USCI_B1</span></span><br><span class="line">UCB1CTL0 |= UCMST + UCMODE_3 + UCSYNC; <span class="comment">//配置为IIC主机，同步模式</span></span><br><span class="line">UCB1CTL1 = UCSSEL_2 + UCSWRST; <span class="comment">//SMCLK，保持UCSWRST置位</span></span><br><span class="line"></span><br><span class="line">UCB1BR0 = <span class="number">12</span>; <span class="comment">//fscl=SMCLK/12=100kHz</span></span><br><span class="line">UCB1BR1 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>设置从机地址</p>
<p>这里假设从机地址是0x48</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UCB1I2CSA = <span class="number">0x48</span>; <span class="comment">//从机地址0x48</span></span><br></pre></td></tr></table></figure></li>
<li><p>启动外设</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UCB1CTL1 &amp;= ~UCSWRST; <span class="comment">//清除复位标志，外设开始运行</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写中断控制函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> IIC_RXByte;</span><br><span class="line"><span class="keyword">uint8_t</span> IIC_TXByte;</span><br><span class="line"><span class="keyword">uint8_t</span> *PRxData; <span class="comment">//接收缓存</span></span><br><span class="line"><span class="keyword">uint8_t</span> *PTxData; <span class="comment">//发送缓存</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=USCI_B1_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">USCI_B1_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(__even_in_range(UCB1IV, <span class="number">12</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//无中断</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//ALIFG</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">//无响应中断NACKIFG</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: <span class="comment">//STTIFG</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>: <span class="comment">//停止位中断STPIFG</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>: <span class="comment">//接收中断RXIFG</span></span><br><span class="line">            IIC_RXByte--; <span class="comment">//递减字节计数变量</span></span><br><span class="line">            <span class="keyword">if</span>(IIC_RXByte) <span class="comment">//如果没有接收完毕</span></span><br><span class="line">            &#123;</span><br><span class="line">                *PRxData++ = UCB1RXBUF; <span class="comment">//接收剩下的数据到缓存区</span></span><br><span class="line">                <span class="keyword">if</span>(IIC_RXByte == <span class="number">1</span>) <span class="comment">//检查是否只剩一个字节未接收</span></span><br><span class="line">                &#123;</span><br><span class="line">                    UCB1CTL1 |= UCTXSTP; <span class="comment">//发送停止条件</span></span><br><span class="line">				&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//已经接收完毕</span></span><br><span class="line">            &#123;</span><br><span class="line">                *PRxData = UCB1RXBUF; <span class="comment">//将最后一字节数据存储到缓存区</span></span><br><span class="line">                UCB1IE &amp;= ~UCRXIE; <span class="comment">//禁用接收中断</span></span><br><span class="line">                __bic_SR_registe_on_exit(LPM0_bits); <span class="comment">//退出LPM0，进入活跃模式</span></span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">12</span>: <span class="comment">//发送中断TXIFG</span></span><br><span class="line">            <span class="keyword">if</span>(IIC_TXByte) <span class="comment">//如果没有发送完毕</span></span><br><span class="line">            &#123;</span><br><span class="line">                UCB1TXBUF = *PTxData; <span class="comment">//IIC发送数据</span></span><br><span class="line">                IIC_TXByte--; <span class="comment">//递减字节计数变量</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//已经接收完毕</span></span><br><span class="line">            &#123;</span><br><span class="line">                UCB1CTL1 |= UCTXSTP; <span class="comment">//置位发送停止条件位</span></span><br><span class="line">                UCB1IFG &amp;= ~UCTTXIFG; <span class="comment">//清除发送中断标志位TXIFG</span></span><br><span class="line">                UCB1IE &amp;= ~UCTXIE; <span class="comment">//禁用发送中断</span></span><br><span class="line">                __bic_SR_registe_on_exit(LPM0_bits); <span class="comment">//退出LPM0，进入活跃模式</span></span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写相关驱动</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TxData[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//发送缓存区</span></span><br><span class="line">RxData[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//接收缓存区</span></span><br><span class="line"><span class="keyword">uint8_t</span> IIC_RXByte;</span><br><span class="line"><span class="keyword">uint8_t</span> IIC_TXByte;</span><br><span class="line"><span class="keyword">uint8_t</span> *PRxData; <span class="comment">//接收缓存</span></span><br><span class="line"><span class="keyword">uint8_t</span> *PTxData; <span class="comment">//发送缓存</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 这里省略初始化部分 */</span></span><br><span class="line">    disable_WDG();</span><br><span class="line">    init_iic();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 发送设置 */</span></span><br><span class="line">        PTxData = TxData;</span><br><span class="line">        IIC_TXByte = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">while</span>(UCB1CTL1 &amp; UCTXSTP); <span class="comment">//确保停止条件已发送，总线空闲</span></span><br><span class="line">        </span><br><span class="line">        UCBCTL1 |= UCTR; <span class="comment">//设置主机工作在发送机模式</span></span><br><span class="line">        UCBCTL1 |= UCTXSTT; <span class="comment">//发送开始条件并发送有“写标志位”的地址</span></span><br><span class="line">        UCB1IE |= UCTXIE; <span class="comment">//使能发送中断</span></span><br><span class="line">        __bis_SR_register(LPM0_bits + GIE); <span class="comment">//进入LPM0，使能全局中断</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 接收设置 */</span></span><br><span class="line">        PRxData = RxData;</span><br><span class="line">        IIC_RXByte = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">while</span>(UCB1CTL1 &amp; UCTXSTP); <span class="comment">//确保停止条件已发送，总线空闲</span></span><br><span class="line">        UCBCTL1 &amp;= ~UCTR;<span class="comment">//设置主机工作在接收机模式</span></span><br><span class="line">        UCBCTL1 |= UCTXSTT; <span class="comment">//发送开始条件并发送有“读标志位”的地址</span></span><br><span class="line">        UCB1IE |= UCRXIE; <span class="comment">//使能接收中断</span></span><br><span class="line">        __bis_SR_register(LPM0_bits + GIE); <span class="comment">//进入LPM0，使能全局中断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h4><p>使用以下代码设置SPI</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这里省略端口复用设置 */</span></span><br><span class="line">UCB0CTL1 |= UCSWrST;</span><br><span class="line">UCB0CTL0 |= UCMST + UCSYNC; <span class="comment">//设置为三线SPI主机模式，8位数据位</span></span><br><span class="line">UCB1CTL1 = UCSSEL_2; <span class="comment">//时钟设置为SMCLK</span></span><br><span class="line">UCB1BR0 = <span class="number">0xFF</span>; <span class="comment">//UCB0CLK = SMCLK / 0xFFF</span></span><br><span class="line">UCB1BR1 = <span class="number">0x0F</span>; <span class="comment">//一般来说可以选择100kHz以上的频率，通常使用4MHz频率</span></span><br><span class="line"></span><br><span class="line">UCB1CTL1 &amp;= ~UCSWRST; <span class="comment">//清除复位标志，外设开始运行</span></span><br></pre></td></tr></table></figure>

<p>中断和驱动编写部分和IIC基本一致，不再赘述</p>
<h3 id="片上模拟外设"><a href="#片上模拟外设" class="headerlink" title="片上模拟外设"></a>片上模拟外设</h3><p>msp430集成了12位ADC/DAC和模拟比较器外设</p>
<h4 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h4><p>f5529配备了SAR架构的ADC12_A模块，支持12位ADC，具有16个模拟输入通道、16个独立的转换和存储单元，可在脱离CPU情况下完成ADC转换，最高200ksp（千次采样/每秒）</p>
<p>基本配置流程如下：</p>
<ol>
<li><p>配置核心控制寄存器，选择时钟、转换模式、启动参考电压生成器</p>
<p>ADC12_A内部具有独立的REF模块，可以提供1.5V、2V、2.5V参考电压。通过REF模块的REFMSTR位选择参考电压：置1时（默认状态）使用REF模块控制参考电压；置0时使用ADC12_A的参考电压模块控制参考电压</p>
<p>使用ADC12REF2_5V控制参考电压大小，ADC12REFON控制是否开启电压生成器，ADC12REFOUT控制是否输出参考电压</p>
<p>ADC使用ADC12CLK时钟用来控制采样和转换的时间和周期，时钟源可选择SMCLK、MCLK、ACLK和ADC12OSC（UCS模块的MODCLK的5MHz内部振荡器），时钟源使用ADC12DIV控制的预分频器和ADC12SSELx控制的分频器进行分频，可选择1-32分频</p>
<p>基本配置程序如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADC12CTL0 = ADC12ON+ADC12SHT0_8+ADC12MSC; <span class="comment">//开启ADC12,设置采样时间,设置采样模式（这里使用了多采样转换）</span></span><br></pre></td></tr></table></figure>

<p>ADC具有4种模式，通过CONSEQx位选择</p>
<ul>
<li><strong>单通道模式</strong>：单通道只采样和转换一次，当ADC12SC置位时触发一次采样转换操作，持续一段时间后自动复位</li>
<li>序列通道（<strong>自动扫描</strong>）<strong>模式</strong>：使用CSTARTADDx位选择开始转换的第一个ADC1MCTLx，指定后序列启动指针会自动递增，被它指向的通道会自动开始转换，转换完成后自动复位，操作一直继续直到处理到ADC12EOS=1的ADC12MCTLx才会停止，ADC12EOS作为序列结束的标志，只在序列转换模式下使用</li>
<li><strong>重复单通道模式</strong>：一个单独的通道会被不断采样转换，可以设置完成中断来读取转换结果</li>
<li><strong>重复序列通道</strong>（自动重复）<strong>模式</strong>：一序列通道会被重复采样和转换，使用CSTARTADDx定义第一个ADC12McTLx，序列再检测到ADC12EOS（序列结束标志）置位后会自动结束，下一个触发信号将重新开始序列</li>
</ul>
</li>
<li><p>保持其处于禁用状态，ADC12ENC=0</p>
</li>
<li><p>配置引脚复用</p>
<p>将GPIO复用为ADC输入引脚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PxSEL |= <span class="number">0x0</span>n; <span class="comment">//选择Px.n引脚复用为ADC输入</span></span><br></pre></td></tr></table></figure>

<p>注意：<strong>只有能接入ADC的对应IO口才能复用</strong></p>
</li>
<li><p>配置采样定时器</p>
<p>一次转换由一个采样信号SHI的上升沿引起，可通过SHSx位来选择，可以选为直接由ADC12SC位控制或使用定时器来控制</p>
<ul>
<li>ADC12SHP=0，使用<strong>扩展采样模式</strong>，SHI信号直接控制SAMPCON并定义采样周期长度；SAMPCON=1时采样活跃，SAMPCON的下降沿会在同步ADC12CLK信号后启动转换</li>
<li>ADC12SHP=1，使用<strong>脉冲采样模式</strong>，SHI信号用于触发采样定时器，采样定时器在同步AD12CLK后将SAMPCON保持在高电平并持续一个可编程的间隔$t_{sample}$，整个采样时间就是$t_{sample}+t_{sync}$</li>
</ul>
</li>
<li><p>可单独配置每个通道的参考电压和输入源</p>
<p>使用ADC12MCTLx（x为0-15）控制转换存储单元，通过ADC12SREF和ADC12INCH分别选择参考电压和模拟信号的输入通道</p>
<p>在单通道单转换模式中，复位ADC12ENC<strong>立刻</strong>停止一个转换且会导致转换结果不可预知，一般来说需要使用以下语句停止单通道转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(ADC12BUSY != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    delay();</span><br><span class="line">&#125;</span><br><span class="line">ADC12ENC = <span class="number">0</span>; <span class="comment">//等待ADC12BUSY = 0后才能停止单通道转换</span></span><br></pre></td></tr></table></figure>

<p>重复单通道模式下，复位ADC12ENC会在<strong>当前转换结束</strong>时停止转换器</p>
<p>序列通道或重复序列通道中，复位ADC12ENC会在<strong>序列结束</strong>时停止转换器</p>
<p><em>任何模式中都可以通过清零ADC12CONSEQ并复位ADC12ENC位来立刻停止，但这样会导致转换结果不可预知</em></p>
</li>
<li><p>可以使能集成温度传感器或配置转换完成中断</p>
<p>ADC可以直接连接内部的温度传感器（这是参考电压生成器的一部分）来获取内部温度，计算公式如下<br>$$<br>T=(ADC_{raw} - CAL_ADC_T30) \times (\frac{85-30}{CAL_ADC_T85 - CAL_ADC_T30}) + 30<br>$$<br>其中T是精确温度值，$ADC_{raw}$是数模转换结果，两个$CAL_ADC_T$为温度矫正参数，需要通过地址进行访问调用，每个设备的矫正参数都不同，该参数会被使用TLV（Tag-Length-Value）的方式写入单片机，地址调用形式如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*((<span class="keyword">unsigned</span> <span class="keyword">int</span>*)<span class="number">0x1A1A</span>) <span class="comment">//具体地址需要根据电压和设备的不同来确定，详细内容参考datasheet即可</span></span><br></pre></td></tr></table></figure>

<p><strong>ADC12_A具有18个中断，共用一个中断源</strong></p>
<p>可单独配置某通道完成中断、ADC12MEMx溢出中断、ADC12_A计时溢出中断，所有中断通过唯一的中断向量寄存器来配置，也就是说只使用一个中断服务函数</p>
<p>注意：任何对于ADC12IV的读写操作都会自动复位ADC12OV或ADC12TOV，如果中断服务函数在访问ADC12IV寄存器时有ADC12OV和ADC12IFGx中断生成，那么ADC12OV中断条件会自动复位，在中断服务函数返回后紧接着处理其他中断，因此应避免中断执行时间过长导致ADC中断占用前台应用</p>
<p>使用下面的程序来开启ADC中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADC12IE = <span class="number">0x01</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>将ADC12ENC=1来使能设备</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADC12CTL0 |= ADC12ENC;</span><br><span class="line">ADC12CTL0 |= ADC12SC;</span><br></pre></td></tr></table></figure></li>
<li><p>通过读取ADC12MCTLx对应的ADC12MEMx来获取转换结果</p>
</li>
</ol>
<p>单通道单次转换示例如下（测量引脚电压高于参考电压则指示灯亮）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	WDTCTL = WDTPW + WDTHOLD;  <span class="comment">//停止WDG</span></span><br><span class="line">  	ADC12CTL0 = ADC12SHT02 + ADC12ON; <span class="comment">//设置采样时间并开启ADC12_A</span></span><br><span class="line"> 	ADC12CTL1 = ADC12SHP; <span class="comment">//使用采样定时器</span></span><br><span class="line">  	ADC12IE = <span class="number">0x01</span>; <span class="comment">//使能中断</span></span><br><span class="line">  	ADC12CTL0 |= ADC12ENC; <span class="comment">//使能转换通道</span></span><br><span class="line">  	P6SEL |= <span class="number">0x01</span>; <span class="comment">//配置P6.1复用为ADC输入</span></span><br><span class="line">  	P1DIR |= <span class="number">0x01</span>; <span class="comment">//配置P1.0信号指示输出</span></span><br><span class="line"></span><br><span class="line">  	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  	&#123;</span><br><span class="line">    	ADC12CTL0 |= ADC12SC; <span class="comment">//开始依次采样</span></span><br><span class="line"></span><br><span class="line">    	__bis_SR_register(LPM0_bits + GIE); <span class="comment">//进入LPM0,开启全局中断</span></span><br><span class="line">    	__no_operation(); <span class="comment">//用于调试器打断点的空指令</span></span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADC中断服务函数 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector = ADC12_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">ADC12_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="keyword">switch</span>(__even_in_range(ADC12IV,<span class="number">34</span>))</span><br><span class="line">  	&#123;</span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">0</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  0:  No interrupt</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">2</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  2:  ADC溢出中断</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">4</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  4:  ADC超时中断</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">6</span>:                                  <span class="comment">// Vector  6:  ADC12IFG0</span></span><br><span class="line">		<span class="comment">/* 测量P1引脚 */</span></span><br><span class="line">    	<span class="keyword">if</span> (ADC12MEM0 &gt;= <span class="number">0x7ff</span>)               <span class="comment">// ADC12MEM = A0 &gt; 0.5AVcc?</span></span><br><span class="line">      		P1OUT |= BIT0;                    <span class="comment">// P1.0 = 1</span></span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">      		P1OUT &amp;= ~BIT0;                   <span class="comment">// P1.0 = 0</span></span><br><span class="line"></span><br><span class="line">    	__bic_SR_register_on_exit(LPM0_bits); <span class="comment">//退出LPM0模式</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">8</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  8:  ADC12IFG1</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">10</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 10:  ADC12IFG2</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">12</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 12:  ADC12IFG3</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">14</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 14:  ADC12IFG4</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">16</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 16:  ADC12IFG5</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">18</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 18:  ADC12IFG6</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">20</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 20:  ADC12IFG7</span></span><br><span class="line"> 	<span class="keyword">case</span> <span class="number">22</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 22:  ADC12IFG8</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">24</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 24:  ADC12IFG9</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">26</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 26:  ADC12IFG10</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">28</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 28:  ADC12IFG11</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">30</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 30:  ADC12IFG12</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">32</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 32:  ADC12IFG13</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">34</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 34:  ADC12IFG14</span></span><br><span class="line">  	<span class="keyword">default</span>: <span class="keyword">break</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>多通道重复转换示例如下（连续读取P6.0、P6.1、P6.2、P6.3的ADC值）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Num_of_Results 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> A0results[Num_of_Results];</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> A1results[Num_of_Results];</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> A2results[Num_of_Results];</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> A3results[Num_of_Results];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	WDTCTL = WDTPW+WDTHOLD;                   <span class="comment">//关闭WDG</span></span><br><span class="line">    </span><br><span class="line">  	P6SEL = <span class="number">0x0F</span>;                             <span class="comment">//使能ADC复用引脚（P6的低四位0、1、2、3进行复用）</span></span><br><span class="line">  	ADC12CTL0 = ADC12ON+ADC12MSC+ADC12SHT0_8; <span class="comment">//开启ADC、扩展采样时间避免结果溢出</span></span><br><span class="line">  	ADC12CTL1 = ADC12SHP+ADC12CONSEQ_3;       <span class="comment">//使用采样定时器，设置为多通道重复采样模式</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置0、1、2、3通道的参数 */</span></span><br><span class="line">  	ADC12MCTL0 = ADC12INCH_0;                 <span class="comment">// ref+=AVcc, channel = A0</span></span><br><span class="line">  	ADC12MCTL1 = ADC12INCH_1;                 <span class="comment">// ref+=AVcc, channel = A1</span></span><br><span class="line">  	ADC12MCTL2 = ADC12INCH_2;                 <span class="comment">// ref+=AVcc, channel = A2</span></span><br><span class="line">  	ADC12MCTL3 = ADC12INCH_3+ADC12EOS;        <span class="comment">// ref+=AVcc, channel = A3 ，设置ADC结束标志</span></span><br><span class="line">    </span><br><span class="line">  	ADC12IE = <span class="number">0x08</span>;                           <span class="comment">//使能ADC12IFG.3中断</span></span><br><span class="line">  	ADC12CTL0 |= ADC12ENC;                    <span class="comment">//使能转换通道</span></span><br><span class="line">  	ADC12CTL0 |= ADC12SC;                     <span class="comment">//开始转换-软件触发</span></span><br><span class="line">  </span><br><span class="line">  	__bis_SR_register(LPM0_bits + GIE);       <span class="comment">//进入LPM0并开启全局中断</span></span><br><span class="line">  	__no_operation();                         <span class="comment">//用于调试器打断点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=ADC12_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">ADC12ISR</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">switch</span>(__even_in_range(ADC12IV,<span class="number">34</span>))</span><br><span class="line">  	&#123;</span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">0</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  0:  No interrupt</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">2</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  2:  ADC overflow</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">4</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  4:  ADC timing overflow</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">6</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  6:  ADC12IFG0</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">8</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  8:  ADC12IFG1</span></span><br><span class="line"> 	<span class="keyword">case</span> <span class="number">10</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 10:  ADC12IFG2</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">12</span>:                                  <span class="comment">// Vector 12:  ADC12IFG3</span></span><br><span class="line">    	A0results[index] = ADC12MEM0;         <span class="comment">// Move A0 results, IFG is cleared</span></span><br><span class="line">    	A1results[index] = ADC12MEM1;         <span class="comment">// Move A1 results, IFG is cleared</span></span><br><span class="line">    	A2results[index] = ADC12MEM2;         <span class="comment">// Move A2 results, IFG is cleared</span></span><br><span class="line">    	A3results[index] = ADC12MEM3;         <span class="comment">// Move A3 results, IFG is cleared</span></span><br><span class="line">    	index++;                              <span class="comment">// 保存到结果缓存区</span></span><br><span class="line">    </span><br><span class="line">    	<span class="keyword">if</span> (index == <span class="number">8</span>)</span><br><span class="line">    	&#123;</span><br><span class="line">      		(index = <span class="number">0</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">  	<span class="keyword">case</span> <span class="number">14</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 14:  ADC12IFG4</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">16</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 16:  ADC12IFG5</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">18</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 18:  ADC12IFG6</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">20</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 20:  ADC12IFG7</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">22</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 22:  ADC12IFG8</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">24</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 24:  ADC12IFG9</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">26</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 26:  ADC12IFG10</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">28</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 28:  ADC12IFG11</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">30</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 30:  ADC12IFG12</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">32</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 32:  ADC12IFG13</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">34</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 34:  ADC12IFG14</span></span><br><span class="line">  	<span class="keyword">default</span>: <span class="keyword">break</span>; </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DAC"><a href="#DAC" class="headerlink" title="DAC"></a>DAC</h4><p>msp430f5529配备了DAC12_A模块，模块组成结构如下：</p>
<ul>
<li><p>核心</p>
<p>可以通过修改DAC12RES的值将DAC12_A配置为8位或12位模式；配置DAC12IR和DAC12OG位可以将满标度输出配置为所选参考电压的1倍、2倍或3倍；配置DAC12DF位选择输入的数据格式是原码还是补码。</p>
</li>
<li><p>端口</p>
<p>大多数DAC复用的端口都有其他复用功能，但是当DAC12AMPx&gt;0时，DAC12_A会忽略PxSEL.y和PxSEL.x的值，自动配置端口为DAC12_A输出复用功能</p>
<p>每个DAC通道都能输出到两个不同的端口，通过DAC122OPS选择，详细参数需要查阅datasheet</p>
</li>
<li><p>参考电压</p>
<p>使用DAC12SREFx选择DAC12_A参考电压，该值从AVCC、外部电压输入、内部1.16V参考电压、内部REF模块提供1.5V、2V、2.5V参考电压之一选择</p>
</li>
<li><p>参考输入和电压输出缓冲区</p>
<p>参考输入和电压输出缓冲区通过寄存器配置来平衡建立时间和功耗，通过配置DAC12AMPx来选择组合，其值越小、建立时间越长、缓冲区上的电流消耗越小</p>
</li>
<li><p>数据格式</p>
<p>使用原码或补码形式都可以设置DAC，使用DAC12_xDAT（取值范围0800h（输出0V）-07ffh（输出标度），另外取值0000h时输出标度的一半）控制</p>
</li>
</ul>
<p>相关示例程序如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 输出固定电压 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW+WDTHOLD; <span class="comment">//关闭WDG</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置无增益，参考电压AVCC，启动DAC校准</span></span><br><span class="line">    DAC12_0CTL0 = DAC12IR + DAC12SREF_1 + DAC12AMP_5 + DAC12CALON;</span><br><span class="line">	DAC12_0CTL0 |= DAC12ENC; <span class="comment">//使能DAC12_A</span></span><br><span class="line">    <span class="comment">//需要注意这里的输出值是12位</span></span><br><span class="line">    DAC12_0DAT = <span class="number">0x000</span>; <span class="comment">//DAC输出0V</span></span><br><span class="line">    <span class="comment">//和上面一样的流程</span></span><br><span class="line">    DAC12_1CTL0 = DAC12IR + DAC12SREF_1 + DAC12AMP_5 + DAC12CALON;</span><br><span class="line">    DAC12_0CTL0 |= DAC12ENC; <span class="comment">//使能DAC12_A</span></span><br><span class="line">    DAC12_0DAT = <span class="number">0x700</span>; <span class="comment">//输出1.4V</span></span><br><span class="line">    __bis_SR_register(LPM4_bits); <span class="comment">//进入LPM4，DAC会自动输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出波形 */</span></span><br><span class="line"><span class="comment">//以FLASH换内存</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> Sin_tab[<span class="number">100</span>] = &#123; </span><br><span class="line"><span class="number">1638</span>,<span class="number">1740</span>,<span class="number">1843</span>,<span class="number">1944</span>,<span class="number">2045</span>,<span class="number">2143</span>,<span class="number">2240</span>,<span class="number">2335</span>,<span class="number">2426</span>,<span class="number">2515</span>,</span><br><span class="line"><span class="number">2600</span>,<span class="number">2681</span>,<span class="number">2758</span>,<span class="number">2831</span>, <span class="number">2899</span>,<span class="number">2962</span>,<span class="number">3020</span>,<span class="number">3072</span>,<span class="number">3119</span>,<span class="number">3160</span>,</span><br><span class="line"><span class="number">3195</span>,<span class="number">3224</span>,<span class="number">3246</span>,<span class="number">3262</span>,<span class="number">3272</span>,<span class="number">3272</span>,<span class="number">3263</span>,<span class="number">3247</span>,<span class="number">3224</span>,<span class="number">3196</span>,</span><br><span class="line"><span class="number">3161</span>,<span class="number">3120</span>,<span class="number">3074</span>,<span class="number">3021</span>,<span class="number">2964</span>,<span class="number">2901</span>,<span class="number">2833</span>,<span class="number">2760</span>,<span class="number">2683</span>,<span class="number">2602</span>,</span><br><span class="line"><span class="number">2517</span>,<span class="number">2429</span>,<span class="number">2337</span>,<span class="number">2243</span>,<span class="number">2146</span>,<span class="number">2047</span>,<span class="number">1947</span>,<span class="number">1845</span>,<span class="number">1743</span>,<span class="number">1640</span>,</span><br><span class="line"><span class="number">1537</span>,<span class="number">1435</span>,<span class="number">1333</span>,<span class="number">1233</span>,<span class="number">1134</span>,<span class="number">1037</span>,<span class="number">943</span>,<span class="number">851</span>,<span class="number">762</span>,<span class="number">677</span>,<span class="number">596</span>,</span><br><span class="line"><span class="number">519</span>,<span class="number">446</span>,<span class="number">378</span>,<span class="number">314</span>,<span class="number">256</span>,<span class="number">204</span>,<span class="number">157</span>,<span class="number">116</span>,<span class="number">81</span>,<span class="number">52</span>,<span class="number">29</span>,<span class="number">13</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>,</span><br><span class="line"><span class="number">12</span>,<span class="number">28</span>,<span class="number">50</span>,<span class="number">78</span>,<span class="number">113</span>,<span class="number">154</span>,<span class="number">200</span>,<span class="number">252</span>,<span class="number">310</span>,<span class="number">373</span>,<span class="number">440</span>,<span class="number">513</span>,<span class="number">590</span>,</span><br><span class="line"><span class="number">671</span>,<span class="number">756</span>,<span class="number">756</span>,<span class="number">844</span>,<span class="number">936</span>,<span class="number">1030</span>,<span class="number">1127</span>,<span class="number">1225</span>,<span class="number">1326</span>,<span class="number">1427</span>,<span class="number">1529</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW + WDTHOLD; <span class="comment">//停看门狗</span></span><br><span class="line"> 	INIT_XT2(); <span class="comment">//开启时钟   </span></span><br><span class="line"></span><br><span class="line"> 	P5SEL = <span class="number">0XFF</span>;</span><br><span class="line"> 	ADC12CTL0 = REFON; <span class="comment">//参考电压为内部2.5v  </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置DMA，直接将Sin_tab数据传输到DAC */</span></span><br><span class="line"> 	DMA0SA = (<span class="keyword">int</span>) Sin_tab; <span class="comment">//源地址寄存器</span></span><br><span class="line"> 	DMA0DA = DAC12_0DAT_; <span class="comment">//目的地址寄存器</span></span><br><span class="line">	DMA0SZ = <span class="number">100</span>; <span class="comment">//传输基本单元的个数</span></span><br><span class="line"> 	DMACTL0 = DMA0TSEL_5; <span class="comment">// DAC12_0CTL的DAC12IFG标志</span></span><br><span class="line"> 	DMA0CTL = DMADT_4 + DMASRCINCR_3 + DMAEN; <span class="comment">//DMADT_4：重复的块传输方式</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使用内部1.5V参考电压，无增益，使能DAC12_A校准并使能DAC12_A */</span></span><br><span class="line">	DAC12_0CTL = DAC12LSEL_2 + DAC12IR + DAC12AMP_5 + DAC12IFG + DAC12ENC; <span class="comment">//配置DAC</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 强制输出第一个中断 */</span></span><br><span class="line"> 	CCTL1 = OUTMOD_3; <span class="comment">//设置并复位</span></span><br><span class="line">	CCR1 = <span class="number">1</span>; <span class="comment">// PWM Duty Cycle   </span></span><br><span class="line">	CCR0 = <span class="number">8</span><span class="number">-1</span>; <span class="comment">//1kHz频率</span></span><br><span class="line">	TACTL = TASSEL_2 + MC_1; <span class="comment">//使用SMCLK时钟源,向上计数模式  </span></span><br><span class="line">	__bis_SR_register(LPM0_bits); <span class="comment">//进入LPM0，DMA和DAC都在工作，会自动输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可编程比较器"><a href="#可编程比较器" class="headerlink" title="可编程比较器"></a>可编程比较器</h4><p>f5529配备了Comp_B模块，支持精密线性数模转换、电源电压监控、外部模拟信号电压监测功能</p>
<p>其中核心是一个精密电压比较器，同相端比反相端电压高，则输出高电平，否则输出低电平，使用CBON位打开/关闭比较器</p>
<p>使用CBCTL0寄存器控制外部输入端口，CBIPEN和CBIMEN分别控制同相端和反相端；使用CBIMSEL和CBIPSEL控制端子连接的GPIO，应选择P6的端口，以这两个寄存器控制端口号</p>
<p>可以使用CBSHORT短路正反相输入，可用来建立简单的采样-保持机制，一般来说设置采样时间为3-10τ，3τ可以将采样电容充电到95%的输入信号电压值，5τ可以将采样电容充电到99%，10τ可以满足12位的精度</p>
<p>使用CBF控制位控制输出信号的输出滤波器</p>
<p>使用参考电压生成器来生成VREF，可以应用于比较器输入端，使用CBREF0x和CBREF1xl来控制</p>
<p>使用CBPWRMD来选择比较器功耗模式，默认为00——最大功耗、最快速度；可以调节到11来使用最低功耗、最低速度</p>
<p>使用CBCTL3来控制比较器的端口是否禁用；使用CBIPSEL或CBIMSEL来控制对应端口的输入缓冲区</p>
<p><strong>比较器也可以开启中断</strong></p>
<p>对于可编程电压比较器而言，一般使用滞后比较来让参考电压根据输出值变化，可以让比较器输出更加稳定，降低噪声</p>
<p>代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW + WDTHOLD; <span class="comment">//停看门狗</span></span><br><span class="line">    P1DIR |= BIT6; <span class="comment">//P1.6作输出</span></span><br><span class="line">    P1SEL |= BIT6; <span class="comment">//复用为比较器输出CBOUT</span></span><br><span class="line">    </span><br><span class="line">    P7DIR |= <span class="number">0xFF</span>; <span class="comment">//P7设置为输出，用来驱动LED显示当前比较器结果</span></span><br><span class="line">    </span><br><span class="line">    CBCTL0 |= CBIPEN + CBIPSEL_0; <span class="comment">//比较器施恩那个，设置输入通道CB0为P6.0</span></span><br><span class="line">    CBCTL1 |= CBPWRMD_0; <span class="comment">//设置为高速模数</span></span><br><span class="line">    CBCTL2 |= CBRSEL; <span class="comment">//使用VREF作为反相端的参考电压</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置高低两个阈值电压 */</span></span><br><span class="line">    CBCTL2 |= CBRS_1 + CBREF13; <span class="comment">//以VCC为参考电压，CBREF1=8，VREF=VCC/4</span></span><br><span class="line">    CBCTL2 |= CBREF04 + CBREF03; <span class="comment">//VREF0=VCC * 3/4</span></span><br><span class="line">    </span><br><span class="line">    CBCTL3 |= BIT0; <span class="comment">//打开Comp_B</span></span><br><span class="line">    CBCTL1 |= CBON; <span class="comment">//使能比较器</span></span><br><span class="line">    __delay_cycles(<span class="number">75</span>); <span class="comment">//等待比较器内部参考电压达到稳定</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(CBCTL1 &amp; CBOUT) <span class="comment">//如果CBOUT为高电平</span></span><br><span class="line">        &#123;</span><br><span class="line">            P7OUT = <span class="number">0x00</span>; <span class="comment">//LED点亮</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            P7OUT = <span class="number">0xFF</span>; <span class="comment">//LED熄灭</span></span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码在输入电压大于VREF0=3/4 VCC时CBOUT输出高电平，LED点亮；输入电压小于VREF0=1/4 VCC时CBOUT输出低电平，LED熄灭；当电压在二者之间时，CBOUT状态不变，起到了稳定输出的作用</p>
<p>同样的比较器也可以产生中断信号，在检测到设定的跳变沿（上升沿或下降沿）后触发中断，进入对应的中断服务函数，可以在其中判断比较器输出的电平，避免了轮询</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CBCTL1 |= CBPWRMD_1 + CBF + CBFDLY_3; <span class="comment">//普通模式，选择中断边压，使用输出滤波</span></span><br><span class="line"><span class="comment">/* 在中间设置其他比较器参数 */</span></span><br><span class="line"><span class="comment">/* 等待一定时间来让参考电压稳定 */</span></span><br><span class="line">CBINT &amp;= ~(CBIFG + CCBIIFG); <span class="comment">//清除错误中断标志</span></span><br><span class="line">CBINT |= CBIE + CBIIE; <span class="comment">//使能比较器输出中断和输出反相中断</span></span><br><span class="line">__bis_SR_register(LPM0_bits + GIE); <span class="comment">//开启全局中断</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=COMP_B_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">Comp_B_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(__even_in_range(CBIV, <span class="number">4</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//无中断</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//中断CBIFG</span></span><br><span class="line">            <span class="keyword">if</span>(CBCTL1 &amp; CBOUT) <span class="comment">//判断是否输出高电平</span></span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">//反相中断CBIIFG</span></span><br><span class="line">            <span class="keyword">if</span>(!(CBCTL1 &amp; CBOUT)) <span class="comment">//反相端需要相反的判断</span></span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里仅列出中断服务函数和其开启方式</p>
<h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><p>msp430的DMA最多有8个通道，但是msp430f5529只有3个通道</p>
<p>基本使用方法和stm32的DMA完全一样，四种模式、单传输、块传输、连续传输都和stm32的传输方法类似，但设置更为简单</p>
<p>一个使用DMA进行UART传输的例子如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> String1[] = &#123;<span class="string">&quot;Hello World\r\n&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW + WDTHOLD; <span class="comment">//停看门狗</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 端口配置 */</span></span><br><span class="line">    P4SEL = BIT4 + BIT5; <span class="comment">//配置P4.4、P4.5为Tx、Rx端口</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* 配置USCI_A1为UART模式 */</span></span><br><span class="line">    UCA1CTL1 = UCSSEL_1; <span class="comment">//使用ACLK为时钟源</span></span><br><span class="line">    <span class="comment">//控制分频器设置波特率为9600</span></span><br><span class="line">	UCA1BR0 = <span class="number">0x03</span>; <span class="comment">//分频器高八位</span></span><br><span class="line">    UCA1BR1 = <span class="number">0x0</span>; <span class="comment">//分频器低八位</span></span><br><span class="line">    UCA1MCTL = UCBRS_3 + UCBRF_0; <span class="comment">//调制器UCBRSx = 3</span></span><br><span class="line">    UCA1CTL1 &amp;= ~UCSWRST; <span class="comment">//启动设备</span></span><br><span class="line">    <span class="comment">/* 配置DMA */</span></span><br><span class="line">    DMACTL0 = DMA0TSEL_1; <span class="comment">//以定时器TA0CCR0 CCIFG为触发源</span></span><br><span class="line">    </span><br><span class="line">    __data16_write_addr((<span class="keyword">uint16_t</span>)&amp;DMA0SA, (<span class="keyword">uint32_t</span>)String1); <span class="comment">//源地址：String1字符串</span></span><br><span class="line">    __data16_write_addr((<span class="keyword">uint16_t</span>)&amp;DMA0DA), (<span class="keyword">uint32_t</span>)&amp;UCA1TXBUF); <span class="comment">//目标地址：UART发送缓存区域</span></span><br><span class="line">	</span><br><span class="line">	DMA0CTL = DMADT_4 + DMASRCINCR_3 + DMASBDB +DMAEN; <span class="comment">//重复单传输，递增模式，字节到字节，并使能DMA</span></span><br><span class="line">    <span class="comment">/* 配置定时器 */</span></span><br><span class="line">    TA0CCR0 = <span class="number">8192</span>; <span class="comment">//字符传输频率=32768/8192=4 字节/s</span></span><br><span class="line">	TA0CTL = TASSEL_1 + MC_1; <span class="comment">//使用ACLK作为时钟源，采用增模式</span></span><br><span class="line">    __bis_SR_register(LPM0_bits); <span class="comment">//进入LPM3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序会连续向外以9600波特率发送串口数据</p>
<h3 id="电源管理"><a href="#电源管理" class="headerlink" title="电源管理"></a>电源管理</h3><p>msp430f5529的电源管理模块PMM由监督器SVS和监视器SVM组成</p>
<p>SVS是强制要求的，用于保障设备稳定运行</p>
<p>SVM是宽松可编程的，用于进行一些低功耗控制和安全保障</p>
<p>可以通过对SVM编程提高VCORE来支持更高的MCLK，也就是所谓的<strong>超频</strong></p>
]]></content>
      <tags>
        <tag>电赛笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>现代C语言2</title>
    <url>/2021/11/14/%E7%8E%B0%E4%BB%A3C%E8%AF%AD%E8%A8%802/</url>
    <content><![CDATA[<h1 id="C语言语法拾遗"><a href="#C语言语法拾遗" class="headerlink" title="C语言语法拾遗"></a>C语言语法拾遗</h1><p>专门总结了一些C语言C99/C11之后的新语法或冷门语法</p>
<h2 id="预处理和宏——灵魂"><a href="#预处理和宏——灵魂" class="headerlink" title="预处理和宏——灵魂"></a>预处理和宏——灵魂</h2><p>预处理器和宏可以说是面向对象语言<em>独有</em>的东西，<strong>这些特性发生在编译这个过程之前</strong>，使得C语言的编译过程变得“可控”，甚至可以说C语言编译本身就是一个开发者可编程的过程——或许这样说比较抽象，举个例子：java的宏并不对一般开发者开放，一般只有OpenJDK的开发者才会面对java宏和相关预编译指令；但是C语言的宏直接出现在hello world程序中：“#include”指令本身就意味着对链接器进行调用——这些宏严格来说并不属于C语言的语法学习范畴，但是如果想靠C语言造轮子，这就是无法避开的</p>
<span id="more"></span>

<p>C预处理器就是C语言的灵魂，上能干涉程序实现，下能检查编译原理</p>
<h3 id="预处理指令的特殊用法"><a href="#预处理指令的特殊用法" class="headerlink" title="预处理指令的特殊用法"></a>预处理指令的特殊用法</h3><ol>
<li><h1 id><a href="#" class="headerlink" title></a></h1><p>预处理器对井号标记<code>#</code>有三种不同的用法：</p>
<p><em>标记一个指令</em></p>
<p>这是最常用的方法，#之前的空白会被忽略，因此各种头文件的格式总是防止重复包含-引用-宏定义-变量定义-函数定义</p>
<p><em>输入的字符串化</em></p>
<p><strong>使用#可以将一个变量转义为字符串，并且如果旁边有其它字符串相邻，会将他们合并在一起</strong></p>
<p>这就是很多c程序处理字符串IO的方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Pevel(cmd) printf(#cmd <span class="meta-string">&quot;:%g\n&quot;</span>,cmd);</span></span><br></pre></td></tr></table></figure>

<p>上面的代码会将输入的变量cmd转换成字符串，输出变量名并输出对应的值</p>
<p><em>把符号连接起来</em></p>
<p>使用两个##就可以将不是字符串的东西拼接在一起</p>
<p>比如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">name = LL;</span><br><span class="line">name##_list</span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line">LL_list</span><br></pre></td></tr></table></figure>

<p>往往使用这种编程方法实现C语言的键值对（字典）轮子</p>
</li>
<li><p>避免头文件包含</p>
<p>这个用法很重要，懂得都懂。不懂的话自己写两个一模一样的.h文件碰几次报错就懂了</p>
<p>使用方法有两种：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __THIS_DOCUMENT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __THIS_DOCUMENT</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这里是头文件内容 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br></pre></td></tr></table></figure>

<p>这行语句只要加在文件开头即可通知编译器不进行二次包含，它实际上依赖于编译器，但每个主流的编译器都支持该指令</p>
</li>
<li><p>static和extern保护</p>
<p>在.c库文件内的所有函数前使用static，并在.h文件中进行声明，可以对函数和变量进行一定的保护</p>
<p>在含有很多全局变量，会被多处包含的.h头文件中使用extern声明全局变量可以防止多次重复编译；但是要注意：只在其中一个包含了该头文件的.c文件中进行变量定义</p>
</li>
</ol>
<h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><p>使用typedef可以提高代码可读性、化简声明复杂度</p>
<p>还可以把一个结构体封装成一个“类”或封装出一个“方法”</p>
<p>这里要强调的是：<strong>typedef</strong>本身是一个C语言指令，<strong>并不是宏</strong>——它在编译阶段才会执行，并为某个数据类型声明一个别名，并且你也可以继续使用这个数据类型原来的名字。typedef并不会在编译阶段就得到执行，虽然现代的C编译器会对其做出优化，但是它的运行还可能会占据微不足道的一段程序运行时间——特别是在某些优化不好的冷门嵌入式设备编译器中，这也有可能导致一些莫名其妙的底层bug</p>
<h3 id="可变参数宏"><a href="#可变参数宏" class="headerlink" title="可变参数宏"></a>可变参数宏</h3><p>宏用于执行文本替换，但其思路和函数并不相同，并且它最大的特点就是：在预处理阶段完成替换，且遵循相对严格的替换原则</p>
<p>因此如果不仔细地写宏很容易造成错误！</p>
<p>宏一般能分成两类，一类是<strong>表达式展开宏</strong>：可以对这类宏进行求值，或宏干脆就是个数值，如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14159265</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T 2-1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> one_to_ten 1/10</span></span><br></pre></td></tr></table></figure>

<p>另一类是<strong>指令展开宏</strong>：一条甚至一系列指令，有可用的未知量，如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max m&gt;n?m:n</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> u(x) x&gt;0?x:0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> t=t+1</span></span><br></pre></td></tr></table></figure>

<p>为了编写鲁棒性更高（人话：更不容易出bug、易于移植）的宏，应遵循以下三条规则</p>
<ul>
<li><p><strong>多用括号</strong>：把所有容易出bug的东西都括起来，防止重复错误和过度替换错误</p>
</li>
<li><p><strong>代码块两端加入花括号</strong></p>
<p>示例如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> doubleincrement(a, b) \</span></span><br><span class="line"><span class="meta">		(a)++;				  \</span></span><br><span class="line"><span class="meta">		(b)++;</span></span><br><span class="line"><span class="comment">//上面这个例子容易出错，应该如下修改</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> doubleincrement(a, b) \</span></span><br><span class="line"><span class="meta">		&#123;(a)++;				  \</span></span><br><span class="line"><span class="meta">		(b)++;&#125;</span></span><br><span class="line"><span class="comment">//还有另外的方法，可以相当程度上保证代码块的安全</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> doubleincrement(a,b) do&#123;(a)++;(b)++;&#125;while(0)</span></span><br><span class="line"><span class="comment">//但是这种方法并不是万能的，要注意灵活变通！</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>避免重复作用</strong>：使用注释等方法提醒用户不要做出越界的使用方法以免过度替换，并使用较少数量的参数，尽量防止参数过多导致bug</p>
</li>
</ul>
<p>现代编译器中往往都会带有宏替换指示功能，Vim、Emacs甚至提供了一整套插件用于纠错，应该合理应用这些插件</p>
<p>这里要介绍的是一个特殊的宏：<strong>可变参数宏</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__VA_ARGS__</span><br></pre></td></tr></table></figure>

<p>它的展开是给定元素的集合</p>
<p>可以使用这个宏来实现<strong>宏输入任意多的参数</strong></p>
<p>著名的<code>printf</code>函数使用了可变参数表，但是可变参数表并不是万能的，它无法使用在宏中，因此一般使用可变参数宏来实现类似的功能</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> __retval;</span><br><span class="line">  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );</span><br><span class="line">  __retval = __mingw_vfprintf( <span class="built_in">stdout</span>, __format, __local_argv );</span><br><span class="line">  __builtin_va_end( __local_argv );</span><br><span class="line">  <span class="keyword">return</span> __retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(...) printf(__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line">DEBUG(<span class="string">&quot;%d&quot;</span>, a);</span><br><span class="line"><span class="comment">//展开成</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a);</span><br></pre></td></tr></table></figure>

<p>其中省略号表示可变的参数表，使用<code>__VA_ARGS__</code>就可以把参数传递给宏</p>
<p>特别地，C++并不支持这一手段</p>
<p>使用该手段可以构造出某些面向对象语言的遍历语句</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> foreach(__c_object, ...) \</span></span><br><span class="line"><span class="meta">for(char** __c_object = (char* []) &#123;__VA_ARGS__, NULL&#125;; *__c_object; __c_object++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用例</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span>** str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	foreach(i, <span class="string">&quot;test&quot;</span>, str, <span class="string">&quot;over&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该函数用于遍历并输出test、hello、over三个字符串，就像是python的for一样!</span></span><br></pre></td></tr></table></figure>

<h2 id="指针与数组——C语言的底层"><a href="#指针与数组——C语言的底层" class="headerlink" title="指针与数组——C语言的底层"></a>指针与数组——C语言的底层</h2><h3 id="内存与变量"><a href="#内存与变量" class="headerlink" title="内存与变量"></a>内存与变量</h3><p>C语言提供了三种内存分配方式：</p>
<ul>
<li><p><strong>自动</strong></p>
<p>一般的变量都是自动类型变量，显式或隐式使用auto标注地变量都使用自动内存分配</p>
<p>在变量作用域中分配得内存，离开作用域后变量对应的内存区域被删除</p>
</li>
<li><p><strong>静态</strong></p>
<p>文件作用域内或函数中使用static声明的变量使用静态分配方式</p>
<p>静态程序在整个生命周期内一直存在</p>
<p>特别地，如果忘记对一个静态变量进行初始化，它会默认初始化为0或NULL</p>
</li>
<li><p><strong>手动</strong></p>
<p>使用free或malloc等C库函数进行手动分配内存</p>
<p>如果手动分配内存出问题，很可能导致<strong>段错误</strong></p>
</li>
</ul>
<h3 id="C程序的底层结构"><a href="#C程序的底层结构" class="headerlink" title="C程序的底层结构"></a>C程序的底层结构</h3><p>C程序经过编译后会形成如下几个结构（注意这几个结构都是C生成目标文件的一部分）进行保存：</p>
<ul>
<li><p>堆栈段</p>
<p>用于存储程序中的局部变量<strong>名</strong>，因此占据空间一般比较小（毕竟只是存名字）</p>
</li>
<li><p>BSS段</p>
<p>用于存储程序中的全局变量和静态变量，包括变量名和变量初值</p>
</li>
<li><p>代码段</p>
<p>用于存储程序中的指令，所有C语句都会被编译成汇编指令再进行汇编得到二进制格式的指令，用于驱动CPU运行（突然想到一个特殊的看待文件的视角：操作系统就是CPU的驱动程序，指令被封装在可执行文件里，操作系统负责驱动CPU执行这些文件描述的指令；对于裸机编程并不需要将指令封装成文件，而是根据CPU的架构分装指令和数据（哈佛架构）或将指令和数据送到CPU之内后再进行区分并执行（冯诺依曼架构），也就是说此时CPU并不需要一个特别的驱动程序）</p>
</li>
</ul>
<p>程序被加载进入内存后则会映射出一个类似的空间，任何函数都会在内存中占据空间中的一部分，称为函数帧，函数帧会独立使用上面的结构保存与这个函数有关的所有信息。</p>
<blockquote>
<p>比如下面这个程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> r=<span class="number">114</span>;</span><br><span class="line"><span class="keyword">int</span> q=<span class="number">514</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">double</span> b=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r;i++)</span><br><span class="line">    	&#123;</span><br><span class="line">        	foo();</span><br><span class="line">    	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> k=<span class="number">1919</span>;</span><br><span class="line">    	k++;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;hello!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会在运行时被分成两个函数帧——main和foo进行保存</p>
<p>其中变量q和r会被作为全局变量保存在BSS段，a、b会被保存在main函数对应的堆栈段，i会被保存在for循环专属的堆栈段或程序堆栈段（根据编译器实现而不同），k会被保存在foo函数对应的堆栈段，两个函数中涉及到的操作指令都会保存在代码段</p>
<p>从main跳转到foo的步骤如下：</p>
<ol>
<li>保护现场，将main函数中属于堆栈段的变量（当前保存在寄存器）都压入main函数栈</li>
<li>在执行for循环时根据条件/分支跳转指令确定跳转到foo，PS指向foo所在的代码段地址</li>
<li>将foo中的变量k的值从foo函数栈中弹出，并加载到寄存器</li>
<li>执行foo中的指令，执行完毕后执行保护现场操作</li>
<li>执行恢复现场，继续执行main函数中的指令</li>
</ol>
</blockquote>
<p>在操作系统进行函数跳转时一般会采用分支跳转指令。更底层的实现可以参考计算机组成原理相关教程</p>
<p><strong>堆栈</strong></p>
<p>要注意：堆栈并不是堆+栈，堆栈就是堆栈</p>
<p>堆栈是内存中一块专门的区域，特点是<em>先入后出</em></p>
<p>长度限制比一般内存小得多，专门用于保存自动变量，也用于临时保存寄存器中的值（保护现场）</p>
<p>堆栈段的内存分配一般由硬件/编译器/操作系统内存分配算法等底层处理系统实现</p>
<p><strong>堆</strong></p>
<p>通过手动方式分配的内存都会保存在堆空间，堆的实现根据操作系统或内存分配算法有所不同</p>
<p>堆是内存分配算法在内存中创建的内存池状数据结构</p>
<p>一般来说堆的大小就是可用内存的剩余大小</p>
<h3 id="C语言中的数据内存分配"><a href="#C语言中的数据内存分配" class="headerlink" title="C语言中的数据内存分配"></a>C语言中的数据内存分配</h3><p>C语言中的数据在进行内存分配时往往会遵循以下原则：</p>
<ul>
<li>在函数外部声明或在函数内部使用static关键字声明一个变量，这个变量就是静态变量</li>
<li>在函数内部使用auto或无额外的关键字声明一个变量，这个变量就是动态变量</li>
<li>声明指针也遵循以上两种原则</li>
</ul>
<p>在声明指针时虽然也遵守基本原则——指针会被保存为“指针变量”（一般的实现中，指针和long long或double具有相同的大小，8字节），但是它指向的东西可以是自动、静态、手动三种类型中的任意一种。这就是为什么需要使用malloc函数对指针指向的内容进行分配内存</p>
<p>这就要谈到指针和数组的不同：指针指向的是需要手工分配的内存区域；数组名则指向已经在数组初始化阶段完成自动分配的内存区域。初始化一个数组的实际过程如下：</p>
<ol>
<li>在栈上分配出一个空间，这个空间就等于数组的大小</li>
<li>将数组名初始化为指针</li>
<li>将该指针指向新分配的地址头部</li>
</ol>
<h3 id="状态机和静态变量"><a href="#状态机和静态变量" class="headerlink" title="状态机和静态变量"></a>状态机和静态变量</h3><p>看如下的经典的递归计算斐波那契数列函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//错误输入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> result = Fibonacci(n - <span class="number">2</span>) + Fibonacci(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它可以被用静态变量的方法替代</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> out = a1 + a2;</span><br><span class="line">    </span><br><span class="line">    a1 = a2;</span><br><span class="line">    a2 = out;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就将一个递归函数转化成了一个<strong>状态机</strong></p>
<p>在C语言中实现状态机的关键就在于静态变量，它可以让一个函数内部的参数保持存在，从而达到多次调用、多次计数的效果</p>
<p>甚至在多线程程序中也可以使用<code>_Thread_local</code>关键字来实现单线程的静态变量</p>
<h3 id="指针定向运算"><a href="#指针定向运算" class="headerlink" title="指针定向运算"></a>指针定向运算</h3><p>声明一个数组实际上就是将指针进行了重定向的运算</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> buf[<span class="number">4</span>];</span><br><span class="line">buf[<span class="number">0</span>]=<span class="number">3</span>;</span><br><span class="line">buf[<span class="number">2</span>]=<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以等价于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *buf = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">4</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">*(buf+<span class="number">0</span>)=<span class="number">3</span>;</span><br><span class="line">*(buf+<span class="number">2</span>)=<span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<p>因此可以使用类似的方法实现数据“重定向”</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bit[<span class="number">0</span>]=*(a);</span><br><span class="line">bit[<span class="number">2</span>]=*(a+<span class="number">2</span>);</span><br><span class="line">bit[<span class="number">3</span>]=<span class="number">0x08</span>;</span><br><span class="line">bit[<span class="number">4</span>]=*(b);</span><br><span class="line">bit[<span class="number">6</span>]=*(b+<span class="number">2</span>);</span><br><span class="line">bit[<span class="number">8</span>]=*(b+<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>使用该方式可以提高代码可读性</p>
<p>同时也可以使用这种方法提高算法效率</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* <span class="built_in">list</span>[] = &#123;</span><br><span class="line">    <span class="string">&quot;first&quot;</span>,</span><br><span class="line">    <span class="string">&quot;second&quot;</span>,</span><br><span class="line">    <span class="string">&quot;third&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">char</span>** p = <span class="built_in">list</span>; *p != <span class="literal">NULL</span>; p++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,p[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用上述方法可以对字符串数组进行快速解析</p>
<p>也可以化简多维数组，这个应该算是老生常谈——<strong>数组的数组就是指向指针的指针</strong></p>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p><strong>回调函数指被传递给另一个函数来进行内部使用的函数</strong></p>
<p>一般使用函数指针来实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">callback1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;callback 1\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">callback2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;callback 2\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">callback3</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;callback 3\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Handle</span><span class="params">(<span class="keyword">int</span> (*callback)())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ENTERING HANDLE FUNC\n&quot;</span>);</span><br><span class="line">	callback(); <span class="comment">//在函数内部执行另一个函数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;LEAVING HANDLE FUNC\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;MAINI\n&quot;</span>);</span><br><span class="line">	Handle(callback1); <span class="comment">//传递回调函数</span></span><br><span class="line">	Handle(callback2);</span><br><span class="line">	Handle(callback3);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;MAINL\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数名本身被视作一个指针，它指向函数程序的首地址，因此可以被当作一般的函数进行传递</p>
<p>下面就是指一个无输入，输出int的函数callback</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*callback)(<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure>

<p>对应的也可以创造出各种复杂的回调函数，回调函数本质上只会被输入和输出的数据类型所限定，其名字并没有决定性意义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct <span class="title">ReturnClass</span> <span class="params">(*MyLocalFunction)</span><span class="params">(struct PassClass, <span class="keyword">void</span>* parameter, <span class="keyword">uint8_t</span> nums)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">OS_ReturnState</span> <span class="params">(*TaskFunctionHandle)</span><span class="params">(<span class="keyword">void</span>* parameter)</span></span></span><br></pre></td></tr></table></figure>

<p>习惯上将回调函数的名字称为回调函数<strong>句柄</strong>（Handle）</p>
<h3 id="void指针"><a href="#void指针" class="headerlink" title="void指针"></a>void指针</h3><p>void指针可以指向任何东西，而使用void指针指向一个结构体可以让大型程序的编写中的传参和调用更加容易，这也是C面向对象的一个基础</p>
<p>下面的函数是FreeRTOS中的任务函数（线程）的原型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*TaskFunction_t)</span><span class="params">( <span class="keyword">void</span> * )</span></span>;</span><br></pre></td></tr></table></figure>

<p>它输入一个参数，并没有返回值。<em>其中的输入参数可以是任何数据类型</em>，这正是<code>void*</code>的妙用：将任意类型适配到当前函数或数据</p>
<p>使用void指针还可以写出完备的高可移植性数据结构，并且它也是实现C泛型的基础</p>
<h2 id="变量和数据类型——骨干"><a href="#变量和数据类型——骨干" class="headerlink" title="变量和数据类型——骨干"></a>变量和数据类型——骨干</h2><p>C变量与数据类型完全基于面向过程思想，也正因此C语言可以通过指针对内存进行操作，或是基于顺序存储的数组、结构体、指针等构建出顺序表、链表等数据结构，甚至构建出面向对象的“类”。因为C变量面向过程的性质，导致它们在使用中存在很多误区或不被注意的问题，这里简单梳理一下C变量的常见问题和基于基本数据类型实现的数据结构</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>类型转换常常会导致一些隐蔽的错误，尤其是在缺少编译器自动纠错辅助的情况下（某些逆大天的嵌入式编程IDE就是这样），下面列举一些常常会导致出错的问题和对应的解决方案</p>
<ol>
<li><p>两个整数相除总是返回整数</p>
<p>可以使用“加0”的方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span>/<span class="number">3</span> == <span class="number">2</span>;</span><br><span class="line"><span class="number">4</span>/(<span class="number">3</span>+<span class="number">0.0</span>) == <span class="number">1.3333</span>;</span><br><span class="line"><span class="number">4</span>/<span class="number">3.</span> == <span class="number">1.3333</span>;</span><br></pre></td></tr></table></figure>

<p>或直接显式进行类型转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span>/(<span class="keyword">double</span>)<span class="number">3</span> == <span class="number">1.3333</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>数组的索引必须是整数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>];</span><br><span class="line">a[<span class="number">3.3</span>]; <span class="comment">//错误</span></span><br><span class="line">a[(<span class="keyword">int</span>)<span class="number">3.3</span>] == a[<span class="number">3</span>]; <span class="comment">//避免错误</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="复合常量"><a href="#复合常量" class="headerlink" title="复合常量"></a>复合常量</h3><p>C99标准引入了符合常量</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> double_value = <span class="number">3.7</span>;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">double</span>[]) &#123;</span><br><span class="line">    <span class="number">20.38</span>,</span><br><span class="line">    double_value,</span><br><span class="line">	<span class="number">9.6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是一个典型例子，复合常量就是包含了同类型已赋值变量的常量，它会自动分配内存，<strong>常用来绕过临时变量</strong></p>
<h3 id="指定初始化器"><a href="#指定初始化器" class="headerlink" title="指定初始化器"></a>指定初始化器</h3><p>指定初始化器是C99引入的新特性，可以像以下方式初始化一个结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">gpio</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">uint8_t</span> direction;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">uint8_t</span> pin;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">uint8_t</span> special;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">uint8_t</span> value;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">uint8_t</span> speed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">gpio</span> <span class="title">GPIO_InitStruct</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GPIO_InitStruct MyGPIO;</span><br><span class="line">    MyGPIO = &#123;</span><br><span class="line">        .direction = OUTPUT;</span><br><span class="line">        .pin = <span class="number">5</span>;</span><br><span class="line">        .special = PullUp;</span><br><span class="line">        .value = GPIO_Pin_HIGH;</span><br><span class="line">        .speed = GPIO_Speed_100MHz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比于</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MyGPIO = &#123;OUTPUT, <span class="number">5</span>, PullUp, GPIO_Pin_HIGH, GPIO_Speed_100MHz&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">MyGPIO.direction = OUTPUT;</span><br><span class="line">......</span><br><span class="line">MyGPIO.speed = GPIO_Speed_100MHz;</span><br></pre></td></tr></table></figure>

<p>这种方法可以有效减少劳动量——因为大多数IDE都集成了这种初始化器的代码提示功能，可以只打出一个<code>.</code>，再从待选列表中选出要赋值的量</p>
<h3 id="C面向对象"><a href="#C面向对象" class="headerlink" title="C面向对象"></a>C面向对象</h3><p>在说明C面向对象编程方法之前需要强调几点：</p>
<ul>
<li>typedef是面向对象编程中用于减少代码书写量的重要工具</li>
<li>C使用结构体和回调函数来实现多种功能</li>
<li>不要害怕阅读很长的数据类型</li>
<li><strong>在使用面向对象编写C之前，应该想想你的需求能否用面向过程的方式解决，再想想使用面向对象后获得的开发思路、可移植性提升比起效率损失而言是否值得，如果感觉有些问题，尽早放弃使用面向对象编写C程序的想法</strong></li>
</ul>
<p>C语言的一般库格式如下：</p>
<ul>
<li>一组数据结构，用于代表库所针对领域的关键概念，并对库针对的问题进行代码结构上的描述</li>
<li>一组函数，用于处理数据结构</li>
</ul>
<p>这也就是经典的数据结构+算法</p>
<p>但是面向对象的语言则不这样处理，它们通常：</p>
<ul>
<li>定义一个或多个类，用于描述问题本身</li>
<li>定义这些类的方法，用于处理问题并建立问题之间的联系</li>
</ul>
<p>同时OOP语言（比如C++）还会进行以下扩展来方便用户进行各种处理：</p>
<ul>
<li>继承：用于扩展已有的类结构</li>
<li>虚函数：规定了一个类中所有对象都默认，但对不同对象的实例都有所限制的行为</li>
<li>私有和公有：用于划分类与方法要处理的范围</li>
<li>运算符重载：让一个运算符能够处理不同但有所类似的数据类型/对象</li>
<li>引用计数：用于自动化地分配和回收内存空间</li>
</ul>
<p>下面将从几个不同的方面阐述C语言实现面向对象编程机制的方法</p>
<h3 id="C实现的类"><a href="#C实现的类" class="headerlink" title="C实现的类"></a>C实现的类</h3><p>先从计算机的底层讲起吧——说起来，计算机的底层是哪里？汇编？CPU？逻辑门？晶体管？答案是数学！</p>
<p>图灵机和lambda代数是等价的两种描述计算机原理的模型</p>
<p>图灵机描述了一个可以在纸带上到处移动并修改其中值的读写头模型；lambda代数则描述了一个使用描述来处理参数列表的表达式</p>
<p>这两者分别就是面向过程和面向对象思想的数学原理</p>
<p>c语言使用下面的结构体来描述一个人的信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">bool</span> sex;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">double</span> height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并使用下面的函数来输出一个人的名字</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">output_name</span><span class="params">(struct person)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> person.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些信息被放在内存中，按顺序保存，当函数执行到的时候，CPU寻址到对应的位置，从对应的位置读取数据并输出</p>
<p>而面向对象语言中，使用类似字典（键值对）的方式保存人的数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">person = &#123;<span class="string">&quot;name&quot;</span>:<span class="number">10</span>, <span class="string">&quot;sex&quot;</span>:<span class="string">&quot;?&quot;</span>, <span class="string">&quot;age&quot;</span>:<span class="number">18</span>, <span class="string">&quot;height&quot;</span>:<span class="number">1.7</span>&#125;</span><br></pre></td></tr></table></figure>

<p>更进一步，将其封装成一个<strong>类</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;描述人属性的类&quot;&quot;&quot;</span></span><br><span class="line">    person_number = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, sex, age, height</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.sex = sex</span><br><span class="line">        self.age = age</span><br><span class="line">        self.height = height</span><br><span class="line">   	 	person_number += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">displayName</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self.name)</span><br></pre></td></tr></table></figure>

<p>调用时只需要按照<code>初始化一个对象-对象.方法</code>就可以对数据进行处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Person a_person</span><br><span class="line">a_person.displayName()</span><br></pre></td></tr></table></figure>

<p>C++、Java这些OOP语言都可以快速扩展现有类型，但是处理速度一般没有C快；同样Python更加直接的扩展命名列表思路只需要向其添加成员，就可以扩展当前数据类型，然而很难得到注册功能来检查代码正确性——有得必有失。然而在很多情况下需要我们实现既快速又便于扩展的代码，尤其是在嵌入式设备上，这时候就需要使用到<strong>C面向对象</strong>编程思想了</p>
<p>面向对象基于类；类是结构体的延伸；C面向对象基于结构体</p>
<p>最简单的，使用结构体就可以实现基于C的字典（基于键值对）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">key_value</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* key;</span><br><span class="line">    <span class="keyword">void</span>* value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">key_value</span> <span class="title">key_value</span>;</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">dictionary</span>&#123;</span></span><br><span class="line">    key_value **pairs;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">dictionary</span> <span class="title">dictionary</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> dictionary* Dictionary;</span><br></pre></td></tr></table></figure>

<p>然而附加问题出现了：</p>
<p>这个字典基于C指针实现；C指针需要使用malloc、free来管理内存；字典管理内存会具有很大不便</p>
<p>对于一般的应用实现来说，开发者手动分配内存并将其封装在大的函数里就足够了，但是总有一些特殊的时候（比如操作系统编写）用户会需要使用到大量的字典操作，因此就应该创造“虚函数”用来管理内存</p>
<p>为了安全起见，也应该设置找不到字典的标志来防止溢出/过放问题</p>
<p>最后应该实现添加和遍历字典的方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span>* dictionary_not_found;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 新建键值对 */</span></span><br><span class="line"><span class="function">key_value* <span class="title">new_key_val</span><span class="params">(<span class="keyword">char</span>* key, <span class="keyword">void</span>* value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    key_value* out = (key_value*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(key_value));</span><br><span class="line">    *out = (key_val)&#123;.key = key, .value = value&#125;;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 复制键值对 */</span></span><br><span class="line"><span class="function">key_value* <span class="title">copy_key_val</span><span class="params">(key_value <span class="keyword">const</span>* in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    key_value* out = (key_value*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(key_value));</span><br><span class="line">    *out = *in;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除键值对 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_key_val</span><span class="params">(key_value* in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(in);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断当前键值对的键值是否和给出的键值对应 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match_key_val</span><span class="params">(key_value <span class="keyword">const</span>* in, <span class="keyword">char</span> <span class="keyword">const</span>* key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !(strcasecmp(in-&gt;key, key));    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 为字典添加键值对 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Dictionary_add_key_val</span><span class="params">(Dictionary in,<span class="keyword">char</span>* key, <span class="keyword">void</span>* value key_value kv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    in-&gt;length ++;</span><br><span class="line">    in-&gt;pairs = (key_value *)<span class="built_in">realloc</span>(in-&gt;pairs, <span class="keyword">sizeof</span>(key_value*) * (in-&gt;length));</span><br><span class="line">    in-&gt;pairs[(in-&gt;length) - <span class="number">1</span>] = kv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 新建字典 */</span></span><br><span class="line"><span class="function">Dictionary <span class="title">newDictionary</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> dnf;</span><br><span class="line">    <span class="keyword">if</span>(!dictionary_not_found)</span><br><span class="line">        dictionary_not_found = &amp;dnf; <span class="comment">//处理找不到字典的情况</span></span><br><span class="line">    Dictionary out = (Dictionary)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(dictionary));</span><br><span class="line">    *out = (dictionary)&#123; &#125;;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteDictionary</span><span class="params">(Dictionary in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        deleteDictionary(in-&gt;pairs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(in);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加新键值对到字典 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addDictionary</span><span class="params">(Dictionary in,<span class="keyword">char</span>* key, <span class="keyword">void</span>* value key_value kv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;NULL is no a valid key.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Dictionary_add_key_value(in, new_key_val(key,value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在字典中找到某个键值对，根据健输出对应值 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">findDictionary</span><span class="params">(<span class="keyword">const</span> Dictionary in, <span class="keyword">char</span> <span class="keyword">const</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">if</span>(match_key_val(in-&gt;pairs[i], key))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> in-&gt;pairs[i]-&gt;value; <span class="comment">//遍历字典并找到键值对的值输出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dictionary_not_found; <span class="comment">//未找到字典</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 复制字典 */</span></span><br><span class="line"><span class="function">Dictionary <span class="title">copyDictionary</span><span class="params">(Dictionary in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Dictionary out = newDictionary();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; in-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Dictionary_add_key_val(out, copy_key_val(in-&gt;pais[i]));</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似这样就可以编写一个C实现的“宏”及其实现操作的“方法”了。</p>
<p>但是这种实现方式仅仅是对C结构体的进一步封装，就连C Primer Plus都把这种操作摆在书里（就在最后一章）</p>
<p>最关键的，如何实现继承？</p>
<p>老版本的C使用非常复杂的结构传递机制实现，而C11给出了更简单的答案：<strong>匿名结构体成员</strong></p>
<p>C11允许在结构中包含匿名的成员，gcc和clang通过*-fms-extensions<em>的命令行选项来使用<strong>强模式</strong>：新结构声明中的某处包含另一个结构；如果不使用这个选项，编译器会自动使用<strong>弱模式</strong>，它不允许开发者使用匿名的结构标识符来引用之前定义过的结构，二是要求结构必须在本地定义。这段话很明显不是地球人能说的，所以*<em>直接看例子</em></em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 强模式 */</span></span><br><span class="line"><span class="comment">//可以无缝地实现继承</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">Point</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">three_point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Point; <span class="comment">//匿名的结构体</span></span><br><span class="line">    <span class="keyword">double</span> z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">three_point</span> <span class="title">ThreePoint</span>;</span></span><br><span class="line"><span class="comment">//以上程序将二维的点扩展为三维点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用时和一般的结构体一致</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo_1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreePoint p =&#123;</span><br><span class="line">        .x = <span class="number">1</span>;</span><br><span class="line">        .y = <span class="number">2</span>;</span><br><span class="line">        .z = <span class="number">3</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (p.x)*(p.y)*(p.z));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 弱模式 */</span></span><br><span class="line"><span class="comment">//要求结构在本地定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">double</span> x;</span><br><span class="line">            <span class="keyword">double</span> y;</span><br><span class="line">        &#125;; <span class="comment">//在本地定义的匿名结构体</span></span><br><span class="line">        Point p2; <span class="comment">//上面的匿名结构体就记作p2</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">double</span> z;</span><br><span class="line">&#125; ThreePoint;</span><br></pre></td></tr></table></figure>

<p>弱模式的处理方式不太好易用，所以一般都会使用强模式实现继承</p>
<p>但是一般在处理老旧代码的时候需要整体搬运结构体，这种情况下为了避免“牵一发而动全身”的情况，应保证使用弱模式——因为<strong>远古编译器并不支持强模式</strong></p>
<p>对于一个典型的C<strong>对象句柄</strong>，更适合使用指针而不是基本的结构体。</p>
<p>使用指针能带来以下好处：</p>
<ul>
<li>指针本身的内存空间会被自动管理，它指向的对象可以使用统一的malloc函数来动态管理内存或使用静态数据变量在程序执行之初进行内存初始化</li>
<li>使用<code>=</code>即可完成指针指向对象的复制</li>
<li>操作指针比直接操作完整的结构体更节省时间</li>
<li>表、栈、FIFO、树、图等数据结构都可以通过指针快速构建和管理</li>
<li>永远使用结构指针就不会对使用结构参数-指针参数二者之间造成困扰</li>
<li>使用专用的free函数和malloc函数操作指针可以更安全地处理对象内存</li>
</ul>
<p>对于越庞大的系统，越适合使用指针实现，特别是编译器、操作系统等不得不用C语言完成的东西</p>
<h3 id="C实现的方法"><a href="#C实现的方法" class="headerlink" title="C实现的方法"></a>C实现的方法</h3><p>C面向对象中，使用<strong>回调函数</strong>实现<strong>方法</strong>，回调函数则基于<strong>函数指针</strong></p>
<p>下面是一个包含了方法的C类</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">myclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> name;</span><br><span class="line">    <span class="keyword">double</span> num;</span><br><span class="line">    <span class="keyword">double</span> (*calculateMyClass) (<span class="keyword">int</span> <span class="keyword">const</span> *in);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> _myclass MyClass;</span><br></pre></td></tr></table></figure>

<p>需要注意：在本博文的代码中采用类Qt的方法命名法（或者说比较通用的C++方法命名法），即<code>小写动词+驼峰类名</code>的形式</p>
<p>这种方法的特色就是“简明易懂”，便于写出自解释的代码；不过相较于<code>类名+动词</code>的命名法，它更难以进行检索，哪种方法好就见仁见智吧</p>
<p><code>calculateMyClass</code>就是一个典型的函数指针，初始化时可以通过以下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> <span class="keyword">const</span> *in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4.7</span> * in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass a;</span><br><span class="line"></span><br><span class="line">a.name = <span class="number">3</span>;</span><br><span class="line">a.num = <span class="number">5.5</span>;</span><br><span class="line">a.calculateMyClass = cal;</span><br></pre></td></tr></table></figure>

<p>下面的代码演示了之前所说键值对类对应的方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">key_value</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* key;</span><br><span class="line">    <span class="keyword">void</span>* value; <span class="comment">//这两个都是原有的私有变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//新增的方法</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">key_value</span> * (*<span class="title">copy_key_val</span>) (<span class="title">key_value</span> <span class="title">const</span>* <span class="title">in</span>);</span></span><br><span class="line">    <span class="keyword">void</span> (*free_key_val) (key_value* in);</span><br><span class="line">    <span class="keyword">int</span> (*match_key_val) (key_value <span class="keyword">const</span>* in, <span class="keyword">char</span> <span class="keyword">const</span>* key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">key_value</span> <span class="title">key_value</span>;</span></span><br><span class="line"><span class="function">key_value* <span class="title">new_key_val</span><span class="params">(<span class="keyword">char</span>* key, <span class="keyword">void</span>* value)</span></span>;</span><br></pre></td></tr></table></figure>

<p>能够注意到：new_key_val并没有作为一个方法实现，因为它用于创建一个键值对对象，需要被用户直接调用，这就涉及到了私有变量和公有变量——这些按下不表，急不可耐的读者可以直接跳到下一节</p>
<p>众所周知，C++有个this，Python有个self，这两个变量都可以很方便地定义出函数的默认值；然而C并不提供这些，如果你见到了C22或者C114514里提供了这些东西，请大声呵斥（笑）</p>
<p>不过C提供了更加高级的实现——预编译器</p>
<p>使用预编译器可以像以下代码一样写出代替this的功能</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Typelist_print(in) (in).estimate(&amp;in)</span></span><br></pre></td></tr></table></figure>

<p>这段代码实现了打印一个默认值（in本身）的效果</p>
<h3 id="private和public"><a href="#private和public" class="headerlink" title="private和public"></a>private和public</h3><p>从作用域说起，C语言中只有三条关于变量作用域的准则：</p>
<ul>
<li><p>变量在未被声明前不在作用域内</p>
</li>
<li><p>如果变量在一对花括号内定义，那么结束花括号（<code>&#125;</code>之后），变量就会处于作用域之外</p>
<p>有一个特例：for循环和函数可以有变量定义在开始的花括号前的一对括弧内——在一对括弧内定义的变量，其作用域等同于在花括号内定义</p>
</li>
<li><p>如果一个变量不在任何花括号内，它的作用域就会从它的声明持续到文件结尾</p>
</li>
</ul>
<p>确实，C语言的作用域限制少得可怜——友元、类作用域、原型作用域、动态作用域、扩展作用域、命名空间……全都没有；或许可以强行称使用malloc的作用域为动态作用域</p>
<p>特别需要说明一下#include包含文件的变量作用域——它们也遵循以上三条规则，<strong>在包含头文件时，就相当于将整个头文件复制粘贴到了 源文件里</strong></p>
<p>在OOP中，<strong>私有数据</strong>表示不应被外界直接调用的数据，函数可以通过直接在.c文件内声明、定义，而不是挂在头文件中实现私有——上面所说的<strong>私有方法</strong>也类似，直接把函数指针封在结构体中就可以实现私有方法；如果想要更严格的限制，还可以在函数前使用static关键字；全局变量同理。不过有得必有失，<strong>局部变量</strong>想要实现<strong>私有</strong>的话，就只能在命名上加上<code>_private</code>后缀并祈求你的用户不会瞎用这个变量吧</p>
<h3 id="有限的运算符重载"><a href="#有限的运算符重载" class="headerlink" title="有限的运算符重载"></a>有限的运算符重载</h3><p>虽然说很难用，但C11标准确实提供了一套使用<strong>宏</strong>来处理运算符重载的机制</p>
<p>个人不是很推荐对C语言进行这样的修改——很明显，这完全不是C所擅长的领域！到目前为止也很少有代码使用C11的**_Generic**，就连Linux内核中也没有出现多少这样的语句</p>
<p>这个预编译语句用法比较复杂，但是GLibC中的很多运算符（复数乘法、矩阵乘法）都通过这个语句进行重载，详细内容可以查看官方文档和库的使用说明，这里处于<em>个人能力所限</em>和篇幅所限不再介绍</p>
<h3 id="C面向对象举例"><a href="#C面向对象举例" class="headerlink" title="C面向对象举例"></a>C面向对象举例</h3><p>这里引用RT-Thread实时操作系统的源码作为例子，这是一个使用了典型的C面向对象编写的大型程序</p>
<p>下面摘录的是其内核实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 内核对象接口</span></span><br><span class="line"><span class="comment"> * 这部分方法用于处理内核对象</span></span><br><span class="line"><span class="comment"> * 所谓内核对象就是RT-Thread抽象出的内核组成部分</span></span><br><span class="line"><span class="comment"> * 包括但不限于 线程（进程）结构、信号量、互斥量、消息队列、驱动设备等</span></span><br><span class="line"><span class="comment"> * 这些对象都为上层应用程序提供服务，并且它们都是从内核对象类衍生而来</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_system_object_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function">struct rt_object_information *</span></span><br><span class="line"><span class="function"><span class="title">rt_object_get_information</span><span class="params">(<span class="keyword">enum</span> rt_object_class_type type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_object_init</span><span class="params">(struct rt_object         *object,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">enum</span> rt_object_class_type type,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">const</span> <span class="keyword">char</span>               *name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_object_detach</span><span class="params">(<span class="keyword">rt_object_t</span> object)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">rt_object_t</span> <span class="title">rt_object_allocate</span><span class="params">(<span class="keyword">enum</span> rt_object_class_type type,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">const</span> <span class="keyword">char</span>               *name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_object_delete</span><span class="params">(<span class="keyword">rt_object_t</span> object)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">rt_bool_t</span> <span class="title">rt_object_is_systemobject</span><span class="params">(<span class="keyword">rt_object_t</span> object)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">rt_uint8_t</span> <span class="title">rt_object_get_type</span><span class="params">(<span class="keyword">rt_object_t</span> object)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">rt_object_t</span> <span class="title">rt_object_find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">rt_uint8_t</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相关的方法内容出于篇幅不再列出，如有兴趣可以自行翻阅官方文档</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内核对象结构体</span></span><br><span class="line"><span class="comment"> * 它继承自一个称为内核对象链表的类，内核对象使用这个链表来进行连接</span></span><br><span class="line"><span class="comment"> * 这样遍历内核对象并进行操作就等价于对链表进行遍历</span></span><br><span class="line"><span class="comment"> * 实际上RT-Thread使用的是一种效率更高的跳表，它可以在多个链表（数量可编程）之间跳转</span></span><br><span class="line"><span class="comment"> * 这样做大大提高了操作系统的效率</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>       name[RT_NAME_MAX];                       <span class="comment">/**&lt; name of kernel object */</span></span><br><span class="line">    <span class="keyword">rt_uint8_t</span> type;                                    <span class="comment">/**&lt; type of kernel object */</span></span><br><span class="line">    <span class="keyword">rt_uint8_t</span> flag;                                    <span class="comment">/**&lt; flag of kernel object */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MODULE</span></span><br><span class="line">    <span class="keyword">void</span>      *module_id;                               <span class="comment">/**&lt; id of application module */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">rt_list_t</span>  <span class="built_in">list</span>;                                    <span class="comment">/**&lt; list node of kernel object */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内核对象类</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_object</span> *<span class="title">rt_object_t</span>;</span>                  <span class="comment">/**&lt; Type for kernel objects. */</span></span><br><span class="line"><span class="comment">//可以看到RT-Thread将内核对象结构体指针定义为了一个类，这样便于发挥指针的优势</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内核对象链表类</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双链表结构体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_list_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_list_node</span> *<span class="title">next</span>;</span>                          <span class="comment">/**&lt; point to next node. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_list_node</span> *<span class="title">prev</span>;</span>                          <span class="comment">/**&lt; point to prev node. */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_list_node</span> <span class="title">rt_list_t</span>;</span>                  <span class="comment">/**&lt; Type for lists. */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单链表结构体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_slist_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_slist_node</span> *<span class="title">next</span>;</span>                         <span class="comment">/**&lt; point to next node. */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_slist_node</span> <span class="title">rt_slist_t</span>;</span>                <span class="comment">/**&lt; Type for single list. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//RT-Thread使用枚举对内核对象类型进行标记，这是一种常用的做法，用来提高程序可读性</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">rt_object_class_type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    RT_Object_Class_Null   = <span class="number">0</span>,                         <span class="comment">/**&lt; The object is not used. */</span></span><br><span class="line">    RT_Object_Class_Thread,                             <span class="comment">/**&lt; The object is a thread. */</span></span><br><span class="line">    RT_Object_Class_Semaphore,                          <span class="comment">/**&lt; The object is a semaphore. */</span></span><br><span class="line">    RT_Object_Class_Mutex,                              <span class="comment">/**&lt; The object is a mutex. */</span></span><br><span class="line">    RT_Object_Class_Event,                              <span class="comment">/**&lt; The object is a event. */</span></span><br><span class="line">    RT_Object_Class_MailBox,                            <span class="comment">/**&lt; The object is a mail box. */</span></span><br><span class="line">    RT_Object_Class_MessageQueue,                       <span class="comment">/**&lt; The object is a message queue. */</span></span><br><span class="line">    RT_Object_Class_MemHeap,                            <span class="comment">/**&lt; The object is a memory heap */</span></span><br><span class="line">    RT_Object_Class_MemPool,                            <span class="comment">/**&lt; The object is a memory pool. */</span></span><br><span class="line">    RT_Object_Class_Device,                             <span class="comment">/**&lt; The object is a device */</span></span><br><span class="line">    RT_Object_Class_Timer,                              <span class="comment">/**&lt; The object is a timer. */</span></span><br><span class="line">    RT_Object_Class_Module,                             <span class="comment">/**&lt; The object is a module. */</span></span><br><span class="line">    RT_Object_Class_Unknown,                            <span class="comment">/**&lt; The object is unknown. */</span></span><br><span class="line">    RT_Object_Class_Static = <span class="number">0x80</span>                       <span class="comment">/**&lt; The object is a static object. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 软件定时器类</span></span><br><span class="line"><span class="comment"> * 从内核对象类中继承而来，用于处理线程调度中的时间片轮转</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_timer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_object</span> <span class="title">parent</span>;</span>                            <span class="comment">/**&lt; inherit from rt_object */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_list_t</span>        row[RT_TIMER_SKIP_LIST_LEVEL];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*timeout_func)(<span class="keyword">void</span> *parameter);              <span class="comment">/**&lt; timeout function */</span>  <span class="comment">//这是一个典型的方法</span></span><br><span class="line">    <span class="keyword">void</span>            *parameter;                         <span class="comment">/**&lt; timeout function&#x27;s parameter */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_tick_t</span>        init_tick;                         <span class="comment">/**&lt; timer timeout tick */</span></span><br><span class="line">    <span class="keyword">rt_tick_t</span>        timeout_tick;                      <span class="comment">/**&lt; timeout tick */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_timer</span> *<span class="title">rt_timer_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于处理内核对象初始化的方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param object the specified object to be initialized.</span></span><br><span class="line"><span class="comment"> * @param type the object type.</span></span><br><span class="line"><span class="comment"> * @param name the object name. In system, the object&#x27;s name must be unique.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_object_init</span><span class="params">(struct rt_object         *object,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">enum</span> rt_object_class_type type,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">const</span> <span class="keyword">char</span>               *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">rt_base_t</span> temp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_list_node</span> *<span class="title">node</span> =</span> RT_NULL;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_object_information</span> *<span class="title">information</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MODULE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_dlmodule</span> *<span class="title">module</span> =</span> dlmodule_self();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get object information */</span></span><br><span class="line">    information = rt_object_get_information(type);</span><br><span class="line">    RT_ASSERT(information != RT_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check object type to avoid re-initialization */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enter critical */</span></span><br><span class="line">    rt_enter_critical();</span><br><span class="line">    <span class="comment">/* try to find object */</span></span><br><span class="line">    <span class="keyword">for</span> (node  = information-&gt;object_list.next;</span><br><span class="line">            node != &amp;(information-&gt;object_list);</span><br><span class="line">            node  = node-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rt_object</span> *<span class="title">obj</span>;</span></span><br><span class="line"></span><br><span class="line">        obj = rt_list_entry(node, struct rt_object, <span class="built_in">list</span>);</span><br><span class="line">        <span class="keyword">if</span> (obj) <span class="comment">/* skip warning when disable debug */</span></span><br><span class="line">        &#123;</span><br><span class="line">            RT_ASSERT(obj != object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* leave critical */</span></span><br><span class="line">    rt_exit_critical();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize object&#x27;s parameters */</span></span><br><span class="line">    <span class="comment">/* set object type to static */</span></span><br><span class="line">    object-&gt;type = type | RT_Object_Class_Static;</span><br><span class="line">    <span class="comment">/* copy name */</span></span><br><span class="line">    rt_strncpy(object-&gt;name, name, RT_NAME_MAX);</span><br><span class="line"></span><br><span class="line">    RT_OBJECT_HOOK_CALL(rt_object_attach_hook, (object));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* lock interrupt */</span></span><br><span class="line">    temp = rt_hw_interrupt_disable();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RT_USING_MODULE</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">module</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rt_list_insert_after(&amp;(<span class="keyword">module</span>-&gt;object_list), &amp;(object-&gt;<span class="built_in">list</span>));</span><br><span class="line">        object-&gt;module_id = (<span class="keyword">void</span> *)<span class="keyword">module</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* insert object into information object list */</span></span><br><span class="line">        rt_list_insert_after(&amp;(information-&gt;object_list), &amp;(object-&gt;<span class="built_in">list</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlock interrupt */</span></span><br><span class="line">    rt_hw_interrupt_enable(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的这个方法非常典型，它用于完备地初始化一个内核对象，规定它的内存空间占用</span></span><br><span class="line"><span class="comment">//将一个内核对象作为参数传入即可完成初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//能够注意到所有操作到类，并且能够被用户使用的方法都并没有作为一个“私有的”方法放置在结构体内，而是直接放在头文件中</span></span><br><span class="line"><span class="comment">//这就是上文所说通过变量作用域控制私有/公有变量的操作</span></span><br></pre></td></tr></table></figure>

<h3 id="一些经常被遗忘但在嵌入式编程中仍有作用的关键字"><a href="#一些经常被遗忘但在嵌入式编程中仍有作用的关键字" class="headerlink" title="一些经常被遗忘但在嵌入式编程中仍有作用的关键字"></a>一些经常被遗忘但在嵌入式编程中仍有作用的关键字</h3><ul>
<li><p>volatile</p>
<blockquote>
<p>一个定义为volatile的变量是说这变量可能随时会被改变，这样编译器就不会去假设这个变量的值——优化器在用到这个变量时必须每次都会重新读取这个变量的值，而不是使用保存在寄存器里的备份</p>
</blockquote>
<p>这个关键字常被用于下面的场合：</p>
<ul>
<li><p>并行设备的硬件寄存器</p>
<p>说人话就是<strong>MCU的外设控制寄存器地址需要用volatile指明</strong></p>
</li>
<li><p>一个中断服务子程序中会访问到的非自动变量</p>
<p>这个就很明显了，<strong>用于指示中断的全局变量</strong></p>
</li>
<li><p>多线程应用中被几个任务共享的变量</p>
<p>这种情况一般会在SMP设备或多核的高性能嵌入式设备中出现，<strong>多核执行任务中一定将全局变量设为volatile</strong>，否则可能导致跑飞。如果有双核并行化需求且对效率没有极致的需求，尽量使用RTOS甚至嵌入式Linux，并在分配任务的时候尽量使用RTOS自带的信号量或消息队列可以减少出现问题的可能性</p>
</li>
</ul>
<p>事实上volatile应该解释为“<em>直接存取原始内存地址</em>”，正因如此，<strong>volatile是可以和const一起使用的</strong>，这表示对于某个只读变量始终直接存取原始内存地址</p>
<p>下面给一个网上随处可见的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面的函数有什么错误?</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *ptr * *ptr;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>这段代码的目的是用来返回指针ptr指向值的平方，但由于ptr指向一个volatile型参数，这个参数的值随时可能变化，编译器可能会将其优化为以下代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a,b;</span><br><span class="line">	a = *ptr;</span><br><span class="line">	b = *ptr;</span><br><span class="line">	<span class="keyword">return</span> a * b;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>实际上编译器生成的是汇编指令，a、b并不影响存取变量，但是会消耗额外的内存空间、让CPU执行不必要的取址甚至分支跳转指令，并且如果外界因素导致ptr指向的变量变化，就会实实在在地影响函数的返回值——会从理论上的a*a变成a*b</p>
<p>正确的代码应该像下面这样</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	a = *ptr;</span><br><span class="line">	<span class="keyword">return</span> a * a;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>使用一个普通变量a来暂存ptr指向的值，虽然这样看似浪费了内存，但是和上面那段代码的内存占用实际上是一样的，并且能够避免出错</p>
</li>
<li><p>extern</p>
<p>在c语言中最不被重视但确实是最重要的关键字</p>
<p>用于<strong>在头文件中声明已在对应.c库文件中定义过的变量</strong></p>
<p>也常用于<strong>在多任务文件中定义main文件中的全局变量</strong></p>
<p>没有这个关键字，编译器必报错，一改就是半天</p>
</li>
<li><p>static</p>
<p>static在不同作用域中有不同的含义</p>
<ul>
<li><p>全局变量static</p>
<p>用于指示这个全局变量只在单文件中起作用，可以用于在.c文件中声明常量来提高文件的可移植性</p>
</li>
<li><p>局部变量static</p>
<p>用于指示静态局部变量，这个学过C语言的人应该都比较熟悉了</p>
<p>最常见的用法是在MCU的按键扫描函数中使用，如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">KEY_Scan</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;	 </span><br><span class="line">	<span class="keyword">static</span> u8 key_up=<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(mode)</span><br><span class="line">        key_up=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(key_up &amp;&amp; ( KEY0==<span class="number">1</span> || WK_UP==<span class="number">1</span> ))</span><br><span class="line">	&#123;</span><br><span class="line">		delay_ms(<span class="number">10</span>); <span class="comment">//软件消抖</span></span><br><span class="line">		key_up=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(KEY0==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> KEY0_PRES;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(WK_UP==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> WKUP_PRES;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(KEY0==<span class="number">0</span> &amp;&amp; WK_UP==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		key_up=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>函数static</p>
<p>用于声明某个函数是本文件内有效的函数</p>
<p>同样用于在.c文件中声明常量来提高文件的可移植性</p>
<p>一般来说会在.h文件中再写一条extern static标明的函数</p>
<p><strong>static函数在内存中只有一份，普通函数会在每次调用中生成一份拷贝</strong></p>
</li>
</ul>
</li>
<li><p>register</p>
<p>这个关键字确实很少使用，但是一旦用上就十有八九是需要硬优化算法的地方，如果实在需要使用这种方法优化，可以使用内联汇编来进行替代，不仅可以稳定”寄存器命中“，还可以更好地强调代码的执行速度优先</p>
</li>
</ul>
<h2 id="库函数与轮子——顶层"><a href="#库函数与轮子——顶层" class="headerlink" title="库函数与轮子——顶层"></a>库函数与轮子——顶层</h2><p>C库函数可以说是编写C程序的重中之重，从基本的stdio到高级的glibc，这些库中的函数都由大师编写，高效、简洁，而一般的开发者至少要学会使用这些库函数和基于C实现的轮子，它们除了在C程序中发挥作用，还能借助辅助工具和其他语言实现共同编译运行以提升其他语言代码的效率</p>
<h3 id="使用C库函数进行字符串处理"><a href="#使用C库函数进行字符串处理" class="headerlink" title="使用C库函数进行字符串处理"></a>使用C库函数进行字符串处理</h3><ol>
<li><p>将字符串转换为数字</p>
<p>最基本的方法是使用<code>atoi</code>和<code>atof</code></p>
<p>使用方法如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a = <span class="string">&quot;42&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> x = atoi(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> million[] = <span class="string">&quot;1e6&quot;</span>;</span><br><span class="line"><span class="keyword">double</span> m = atof(million);</span><br></pre></td></tr></table></figure>

<p>更安全一点的库函数如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = strtod(<span class="keyword">char</span> <span class="built_in">string</span>[],<span class="keyword">char</span> *p);</span><br><span class="line"><span class="comment">//里面的指针p会被指向第一个不能被解析成数字的字母</span></span><br></pre></td></tr></table></figure></li>
<li><p>asprintf函数</p>
<p>该函数需要使用支持GNU或BSD标准库的系统，但也可以使用vsnprintf函数快速实现asprintf函数</p>
<p>该函数可以让字符串处理更方便</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 一般的字符串处理方法 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_strings</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* cmd;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(<span class="string">&quot;strings &quot;</span>) + <span class="built_in">strlen</span>(in) + <span class="number">1</span>;</span><br><span class="line">    cmd = <span class="built_in">malloc</span>(len);</span><br><span class="line">    <span class="built_in">snprintf</span>(cmd, len, <span class="string">&quot;strings %s&quot;</span>, in);</span><br><span class="line">    <span class="keyword">if</span>(system(cmd))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;something went wrong running %s.\n&quot;</span>, cmd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用asprintf的字符串处理方法 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_strings</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* cmd;</span><br><span class="line">    asprintf(&amp;cmd, <span class="string">&quot;strings %s&quot;</span>, in);</span><br><span class="line">    <span class="keyword">if</span>(system(cmd))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;something went wrong running %s.\n&quot;</span>, cmd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    get_strings(argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>asprintf和sprintf很相似，但是它需要传入的是字符串在内存中的位置而不是字符串本身，因为这个函数会为字符串分配新的空间</p>
<p>可以通过运行两次vsnprintf来实现asprintf</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ASPRINTF_EX_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __ASPRINTF_EX_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">asprintf</span><span class="params">(<span class="keyword">char</span> **str, <span class="keyword">char</span> *format, ...)</span> __<span class="title">attribute__</span> <span class="params">((format(prntf,<span class="number">2</span>,<span class="number">3</span>)))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">asprintf</span><span class="params">(<span class="keyword">char</span> **str, <span class="keyword">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list argp;</span><br><span class="line">    va_start(argp, format);</span><br><span class="line">    <span class="keyword">char</span> one_char[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> len = vanprintf(one_char, <span class="number">1</span>, format, argp); </span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;An encoding error occurred. Setting the input pointer to NULL.\r\n&quot;</span>);</span><br><span class="line">        *str = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(argp);</span><br><span class="line">    </span><br><span class="line">    *str = <span class="built_in">malloc</span>(len + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Couldn&#x27;t allocate %i bytes.\r\n&quot;</span>, len + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    va_start(argp, format);</span><br><span class="line">    vsnprintf(*str, len + <span class="number">1</span>, format, argp);</span><br><span class="line">    va_end(argp);</span><br><span class="line">    <span class="keyword">return</span> len</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>该函数具有防止数据越界、自动分配内存、自动控制内存大小的安全特性，同时可以使用该函数来实现连接字符串的功能</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">asprintf(&amp;q, <span class="string">&quot;%s and another clause %s&quot;</span>, q, add);</span><br></pre></td></tr></table></figure>

<p>这个特性可以用来实现数据库查询的底层</p>
</li>
<li><p>字符串解析</p>
<p>一般的字符串解析需要根据分隔符，配合正则表达式来抽取出子字符串。但是简单情况下只要使用c库函数strtok就可以完成使用分隔符划分字符串的任务：它会对输入的字符串进行迭代，直到遇到第一个分隔符，然后用一个<code>&#39;\0&#39;</code>来覆盖它，并返回一个指向这个子字符串头部的指针；当再次调用时，它会检索到下一个标记的尾部，并以合法的字符串形式返回这个标记。可以使用<code>strto_s</code>版本来实现多线程保护和提高安全性，它支持一个额外的参数：提供输入字符串的长度，并在后续的调用过程中不断缩短，表示每次调用时剩余字符串的长度，示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> len = <span class="built_in">strlen</span>(instring);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//第一次使用</span></span><br><span class="line">txt = strtok_s(instring, &amp;len, delimiter, &amp;scratch);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二次使用</span></span><br><span class="line">txt = strtok_s(<span class="literal">NULL</span>, &amp;len, delimiter, &amp;scratch);</span><br></pre></td></tr></table></figure>

<p><strong>特别注意</strong>：如果有连续的两个或更多分隔符被当作单个分隔符，那么空白标记会被忽略</p>
</li>
<li><p>Unicode解析</p>
<p>ASCII已经不适合这个版本了，大家都在用Unicode：为每个用于人类通信的字符设置一个单独的十六进制数值，一般是从0x0000到0xffff之间。Unicode具有以下几个流行的编码格式，他们之间的区别子啊与设置几个字节作为分析单位</p>
<ul>
<li>UTF-32：指定4字节（32位二进制位）作为基本单位，每个字符都可以用1个单位进行编码，但需要使用很多空白填充</li>
<li>UTF-16：使用2字节（16位二进制位）作为基本单位，有些字符需要使用2个单位来表示，但大多数字符都能用1个单位表示</li>
<li>UTF-8：使用1字节（8位二进制位）作为基本单位，许多字符需要使用多个单位来表示</li>
</ul>
<p>这三种方式中的字符序列不一定相关，特定的用于解析Unicode字符的c函数也应运而生</p>
<p>超过73%的网站使用了UTF-8，Mac和Linux操作系统在默认情况下使用UTF-8表示任何文本。作为程序开发者，需要进行以下操作：</p>
<ul>
<li>确定宿主系统的编码方式</li>
<li>按照合适的编码存储文本</li>
<li>认识到一个字符并不占据固定数量的字节，防止以基地址+偏移量表示的代码不会产生编码点的碎片</li>
<li>用便利的工具函数完成任何类型的文本理解</li>
</ul>
<p>UTF-8的内部编码对于C语言来说可以轻松处理，但是具有一些需要注意的隐患，因为：</p>
<ul>
<li>单位是8个二进制位，即一个char型，因此可以把一个UTF-8字符串写成char*字符串，与ASCII类似</li>
<li>前128个UTF-8和ASCII完全匹配；非ASCII的Unicode字符则无法和ASCII匹配</li>
<li>U+0000是一个合法的编码点，可以写成<code>&#39;\0&#39;</code>；但是这也导致把UTF-16或UTF-32赋值给char*变量时很可能出现一个充满NULL字节的字符串</li>
</ul>
<p>大多数POSIX和c-string库标准函数都可以对UTF-8编码生效</p>
<p>GNU还提供了一个可移植的libiconv函数库，指定了一个命令行的iconv程序，用于c函数上传至shell</p>
<p>对于UTF-16字符，C标准可以使用wchar_t来进行处理（windows将wchar_t置为16位），C11还提供了char16_t和char32_t的类型，分别对应16位和32位字符，但是目前还不太常用</p>
</li>
</ol>
<h3 id="多线程与原子操作"><a href="#多线程与原子操作" class="headerlink" title="多线程与原子操作"></a>多线程与原子操作</h3><p>现在是2201年了，不会有人还在用单核的PC吧——就连MCU都在搭载双核乃至四核处理器，C语言也与时俱进，利用POSIX和现有的C库实现多线程-原子操作！</p>
<p>借助POSIX或者OpenMP编译器命令，可以很轻松的将命令转到多线程执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br></pre></td></tr></table></figure>

<p>使用上面一行语句即可将单线程程序变成多线程的。OpenMP会自动计算系统可用线程数，并将工作拆分</p>
<p>如果你在嵌入式设备上移植了RTOS，应该会很熟悉借助互斥量、消息队列实现的线程（任务）间同步与消息传输，不过要在PC上使用C进行多线程编译，还应该调整编译器指令</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CFLAGS = -g -Wall -O3 -fopenmp -pthread <span class="comment">#同时使用fopenmp pthread atomic支持</span></span><br><span class="line">LDLIBS = -fopenmp -latomic</span><br></pre></td></tr></table></figure>

<p>不过虽然多线程能让任务效率提高，但是也可能会导致代码出现某些玄学bug</p>
<p><strong>多线程Bug比单线程Bug更难处理</strong></p>
<p>这时候就需要利用经验Debug了，加油吧</p>
<p>OpenMP和POSIX还有其他的一些指令，可以提供更完善的多线程支持，可以查看官方文档来了解它们，这里不再介绍</p>
<p><strong>原子操作，即不能被中断的操作</strong>——这是嵌入式编程的专有术语？不，多线程编程中的原子操作也指不能被线程切换打断的操作，使用以下命令高速OpenMP原子操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp atomic read <span class="comment">//原子读数据</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp atomic write seq_cst <span class="comment">//原子写数据（赋值）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp atomic update seq_cst <span class="comment">//原子自增/自减1</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp atomic update <span class="comment">//原子自增/自减一定值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp atomic capture seq_cst <span class="comment">//原子改变自己的值并进行读数据操作</span></span></span><br></pre></td></tr></table></figure>

<p>可以使用高频的原子操作在某种程度上替代互斥操作；然而请不要一直使用它——否则这和单线程编程又有什么区别呢</p>
<p>使用POSIX的pthread机制可以更标准地对Linux程序进行移植/多线程修改</p>
<p>如果你读过C Primer Plus，那么里面简要介绍的<code>_Atomic</code>关键字应该会让你懵一会，这个东西其实也是C11标准为了更好兼容多线程编程而创建的关键字，可以用于保护变量在多线程执行中不被额外的线程改变，各种各样的变量都可以修改成原子的——从int到struct</p>
<h3 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h3><p>SQL即结构化查询语言，这是一个大体上人类可阅读的与数据库交互的语言。一个SQL数据库可以抽取一个数据集合的子集，也可以合并多个数据集合。C程序可以使用<strong>SQLite</strong>提供的接口来实现数据库搭建和使用，而这个东西本体仅包括一个C文件和一个头文件。</p>
<p>这个库使用了多种宏和C预编译指令来实现SQL的操作，并将API封装到了 统一的接口上</p>
<p>相关内容可以参考<a href="www.sqlite.org">SQLite简介</a></p>
<h3 id="cJSON"><a href="#cJSON" class="headerlink" title="cJSON"></a>cJSON</h3><p>c语言中，没有直接的字典、字符串数组等数据结构，所以要借助结构体处理json。cJSON就是一个为json数据解析而生的高效率c库</p>
<p>类似的，也存在用于XML（扩展标记语言）、HTML（超文本标记语言）等数据解析的C库libxml和cURL</p>
<p>cJSON使用称为cJSON的数据结构负责JSON数据的编解码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> &#123;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span> <span class="comment">//链表指针域</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> *<span class="title">child</span>;</span> <span class="comment">//子对象</span></span><br><span class="line">     <span class="keyword">int</span> type; <span class="comment">//类型</span></span><br><span class="line">     <span class="keyword">char</span> *valuestring; <span class="comment">//指向值的字符串</span></span><br><span class="line">     <span class="keyword">int</span> valueint; <span class="comment">//存放整型</span></span><br><span class="line">     <span class="keyword">double</span> valuedouble; <span class="comment">//存放浮点型</span></span><br><span class="line">     <span class="keyword">char</span> *<span class="built_in">string</span>; <span class="comment">//键</span></span><br><span class="line">&#125; cJSON;</span><br></pre></td></tr></table></figure>

<p>使用顺序如下：</p>
<ol>
<li><p>包含头文件</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cJSON.h&quot;</span></span></span><br><span class="line"><span class="comment">//上面是必须的几个头文件</span></span><br></pre></td></tr></table></figure></li>
<li><p>JSON解析</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cJSON *root_json = cJSON_Parse(data); <span class="comment">//将字符串解析成json结构体</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == root_json)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;error:%s\n&quot;</span>, cJSON_GetErrorPtr());</span><br><span class="line">    cJSON_Delete(root_json);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&quot;name&quot;:&quot;EVDI&quot;</span></span><br><span class="line">cJSON *name_json = cJSON_GetObjectItem(root_json, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (name_json != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span> *name = cJSON_Print(name_json); <span class="comment">//将JSON结构体打印到字符串中</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name:%s\n&quot;</span>, name);</span><br><span class="line">	<span class="built_in">free</span>(name); <span class="comment">//自行处理内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>获取JSON数据</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cJSON *data_json = cJSON_GetObjectItem(root_json, <span class="string">&quot;data&quot;</span>); <span class="comment">//获取data键对应的值</span></span><br><span class="line"><span class="keyword">int</span> id = cJSON_GetObjectItem(data_json, <span class="string">&quot;id&quot;</span>)-&gt;valueint;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;id:%d\n&quot;</span>, id); <span class="comment">//输出</span></span><br></pre></td></tr></table></figure></li>
<li><p>输出JSON数据</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *username = cJSON_Print(cJSON_GetObjectItem(data_json, <span class="string">&quot;username&quot;</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;username:%s\n&quot;</span>, username);</span><br><span class="line"><span class="built_in">free</span>(username);</span><br></pre></td></tr></table></figure></li>
<li><p>创建JSON并添加值</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cJSON *root_json = cJSON_CreateObject(); <span class="comment">//创建一个JSON串</span></span><br><span class="line">cJSON_AddItemToObject(data_json, <span class="string">&quot;id&quot;</span>, cJSON_CreateNumber(<span class="number">1</span>)); <span class="comment">//数字值</span></span><br><span class="line">cJSON_AddItemToObject(data_json, <span class="string">&quot;userpass&quot;</span>, cJSON_CreateString(<span class="string">&quot;123456&quot;</span>)); <span class="comment">//字符串值</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>C语言进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>电路设计从入门到弃坑1【基础晶体管】</title>
    <url>/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/</url>
    <content><![CDATA[<h1 id="电路设计从入门到弃坑1【基础晶体管】"><a href="#电路设计从入门到弃坑1【基础晶体管】" class="headerlink" title="电路设计从入门到弃坑1【基础晶体管】"></a>电路设计从入门到弃坑1【基础晶体管】</h1><p>最基础的电路是由无源元件，即电阻、电容、电感三者构成的电路，两端通电后可以产生一个暂时稳定的电信号。不论是机缘巧合还是为了验证实验，曾经的物理学家开始注意到电的特殊性质，并加以研究，他们最先对电的性质进行探寻，从风筝实验到电磁感应定律一点点理解了电磁运作的原理，于是电气工程就出现了。然而到19世纪末为止，一直都只有无源电路的存在，电路的分析理论也仅有基础的电磁感应定律和由麦克斯韦方程组衍生出的基尔霍夫定律——直到20世纪的工程师发明出真空管，开启电子电路的时代。电路从最初使用电能和磁场能来控制、转化其他能量这个单一用途，进一步拓展出使用电信号来描述、控制其他信号，乃至使用电信号进行计算的用途。实现这些功能的基础就是具有控制功能的有源器件，也就是常说的二极管、三极管等元件。现代的半导体晶体管在20世纪中期才被发明出来，在此之前承担电子信号变换作用的元件一直是真空管。</p>
<span id="more"></span>

<h2 id="真空管"><a href="#真空管" class="headerlink" title="真空管"></a>真空管</h2><p>在半导体材料被发明之前，人们都使用电子管或者说真空管对电路进行操控，现代的半导体技术实质上还是在使用半导体达到真空管的用途，只不过因为半导体材料可以在硅片上进行制造，大大缩小了电路体积——但是它们的用途是相似的</p>
<p>现在真空管已经被市场淘汰，剩下的也不过成了爱好者们的玩具，不过理解真空管有助于了解二极管、三极管等基本的晶体管在电路中起到的作用</p>
<p>电子管主要分为：二极管、三极管、五极管、束射管、复合管等，听上去和半导体器件很相似</p>
<p>二极管是其中最简单的，它中间装有两个电极，一个是由金属丝制成用于发射电子的阴极，另一个是接收电子的屏极。给阴极通电，电流会将金属加热，管内已经被抽成了真空，因此金属丝就能发射电子，屏极则负责将这些电子接收。</p>
<p>在屏极接高电势，阴极接低电势时，屏极会主动吸引阴极发出的电子。一般来说二极管的加热部件是独立的，围绕在阴极周围，如下图所示（图b为电路符号，K为阴极，a为屏极，两个f表示加热部件）</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210814022541069.png" alt="image-20210814022541069"></p>
<p>因此实际上会有很多（效率懂得都懂，但是当时能用就行）电子从阴极到达屏极；反之在屏极接低电势，阴极接高电势时，电子的发射会被抑制——这就造成了二极管具有<strong>单向导电性</strong></p>
<p>基于PN结的二极管实际上也是起到单向导电性的作用，只不过由于引入了半导体技术，它的功能更加丰富、复杂了（实际上前人们也使用了很多方法改进真空管让它们做到现在半导体二极管的功能——毕竟第一台电子计算机都是用真空管制造的）</p>
<p>容易看出，这个大二极管具有一个致命的问题：功耗大得离谱，这玩意实际上就是个电灯泡——工作时常常能达到外壳100多度，用手摸一下就能烫熟的那种……这就是真空管的通病了：它们都需要使用额外的电热丝来让金属发出电子，而半导体管则不需要这些</p>
<p>再来看三极管：<img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210814023224226.png" alt="image-20210814023224226"></p>
<p>它中间多了一个栅极g——这个称呼也被保留到了后来的场效应管中——可以通过控制栅极来实现控制阴极-屏极电流，这也是双极结型晶体管和场效应管的共同原理和要达到的目的：<strong>用一个电流/电压控制另一个电流/电压</strong></p>
<p>值得指出的是：真空三极管的很多特性与专有名词被移植到了晶体三级管上，如果学完了三极管/晶体管再来学另一个，会感到很熟悉</p>
<p>真空管中还有一个较三极管更复杂的分支——五极管。他在三极管的栅极和屏极之间插入另外两个电极，于是栅极被分成了<em>控制栅极</em>、<em>帘栅极</em>和<em>抑制栅极</em>，这个器件主要用于减少的真空三极管中超大寄生电容和超量漂移电流的影响，从而能够实现“<strong>高频开关和放大</strong>”（在当时确实是高频）的开关，第一台电子计算机中也大多用了五极管配合继电器进行开关</p>
<p>最后需要提的就是束射管（至于复合管嘛，管如其名），它就是高中物理里面大名鼎鼎示波管的父类——通过将高速电子流打在荧光屏上实现显示功能，使用周边的电磁铁来控制显示的位置</p>
<p>不过束射管还有很多其他变种，辉光管、荧光管等上世纪苏联时代的遗产都是束射管的成员，它们大都利用加热器-金属灯丝-荧光材料/电子射线的原理进行发光显示信息，可以说是现代发光二极管的鼻祖了</p>
<p>利用这些真空管，前人们也制造出了放大器、振荡器、线性电源乃至开关电源等设备，其耐用性甚至能把一部分使用现代技术的设备打趴下。比起教科书中从半导体物理直接讲起，个人认为晶体管这种”朴素“的老古董更能体现模拟电路的本质——<strong>通过支路量操控支路量，从而实现模拟电信号的变换</strong></p>
<p>而真空管中的几个基本元件的性质也会在晶体管元件上得到体现</p>
<ul>
<li>二极管——单向导电与反向击穿</li>
<li>三极管——电流放大与开关控制</li>
</ul>
<h2 id="二极管"><a href="#二极管" class="headerlink" title="二极管"></a>二极管</h2><blockquote>
<p>我再用真空管，诺伊斯就是个伞兵！——肖克利（他没说过）</p>
</blockquote>
<p>简单了解过真空管，我们再来看看现代半导体科技的结晶，<strong>晶体管</strong></p>
<p>首先要谈的就是二极管了。不过要看懂现代半导体科技，就要从它们的基础——半导体材料开始。由于本篇的重点在于半导体器件，所以这里仅进行笼统的概括。我们先从二极管的物理基础<strong>PN结</strong>看起。</p>
<h3 id="二极管就是PN结"><a href="#二极管就是PN结" class="headerlink" title="二极管就是PN结"></a>二极管就是PN结</h3><p>半导体材料（硅/锗）的单质都是很难导电的，因为其中的电子和空穴浓度相等，即使外加电压，也会很快形成电流的动态平衡；然而这种平衡容易随着外界环境改变而改变，通过向纯净的半导体材料中掺入受控量的N型杂质和P型杂质，可以分别得到<strong>N型半导体</strong>和<strong>P型半导体</strong>，这种技术称为<strong>掺杂</strong></p>
<blockquote>
<p>N型杂质就是氮族元素（IVA族），它们的最外层电子数为5；P型杂质则是硼族元素（IIIA族），它们的最外层电子数为3</p>
<p>显而易见，N型杂质的掺杂会导致自由电子数量增多，半导体的载流子为多子，即自由电子，这就是为什么它被称为<strong>N</strong>egative；相反地，P型杂质的掺杂会导致空穴数量增多，半导体的载流子为多子，即空穴，这也是为什么它被称为<strong>P</strong>ositive</p>
<p>使用能带理论可以解释多子导电：导带中的电子就是载流子，能够导电；而空穴作为电子反向移动（跃迁）的等效，也可以等效地导电。相关内容可以参考《半导体物理》教材或本博文的参考书《模拟电子系统设计指南（基础篇）：从半导体、分立元件到TI集成电路》</p>
</blockquote>
<p>幼儿园的小朋友都知道，半导体材料的导电性容易受到外界温度、光照等因素影响。这是因为在特定温度热平衡的条件下，对特定的半导体材料，电子浓度$n_o$和空穴浓度$p_o$的乘积始终为常数，公式如下：$n_o * p_o = n_i^2$</p>
<blockquote>
<p>电子在核外的量子分布状态成为<strong>状态密度</strong>；电子的能量分布称为<strong>费米函数</strong></p>
<p>费米函数可以表明电子占据特定允态能级的概率，而它的值是由当前温度T和<strong>费米能级</strong>$E_F$决定的，表达式如下：<br>$$<br>f(E)=\frac{1}{1+e^{(E-E_F)/kT}}<br>$$<br>当T=0K时，可以发现所有低于费米能级的允态能级会被填充；高于费米能级的允态能级则会空出</p>
<p>当T有一个大于0K的确定值时，上式就存在一个极限值，并且填充态和空态之间出现了过渡，随着温度升高，这个极限值会逐渐降低，这就导致<strong>导带中热平衡的电子浓度会随着导带能级与温度变化而变化</strong>，表达式如下<br>$$<br>n_0=N_Ce^{-(E_C-E_F)/kT}<br>$$<br>参数$N_C$表示导带中的有效态密度函数，它的值仅由半导体材料的有效质量和温度确定</p>
</blockquote>
<p>根据上式不难得出：在温度稳定的条件下，半导体材料的本征浓度为常数</p>
<p>一般地，把两种不同的体系合二为一时，载流子可以互相流动；但是热平衡的时候一定会形成统一的费米能级，这是因为出现了载流子浓度交换，因此可以<strong>把掺杂的过程看作使费米能级变化进而改变导带宽度的过程</strong>；由此也可以推断出光照和温度也会让导带宽度变化，进而影响半导体材料导电性</p>
<p>说完了P型和N型半导体，终于能谈到PN结了——二极管归根结底就是一个封装起来的PN结，通过控制PN结的物理性质就可以制造出不同种类的二极管</p>
<p>PN结的物理性质十分复杂，这里我们只讲<em>简化的PN结模型</em></p>
<p>在一个晶格内，将P型和N型半导体连接在一起就形成了PN结，电子会从N区扩散到P区，空穴会从P区扩散到N区，因此在二者的接触区附近，电子和空穴会复合抵消，将其称为<strong>耗尽区</strong>或<strong>空间电荷区</strong>——在特定温度的热平衡条件下，不施加额外能量，电子或空穴是不能通过PN节的；同时由于在结的两侧存在相反的电荷，这就建立了一个穿越PN结的电场</p>
<p>当没有给PN结施加额外能量时，耗尽区会阻挡电流形成，不过仍然会存在微弱的电流穿过耗尽区，根据方向分为<strong>正向扩散电流</strong>和<strong>反向漂移电流</strong>；如果在外部对PN结两端施加正向电场，使得耗尽区内电场被抵消，空穴和电子就能够自由流动，在此过程中耗尽区越厚，所需要施加的外部能量就越大</p>
<blockquote>
<p>想象一种极端情况，将P型半导体的掺杂浓度提升到极限，甚至将其换成金属，那么电子便会自由地从P区向N区扩散，但是随着扩散，P区的电子浓度会逐渐变低，反而会形成一个从N区到P区的势垒，这一过程是动态平衡，这个势垒就是大名鼎鼎的肖特基势垒，利用贵金属和N型半导体就可以制成<em>肖特基二极管</em>，它的原理和结型二极管十分相似，但是最后的产物完全不一样：加正向电压时肖特基势垒会变窄而导致其内阻减小，这一性质导致它具有正向压降低的优点</p>
</blockquote>
<p>虽然二极管耗尽区的这个电场（一般称为内建势垒或内电场）很强，能抑制多子的运动，但是P区的少子电子会因此漂移到N区；N区的少子空穴也会穿过PN结到达P区，二者引起的电流分别称为正向扩散电流和反向漂移电流，二者大小相等、方向相反</p>
<p>因此，PN结也就是二极管的最根本、最基础特性就是<strong>单向导电性</strong></p>
<h3 id="从伏安特性出发"><a href="#从伏安特性出发" class="headerlink" title="从伏安特性出发"></a>从伏安特性出发</h3><p>回想一下真空管时代我们都用真空二极管干了什么？拿它单向导电和反向稳压！当年肖克利老爷子准备了一份真空管的伏安特性，然后对着面前的硅片就开始研究：怎么让这破玩意弄得像真空管一样？我们也先从伏安特性出发，理解二极管的性质</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210828014723118.png" alt="image-20210828014723118"></p>
<ul>
<li><p>正偏曲线</p>
<p>  二极管的P极接高电势、N极接低电势，即<strong>正偏</strong>，在这个情况下二极管的伏安特性曲线近似于指数函数</p>
<p>  二极管正偏伏安特性曲线如下所示：</p>
<p>  <img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210828014716192.png" alt="image-20210828014716192"></p>
<p>  U<del>ON</del>为<strong>二极管导通电压，硅管约为0.7V，锗管约为0.3V</strong>。因为二极管导通电压相对较低，而导通后电流升高速度很快，在$2 * U_{ON}$后就可以看作是短路状态，因此也常使用二极管的简化模型：当电压&lt;0V（或导通电压）时二极管关断，当电压&gt;0V（或导通电压）时二极管导通且为短路</p>
<blockquote>
<p>顺带一提，锗二极管虽然导通电压更低，但是已经基本被市场淘汰了，因为</p>
<ol>
<li>锗稳定性不好、提炼加工困难导致其一致性难以保证</li>
<li>价格更高</li>
<li>难以在硅片上集成</li>
</ol>
<p>同样遭遇的还有锗三极管，它的结压降也是约为0.3V（甚至视型号不同会更低一些），但是因为制造工艺和品控问题早早停产，只有一些HiFi发烧友在使用锗器件来达到更好的放大性能</p>
<p>特别地，<strong>锗管反向饱和电流为μA级，硅管则为nA级</strong>，显然硅管的截止更彻底</p>
</blockquote>
</li>
<li><p>反偏曲线</p>
<p>  之前没有说二极管PN结<strong>反偏</strong>（P极接低电势，N极接高电势）的结果：当阴极电压比阳极电压高时，会形成一个由阴极到阳极的外电场，电流根本不会产生，但是如果这个电压逐渐增高，甚至能够抵消耗尽区的内电场时，二极管就会被<strong>击穿</strong>，击穿时，整个晶体管内会产生大量电子-空穴对，电流会达到最大，换句话说此时二极管近似于短路，在这个过程中二极管会因为电流而剧烈发热，但是<strong>这并不意味着二极管损坏</strong>，如果再撤销这个反向电压，二极管还是会因为内电场重新建立而恢复原状。</p>
<blockquote>
<p><strong>材料掺杂浓度较低的PN结中</strong>，当PN结反向电压增加时，空间电荷区中的电场随之增强。这样通过空间电荷区的电子和空穴就会在电场作用下，使获得的能量增大。在晶体中运行的电子和空穴将不断与晶体原子发生碰撞，通过这样的碰撞可使被束缚在共价键中的键电子碰撞出来，产生自由电子-空穴对。紧接着新产生的载流子会在电场作用下撞出其他价电子，又产生新的自由电子-空穴对。如此连锁反应，使得空间电荷区中的载流子的数量雪崩式（也可以理解为链式反应）增加，流过PN结的电流就急剧增大击穿PN结，这种碰撞电离导致击穿称为<strong>雪崩击穿</strong></p>
<p>而在<strong>材料掺杂浓度较高的PN结中</strong>，耗尽区本来就比较薄，而在此时反偏一个强电场，这就是的耗尽层内中性原子的价电子会被快速拉出，成为自由电子，同时产生空穴，这个过程被称为<strong>场致激发</strong>。在场致激发的影响下二极管内会产生大量载流子，因此出现反向击穿的现象，这种击穿一般需要的外部能量较雪崩击穿更少，被称为<strong>齐纳击穿</strong></p>
</blockquote>
<p>  事实上能够损坏二极管的只有高温和外部破坏。因为<strong>导带中热平衡的电子浓度会随着导带能级与温度变化而变化</strong>，温度越高，热平衡电子浓度越高，越难以导电，而当反向击穿积聚的热量无法被释放时，二极管会被烧毁。二极管的反偏伏安特性如下所示：</p>
<p>  <img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210828013041349.png" alt="image-20210828013041349"></p>
<p>  U<del>BR</del>表示<strong>击穿电压</strong>（分为<strong>雪崩电压</strong>和<strong>齐纳电压</strong>），I<del>S</del>为漏电流（反向饱和电流），可见当二极管反偏时，在击穿电压范围内电流会达到很小，而超过击穿电压后，通过二极管的电流就会迅速增大（一般雪崩击穿电流增大速率比齐纳击穿更快）</p>
</li>
<li><p>特别的，可以使用公式<br>  $$<br>  i=I_s(e^{\frac{u}{U_T}}-1)<br>  $$<br>  近似表示二极管的伏安特性</p>
</li>
</ul>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol>
<li><p>单向导电性</p>
<p> 二极管的单向导电性应该不用多介绍，大家品鉴的足够多了。一般利用这个性质，可以实现二极管的半桥整流或<strong>全桥整流</strong>（对于三相电可以使用三相桥整流），用于将交流信号变成脉动的直流信号。对于单相交流信号，可以直接在变压器中间抽头，用两个背对背的二极管就可以实现全桥整流</p>
<p> 还可以利用这个性质实现<strong>boost电路</strong>（倍压整流）来进行DC-DC升压；对于高频信号则可以使用类似的电路（二极管后接电阻和并联的电容，前接激励源）实现<strong>包络检测</strong>，从高频调制的信号中提取低频信号</p>
<p> 在一般电路中应用比较多的就是<strong>钳位电路</strong>和<strong>削波电路</strong>，可以通过两个二极管分别连到VCC和GND端防止某个节点的电压偏高/过低，但是应该注意要在二极管同一支路串接保护电阻防止泄放电流过大</p>
<p> 因为二极管可以起到改变高频信号偏置电流的作用（因为它的正向电容可以在一定程度上滤除高频信号），所以可以使用它和分压电阻、电容实现压控衰减器，示例电路如下</p>
<p> <img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210828023423864.png" alt="image-20210828023423864"></p>
</li>
<li><p>反偏稳压性</p>
<p> 如果二极管反向电压超过击穿电压时，它会工作在击穿去，反向电流迅速增加，但电压基本不变，因此可以在保证二极管不过热的情况下让二极管在击穿区实现稳压功能，通过专门设计的，在击穿区内有着陡峭特性曲线（利用齐纳击穿特性）的二极管成为齐纳二极管，也就是俗称的稳压二极管</p>
<blockquote>
<p>一般来说稳压二极管都会有很高的掺杂浓度，这是因为稳压管利用了齐纳击穿而不是雪崩击穿：雪崩击穿所需的外部电压一般相当高，击穿时会很快产生巨大的电流，在这种情况下二极管的结温非常难以控制，因此一般的二极管一旦出现雪崩击穿基本就意味着烧毁；但是齐纳击穿的击穿电压相对较低，而且它的击穿伏安特性更平滑，只要在外接一个电阻用于控制击穿电流就可以相对容易地实现稳压</p>
</blockquote>
</li>
<li><p>反偏变容性</p>
<p> 耗尽层相当于PN两块半导体之间的绝缘体，因此二极管存在寄生电容（<em>结电容</em>）；又因为外加电压时耗尽层厚度会发生变化，因此二极管的寄生电容就会发生变化——通过在某一侧只掺入微量杂质，可以实现一个相当厚的耗尽区，如果此时对二极管反偏，这个耗尽区厚度会很容易变化，由此达到<strong>变容二极管</strong>的作用</p>
</li>
<li><p>温度敏感性</p>
<p> 因为导带中热平衡的电子浓度会随着导带能级与温度变化而变化，所以<strong>反向饱和电流</strong>会对温度敏感——会<strong>随温度增加而快速增加</strong>。其次，<strong>温度升高，二极管正向压降减小，正向工作电流增大，</strong>这是因为温度升高会导致耗尽区的原子共价键不稳定，更容易被外加电场激发出自由电子-空穴对</p>
</li>
<li><p>耗尽电容与扩散电容</p>
<p> 高频交流信号下，二极管中的耗尽层会演变成一个以硅为电介质的平行板电容器，对应的电容被称为<strong>耗尽电容</strong>。它会随二极管反向偏压而变化。</p>
<p> 当二极管正片时，由于耗尽层附近区域会有过量少子电荷聚集，出现电荷存储效应，局部的电荷浓度出现了不平衡，这就相当于又引入了一个电容，被称为<strong>扩散电容</strong>，它的大小与PN结点的横截面积成正比，一般为10-100pF</p>
<p> 利用这两个电容可以推导出二极管的高频小信号模型：正偏时一个小电阻并两个电容；反偏时一个大电阻并一个电容（耗尽电容）</p>
</li>
</ol>
<p>其实还有发光二极管、肖特基二极管等多种结构的二极管，它们都有自己的特点，但是暂且不作介绍</p>
<h3 id="电路应用"><a href="#电路应用" class="headerlink" title="电路应用"></a>电路应用</h3><p>下面给出1n4148二极管（来自安森美）的datasheet</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210828021027904.png" alt="image-20210828021027904"></p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210828021038170.png" alt="image-20210828021038170"></p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210828021047611.png" alt="image-20210828021047611"></p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210828021054300.png" alt="image-20210828021054300"></p>
<p>常见的参数都已给出，1n4148是通用性的开关二极管，电路设计中主要需要参考其击穿电压（100V）、最大正向电流（200mA）、峰值电流（400mA）、工作温度（-55到175）、功率（500mW）、漏电流（0.025uA-5uA）、开关频率（或者说恢复时间）（4ns）</p>
<p>可见它的开关频率比较高，但耐压相对一般，也缺少反向击穿稳压的能力，因此适合用作开关二极管或检波二极管的替代品</p>
<h2 id="三极管"><a href="#三极管" class="headerlink" title="三极管"></a>三极管</h2><blockquote>
<p>一个有源器件可以通过一个电信号控制其他电信号——真空三极管告诉电气工程师的遗言</p>
</blockquote>
<p>三极管又称<strong>双极结型晶体管</strong>，也就是所谓的<strong>BJT</strong>（Bipolar Junction Transistor）</p>
<p>特别地，“晶体管”——Transistor实际上是贝尔实验室对跨导变阻器（Transconductance Varistor）的简称</p>
<h3 id="三极管与二极管"><a href="#三极管与二极管" class="headerlink" title="三极管与二极管"></a>三极管与二极管</h3><p>为了实现电信号的相互控制，三端器件是必须的。对于一个三端器件，我们一般通过双端口网络模型进行分析。对于三极管，更适合使用双端口网络的T参数和H参数矩阵进行描述——但这太学术了！从直观上理解<strong>三极管就是一个水龙头</strong></p>
<p>我们先来看需要三端元件做什么：首先它要使用一端的电压/电流进行控制，就假设这个三端元件有ABC三个端口，要想在A端口产生这个电压/电流，就要找到一个地，因此三端元件一定需要一个接地点，让另外两端到这一端产生电流。暂且假设这个接地点是B——既然有电流产生，根据基尔霍夫电流定律，A端流入和C端流入电流之和就是B端流出的电流。一切都解释的通了：A端通过AC之间的电流/电压控制BC之间的电流/电压，这不就是一个受控源吗！我们将AC之间的电流/电压与BC之间电流/电压的比值记作<strong>增益β</strong>，不难看出<strong>β&lt;1</strong>恒成立，换个角度，这其实就是T参数矩阵中的一个参数</p>
<p>这就能解释三极管是水龙头这个比喻了：通过扭动水龙头把手可以可以控制水流的大小</p>
<p>对于三极管来说，他正是使用电流控制电流，A端被称为<strong>基极</strong>，记为<strong>b</strong>（<strong>B</strong>ase），B端称为<strong>发射极e</strong>极（<strong>E</strong>mitter），C端称为<strong>集电极c</strong>极（<strong>C</strong>ollector）。<strong>be电流控制ce电流</strong>。以下部分都会使用e、b、c三个极的简写形式</p>
<h3 id="一点简单的原理"><a href="#一点简单的原理" class="headerlink" title="一点简单的原理"></a>一点简单的原理</h3><p>三极管有两种大类型：<strong>NPN</strong>和<strong>PNP</strong>。它们的名字来源于其中“结”的排列顺序。它们的大致结构和电路符号如下所示：</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210831003431811.png" alt="image-20210831003431811"></p>
<p>BJT使用c和e极作为电流源端，b作为电流控制端，<strong>电路符号中的箭头表示器件处于正向有源状态时的电流方向</strong></p>
<p>目前PNP和NPN两种晶体管都被大量生产，但是相对而言NPN型生产效果更好——半导体中电子的流动性比空穴流动性更强，NPN的内部具有两个N型半导体区，所以它内部的电子浓度更高，可以达到更高的工作速度和承载更大电流。对于NPN管而言，共e极模式下，c极将基极注入的小电流放大输出；其他条件下，<strong>当E<del>b</del>&gt;E<del>e</del>时，晶体管c、e导通</strong>；PNP管与其相反，共射模式下，c极将离开b极的小电流放大输出，而<strong>当E<del>b</del>&lt;E<del>e</del>时，晶体管c、e导通</strong></p>
<p>实际上三极管的原理比较复杂，但在这里我们主要讨论的是其电气性质，所以只用NPN举例简单解释一下。正如其命名，BJT是由两个PN结构成的，其中电荷载流子穿过两个不同电荷浓度区域PN结时会发生双向扩散，这就导致了BJT的内电流。一个BJT的剖面图如下所示</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210831004908286.png" alt="image-20210831004908286"></p>
<blockquote>
<p>原谅我的灵魂画作</p>
</blockquote>
<p>可以发现<strong>BJT成型于c极底座，面积很大，b极被做得很薄且具有极低的掺杂浓度，e极则被控制在较高的掺杂浓度</strong>。这么做主要有以下几个原因：</p>
<ol>
<li>让e极可以很容易地被be电压激发出电子</li>
<li>让b极容易被穿过</li>
<li>c极可以完整接住来源于e极的电子</li>
</ol>
<p>可以发现整个流程和真空三极管的发射电子-控制电子-接收电子有异曲同工之妙。特别地，e极电子作为多子向b极扩散后，本来是少子的b极电子浓度大增，会自发向电子浓度相对较低的c极扩散，因此BJT被划分为少子载流元件</p>
<blockquote>
<p>顺便一提场效应管FET是多子载流元件，这就是为什么FET能承受相对更大的电流，这个话题按下不表</p>
</blockquote>
<p>当b极和e极加正向电压时，e极高浓度电子被快速激发，直接在电场作用下达到e极，而如果没有其他电源，这些电子会自行穿过b极进入外电路；但是一旦施加了更高（大于E<del>ce</del>）的电压，这些电子中的绝大多数就会进入c极（因为c极的面积比b极大得多），随后进入外电路。生产中为了降低在到达c极之前被空穴中和掉电子的百分比和被b极电压“吸引走”电子的百分比，b区就被做得很薄了</p>
<blockquote>
<p>有些人在学习模电不久后觉得三极管就是两个二极管的简单串联，只不过多加了一个控制功能，这种想法是完全<strong>错误</strong>的！</p>
</blockquote>
<p>一般在模拟电路设计中，认为c极电流是b极电流的线性函数，也就是大名鼎鼎的<strong>β</strong>；但是对于更精确的BJT电路，需要使用电压控制模型，或者说<strong>EM（Ebers-Moll）模型</strong>，需要考虑一个指数函数<br>$$<br>I_C=I_S(e^{\frac{qV_{BE}}{kT}-1})<br>$$<br>这个模型基于三极管的物理模型建立，相对精确。V<del>BE</del>可以被描述为$V_{BE}=\frac{kT}{q} ln \frac{I_C}{I_S}$</p>
<p>使用这个模型的一个优点在于可以将三极管建模成跨导：电压控制，跨导和集电极电流成比例关系，常用于SPICE模型仿真和高频电路的理论计算中</p>
<p>上面提到了<strong>β值</strong>，这可以说是三极管最重要的性能指标了，它的正式名称为<strong>共射极电流增益</strong>，<strong>在正向有源区近似于c极直流电流和b极直流电流的比值</strong>；另一个重要参数是<strong>共基极电流增益α</strong>，<strong>在正向有源区近似于从发射极到集电极的电流增益</strong>，其值一般接近于1。相关公式如下<br>$$<br>\alpha=\frac{I_C}{I_E} \<br>\beta=\frac{I_C}{I_B} \<br>I_E=I_B+I_C \<br>\beta=\frac{\alpha}{1-\alpha} \<br>\alpha=\frac{\beta}{1-\beta}<br>$$</p>
<blockquote>
<p>BJT是非对称器件，因此当把c、e极互换后BJT会工作在反向有源模式，一般不会这样使用BJT，它的内部结构也为正向有源模式进行了优化。在CMOS制造工艺中，常常使用低性能的“横向”对称BJT，这是为了平衡成本（硅片面积）和性能</p>
</blockquote>
<p>在应用方面，可以直接通过三极管的工作电流电压测出其β值：$\beta=\frac{\Delta i_c}{\Delta i_b}$</p>
<p><strong>三极管的be结电阻</strong>也是一个重要参数，它需要使用半导体物理的公式得出：<br>$$<br>R_{BE}=r_{bb’}+\frac{26mV}{I_{BQ}}<br>$$<br>其中r<del>bb’</del>是三极管的基区电阻，这是一个大致在100~200Ω之间的常数，只与三极管的制造工艺有关，它加上PN结电阻，也就是后面那部分就可以得到be结总电阻了</p>
<h3 id="很多复杂的性质"><a href="#很多复杂的性质" class="headerlink" title="很多复杂的性质"></a>很多复杂的性质</h3><p>因为很复杂，所以跳过！</p>
<p>三极管的性质太多了，而这些性质造就了它的多种用途。可以说现代中小功率模拟电路就是建立在三极管之上的；而大功率模拟电路则被场效应管所掌控</p>
<p>下一部分会详细讲述三极管的基本应用。这里先了解一下三极管的基本工作区域和输入输出性质（以NPN为例）</p>
<p>BJT有5个不同的工作区，列举如下：</p>
<ol>
<li><strong>正向有源（正偏）</strong>：V<del>c</del>&gt;V<del>b</del>&gt;V<del>e</del>，$I_C=\beta I_B$，水龙头把手在开合范围内，可以控制水流大小。be结正偏，bc结反偏</li>
<li><strong>饱和（完全导通）</strong>：V<del>b</del>&gt;V<del>e</del>，V<del>c</del>&lt;V<del>b</del>，b极电压超过了c极电压，就像是手把水龙头开到最大，水龙头把手都扭歪了，自然水会喷涌而出，这时三极管c极电流会达到最大。所有PN结正偏，常用于实现逻辑电路中的开关闭合</li>
<li><strong>截止</strong>：V<del>b</del>&lt;V<del>e</del>，水龙头被关上，BJT的c极电流近似于0，属于漏电流；e极电流则近似等于b极电流。所有PN结反偏，可以实现逻辑电路中的开关断开</li>
<li><strong>反向有源（反偏）</strong>：V<del>c</del>&lt;V<del>b</del>&lt;V<del>e</del>，反向电流通过三极管，相当于把c、e极对调。实际中很少使用该模式，因为β值会小得多，相当于三极管内阻被放大了。集成电路中可能会在某些地方用到（大概）</li>
<li><strong>雪崩击穿</strong>：俗称炸管，一般来说三极管被击穿会直接烧毁，因为两个PN结的性质不可能完全一致，这就导致但凡电流过大一点，一个PN结不会被烧毁，另一个一定会被烧掉！三极管的耐压规定了ce、be电压的最大值，选型前一定要注意</li>
</ol>
<p>PNP型三极管的性质和NPN型的性质正好对偶，有兴趣的读者可以自行证明PNP三极管的相关性质</p>
<blockquote>
<p>自证不难</p>
</blockquote>
<p>下面是经典的小信号通用三极管S8050的datasheet</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210831013945373.png" alt="image-20210831013945373"></p>
<p>它使用了经典的TO-92封装，在很多收音机里都能见到这个NPN开关管的身影。</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210831014034027.png" alt="image-20210831014034027"></p>
<p>耐压be 5V；ce 20V；cb 30V。也就是说最好驱动电压不要超过5V，如果使用独立电源为三极管供电，电源也不能超过20V</p>
<p>c极电流700mA，算是开关管里面比较大的，能够驱动一些小型的功率设备了</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210831014222806.png" alt="image-20210831014222806"></p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210831014318634.png" alt="image-20210831014318634"></p>
<p><strong>开关管是指用于充当开关元件的三极管</strong>，也就是说它会工作在截止-导通两个状态下，因此其最重要属性就是开关频率，其次才是增益</p>
<p>而<strong>功率管是指专门用于功率放大的三极管</strong>，它会一直工作在正偏状态下，其最重要属性是增益</p>
<p><strong>通用管是指介于二者之间，能够在一定范围内通用使用的三极管</strong>，在各种各样的电路里都能见到这种三极管，它们的性能指标比较均衡，一般来说两个不同型号的通用管是很有可能相互取代的</p>
<p>可以从output capacitance输出电容看出s8050的开关频率：1MHz下为9pF，一般来说工作在几十kHz可以达到更低的电容量，属于工作在中频的三极管。它的增益在120到400之间，取200的中间值，属于放大性能一般的三极管。s8050就是这样一个中庸的三极管，各种地方都能使用，因此它的出货量很大，价格便宜。生产商也很多。</p>
<p>**DC Current Gain指的就是β值了，在大多数数据手册里面，这个参数被称为$h_{FE}$或$HFE$**，可以看出这个管子的β在120~400，算是性能中庸的</p>
<p>特别提一下current gain bandwidth product电流增益带宽积：放大器带宽和带宽的增益的乘积，在频率足够大时是一个常数，三极管的CGBP其实没有什么用，<em>在高频运算放大器中可以指示放大器的性能</em></p>
<h2 id="场效应管"><a href="#场效应管" class="headerlink" title="场效应管"></a>场效应管</h2><p>场效应管（FET，Field Effet Transistor）和三极管一样，同属于晶体管大家族，其中比较常用的就是MOSFET金属氧化物半导体场效应管（Metal Oxide Semiconductor Field Effect Transistor），它常常以互补金属氧化物半导体（CMOS，Complementary Metal Oxide Semiconductor）的形式出现在数字集成电路中，抑或是以直插功率元件的形式出现在开关电源里。下面对它进行简单的介绍（<em>下面全部使用简称</em>MOSFET或JFET）</p>
<p>由于MOSFET涉及的知识点较多，在这里只进行总体介绍，在后面的博文里会详细谈到MOSFET相关内容</p>
<h3 id="电场效应"><a href="#电场效应" class="headerlink" title="电场效应"></a>电场效应</h3><p>就像四大天王有五个一样，三端元件MOSFET有四个端子，除了<strong>源极s</strong>（<strong>S</strong>ource）、<strong>栅极g</strong>（<strong>G</strong>ate）、<strong>漏极d</strong>（<strong>D</strong>rain）外，还有一个俗称<em>衬底</em>的<strong>体极b</strong>（<strong>B</strong>ody）。一般来说衬底是连接到源极的，因此它表面上和其他三端元件一样。</p>
<p>MOSFET与BJT不同，是电压控制电流器件，它通过施加在栅极上的电压来控制从源极到漏极的电流；同时MOSFET是多子载流器件。BJT需要的开启电流大，开启电压小，能提供给负载的驱动电流也较小；但是MOSFET开启电压大，开启电流小（漏电流也相当小），可以给负载提供很大的电流</p>
<blockquote>
<p>你知道吗？高铁、电磁炮、<del>御坂美琴</del>常用于控制电流的绝缘栅双极型晶体管IGBT就是用三极管和MOSFET复合而成的，其中三极管负责对信号进行放大，通过特制的续流二极管芯片进行隔离，驱动负责导通/关断大电流的MOSFET，兼顾了MOSFET的高输入阻抗和BJT的低导通压降，同时由于是复合管，增益直接爆炸。将其与外围电路封装成模块，常用于控制400V、100A及以上的强电系统！</p>
</blockquote>
<p>MOSFET分为四种：N沟道-P沟道、增强型-耗尽型。这里先不解释它们的含义，我们先来看它的结构：</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901010858481.png" alt="image-20210901010858481"></p>
<p>MOSFET就是一个沿用了真空管三极称呼的器件：因为它本质上就是一个使用电场效应替代电子射线的真空管。解释一下它的名称由来：</p>
<ul>
<li>M代表Metal金属，曾经MOSFET使用金属材料制作栅极，但是现在处于生产便利考虑使用<strong>多晶硅</strong>，因为它能生成自对齐的栅极。现在只有高频MOSFET才会使用金属栅极来提高工作速度（事实上当前速度最快的FINFET工艺采用的仍是硅晶体，在某种程度上说金属应该是个“误解”）</li>
<li>O代表氧化物，目前这也变成了一个“误区”，因为现代的MOSFET会使用各种不同的绝缘材料，目前比较常用的其实是高k绝缘体。这样做的原因只有一个：降低MOSFET的开启电压，提高s-d电流，尽可能降低g极漏电流。<strong>使用xx nm衡量半导体工艺，一般来说这个长度是指MOSFET的沟道宽度</strong>，因为<em>沟道宽度</em>（在之后会解释沟道）减少时，漏电流就会增加；反之，漏电流减少、供电电压降低，意味着MOSFET的性能得到提高</li>
<li>S代表半导体，现代MOSFET的制作工艺就基于半导体材料：在硅衬底顶部生长一层硅氧化物（或其他什么绝缘/半导材料），再沉淀一层金属或多晶硅，就能获得传统的MOSFET了。现在一些厂商开始在MOSFET的沟道中使用硅和锗的化合物，也有一些科研人员在探索新的半导体材料（石墨烯、氮化镓等等），并将其应用在MOSFET上。</li>
<li>FET：场效应，就是所谓的“电场效应”。传统MOSFET等效于一个电容器，一个电极是半导体硅衬底，一个电极是多晶硅。这里先考虑使用的衬底是P型半导体（作为b极），当给金属/多晶硅（作为g极）施加外电压（正电压）时，带有正电荷的空穴就会远离g极和氧化物的中间区域，但是因为整体是个电容，电荷并不会从g极流出。这就创造了一个<strong>耗尽层</strong>，在这个区域里自由载流子无法移动。当g-b电压足够大时，会在靠近半导体和绝缘体之间薄薄一层形成高浓度的负电荷载流子区域，称为<strong>反转层</strong>。将反转层内电子体积密度和体内空穴密度相等的电压称为<strong>阈值电压</strong>。当g-b电压超过阈值电压时，就会形成反转层，此使MOSFET开启，对应的电压称为<strong>开启电压</strong>。而通过外加g-b电压形成反转层导致MOSFET开启的这个过程就称为<strong>电场效应</strong>。</li>
</ul>
<p>真空三极管使用通电的灯丝放出电子流；MOSFET使用场效应开启反转层，在氧化物绝缘层下方生成一个载流子浓度极高可以导电的区域</p>
<p>真空三极管使用栅极（实质上是通过栅极外加电压）控制到达屏极的电子数量，从而控制电流；MOSFET使用栅极电压控制场效应的强度，进而控制反转层的载流子浓度，从而控制s-d电流。</p>
<p>真空三极管的阴极和阳极具有单向导电性；MOSFET的d极和b极（衬底）之间存在一个寄生二极管，某种程度上也存在单向导电性</p>
<p>从上面可以看到MOSFET的性质和真空管的性质十分接近，这也是它沿用了栅极名称的原因之一。</p>
<p>MOSFET的原理就是利用g极的电场效应在绝缘层下方开启一个导电沟道，从而让s-d极能够导电。<strong>增强型MOSFET</strong>就是指随着g极电场增强，进入沟道的载流子增多，导电性增加；<strong>耗尽型MOSFET</strong>则是利用一个<em>表面掺杂层</em>中的载流子构成导电沟道，随着g极电场增强，外电场会抵消掉来自表面掺杂层的载流子，导电性减弱。在g极和衬底之间施加电压时，电场会先导致半导体层中出现电荷分离的情况，根据<strong>衬底中半导体掺杂</strong>的不同，可将MOSFET分为PMOS和NMOS。<strong>NMOS</strong>结构就是上述过程所形容的；而<strong>NMOS</strong>在被施以外部电场时，电子作为少子会被聚集在氧化物底层，但是因为密度太小并不能形成反转层，因此NMOS必须施加<em>b正g负</em>的反向电场，这样多子空穴会聚集并形成反转层。上面的四个MOSFET结构可以组合起来，成为四种基本的MOSFET</p>
<ul>
<li>增强型NMOS</li>
<li>耗尽型NMOS</li>
<li>增强型PMOS</li>
<li>耗尽型PMOS</li>
</ul>
<p>它们的电路符号如下所示：</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901020726001.png" alt="image-20210901020726001"></p>
<p>用一条竖线表示导电沟道，另一条短竖线表示g极的半导体</p>
<p>需要注意的是g极呈现“L”型，它的输入引脚更靠近s极，用来显著地指示方向——如果使用简化的图标，也要用箭头标明s极</p>
<p><strong>b极（s极）上会注明一个箭头，它永远指向从P到N的方向</strong>，因此它用来指示PMOS/NMOS（<strong>PMOS向外指；NMOS向内指</strong>，具体原因留给读者自行考虑）</p>
<blockquote>
<p>思考题答案：因为箭头永远指向N，只要沟道是N，那箭头就会指向沟道，也就是向内指了；P沟道则相反</p>
</blockquote>
<p>一般来说MOSFET会通过一个竖线将衬底和s极连在一起，如下图所示</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901021103401.png" alt="image-20210901021103401"></p>
<p>这就表示衬底和源极连在一起引出。</p>
<p>有的时候MOSFET会在d极和s极之间跨接一个二极管标识，这常用于开关电路或者高频电路中的MOSFET表示</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901021550063.png" alt="image-20210901021550063"></p>
<p>实际上这个二极管指的是MOSFET的<strong>寄生二极管</strong>，正是因为这个二极管，导致大功率下MOSFET具有一定的单向导电性和复杂电气特性</p>
<blockquote>
<p>大功率MOS管d极从硅片衬底底部引出，而s极被放在衬底底部的另一半，d极和s极都由不同种类的半导体材料制成，如下图所示</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901022016180.png" alt="image-20210901022016180"></p>
<p>这就导致了N-P-N之间出现了PN结，上图中左侧的PN结由于b-s短接而无效，右侧的b-&gt;d的PN结则相当于一个从b极接到d极的二极管，对于NMOS来说也是如此，<strong>总会存在一个与箭头方向（箭头指示P-&gt;N）相同的寄生二极管</strong></p>
</blockquote>
<p>寄生二极管并不是大功率MOSFET独有的，只要是NPN或PNP型的MOSFET都会存在PN结，只要有PN结就会或多或少存在寄生二极管。上图中s、d区是由不同于衬底的掺杂半导体制成的，这个工艺的原理在下面讲述</p>
<h3 id="增强型MOSFET"><a href="#增强型MOSFET" class="headerlink" title="增强型MOSFET"></a>增强型MOSFET</h3><p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901231358388.png" alt="image-20210901231358388"></p>
<p>上图是增强型N沟道MOS的结构，将N和P型半导体调换，即可得到增强型P沟道MOS的结构</p>
<p>一般使用W表示栅极宽度，使用L表示栅极长度，因为绝缘层非常薄，所以栅极长度和沟道长度近似相等，它也称为沟道宽度。<strong>栅极、源极、漏极之间的重叠区域要求保证反转层可以在源极和漏极之间形成连续的导电通道，为了减少寄生电容，这个重叠区域要尽量小</strong>。现代的NMOS与传统MOSFET的最大不同就是通过引入两个P型半导体电极降低了沟道开启所需电压。</p>
<p>需要注意：一般N型半导体上方引出电极使用金属铝</p>
<p>PMOS和NMOS结构大同小异，二者最大的不同在于形成的导电沟道方向和寄生二极管方向——由于MOSFET内部N-P型半导体交界耗尽区而形成的沟道外延被称为<strong>诱生沟道</strong></p>
<p>增强型MOSFET的工作模式有以下几种：</p>
<ol>
<li><p><strong>截止模式</strong></p>
<p> V<del>GS</del>&lt;V<del>th</del>（阈值电压）。此时不会形成s-d之间的导电通路，也就是<strong>导电沟道无法开启</strong>。但是由于电子能量的玻尔兹曼分布，s极的一些高能量电子可以进入沟道并扩散到d极。同样的，理想情况下d-s电流应为0，但是存在<strong>弱反转电流</strong>，它与V<del>GS</del>-V<del>th</del>成正指数关系，与斜率因子n=1+耗尽层电容/氧化物层电容成负指数关系。在集成电路中，还需要考虑短沟道的<strong>漏极势垒降低</strong>（Drain Induced Barrier Lowering，<strong>DIBL</strong>）效应，这个效应的强弱和器件的几何形状、PN结掺杂等有关，这个效应既有利也有弊：微功耗模拟电路利用低于阈值条件的优势，使得MOSFET可以尽可能提供较高的跨导-电流比值，甚至能和BJT一较高下。但是一般情况下，低于阈值的伏安特性会导致产品一致性难以保证</p>
</li>
<li><p><strong>欧姆模式</strong>（线性模式、线性区）</p>
<p> 当$V_{GS}&gt;V_{th}$且$V_{DS}&lt;(V_{GS}-V_{th})$时，MOS闭合，<strong>导电沟道开启，但是没有完全开启</strong>。<em><strong>此时MOSFET就像一个电阻</strong></em>：s-d电流可以使用以下公式表述<br> $$<br> I_D=\mu_n C_{ox} \frac{W}{L} [(V_{GS}-V_{th})V_{DS} - \frac{V^2_{DS}}{2}]<br> $$<br> μ<del>n</del>表示电荷载流子有效迁移率，其他参数就是字面意思（请读者翻看上文并理解各个符号的含义）</p>
<p> 可以看出s-d电流和ds电压具有相关性，进一步推到可以发现这个曲线相当接近直线，也就是说在欧姆模式，MOSFET可以起到类似电阻的作用，从而实现电流-电压控制</p>
</li>
<li><p><strong>饱和模式</strong></p>
<p> 当$V_{GS}&gt;V_{th}$且$V_DS&gt;(V_{GS}-V_{th})$，生成一条沟道以允许在d极和s极之间流过电流，也就是<strong>导电沟道完全开启</strong>。由于d极电压大于g极电压，电子会顺势扩散，<em>在该工作模式下，MOSFET的d-s极近乎短路</em></p>
</li>
</ol>
<p>增强型MOSFET还有几个性质：</p>
<ol>
<li><p>转移特性    </p>
<p> s-d电压恒定时，测量g-s两端电压和d极电流之间的关系</p>
<p> 实际上就是二端口网络的转移特性矩阵实例</p>
<p> <img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901235023213.png" alt="image-20210901235023213"></p>
</li>
<li><p>输出特性</p>
<p> g-s电压恒定时，s-d电压和d极电流之间的关系（输出特性矩阵实例）</p>
<p> <img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901235011715.png" alt="image-20210901235011715"></p>
</li>
<li><p>温度特性</p>
<p> 随温度升高，流经d极的电流会逐渐下降</p>
</li>
</ol>
<h3 id="耗尽型MOSFET"><a href="#耗尽型MOSFET" class="headerlink" title="耗尽型MOSFET"></a>耗尽型MOSFET</h3><p>耗尽型MOSFET与增强型MOSFET原理上最大的不同就是它使用了实实在在的“沟道”</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210901235247565.png" alt="image-20210901235247565"></p>
<p>如上图，耗尽型PMOS的两个P型半导体之间额外沉积了一层薄薄的P半导体沟道，因此PN结的耗尽层在沟道下方出现，当V<del>GS</del>&lt;0时，沟道中的空穴会被排斥出沟道进入耗尽层，并与其中的电子中和，这样使得P型半导体沟道中的载流子浓度大减，沟道会变窄——如果更进一步，沟道附近的衬底会称为缺P型，导电能力增强，但<strong>沟道的导电能力会变得近乎没有</strong>。这就实现了“耗尽”的目的。沟道失去导电性的瞬间称为“<strong>沟道夹断</strong>”</p>
<p>从应用上看，耗尽型MOSFET相当于对增强型MOSFET进行了“非运算”，高V<del>GS</del>会开启增强型MOS，但是会夹断耗尽型MOSFET</p>
<blockquote>
<p>利用增强型-耗尽型MOSFET的互补性可以实现MOSFET图腾柱电路：两个MOSFET的d-s极首尾相连，最上面的MOSFET的s极引出到电源，下面的MOSFET则引到地，这样使用一个“不高不低”的电压就能够实现放大作用；使用高/低电平则会让二者之一导通，实现最大的开关性能。该电路也可以使用NPN-PNP三极管对管或者NMOS-PMOS对管实现</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210902000134796.png" alt="image-20210902000134796"></p>
<p>这个电路常常被用来作为电机、功率设备的驱动电路，三个相同的电路接到三相电上还可以实现H桥架构，进而驱动三相电机</p>
</blockquote>
<h3 id="小号继电器"><a href="#小号继电器" class="headerlink" title="小号继电器"></a>小号继电器</h3><p>MOSFET因为较低的启动电压和高输入阻抗，常常被用来<strong>作为继电器在非隔离情形下的替代品</strong></p>
<p>但是由于MOSFET的导通电压一般比数字IC能提供的更高，所以在使用之前也应该在IO处接入一个光耦-三极管放大电路或者直接接入一个三极管推完结构进行电流、电压放大，从而让弱输出能够驱动MOSFET</p>
<p>使用方法还挺像继电器的，但是二者的性能、功耗可不一样——MOSFET的开关频率比继电器高出两个数量级，功耗也比继电器低多了，同时还不会造成太大的电路噪声干扰，如果遇到需要隔离但是功率不大的情况，应该优先选择MOSFET而不是继电器</p>
<h3 id="功率半导体器件"><a href="#功率半导体器件" class="headerlink" title="功率半导体器件"></a>功率半导体器件</h3><p>简单说一下达林顿管和IGBT吧</p>
<p><strong>达林顿管=叠在一起的三极管</strong></p>
<p><strong>IGBT=叠在一起的三极管和MOSFET</strong></p>
<p>实际上的达林顿管是使用集成电路工艺制造的，将多个三极管制造在同一片晶圆上。但是还会针对PN结的性能进行优化。比较特殊的就是<strong>达林顿管的极性和前面三极管的极性保持一致</strong>，而不管后续接入的三极管是什么极性。因此前面的小管被称为达林顿<strong>基管</strong>；后面的小管被称为达林顿<strong>放大管</strong>。达林顿管以最前面小管的基极为整管基极，以最后接入的三极管发射极为整管发射极，<strong>最后的放大倍数是所有叠加的三极管放大倍数的乘积</strong><br>$$<br>\beta = \beta_1 \beta_2<br>$$<br>因此，达林顿管的功率、发热都会非常大，常用于驱动小型继电器、舵机、直流电机等等</p>
<p>IGBT则是典型的模拟集成电路结晶。博采众长，结合了三极管的低导通压降和MOS管的高输入阻抗，在不超过限制电压电流的情况下可以直接作为继电器使用——不过还是要注意，它的输出和输入之间还是存在耦合电阻的！</p>
<p>IGBT的结构就是一个三极管和一个MOSFET竖向叠起来，从MOSFET最上层两个隔开的栅极上引出IGBT的E极，MOSFET的P区同时作为三极管的B极P区，但是在三极管基础上多增加了一层B极N区和N缓冲区，主要用于存储电子，最下面一层是P+层，从它上面引出IGBT的C极</p>
<p><img src="/2021/11/14/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E7%A1%80%E6%99%B6%E4%BD%93%E7%AE%A1%E3%80%91/image-20210930000527652.png" alt="image-20210930000527652"></p>
<p>如上图所示（N沟道增强型IGBT），MOSFET部分的N+区称为<strong>源区</strong>，附于其上的电极称为源极，被引出作为IGBT的发射极E；N基极又称<strong>漏区</strong>D。为了区分IGBT和MOSFET，将同位置引出的G极翻译成<strong>门极</strong>，与MOSFET不同，IGBT的门极是悬浮在绝缘介质中的，并直接引出。沟道会在紧靠门极的边界形成。C、E两极之间的P型区（包括P+和P-区）被称为亚沟道区，事实上的沟道在这个区域形成。在漏区另一侧的P+区称为<strong>漏注入区</strong>，它是IGBT特有的功能区，与漏区和亚沟道区一起形成PNP双极型晶体管，起到其中发射极E的作用，向漏极注入空穴，进行导电调制，以降低器件的导通电压。最后，附于漏注入区上的电极称为漏极（也就是对应三极管的集电极C）。</p>
<p>IGBT的开关作用是通过<strong>加正向栅极电压形成沟道</strong>，<strong>给PNP</strong>（原来为NPN，但经过与IGBT耦合后，极性反转）<strong>晶体管提供基极电流，使IGBT导通</strong>。反之，可以加反向门极电压消除沟道，切断基极电流，使IGBT关断。IGBT的驱动方法和MOSFET基本相同，只需控制输入极N-沟道MOSFET即可，毕竟它控制的电流的第一步就是驱动一个栅极,所以IGBT具有高输入阻抗特性。当MOSFET的沟道形成后，从P+基极注入到N-层的空穴（少子）对N-层进行电导调制，减小N-层的电阻，使IGBT在高电压时也具有相对较低的导通电压</p>
]]></content>
      <tags>
        <tag>电路设计</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32_IDF学习2【WiFi】</title>
    <url>/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A02%E3%80%90WiFi%E3%80%91/</url>
    <content><![CDATA[<h1 id="WiFi外设配置"><a href="#WiFi外设配置" class="headerlink" title="WiFi外设配置"></a>WiFi外设配置</h1><p>ESP32/8266的Wi-Fi库支持配置及监控Wi-Fi连网功能</p>
<p>相关内容参考乐鑫的ESP32/8266文档<a href="https://docs.espressif.com/projects/esp-idf/zh_CN/release-v4.1/api-reference/network/esp_wifi.html">https://docs.espressif.com/projects/esp-idf/zh_CN/release-v4.1/api-reference/network/esp_wifi.html</a></p>
<h2 id="基本模式"><a href="#基本模式" class="headerlink" title="基本模式"></a>基本模式</h2><ol>
<li><p>基站模式（又称<strong>STA模式</strong>或Client模式）：将ESP连接到附近的AP，此时<strong>相当于ESP在蹭网</strong></p>
</li>
<li><p><strong>AP模式</strong>（又称Soft-AP模式或Server模式）：将ESP设置为AP，可供周围设备连接，此时<strong>相当于ESP开热点</strong></p>
</li>
<li><p>AP-STA<strong>共存模式</strong>：ESP32既是接入点，同时又作为基站连接到另外一个接入点，此时<strong>相当于ESP连着隔壁wifi开热点给自家用</strong></p>
</li>
</ol>
<p>同时支持以上模式的安全模式（WPA、WPA2、WEP等），可以理解成<strong>安全蹭网</strong></p>
<span id="more"></span>

<h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><ol>
<li>主动/被动扫描附近AP，<strong>主动找别人家网蹭</strong></li>
<li>使用混杂模式监控IEEE802.11 Wi-Fi数据包，<strong>可以理解成ESP能看到你上了什么不可描述的网站</strong></li>
</ol>
<h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2><ol>
<li>初始化与设置</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">esp_wifi_init(<span class="keyword">const</span> <span class="keyword">wifi_init_config_t</span> *config)<span class="comment">//WiFi功能初始化，config为初始化结构体句柄</span></span><br><span class="line">esp_wifi_set_config(<span class="keyword">wifi_interface_t</span> interface, <span class="keyword">wifi_config_t</span> *conf)<span class="comment">//使能设置</span></span><br><span class="line">esp_wifi_set_mode(<span class="keyword">wifi_mode_t</span> mode)<span class="comment">//模式设置</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//可如下配置</span></span><br><span class="line">WIFI_MODE_NULL=<span class="number">0</span></span><br><span class="line">WIFI_MODE_STA<span class="comment">//STA模式</span></span><br><span class="line">WIFI_MODE_AP<span class="comment">//软AP模式</span></span><br><span class="line">WIFI_MODE_APSTA<span class="comment">//混合模式</span></span><br><span class="line">WIFI_MODE_MAX</span><br><span class="line">    </span><br><span class="line">esp_wifi_get_mode(<span class="keyword">wifi_mode_t</span> *mode)<span class="comment">//获取当前模式</span></span><br><span class="line">esp_wifi_get_config(<span class="keyword">wifi_interface_t</span> interface, <span class="keyword">wifi_config_t</span> *conf)<span class="comment">//获取当前设置</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>关闭WiFi</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">esp_wifi_stop()<span class="comment">//STA模式下断开wifi连接，AP模式下关闭热点并释放内存，共用模式下断开连接并关闭热点</span></span><br><span class="line">esp_wifi_deinit()<span class="comment">//释放曾在esp_wifi_init中申请的资源并停止WiFi工作，不需要wifi功能时可以使用</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>连接/断开WiFi</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 用于STA模式 */</span></span><br><span class="line">esp_wifi_connect()<span class="comment">//连接WiFi</span></span><br><span class="line">esp_wifi_disconnect()<span class="comment">//断开WiFi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用于AP模式 */</span></span><br><span class="line">esp_wifi_deauth_sta(<span class="keyword">uint16_t</span> aid)<span class="comment">//停止对接入设备的授权——不让别人蹭网</span></span><br><span class="line">esp_wifi_ap_get_sta_aid(<span class="keyword">const</span> <span class="keyword">uint8_t</span> mac[<span class="number">6</span>], <span class="keyword">uint16_t</span> *aid)<span class="comment">//获取当前接入的设备信息</span></span><br><span class="line">esp_wifi_ap_get_sta_list(<span class="keyword">wifi_sta_list_t</span> *sta)<span class="comment">//获取当前接入的设备列表</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>扫描附近</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">esp_wifi_scan_start(<span class="keyword">const</span> <span class="keyword">wifi_scan_config_t</span> *config, <span class="keyword">bool</span> block)<span class="comment">//扫描AP以蹭网</span></span><br><span class="line"><span class="comment">/* 推荐最大扫描时间为1500ms */</span></span><br><span class="line">esp_wifi_scan_stop()<span class="comment">//在途中停止扫描</span></span><br><span class="line">esp_wifi_scan_get_ap_num(<span class="keyword">uint16_t</span> *number)<span class="comment">//获得最后一次扫描得到的AP号码</span></span><br><span class="line">esp_wifi_scan_get_ap_records(<span class="keyword">uint16_t</span> *number, <span class="keyword">wifi_ap_record_t</span> *ap_records)<span class="comment">//获取扫描记录</span></span><br><span class="line">esp_wifi_sta_get_ap_info(<span class="keyword">wifi_ap_record_t</span> *ap_info)<span class="comment">//获取当前连接wifi的相关信息</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//返回如下结构体的指针</span></span><br><span class="line"><span class="keyword">uint8_t</span> bssid[<span class="number">6</span>]<span class="comment">//MAC地址</span></span><br><span class="line"><span class="keyword">uint8_t</span> ssid[<span class="number">33</span>]<span class="comment">//SSID</span></span><br><span class="line"><span class="keyword">uint8_t</span> primary<span class="comment">//AP通道</span></span><br><span class="line"><span class="keyword">wifi_second_chan_t</span> second<span class="comment">//AP第二通道</span></span><br><span class="line"><span class="keyword">int8_t</span> rssi<span class="comment">//信号强度</span></span><br><span class="line"><span class="keyword">wifi_auth_mode_t</span> authmode<span class="comment">//认证模式</span></span><br><span class="line"><span class="keyword">wifi_cipher_type_t</span> pairwise_cipher<span class="comment">//PTK成对传输密钥，用于单播数据帧的加密解密</span></span><br><span class="line"><span class="keyword">wifi_cipher_type_t</span> group_cipher<span class="comment">//GTK组临时密钥，用于组播数据帧和广播数据帧的加密和解密</span></span><br><span class="line"><span class="keyword">wifi_ant_t</span> ant<span class="comment">//用于接收信号的天线引脚</span></span><br><span class="line"><span class="comment">/* 相关控制寄存器位 */</span></span><br><span class="line"><span class="keyword">uint32_t</span> phy_11b : <span class="number">1</span><span class="comment">//11b模式开启标志</span></span><br><span class="line"><span class="keyword">uint32_t</span> phy_11g : <span class="number">1</span><span class="comment">//11g模式开启标志</span></span><br><span class="line"><span class="keyword">uint32_t</span> phy_11n : <span class="number">1</span><span class="comment">//11n模式开启标志</span></span><br><span class="line"><span class="keyword">uint32_t</span> phy_lr : <span class="number">1</span><span class="comment">//低频模式开启标志</span></span><br><span class="line"><span class="keyword">uint32_t</span> wps : <span class="number">1</span><span class="comment">//WPS支持情况标志</span></span><br><span class="line"><span class="keyword">uint32_t</span> reserved : <span class="number">27</span><span class="comment">//寄存器保留位</span></span><br><span class="line"><span class="comment">/* 相关控制寄存器位 */</span></span><br><span class="line"><span class="keyword">wifi_country_t</span> country<span class="comment">//AP的国家信息</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>操作系统相关</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">esp_wifi_set_event_mask(<span class="keyword">uint32_t</span> mask)<span class="comment">//设置事件掩码</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>其他</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">esp_wifi_set_protocol(<span class="keyword">wifi_interface_t</span> ifx, <span class="keyword">uint8_t</span> protocol_bitmap)<span class="comment">//设置特殊接口的协议类型</span></span><br><span class="line"><span class="comment">//可选WIFI_PROTOCOL_11B、WIFI_PROTOCOL_11G、WIFI_PROTOCOL_11N)</span></span><br><span class="line">esp_wifi_get_protocol(<span class="keyword">wifi_interface_t</span> ifx, <span class="keyword">uint8_t</span> *protocol_bitmap)<span class="comment">//获取当前协议类型</span></span><br><span class="line">    </span><br><span class="line">sp_wifi_set_bandwidth(<span class="keyword">wifi_interface_t</span> ifx, <span class="keyword">wifi_bandwidth_t</span> bw)<span class="comment">//设置带宽</span></span><br><span class="line">esp_wifi_get_bandwidth(<span class="keyword">wifi_interface_t</span> ifx, <span class="keyword">wifi_bandwidth_t</span> *bw)<span class="comment">//获取当前带宽</span></span><br><span class="line">    </span><br><span class="line">sp_wifi_set_channel(<span class="keyword">uint8_t</span> primary, <span class="keyword">wifi_second_chan_t</span> second)<span class="comment">//设置primary/secondary通道</span></span><br><span class="line">esp_wifi_get_channel(<span class="keyword">uint8_t</span> *primary, <span class="keyword">wifi_second_chan_t</span> *second)<span class="comment">//获取当前使用的通道</span></span><br><span class="line">    </span><br><span class="line">esp_wifi_set_country(<span class="keyword">const</span> <span class="keyword">wifi_country_t</span> *country)<span class="comment">//设置当前的国家信息</span></span><br><span class="line">esp_wifi_get_country(<span class="keyword">wifi_country_t</span> *country)<span class="comment">//获取当前的国家信息</span></span><br><span class="line">    </span><br><span class="line">esp_wifi_set_mac(<span class="keyword">wifi_interface_t</span> ifx, <span class="keyword">const</span> <span class="keyword">uint8_t</span> mac[<span class="number">6</span>])<span class="comment">//设置当前mac地址</span></span><br><span class="line">esp_wifi_get_mac(<span class="keyword">wifi_interface_t</span> ifx, <span class="keyword">uint8_t</span> mac[<span class="number">6</span>])<span class="comment">//获取当前mac地址</span></span><br><span class="line">    </span><br><span class="line">esp_wifi_set_ant_gpio(<span class="keyword">const</span> <span class="keyword">wifi_ant_gpio_config_t</span> *config)<span class="comment">//设置天线引脚</span></span><br><span class="line">esp_wifi_get_ant_gpio(<span class="keyword">wifi_ant_gpio_config_t</span> *config)<span class="comment">//获取当前天线引脚</span></span><br><span class="line">esp_wifi_set_ant(<span class="keyword">const</span> <span class="keyword">wifi_ant_config_t</span> *config)<span class="comment">//设置天线设定</span></span><br><span class="line">esp_wifi_get_ant(<span class="keyword">wifi_ant_config_t</span> *config)<span class="comment">//获取当前天线设定</span></span><br><span class="line">    </span><br><span class="line">esp_wifi_set_promiscuous(<span class="keyword">bool</span> en)<span class="comment">//使能混杂模式</span></span><br><span class="line">esp_wifi_get_promiscuous(<span class="keyword">bool</span> *en)<span class="comment">//获取混杂模式</span></span><br><span class="line">esp_wifi_set_promiscuous_filter(<span class="keyword">const</span> <span class="keyword">wifi_promiscuous_filter_t</span> *filter)<span class="comment">//设置混杂模式过滤器，默认过滤除WIFI_PKT_MISC外的包</span></span><br><span class="line">esp_wifi_get_promiscuous_filter(<span class="keyword">wifi_promiscuous_filter_t</span> *filter)<span class="comment">//获取混杂模式过滤器</span></span><br><span class="line">esp_wifi_set_promiscuous_ctrl_filter(<span class="keyword">const</span> <span class="keyword">wifi_promiscuous_filter_t</span> *filter)<span class="comment">//使能混杂类型过滤器的子类型过滤</span></span><br><span class="line">esp_wifi_get_promiscuous_ctrl_filter(<span class="keyword">wifi_promiscuous_filter_t</span> *filter)<span class="comment">//获取混杂类型过滤器的子类型过滤</span></span><br><span class="line">esp_wifi_set_promiscuous_rx_cb(<span class="keyword">wifi_promiscuous_cb_t</span> cb)<span class="comment">//设置混杂模式监控回调函数  </span></span><br></pre></td></tr></table></figure>

<ol start="8">
<li>低功耗相关</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">esp_wifi_set_inactive_time(<span class="keyword">wifi_interface_t</span> ifx, <span class="keyword">uint16_t</span> sec)<span class="comment">//设置暂时休眠时间</span></span><br><span class="line">esp_wifi_get_ant(<span class="keyword">wifi_ant_config_t</span> *config)<span class="comment">//获取暂时休眠时间</span></span><br></pre></td></tr></table></figure>

<p>特征：大部分API都有对应的set和get两个方向，需要回传数据时使用get*，初始设置时使用set*</p>
<h3 id="AP模式初始化"><a href="#AP模式初始化" class="headerlink" title="AP模式初始化"></a>AP模式初始化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wifi_init_softap</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ESP_ERROR_CHECK(esp_netif_init());</span><br><span class="line">    ESP_ERROR_CHECK(esp_event_loop_create_default());</span><br><span class="line">    </span><br><span class="line">    esp_netif_create_default_wifi_ap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wifi_init_config_t</span> cfg = WIFI_INIT_CONFIG_DEFAULT();</span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_init(&amp;cfg));</span><br><span class="line">    ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT,</span><br><span class="line">                                                        ESP_EVENT_ANY_ID,</span><br><span class="line">                                                        &amp;wifi_event_handler,</span><br><span class="line">                                                        <span class="literal">NULL</span>,</span><br><span class="line">                                                        <span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wifi_config_t</span> wifi_config = &#123;</span><br><span class="line">        .ap = &#123;</span><br><span class="line">            .ssid = EXAMPLE_ESP_WIFI_SSID,</span><br><span class="line">            .ssid_len = <span class="built_in">strlen</span>(EXAMPLE_ESP_WIFI_SSID),</span><br><span class="line">            .channel = EXAMPLE_ESP_WIFI_CHANNEL,</span><br><span class="line">            .password = EXAMPLE_ESP_WIFI_PASS,</span><br><span class="line">            .max_connection = EXAMPLE_MAX_STA_CONN,</span><br><span class="line">            .authmode = WIFI_AUTH_WPA_WPA2_PSK</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(EXAMPLE_ESP_WIFI_PASS) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        wifi_config.ap.authmode = WIFI_AUTH_OPEN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP));</span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_AP, &amp;wifi_config));</span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_start());</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;wifi_init_softap finished. SSID:%s password:%s channel:%d&quot;</span>,</span><br><span class="line">             EXAMPLE_ESP_WIFI_SSID, EXAMPLE_ESP_WIFI_PASS, EXAMPLE_ESP_WIFI_CHANNEL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中主要用到了wifi_config_t这个结构体，它的内容如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> ssid[<span class="number">32</span>];<span class="comment">//SSID</span></span><br><span class="line">    <span class="keyword">uint8_t</span> password[<span class="number">64</span>];<span class="comment">//密码</span></span><br><span class="line">    <span class="keyword">uint8_t</span> ssid_len;<span class="comment">//SSID长度，若设为0则会自动查找到终止字符；否则会在规定长度处截断</span></span><br><span class="line">    <span class="keyword">uint8_t</span> channel;<span class="comment">//AP的通道</span></span><br><span class="line">    <span class="keyword">wifi_auth_mode_t</span> authmode;<span class="comment">//授权模式</span></span><br><span class="line">    <span class="keyword">uint8_t</span> ssid_hidden;<span class="comment">//是否广播SSID，默认为0-广播；设为1则不广播</span></span><br><span class="line">    <span class="keyword">uint8_t</span> max_connection;<span class="comment">//能连接的最大节点数量，默认为4，最大为4</span></span><br><span class="line">    <span class="keyword">uint16_t</span> beacon_interval;<span class="comment">//信标间隔，默认100ms，应设置在100-60000ms内</span></span><br><span class="line">&#125; <span class="keyword">wifi_ap_config_t</span>;</span><br></pre></td></tr></table></figure>

<h3 id="STA模式初始化"><a href="#STA模式初始化" class="headerlink" title="STA模式初始化"></a>STA模式初始化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wifi_init_sta</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s_wifi_event_group = xEventGroupCreate();</span><br><span class="line">    ESP_ERROR_CHECK(esp_netif_init());</span><br><span class="line">    ESP_ERROR_CHECK(esp_event_loop_create_default());</span><br><span class="line">    </span><br><span class="line">    esp_netif_create_default_wifi_sta();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wifi_init_config_t</span> cfg = WIFI_INIT_CONFIG_DEFAULT();</span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_init(&amp;cfg));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">esp_event_handler_instance_t</span> instance_any_id;</span><br><span class="line">    <span class="keyword">esp_event_handler_instance_t</span> instance_got_ip;</span><br><span class="line">    ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT,</span><br><span class="line">                                                        ESP_EVENT_ANY_ID,</span><br><span class="line">                                                        &amp;event_handler,</span><br><span class="line">                                                        <span class="literal">NULL</span>,</span><br><span class="line">                                                        &amp;instance_any_id));</span><br><span class="line">    ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT,</span><br><span class="line">                                                        IP_EVENT_STA_GOT_IP,</span><br><span class="line">                                                        &amp;event_handler,</span><br><span class="line">                                                        <span class="literal">NULL</span>,</span><br><span class="line">                                                        &amp;instance_got_ip));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wifi_config_t</span> wifi_config = &#123;</span><br><span class="line">        .sta = &#123;</span><br><span class="line">            .ssid = EXAMPLE_ESP_WIFI_SSID,</span><br><span class="line">            .password = EXAMPLE_ESP_WIFI_PASS,</span><br><span class="line">            <span class="comment">/* Setting a password implies station will connect to all security modes including WEP/WPA.</span></span><br><span class="line"><span class="comment">             * However these modes are deprecated and not advisable to be used. Incase your Access point</span></span><br><span class="line"><span class="comment">             * doesn&#x27;t support WPA2, these mode can be enabled by commenting below line */</span></span><br><span class="line">	     	.threshold.authmode = WIFI_AUTH_WPA2_PSK,</span><br><span class="line">            .pmf_cfg = &#123;</span><br><span class="line">                .capable = <span class="literal">true</span>,</span><br><span class="line">                .required = <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA) );</span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_STA, &amp;wifi_config) );</span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_start() );</span><br><span class="line"></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;wifi_init_sta finished.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Waiting until either the connection is established (WIFI_CONNECTED_BIT) or connection failed for the maximum</span></span><br><span class="line"><span class="comment">     * number of re-tries (WIFI_FAIL_BIT). The bits are set by event_handler() (see above) */</span></span><br><span class="line">    EventBits_t bits = xEventGroupWaitBits(s_wifi_event_group,</span><br><span class="line">            WIFI_CONNECTED_BIT | WIFI_FAIL_BIT,</span><br><span class="line">            pdFALSE,</span><br><span class="line">            pdFALSE,</span><br><span class="line">            portMAX_DELAY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* xEventGroupWaitBits() returns the bits before the call returned, hence we can test which event actually</span></span><br><span class="line"><span class="comment">     * happened. */</span></span><br><span class="line">    <span class="keyword">if</span> (bits &amp; WIFI_CONNECTED_BIT) &#123;</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;connected to ap SSID:%s password:%s&quot;</span>,</span><br><span class="line">                 EXAMPLE_ESP_WIFI_SSID, EXAMPLE_ESP_WIFI_PASS);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bits &amp; WIFI_FAIL_BIT) &#123;</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;Failed to connect to SSID:%s, password:%s&quot;</span>,</span><br><span class="line">                 EXAMPLE_ESP_WIFI_SSID, EXAMPLE_ESP_WIFI_PASS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">&quot;UNEXPECTED EVENT&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The event will not be processed after unregister */</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_event_handler_instance_unregister(IP_EVENT, IP_EVENT_STA_GOT_IP, instance_got_ip));</span><br><span class="line">    ESP_ERROR_CHECK(esp_event_handler_instance_unregister(WIFI_EVENT, ESP_EVENT_ANY_ID, instance_any_id));</span><br><span class="line">    vEventGroupDelete(s_wifi_event_group);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中主要用到了wifi_sta_config_t这个结构体，它的内容如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> ssid[<span class="number">32</span>];<span class="comment">//SSID</span></span><br><span class="line">    <span class="keyword">uint8_t</span> password[<span class="number">64</span>];<span class="comment">//密码</span></span><br><span class="line">    <span class="keyword">bool</span> bssid_set;<span class="comment">//是否设置目标AP的MAC地址，一般设为0；只有用户需要查看AP的MAC地址时才设为1</span></span><br><span class="line">    <span class="keyword">uint8_t</span> bssid[<span class="number">6</span>];<span class="comment">//目标AP的MAC地址</span></span><br><span class="line">    <span class="keyword">uint8_t</span> channel;<span class="comment">//目标AP的通道，如果未知设为0；范围是1-13</span></span><br><span class="line">&#125; <span class="keyword">wifi_sta_config_t</span>;</span><br></pre></td></tr></table></figure>

<h3 id="AP-STA共存模式"><a href="#AP-STA共存模式" class="headerlink" title="AP-STA共存模式"></a>AP-STA共存模式</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">event_handler</span><span class="params">(<span class="keyword">void</span> *ctx, <span class="keyword">system_event_t</span> *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event-&gt;event_id)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> SYSTEM_EVENT_STA_START:</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;Connecting to AP&quot;</span>);</span><br><span class="line">        esp_wifi_connect();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> SYSTEM_EVENT_STA_GOT_IP:</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;Connected&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> SYSTEM_EVENT_STA_DISCONNECTED:</span><br><span class="line">        <span class="comment">//ESP_LOGI(TAG, &quot;Wifi disconnected, try to connect again...&quot;);</span></span><br><span class="line">        esp_wifi_connect();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ESP_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ESP_net_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ESP_ERROR_CHECK(esp_event_loop_init(event_handler, <span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">wifi_init_config_t</span> cfg = WIFI_INIT_CONFIG_DEFAULT();</span><br><span class="line">    ESP_ERROR_CHECK( esp_wifi_init(&amp;cfg) );</span><br><span class="line">    ESP_ERROR_CHECK( esp_wifi_set_storage(WIFI_STORAGE_RAM) );</span><br><span class="line">    ESP_ERROR_CHECK( esp_wifi_set_mode(WIFI_MODE_APSTA) );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wifi_config_t</span> sta_config = &#123;</span><br><span class="line">        .sta = &#123;</span><br><span class="line">            .ssid = TARGET_ESP_WIFI_SSID,</span><br><span class="line">            .password = TARGET_ESP_WIFI_PASS,</span><br><span class="line">            .bssid_set = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">wifi_config_t</span> ap_config = &#123;</span><br><span class="line">        .ap = &#123;</span><br><span class="line">            .ssid = AP_ESP_WIFI_SSID,</span><br><span class="line">            .password = AP_ESP_WIFI_PASS,</span><br><span class="line">            .ssid_len = <span class="number">0</span>,</span><br><span class="line">            .max_connection = AP_MAX_STA_CONN,</span><br><span class="line">            .authmode = WIFI_AUTH_WPA_PSK</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &amp;sta_config));</span><br><span class="line">    <span class="keyword">esp_err_t</span> tmp=esp_wifi_set_config(WIFI_IF_AP, &amp;ap_config);</span><br><span class="line"></span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_start());</span><br><span class="line">    esp_wifi_connect();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//init NVS</span></span><br><span class="line">    <span class="keyword">esp_err_t</span> ret = nvs_flash_init();</span><br><span class="line">    <span class="keyword">if</span> (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND)</span><br><span class="line">    &#123;</span><br><span class="line">        ESP_ERROR_CHECK(nvs_flash_erase());</span><br><span class="line">        ret = nvs_flash_init();</span><br><span class="line">    &#125;</span><br><span class="line">    ESP_ERROR_CHECK(ret);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//init wifi ap and station</span></span><br><span class="line">    ESP_net_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里使用了状态机（SM）的编程思路，【开始连接】-【连接完毕】-【丢失连接】几个状态切换中都会调用event_handler()进行处理并打印相关信息</p>
<h2 id="基本初始化方法"><a href="#基本初始化方法" class="headerlink" title="基本初始化方法"></a>基本初始化方法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置线程</span></span><br><span class="line"><span class="keyword">wifi_init_config_t</span> cfg = WIFI_INIT_CONFIG_DEFAULT();<span class="comment">//进行默认初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置wifi_config结构体来配置具体的wifi模式</span></span><br><span class="line"><span class="keyword">wifi_config_t</span> sta_wifi_config = &#123;</span><br><span class="line">        .sta = &#123;</span><br><span class="line">            .ssid = SSID,</span><br><span class="line">            .password = PASSWORD,</span><br><span class="line">	     	.threshold.authmode = WIFI_AUTH_WPA2_PSK,</span><br><span class="line">            .pmf_cfg = &#123;<span class="comment">//这里可省略</span></span><br><span class="line">                .capable = <span class="literal">true</span>,</span><br><span class="line">                .required = <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">wifi_config_t</span> ap_wifi_config = &#123;</span><br><span class="line">        .ap = &#123;</span><br><span class="line">            .ssid = SSID,</span><br><span class="line">            .ssid_len = <span class="built_in">strlen</span>(EXAMPLE_ESP_WIFI_SSID),</span><br><span class="line">            .channel = WIFI_CHANNEL,</span><br><span class="line">            .password = PASSWORD,</span><br><span class="line">            .max_connection = MAX_STA_CONN,<span class="comment">//这里可省略</span></span><br><span class="line">            .authmode = WIFI_AUTH_WPA_WPA2_PSK</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strlen</span>(PASSWORD) == <span class="number">0</span>)<span class="comment">//检查密码是否为空</span></span><br><span class="line">&#123;</span><br><span class="line">	wifi_config.ap.authmode = WIFI_AUTH_OPEN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查错误并使能设置</span></span><br><span class="line">ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &amp;sta_config));</span><br><span class="line"><span class="keyword">esp_err_t</span> tmp=esp_wifi_set_config(WIFI_IF_AP, &amp;ap_config);</span><br><span class="line"></span><br><span class="line">esp_wifi_connect();<span class="comment">//连接wifi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中间可加入ESP_LOGI()输出debg消息 */</span></span><br></pre></td></tr></table></figure>

<p>WiFi连接实际上使用的是一套异步的状态机，所有需要调用的外设都被ESP-IDF封装起来了，开发者只需要配置基本逻辑即可。流程如下：</p>
<ol>
<li><p>初始化用于存储WiFi配置数据（包括ssid和密码）的NVS</p>
</li>
<li><p>配置WiFi数据并将其写入WiFi外设（或NVS）</p>
</li>
<li><p>开启WiFi</p>
</li>
<li><p>设备自动根据外设寄存器内的配置连接附近WiFi，并根据当前连接情况向主程序发送事件集</p>
</li>
<li><p>开发者编写的状态机负责处理WiFi外设发来的事件，主要分成以下几种情况：</p>
<ul>
<li>WiFi已连接</li>
<li>WiFi未连接</li>
<li>找不到指定ssid的WiFi</li>
<li>连接丢失</li>
</ul>
<p>一般使用ESP-IDF中的<strong>默认事件循环</strong>来实现状态机</p>
<p>使用其中的<strong>事件类型</strong>和<strong>事件ID</strong>区分各个不同的具体时间</p>
</li>
</ol>
<p>关于ESP-IDF的事件集可以参考ESP32上移植的FreeRTOS相关教程</p>
]]></content>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32_IDF学习6【HTTP服务器】</title>
    <url>/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A06%E3%80%90HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%91/</url>
    <content><![CDATA[<h1 id="TCP-IP组件"><a href="#TCP-IP组件" class="headerlink" title="TCP/IP组件"></a>TCP/IP组件</h1><p>ESP系列提供了实现TCP/IP协议栈的库函数，<code>#include &lt;esp_netif.h&gt;</code>即可使用这些库函数</p>
<p>特点如下：</p>
<span id="more"></span>

<ul>
<li>提供TCP/IP协议栈的应用抽象层</li>
<li>提供线程保护</li>
<li>目前只用于lwIP TCP/IP协议栈（lwIP：Light Weight IP Protocol，支持在嵌入式设备中使用的小型TCP/IP协议栈，占用内存较少）</li>
<li>具有丰富的API库函数</li>
<li>大多数情况下，应用程序不需要直接调用组件的API，而是从默认的网络事件处理函数中调用</li>
<li>不兼容idf4.1以下使用的TCP/IP适配器相关函数，需修改代码进行迁移</li>
</ul>
<p>ESP-NETIF结构如下（摘自官方文档）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                 |          (A) USER CODE                 |</span><br><span class="line">                 |                                        |</span><br><span class="line">    .............| init          settings      events     |</span><br><span class="line">    .            +----------------------------------------+</span><br><span class="line">    .               .                |           *</span><br><span class="line">    .               .                |           *</span><br><span class="line">--------+        +===========================+   *     +-----------------------+</span><br><span class="line">        |        | new/config     get/set    |   *     |                       |</span><br><span class="line">        |        |                           |...*.....| init                  |</span><br><span class="line">        |        |---------------------------|   *     |                       |</span><br><span class="line">  init  |        |                           |****     |                       |</span><br><span class="line">  start |********|  event handler            |*********|  DHCP                 |</span><br><span class="line">  stop  |        |                           |         |                       |</span><br><span class="line">        |        |---------------------------|         |                       |</span><br><span class="line">        |        |                           |         |    NETIF              |</span><br><span class="line">  +-----|        |                           |         +-----------------+     |</span><br><span class="line">  | glue|----&lt;---|  esp_netif_transmit       |--&lt;------| netif_output    |     |</span><br><span class="line">  |     |        |                           |         |                 |     |</span><br><span class="line">  |     |----&gt;---|  esp_netif_receive        |--&gt;------| netif_input     |     |</span><br><span class="line">  |     |        |                           |         + ----------------+     |</span><br><span class="line">  |     |....&lt;...|  esp_netif_free_rx_buffer |...&lt;.....| packet buffer         |</span><br><span class="line">  +-----|        |                           |         |                       |</span><br><span class="line">        |        |                           |         |         (D)           |</span><br><span class="line">  (B)   |        |          (C)              |         +-----------------------+</span><br><span class="line">--------+        +===========================+</span><br><span class="line">communication                                                NETWORK STACK</span><br><span class="line">DRIVER                   ESP-NETIF</span><br></pre></td></tr></table></figure>

<p>其中……代表初始化；—-&gt;—或—&lt;—-代表数据包走向；******代表操作系统的事件调用；|代表用户代码的设置和运行时的配置</p>
<h2 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ol>
<li>初始化IO驱动</li>
<li>创建一个ESP-NETIF的实例并进行如下配置：<ol>
<li>特殊属性</li>
<li>网络协议栈相关设置</li>
<li>IO设置</li>
</ol>
</li>
<li>将IO驱动句柄和NETIF实例关联</li>
<li>配置事件处理函数，至少需要：<ol>
<li>默认处理函数：用于普通的来自IO驱动器或其他特殊的接口的事件调用</li>
<li>register处理函数：用故意相关联的应用程序事件调用</li>
</ol>
</li>
</ol>
<h3 id="运行时配置"><a href="#运行时配置" class="headerlink" title="运行时配置"></a>运行时配置</h3><ol>
<li>获取当前TCP/IP设置</li>
<li>收取IP事件</li>
<li>控制应用程序的FSM</li>
</ol>
<h1 id="配置的实例"><a href="#配置的实例" class="headerlink" title="配置的实例"></a>配置的实例</h1><h2 id="WiFi默认初始化"><a href="#WiFi默认初始化" class="headerlink" title="WiFi默认初始化"></a>WiFi默认初始化</h2><p>使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_netif_t</span> *<span class="title">esp_netif_create_default_wifi_ap</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//初始化wifi为ap模式</span></span><br><span class="line"><span class="function"><span class="keyword">esp_netif_t</span> *<span class="title">esp_netif_create_default_wifi_sta</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//初始化wifi为STA模式</span></span><br></pre></td></tr></table></figure>

<p>两个API进行默认状态的wifi初始化，函数会返回对应的esp-netif实例</p>
<p>注意：创建的实例如果不再运行时需要停止并释放内存空间，且不能被多次创建</p>
<p><strong>如果需要使用AP+STA模式，两个接口都需要被创建</strong></p>
<h2 id="相关库函数"><a href="#相关库函数" class="headerlink" title="相关库函数"></a>相关库函数</h2><ol>
<li>初始化</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">esp_netif_init(<span class="keyword">void</span>);<span class="comment">//初始化组件</span></span><br><span class="line">esp_netif_deinit(<span class="keyword">void</span>);<span class="comment">//销毁组件</span></span><br><span class="line">esp_netif_new(<span class="keyword">const</span> <span class="keyword">esp_netif_config_t</span> *esp_netif_config);<span class="comment">//根据配置结构体esp_netif_config创建一个新esp-netif实例</span></span><br><span class="line">esp_netif_destroy(<span class="keyword">esp_netif_t</span> *esp_netif);<span class="comment">//删除一个esp-netif实例</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">esp_netif_set_driver_config(<span class="keyword">esp_netif_t</span> *esp_netif, <span class="keyword">const</span> <span class="keyword">esp_netif_driver_ifconfig_t</span> *driver_config);</span><br><span class="line"><span class="comment">//设置与esp-netif对象关联的IO驱动器</span></span><br><span class="line">esp_netif_attach(<span class="keyword">esp_netif_t</span> *esp_netif, esp_netif_iodriver_handle driver_handle);</span><br><span class="line"><span class="comment">//关联esp-netif对象与IO驱动器</span></span><br><span class="line"><span class="comment">//可以在完成关联后调用处理函数来进行回调或启动驱动器任务</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">esp_netif_receive(<span class="keyword">esp_netif_t</span> *esp_netif, <span class="keyword">void</span> *buffer, <span class="keyword">size_t</span> len, <span class="keyword">void</span> *eb);</span><br><span class="line"><span class="comment">//从应用向TCP/IP协议栈发送包</span></span><br><span class="line">esp_netif_action_start(<span class="keyword">void</span> *esp_netif, <span class="keyword">esp_event_base_t</span> base, <span class="keyword">int32_t</span> event_id, <span class="keyword">void</span> *data);</span><br><span class="line"><span class="comment">//自动启用TCP/IP协议（使能如DHCP的功能）</span></span><br><span class="line">esp_netif_action_stop(<span class="keyword">void</span> *esp_netif, <span class="keyword">esp_event_base_t</span> base, <span class="keyword">int32_t</span> event_id, <span class="keyword">void</span> *data);</span><br><span class="line"><span class="comment">//停止向TCP/IP协议栈发送包</span></span><br><span class="line"></span><br><span class="line">esp_netif_action_got_ip(<span class="keyword">void</span> *esp_netif, <span class="keyword">esp_event_base_t</span> base, <span class="keyword">int32_t</span> event_id, <span class="keyword">void</span> *data);</span><br><span class="line"><span class="comment">//获取当前IP</span></span><br><span class="line">esp_netif_set_mac(<span class="keyword">esp_netif_t</span> *esp_netif, <span class="keyword">uint8_t</span> mac[]);</span><br><span class="line"><span class="comment">//设置当前MAC地址</span></span><br><span class="line">esp_netif_set_hostname(<span class="keyword">esp_netif_t</span> *esp_netif, <span class="keyword">const</span> <span class="keyword">char</span> *hostname);</span><br><span class="line"><span class="comment">//设置当前主机名</span></span><br><span class="line">esp_netif_get_hostname(<span class="keyword">esp_netif_t</span> *esp_netif, <span class="keyword">const</span> <span class="keyword">char</span> **hostname);</span><br><span class="line"><span class="comment">//获取当前主机名</span></span><br><span class="line">esp_netif_get_ip_info(<span class="keyword">esp_netif_t</span> *esp_netif, <span class="keyword">esp_netif_ip_info_t</span> *ip_info);</span><br><span class="line"><span class="comment">//获取当前IP地址相关信息</span></span><br><span class="line">esp_netif_set_ip_info(<span class="keyword">esp_netif_t</span> *esp_netif, <span class="keyword">const</span> <span class="keyword">esp_netif_ip_info_t</span> *ip_info);</span><br><span class="line"><span class="comment">//设置当前IP地址相关信息</span></span><br><span class="line"></span><br><span class="line">esp_netif_get_netif_impl_index(<span class="keyword">esp_netif_t</span> *esp_netif);</span><br><span class="line"><span class="comment">//获取当前网络接口的代号</span></span><br><span class="line"></span><br><span class="line">esp_netif_dhcps_option(<span class="keyword">esp_netif_t</span> *esp_netif,</span><br><span class="line">                       <span class="keyword">esp_netif_dhcp_option_mode_t</span> opt_op,</span><br><span class="line">                       <span class="keyword">esp_netif_dhcp_option_id_t</span> opt_id,</span><br><span class="line">                       <span class="keyword">void</span> *opt_val,</span><br><span class="line">                       <span class="keyword">uint32_t</span> opt_len);</span><br><span class="line"><span class="comment">//配置DHCP服务器</span></span><br><span class="line">esp_netif_dhcpc_option(<span class="keyword">esp_netif_t</span> *esp_netif,</span><br><span class="line">                       <span class="keyword">esp_netif_dhcp_option_mode_t</span> opt_op,</span><br><span class="line">                       <span class="keyword">esp_netif_dhcp_option_id_t</span> opt_id,</span><br><span class="line">                       <span class="keyword">void</span> *opt_val,</span><br><span class="line">                       <span class="keyword">uint32_t</span> opt_len)</span><br><span class="line"><span class="comment">//配置DHCP客户端</span></span><br><span class="line">esp_netif_dhcpc_start(<span class="keyword">esp_netif_t</span> *esp_netif);<span class="comment">//开启DHCP客户端</span></span><br><span class="line">esp_netif_dhcpc_stop(<span class="keyword">esp_netif_t</span> *esp_netif);<span class="comment">//停止DHCP客户端</span></span><br><span class="line">esp_netif_dhcps_start(<span class="keyword">esp_netif_t</span> *esp_netif);<span class="comment">//开启DHCP服务器</span></span><br><span class="line">esp_netif_dhcps_stop(<span class="keyword">esp_netif_t</span> *esp_netif);<span class="comment">//关闭DHCP服务器</span></span><br><span class="line">esp_netif_dhcpc_get_status(<span class="keyword">esp_netif_t</span> *esp_netif, <span class="keyword">esp_netif_dhcp_status_t</span> *status);</span><br><span class="line"><span class="comment">//获取当前DHCP客户端状态</span></span><br><span class="line">esp_netif_dhcps_get_status(<span class="keyword">esp_netif_t</span> *esp_netif, <span class="keyword">esp_netif_dhcp_status_t</span> *status);</span><br><span class="line"><span class="comment">//获取当前DHCP服务器状态</span></span><br><span class="line"></span><br><span class="line">esp_netif_set_dns_info(<span class="keyword">esp_netif_t</span> *esp_netif, <span class="keyword">esp_netif_dns_type_t</span> type, <span class="keyword">esp_netif_dns_info_t</span> *dns);</span><br><span class="line"><span class="comment">//设置DNS服务器信息</span></span><br><span class="line">esp_netif_get_dns_info(<span class="keyword">esp_netif_t</span> *esp_netif, <span class="keyword">esp_netif_dns_type_t</span> type, <span class="keyword">esp_netif_dns_info_t</span> *dns);</span><br><span class="line"><span class="comment">//获取DNS服务器信息</span></span><br><span class="line"></span><br><span class="line">esp_netif_create_ip6_linklocal(<span class="keyword">esp_netif_t</span> *esp_netif);<span class="comment">//创建本地IPv6地址</span></span><br><span class="line">esp_netif_set_ip4_addr(<span class="keyword">esp_ip4_addr_t</span> *addr, <span class="keyword">uint8_t</span> a, <span class="keyword">uint8_t</span> b, <span class="keyword">uint8_t</span> c, <span class="keyword">uint8_t</span> d);<span class="comment">//设置本地IPv4地址</span></span><br><span class="line">esp_netif_get_ip6_global(<span class="keyword">esp_netif_t</span> *esp_netif, <span class="keyword">esp_ip6_addr_t</span> *if_ip6)<span class="comment">//创建全局IPv6地址</span></span><br><span class="line">esp_netif_get_ip6_linklocal(<span class="keyword">esp_netif_t</span> *esp_netif, <span class="keyword">esp_ip6_addr_t</span> *if_ip6);<span class="comment">//获取本地IPv6地址</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>事件处理函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">esp_wifi_set_default_wifi_sta_handlers(<span class="keyword">void</span>);</span><br><span class="line">esp_wifi_set_default_wifi_ap_handlers(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>默认设置</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">esp_netif_create_default_wifi_ap(<span class="keyword">void</span>);</span><br><span class="line">esp_netif_create_default_wifi_sta(<span class="keyword">void</span>);</span><br><span class="line">esp_netif_create_default_wifi_mesh_netifs(<span class="keyword">esp_netif_t</span> **p_netif_sta, <span class="keyword">esp_netif_t</span> **p_netif_ap);</span><br></pre></td></tr></table></figure>

<h1 id="HTTP-Server组件"><a href="#HTTP-Server组件" class="headerlink" title="HTTP Server组件"></a>HTTP Server组件</h1><p>原文地址：<a href="https://docs.espressif.com/projects/esp-idf/zh_CN/release-v4.1/api-reference/protocols/esp_http_server.html">https://docs.espressif.com/projects/esp-idf/zh_CN/release-v4.1/api-reference/protocols/esp_http_server.html</a></p>
<p>HTTP Server 组件提供了在 ESP32 上运行轻量级 Web 服务器的功能</p>
<p>使用步骤：</p>
<ol>
<li>使用httpd_start()创建HTTP Server的实例</li>
</ol>
<p>API会根据具体配置为其分配内存和资源，该函数返回指向服务器实例的指针（句柄）</p>
<p>服务器使用两个套接字，其中一个用于监听HTTP流量（TCP类型），一个用来处理控制信号（UDP类型），它们在服务器的任务循环中轮流使用。TCP 流量被解析为 HTTP 请求，根据请求的 URI （Uniform Resource Identifier统一资源标志符，表示web上每一种可用的资源）来调用用户注册的处理程序，在处理程序中需要发送回 HTTP 响应数据包。</p>
<p><strong>URI通常由三部分组成：资源的命名机制；存放资源的主机名；资源自身的名称</strong>。另外，常说的URL是URI的一个子集（Uniform Resource Locator统一资源定位符），URL是一种具体的URI，它是URI的一个子集，它不仅唯一标识资源，而且还提供了定位该资源的信息。URL是Internet上描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，<strong>URL的格式由三部分组成：第一部分是协议(或称为服务方式)；第二部分是存有该资源的主机IP地址(有时也包括端口号)；第三部分是主机资源的具体地址，如目录和文件名等</strong>。第一部分和第二部分用“://”符号隔开，第二部分和第三部分用“/”符号隔开。第一部分和第二部分是不可缺少的，第三部分有时可以省略。 </p>
<p>使用结构体httpd_config_t来配置服务器的各种设定（任务优先级、堆栈大小）</p>
<p>API和结构体如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">httpd_start(<span class="keyword">httpd_handle_t</span> *handle, <span class="keyword">const</span> <span class="keyword">httpd_config_t</span> *config);<span class="comment">//开启HTTP服务器并分配内存资源</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例应用</span></span><br><span class="line"><span class="function"><span class="keyword">httpd_handle_t</span> <span class="title">start_webserver</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">//可以使用以下宏函数来初始化httpd_config为默认值</span></span><br><span class="line">     <span class="keyword">httpd_config_t</span> config = HTTPD_DEFAULT_CONFIG();</span><br><span class="line">     <span class="comment">//设置服务器句柄为空</span></span><br><span class="line">     <span class="keyword">httpd_handle_t</span> server = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//启动HTTP服务器</span></span><br><span class="line">     <span class="keyword">if</span> (httpd_start(&amp;server, &amp;config) == ESP_OK)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">//注册uri句柄</span></span><br><span class="line">         httpd_register_uri_handler(server, &amp;uri_get);</span><br><span class="line">         httpd_register_uri_handler(server, &amp;uri_post);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//返回服务器句柄，如果启动失败则句柄为空</span></span><br><span class="line">     <span class="keyword">return</span> server;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">httpd_config</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> task_priority;<span class="comment">//RTOS服务器任务优先级</span></span><br><span class="line">    <span class="keyword">size_t</span> stack_size;<span class="comment">//服务器任务的最大栈大小</span></span><br><span class="line">    BaseType_t core_id;<span class="comment">//服务器任务运行在哪个CPU core上</span></span><br><span class="line">    <span class="keyword">uint16_t</span> server_port;<span class="comment">//服务器使用的端口号</span></span><br><span class="line">    <span class="keyword">uint16_t</span> ctrl_port;<span class="comment">//在服务器组件间异步交换控制信号的UDP端口号</span></span><br><span class="line">    <span class="keyword">uint16_t</span> max_open_sockets;<span class="comment">//最大连接的套接字/客户端数量</span></span><br><span class="line">    <span class="keyword">uint16_t</span> max_uri_handlers;<span class="comment">//最大允许的uri句柄数量</span></span><br><span class="line">    <span class="keyword">uint16_t</span> max_resp_headers;<span class="comment">//最大允许的HTTP响应头</span></span><br><span class="line">    <span class="keyword">uint16_t</span> backlog_conn;<span class="comment">//积压链接的数量</span></span><br><span class="line">    <span class="keyword">bool</span> lru_purge_enable;<span class="comment">//是否清除最近使用的连接</span></span><br><span class="line">    <span class="keyword">uint16_t</span> recv_wait_timeout;<span class="comment">//接收函数的超时时间</span></span><br><span class="line">    <span class="keyword">uint16_t</span> send_wait_timeout;<span class="comment">//发送函数的超时时间</span></span><br><span class="line">    <span class="keyword">void</span> *global_user_ctx;<span class="comment">//全局用户上下文，专门用于存储服务器上下文中的用户数据</span></span><br><span class="line">    <span class="keyword">httpd_free_ctx_fn_t</span> global_user_ctx_free_fn;<span class="comment">//释放空间函数</span></span><br><span class="line">    <span class="keyword">void</span> *global_transport_ctx;<span class="comment">//全局传输上下文，用于存储部分解码或加密使用到的数据，和全局用户上下文意昂需要用free()函数释放内存空间，除非global_transport_ctx_free_fn被指定</span></span><br><span class="line">    <span class="keyword">httpd_free_ctx_fn_t</span> global_transport_ctx_free_fn;<span class="comment">//释放空间函数</span></span><br><span class="line">    <span class="keyword">httpd_open_func_t</span> open_fn;<span class="comment">//自定义session开启回调函数，在新的session开启时被调用</span></span><br><span class="line">    <span class="keyword">httpd_close_func_t</span> close_fn;<span class="comment">//自定义session关闭回调函数</span></span><br><span class="line">    <span class="keyword">httpd_uri_match_func_t</span> uri_match_fn;<span class="comment">//URI匹配函数，用于在搜索到匹配的URI时调用</span></span><br><span class="line">&#125;<span class="keyword">httpd_config_t</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置URI处理程序</li>
</ol>
<p>使用httpd_register_uri_handler()完成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//API原型</span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">httpd_register_uri_handler</span><span class="params">(<span class="keyword">httpd_handle_t</span> handle, <span class="keyword">const</span> <span class="keyword">httpd_uri_t</span> *uri_handler)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//示例</span></span></span><br><span class="line"><span class="function"><span class="comment">//URI处理函数</span></span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">my_uri_handler</span><span class="params">(<span class="keyword">httpd_req_t</span>* req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//收取请求、处理并发送响应</span></span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">//出错状态</span></span><br><span class="line">    <span class="keyword">if</span> (....)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//返回错误</span></span><br><span class="line">        <span class="keyword">return</span> ESP_FAIL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成功状态</span></span><br><span class="line">    <span class="keyword">return</span> ESP_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//URI句柄结构体</span></span><br><span class="line"><span class="keyword">httpd_uri_t</span> my_uri &#123;</span><br><span class="line">    .uri      = <span class="string">&quot;/my_uri/path/xyz&quot;</span>,<span class="comment">//相关的URI</span></span><br><span class="line">    .method   = HTTPD_GET,<span class="comment">//方法</span></span><br><span class="line">    .handler  = my_uri_handler,<span class="comment">//URI处理函数</span></span><br><span class="line">    .user_ctx = <span class="literal">NULL</span><span class="comment">//指向用户上下文数据的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册句柄</span></span><br><span class="line"><span class="keyword">if</span> (httpd_register_uri_handler(server_handle, &amp;my_uri) != ESP_OK)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//如果注册失败就....</span></span><br><span class="line">   ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过传入httpd_uri_t结构体类型的对象来注册 URI 处理程序</p>
<ol start="3">
<li>使用httpd_stop()函数停止HTTP服务器</li>
</ol>
<p>该API会根据传入的句柄停止服务器并释放相关联的内存和资源。这是一个阻塞函数——首先给服务器任务发送停止信号，然后等待其终止。期间服务器任务会关闭所有已打开的连接，删除已注册的 URI 处理程序，并将所有会话的上下文数据重置为空。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">httpd_stop</span><span class="params">(<span class="keyword">httpd_handle_t</span> handle)</span></span>;<span class="comment">//根据传入的服务器句柄停止指向的服务器</span></span><br></pre></td></tr></table></figure>

<p>可以使用以下的代码来安全地停止服务器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例应用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop_webserver</span><span class="params">(<span class="keyword">httpd_handle_t</span> server)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">//确保指针非空</span></span><br><span class="line">     <span class="keyword">if</span> (server != <span class="literal">NULL</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         httpd_stop(server);<span class="comment">//停止服务器</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* URI 处理函数，在客户端发起 GET /uri 请求时被调用 */</span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">get_handler</span><span class="params">(<span class="keyword">httpd_req_t</span> *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 发送回简单的响应数据包 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>[] resp = <span class="string">&quot;URI GET Response&quot;</span>;</span><br><span class="line">    httpd_resp_send(req, resp, <span class="built_in">strlen</span>(resp));</span><br><span class="line">    <span class="keyword">return</span> ESP_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* URI 处理函数，在客户端发起 POST /uri 请求时被调用 */</span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">post_handler</span><span class="params">(<span class="keyword">httpd_req_t</span> *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 定义 HTTP POST 请求数据的目标缓存区</span></span><br><span class="line"><span class="comment">     * httpd_req_recv() 只接收 char* 数据，但也可以是任意二进制数据（需要类型转换）</span></span><br><span class="line"><span class="comment">     * 对于字符串数据，null 终止符会被省略，content_len 会给出字符串的长度 */</span></span><br><span class="line">    <span class="keyword">char</span>[<span class="number">100</span>] content;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果内容长度大于缓冲区则截断 */</span></span><br><span class="line">    <span class="keyword">size_t</span> recv_size = MIN(req-&gt;content_len, <span class="keyword">sizeof</span>(content));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = httpd_req_recv(req, content, recv_size);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)<span class="comment">/* 返回 0 表示连接已关闭 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 检查是否超时 */</span></span><br><span class="line">        <span class="keyword">if</span> (ret == HTTPD_SOCK_ERR_TIMEOUT) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 如果是超时，可以调用 httpd_req_recv() 重试</span></span><br><span class="line"><span class="comment">             * 简单起见，这里我们直接响应 HTTP 408（请求超时）错误给客户端 */</span></span><br><span class="line">            httpd_resp_send_408(req);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 如果发生了错误，返回 ESP_FAIL 可以确保底层套接字被关闭 */</span></span><br><span class="line">        <span class="keyword">return</span> ESP_FAIL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送简单的响应数据包 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>[] resp = <span class="string">&quot;URI POST Response&quot;</span>;</span><br><span class="line">    httpd_resp_send(req, resp, <span class="built_in">strlen</span>(resp));</span><br><span class="line">    <span class="keyword">return</span> ESP_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* GET /uri 的 URI 处理结构 */</span></span><br><span class="line"><span class="keyword">httpd_uri_t</span> uri_get = &#123;</span><br><span class="line">    .uri      = <span class="string">&quot;/uri&quot;</span>,</span><br><span class="line">    .method   = HTTP_GET,</span><br><span class="line">    .handler  = get_handler,</span><br><span class="line">    .user_ctx = <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* POST /uri 的 URI 处理结构 */</span></span><br><span class="line"><span class="keyword">httpd_uri_t</span> uri_post = &#123;</span><br><span class="line">    .uri      = <span class="string">&quot;/uri&quot;</span>,</span><br><span class="line">    .method   = HTTP_POST,</span><br><span class="line">    .handler  = post_handler,</span><br><span class="line">    .user_ctx = <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 启动 Web 服务器的函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">httpd_handle_t</span> <span class="title">start_webserver</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 生成默认的配置参数 */</span></span><br><span class="line">    <span class="keyword">httpd_config_t</span> config = HTTPD_DEFAULT_CONFIG();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 置空 esp_http_server 的实例句柄 */</span></span><br><span class="line">    <span class="keyword">httpd_handle_t</span> server = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 启动 httpd server */</span></span><br><span class="line">    <span class="keyword">if</span> (httpd_start(&amp;server, &amp;config) == ESP_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 注册 URI 处理程序 */</span></span><br><span class="line">        httpd_register_uri_handler(server, &amp;uri_get);</span><br><span class="line">        httpd_register_uri_handler(server, &amp;uri_post);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果服务器启动失败，返回的句柄是 NULL */</span></span><br><span class="line">    <span class="keyword">return</span> server;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 停止 Web 服务器的函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop_webserver</span><span class="params">(<span class="keyword">httpd_handle_t</span> server)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (server)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 停止 httpd server */</span></span><br><span class="line">        httpd_stop(server);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32_IDF学习8【电源管理与低功耗模式】</title>
    <url>/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A08%E3%80%90%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86%E4%B8%8E%E4%BD%8E%E5%8A%9F%E8%80%97%E6%A8%A1%E5%BC%8F%E3%80%91/</url>
    <content><![CDATA[<h1 id="电源管理"><a href="#电源管理" class="headerlink" title="电源管理"></a>电源管理</h1><p>ESP-IDF中集成的电源管理算法可以根据应用程序组件的需求，调整外围总线 (APB) 频率、CPU 频率，并使芯片进入 Light-sleep 模式，尽可能减少运行应用程序的功耗</p>
<p>应用程序组件可以通过创建和获取电源管理锁来控制功耗</p>
<p>编译时可使用CONFIG_PM_ENABLE选项启用电源管理功能</p>
<span id="more"></span>

<h2 id="电源管理配置"><a href="#电源管理配置" class="headerlink" title="电源管理配置"></a>电源管理配置</h2><p>（摘自官网）启用电源管理功能将会增加中断延迟。额外延迟与多个因素有关，例如CPU频率、单/双核模式、是否需要进行频率切换等（CPU 频率为 240 MHz 且未启用频率调节时，最小额外延迟为 0.2 us；如果启用频率调节，且在中断入口将频率由 40 MHz 调节至 80 MHz，则最大额外延迟为 40 us）</p>
<p>应用程序可以通过调用esp_pm_configure()函数启用动态调频（DFS）功能和自动light-sleep模式。</p>
<p>通过esp_pm_config_esp32_t结构体来设置相关参数，如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">esp_pm_config_esp32_t</span>//<span class="title">pm</span>代表<span class="title">power</span> <span class="title">management</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> max_freq_mhz;<span class="comment">//最大CPU频率，也就是获取ESP_PM_CPU_FREQ_MAX锁后使用的频率，单位MHz</span></span><br><span class="line">    <span class="keyword">int</span> min_freq_mhz;<span class="comment">//最小CPU频率，也就是获取ESP_PM_APB_FREQ_MAX锁后使用的频率，单位MHz，可设置为晶振频率值或晶振频率除以一个整数，但是需要注意10MHz是生成1MHz的REF_TICK默认时钟所需的最小频率</span></span><br><span class="line">    <span class="keyword">bool</span> light_sleep_enable;<span class="comment">//当未获得任何管理锁时，决定系统是否需要自动进入light-sleep状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="电源管理锁与管理算法"><a href="#电源管理锁与管理算法" class="headerlink" title="电源管理锁与管理算法"></a>电源管理锁与管理算法</h2><p><strong>应用程序可以通过获取或释放管理锁来控制电源管理算法</strong></p>
<p>ESP32 支持下表中所述的三种电源管理锁。</p>
<table>
<thead>
<tr>
<th>电源管理锁</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ESP_PM_CPU_FREQ_MAX</td>
<td>请求使用esp_pm_configure将CPU频率设置为最大值。ESP32可以将该值设置为 80 MHz、160 MHz 或 240 MHz。</td>
</tr>
<tr>
<td>ESP_PM_APB_FREQ_MAX</td>
<td>请求将APB频率设置为最大值，ESP32支持的最大频率为80MHz</td>
</tr>
<tr>
<td>ESP_PM_NO_LIGHT_SLEEP</td>
<td>禁止自动切换至Light-sleep模式</td>
</tr>
</tbody></table>
<p>如果没有获取任何管理锁，调用esp_pm_configure()将启动Light-sleep模式</p>
<p>Light-sleep模式持续时间由以下因素决定：1.处于阻塞状态的FreeRTOS任务书；2.高分辨率定时器API注册的计数器数量</p>
<h2 id="动态调频和外设驱动"><a href="#动态调频和外设驱动" class="headerlink" title="动态调频和外设驱动"></a>动态调频和外设驱动</h2><p>启用动态调频后，APB频率可在一个RTOS滴答周期内多次更改。有些外设不受APB频率变更的影响，但有些外设可能会出现问题</p>
<p>UART、LEDC、RMT不受APB频率变更的影响</p>
<p>SPI master、I2C、I2S、SDMMC可以感知动态调频并在调频期间使用ESP_PM_APB_FREQ_MAX锁</p>
<p>启用SPI slave、以太网、wifi、蓝牙、CAN时，将占用ESP_PM_APB_FREQ_MAX锁</p>
<p>MCPWM、PCNT、Sigma-delta、Timer Group无法感知动态调频，需要应用程序自行获取、释放管理锁</p>
<p>ESP32 在内置<strong>Deep-sleep低功耗模式</strong>、<strong>RTC外设</strong>和<strong>ULP协处理器</strong>的支持下，可以满足多种应用场景下的低功耗需求</p>
<p>（ULP协处理器见最后部分）</p>
<h1 id="低功耗模式"><a href="#低功耗模式" class="headerlink" title="低功耗模式"></a>低功耗模式</h1><p>ESP32可以进入light-sleep和deep-sleep模式，还能进入一个用于相对较低功耗运行的modem-sleep模式</p>
<p>注意：<strong>进入低功耗模式前，应用程序必须关闭wifi和蓝牙设备</strong>，如果需要维持wifi连接，应当使用modem-sleep模式，在这个模式下当需要wifi驱动执行时系统会自动唤醒来维持wifi连接</p>
<h2 id="light-sleep"><a href="#light-sleep" class="headerlink" title="light-sleep"></a>light-sleep</h2><p><strong>CPU暂停运行，wifi/蓝牙基带和射频关闭。RTC、ULP运行，任何唤醒事件都会唤醒芯片</strong></p>
<p>在light-sleep模式下，数字外设、大部分内存和CPU都会被停用（停用时钟），电源功耗也会降低，从light-sleep模式下唤醒后外设和CPU会接回时钟源并继续工作，他们的外部状态会被保存</p>
<p><strong>这个模式可以理解为电脑的挂起休眠</strong></p>
<h2 id="deep-sleep"><a href="#deep-sleep" class="headerlink" title="deep-sleep"></a>deep-sleep</h2><p><strong>CPU、大部分外设掉电，wifi/蓝牙基带和射频关闭，进有RTC、ULP运行，wifi和蓝牙连接数据被转移到RTC内存中。仅有一部分中断源会唤醒芯片</strong></p>
<p>deep-sleep模式下，由APB_CLK时钟提供是时钟源的CPU、大部分内存和所有数字外设都会掉电；只有片上RTC控制器、RTC外设、ULP和RTC内存会被保留电源</p>
<p><strong>这个模式可以理解为电脑的断电休眠</strong></p>
<p>Deep-sleep模式下支持从以下唤醒源触发的设备唤醒</p>
<ul>
<li>定时器</li>
<li>touchpad</li>
<li>Ext(0)：RTC IO中某个指定GPIO满足指定电平即唤醒</li>
<li>Ext(1)：RTC IO中某些指定GPIO同时满足指定电平才能唤醒</li>
<li>ULP协处理器</li>
</ul>
<p>睡眠唤醒源可以在进入light-sleep或deep-sleep之前的任何时间设置</p>
<p>特别地，应用程序可以调用esp_sleep_pd_config()函数来让RTC外设和RTC内存掉电</p>
<p>设置好中断源后可以使用esp_light_sleep_start()和esp_deep_sleep_start()来进入睡眠模式</p>
<h3 id="中断源"><a href="#中断源" class="headerlink" title="中断源"></a>中断源</h3><p>使用esp_sleep_disable_wakeup_source()来停用某个已经设置的中断源</p>
<p>设置中断源的方法如下</p>
<h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p>RTC控制器自带一个能够在预定义时间后进行唤醒的定时器</p>
<p>这个换新模式不需要在睡眠期间为RTC外设或RTC内存上电</p>
<p>使用esp_sleep_enable_timer_wakeup()使能这个功能</p>
<h4 id="触摸检测"><a href="#触摸检测" class="headerlink" title="触摸检测"></a>触摸检测</h4><p>RTC IO模块包括了一套触摸传感器中断触发唤醒的逻辑，需要在MCU进入睡眠之前配置好触摸中断唤醒</p>
<p>只有在RTC外设没有被强行上电的时候才能使用这个唤醒模式</p>
<p>使用esp_sleep_enable_touchpad_wakeup()函数来使能这个中断源</p>
<h4 id="特定外部引脚"><a href="#特定外部引脚" class="headerlink" title="特定外部引脚"></a>特定外部引脚</h4><p>RTC IO模块包括了一套GPIO触发唤醒的逻辑。如果这个中断源被使能，RTC外设需要保持上电状态。因为RTC IO模组在这个模式中被使能，中断上拉或下拉电阻也会被使用到，它们需要通过rtc_gpio_pullup_en()和rtc_gpio_pulldown_en()函数设置</p>
<p>调用esp_sleep_enable_ext0_wakeup()函数来使能这个中断源</p>
<p>此外，也可以使用多个GPIO同时触发唤醒</p>
<p>配置API如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">esp_sleep_pd_config(ESP_PD_DOMAIN_RTC_PERIPH, ESP_PD_OPTION_ON);<span class="comment">//开启特定GPIO唤醒</span></span><br><span class="line">gpio_pullup_dis(gpio_num);<span class="comment">//配置gpio_num为上拉</span></span><br><span class="line">gpio_pulldown_en(gpio_num);<span class="comment">//配置gpio_num为下拉</span></span><br><span class="line">rtc_gpio_isolate(gpio_num);<span class="comment">//配置gpio_num为高阻态</span></span><br><span class="line"></span><br><span class="line">rtc_gpio_deinit(gpio_num);<span class="comment">//使用这个函数来取消配置引脚</span></span><br></pre></td></tr></table></figure>

<p>rtc_gpio_isolate()可以用于防止进入休眠后由GPIO产生的额外功耗</p>
<h4 id="ULP协处理器"><a href="#ULP协处理器" class="headerlink" title="ULP协处理器"></a>ULP协处理器</h4><p>可以使用esp_sleep_enable_ulp_wakeup()来启用ULP协处理器指令唤醒</p>
<h4 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h4><p>除了特定的外部引脚触发唤醒，还可以<strong>在light-sleep下</strong>使用gpio_wakeup_enable()来设定任意GPIO的高/低电平触发唤醒</p>
<p>在进入睡眠模式之前使用esp_sleep_enable_gio_wakeup()来使能该唤醒源</p>
<h4 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h4><p><strong>在light-sleep下</strong>可以使用esp_sleep_enable_uart_wakeup()来启用UART触发唤醒</p>
<p>若开启该触发源，当睡眠状态的ESP32收到来自外部设备的UART输入的数个上升沿时，会自动唤醒，该上升沿数目可以用uart_set_wakeup_threshold()函数配置；在这个触发信号被接收之前，所有信息不会被接收——这就意味着外部设备需要发送额外的字符给ESP32来让它唤醒</p>
<h2 id="modem-sleep"><a href="#modem-sleep" class="headerlink" title="modem-sleep"></a>modem-sleep</h2><p><strong>CPU运行、可配置时钟，wifi/蓝牙基带和射频关闭，但会维持wifi连接</strong></p>
<h1 id="RTC外设"><a href="#RTC外设" class="headerlink" title="RTC外设"></a>RTC外设</h1><p>RTC外设不仅包括RTC，还包括了片上温度传感器、ADC、RTC-GPIO和touchpad外设</p>
<h1 id="ULP协处理器-1"><a href="#ULP协处理器-1" class="headerlink" title="ULP协处理器"></a>ULP协处理器</h1><p>ULP（Ultra Low Power超低功耗）协处理器是一种简单的<strong>有限状态机</strong>（FSM）。在主处理器处于Deep-sleep深度睡眠模式时，它可以使用ADC、温度传感器和外部IIC传感器执行测量操作。ULP协处理器可以访问RTC慢速内存区域（RTC_SLOW_MEM）及RTC_CNTL、RTC_IO、SARADC等外设寄存器。ULP协处理器使用<strong>32位固定宽度的指令</strong>、<strong>32位内存寻址</strong>，配备<strong>4个16位通用寄存器</strong></p>
<h2 id="ULP协处理器编程"><a href="#ULP协处理器编程" class="headerlink" title="ULP协处理器编程"></a>ULP协处理器编程</h2><p>ULP协处理器代码是用<strong>汇编</strong>语言编写的，并使用<strong>binutils-esp32ulp工具链</strong>进行编译</p>
<p>开发环境被集成到ESP-IDF中</p>
<p>编译方法如下：</p>
<ol>
<li><p>ULP代码必须导入到一个或多个.S扩展文件中，源文件必须放在组件目录中一个独立的目录（如ulp/）</p>
</li>
<li><p>注册后从组件CMakeLists.txt中调用ulp_embed_binary，示例如下</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">idf_component_register()</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(ulp_app_name ulp_<span class="variable">$&#123;COMPONENT_NAME&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(ulp_s_sources ulp/ulp_assembly_source_file.S)</span><br><span class="line"><span class="keyword">set</span>(ulp_exp_dep_srcs <span class="string">&quot;ulp_c_source_file.c&quot;</span>) <span class="comment">#二进制文件命名</span></span><br><span class="line"></span><br><span class="line">ulp_embed_binary(<span class="variable">$&#123;ulp_app_name&#125;</span> <span class="string">&quot;$&#123;ulp_s_sources&#125;&quot;</span> <span class="string">&quot;$&#123;ulp_exp_dep_srcs&#125;&quot;</span>) <span class="comment"># 导入二进制文件</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用常规方法编译应用程序，ULP程序会被自动生成</p>
<p>构建系统的内部编译步骤如下：</p>
<ol>
<li>通过C预处理器运行每个.S文件，生成依赖文件和经过预处理的程序集文件</li>
<li>运行汇编器进行编译</li>
<li>通过C预处理器运行链接器脚本模板（位于components/ulp/ld目录）</li>
<li>将目标文件链接到.elf输出文件</li>
<li>将elf中的内容转储为.bin二进制文件</li>
<li>使用esp32ulp-elf-nm工具在elf文件中生成全局符号列表</li>
<li>创建LD导出脚本和头文件</li>
<li>将生成的二进制文件添加到要嵌入应用程序的二进制文件列表中</li>
</ol>
<p>总体过程和在mcu中嵌入二进制格式的其他文件类似，只是多出了编译的几步</p>
</li>
</ol>
<h2 id="使用ULP程序"><a href="#使用ULP程序" class="headerlink" title="使用ULP程序"></a>使用ULP程序</h2><p><strong>在ULP程序中定义的全局符号也可以在主程序中使用</strong></p>
<p>如果要从主程序访问ULP程序变量，应先<strong>使用include语句包含生成的头文件</strong>，这样就可以像访问常规变量一样访问ulp程序变量</p>
<p>注意：<strong>ULP程序在RTC内存中只能使用32位字的低16位，因为寄存器是16位的并且不具备从字的高位加载的指令</strong></p>
<p>主应用程序需要<strong>调用ulp_load_binary函数</strong>将ULP程序加载到RTC内存中，然后<strong>调用ulp_run函数</strong>启动ULP程序。ULP协处理器由定时器启动，而调用ulp_run则可启动此定时器，定时器为RTC_SLOW_CLK的Tick事件计数（默认情况下，Tick由内部150 KHz晶振器生成）。一旦定时器为所选的SENS_ULP_CP_SLEEP_CYCx_REG寄存器的Tick事件计数，ULP协处理器就会启动，并调用ulp_run的入口点开始运行程序。程序保持运行，直到遇到halt指令或非法指令。一旦程序停止，ULP协处理器电源关闭，定时器再次启动。</p>
<p>使用 <code>SENS_ULP_CP_SLEEP_CYCx_REG</code> 寄存器 (x = 0..4) 设置 Tick 数值。第一次启动 ULP 时，使用 <code>SENS_ULP_CP_SLEEP_CYC0_REG</code> 设置定时器 Tick 数值，之后，ULP 程序可以使用 <code>sleep</code> 指令来另外选择 <code>SENS_ULP_CP_SLEEP_CYCx_REG</code> 寄存器</p>
<h2 id="汇编指令集参考"><a href="#汇编指令集参考" class="headerlink" title="汇编指令集参考"></a>汇编指令集参考</h2><p>ESP32与ESP32S2的汇编指令集并不相同，详情参考官网即可</p>
<p><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/release-v4.1/api-guides/ulp_instruction_set.html">ESP32指令集参考</a></p>
<p><a href="https://docs.espressif.com/projects/esp-idf/zh_CN/release-v4.1/api-guides/ulps2_instruction_set.html">ESP32S2指令集参考</a></p>
<p>汇编大同小异，下面给出几个常见的指令</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NOP</td>
<td>空指令</td>
</tr>
<tr>
<td>SUB R1,R2,R3</td>
<td>R1=R2-R3</td>
</tr>
<tr>
<td>AND R1,R2,R3</td>
<td>R1=R2&amp;R3</td>
</tr>
<tr>
<td>OR R1,R2,R3</td>
<td>R1=R2|R3</td>
</tr>
<tr>
<td>LSH R1,R2,R3</td>
<td>R1=R2&lt;&lt;R3</td>
</tr>
<tr>
<td>RSH R1,R2,R3</td>
<td>R1=R2&gt;&gt;R3</td>
</tr>
<tr>
<td>MOVE R1,R2</td>
<td>R1=R2</td>
</tr>
<tr>
<td>ST R1,R2,k</td>
<td>MEM[R2+k]=R1</td>
</tr>
<tr>
<td>LD R1,R2,k</td>
<td>R1=MEM[R2+k]</td>
</tr>
<tr>
<td>JUMP R1</td>
<td>跳转到R1所在地址</td>
</tr>
<tr>
<td>HALT</td>
<td>协处理器停机</td>
</tr>
<tr>
<td>WAKE</td>
<td>协处理器唤醒</td>
</tr>
<tr>
<td>SLEEP k</td>
<td>协处理器睡眠k个时间单位</td>
</tr>
<tr>
<td>REG_RD Addr,HIGH,LOW</td>
<td>读外设寄存器地址为Addr从LOW到HIGH的内容</td>
</tr>
<tr>
<td>REG_WR Addr,HIGH,LOW,Data</td>
<td>将Data写入外设寄存器地址为Addr从LOW到HIGH的内容</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32_IDF学习1【基本内容】</title>
    <url>/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A01%E3%80%90%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9%E3%80%91/</url>
    <content><![CDATA[<p>学校老师留了个作业，让用剩下一半的寒假学学ESP32，做蓝牙透传+STA&amp;AP模式下工作的http服务器，但是不准用Arduino</p>
<p>当场就傻了：ESP32我刚刚好就会一手Arduino；乐鑫那套ESPIDF太难啃，之前点了个灯就去快乐stm32了；micropython……刷完固件发现蓝牙支持跟【数据删除】一样，还不如用c写——一咬牙一跺脚，回头肝ESPIDF吧</p>
<p><strong>总体思路：资源少，跟着官方走准没错，硬啃就完事了</strong></p>
<p>这个系列笔记可以供只接触过单片机开发（STM32、51基础）和硬件相关知识但没有接触过网络相关知识的同学翻阅学习</p>
<span id="more"></span>

<h1 id="项目文件夹构建"><a href="#项目文件夹构建" class="headerlink" title="项目文件夹构建"></a>项目文件夹构建</h1><p>ESP-IDF项目由各种“组件”构成，你需要什么功能就要往里扔进去什么组件</p>
<p>如果你的代码里用了一堆WiFi的库函数，但是没把WiFi组件加入进去，你是没办法用WiFi功能的</p>
<p>项目保存在项目文件夹下，它的根目录如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── CMakeLists.txt				Cmake使用的文件</span><br><span class="line">├── other_documents				其他文件</span><br><span class="line">├── main						存储主程序</span><br><span class="line">│   ├── CMakeLists.txt			</span><br><span class="line">│   ├── component.mk           组件的make file</span><br><span class="line">│   └── main.c</span><br><span class="line">└── Makefile                   由传统的GNU make程序使用的Makefile</span><br></pre></td></tr></table></figure>

<p>需要注意的是：<strong>ESP-IDF并不是项目文件夹的一部分</strong>，它更像是一个自助编译器，项目文件夹通过idf.py esptools等工具和${IDF_PATH}与ESP-IDF目录建立联系；同样，esp的开发工具链也独立于项目存在，通过${PATH}对项目进行作用</p>
<p>项目建立前，esp-idf会通过idf.py menuconfig配置出Makefile，这些配置保存在sdkconfig中。sdkconfig会被保存在项目文件夹的根目录</p>
<p>CMakeLists.txt通过idf_component_register将项目文件夹下面的组件进行注册，如下所示</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">idf_component_register(SRCS <span class="string">&quot;foo.c&quot;</span> <span class="string">&quot;bar.c&quot;</span></span><br><span class="line">                       INCLUDE_DIRS <span class="string">&quot;include&quot;</span></span><br><span class="line">                       REQUIRES mbedtls)</span><br></pre></td></tr></table></figure>

<p>SRCS给出了源文件清单，能支持的源文件后缀名为.c .cpp .cc .S</p>
<p>INCLUDE_DIRS给出了组件中文件的搜索路径</p>
<p>REQUIRES不是必须的，它声明了其他需要加入的组件</p>
<p>通过这个txt文档，esp-idf就能知道你往里扔了什么组件，然后在编译的时候就会把这些组件编译链接进去（可以理解成操作系统的静态链接）</p>
<p>当编译完成后，文件根目录下会多出build文件夹和sdkconfig文件，build文件夹用来存放编译过程中的文件和生成的文件，sdkconfig文件是在menuconfig的过程中产生的，如果曾经多次重新设置过menuconfig，还会发现多出了以.old结尾的config文件</p>
<p>另外组件也可以自制，详细内容参考官方教程；而idf.py 的底层是用Cmake、make工具实现的，所以也可以直接用这些工具进行编译（不过应该没人这么干）</p>
<h2 id="CMake与component组件"><a href="#CMake与component组件" class="headerlink" title="CMake与component组件"></a>CMake与component组件</h2><p>【摘自官方文档】<strong>一个ESP-IDF项目可以看作是多个不同组件（component）的集合</strong>，组件是模块化且独立的代码，会被编译成静态库并链接到应用程序。ESP-IDF自带一些组件，也可以去找开源项目已有的组件来用</p>
<p>ESP-IDF的组件其实是对CMake的封装，如果使用纯CMake风格的构建方式也可行（说到底还是交叉编译的那套流程，只是乐鑫针对ESP32进行了优化），如下所示</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"><span class="keyword">project</span>(my_custom_app C)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 源文件 main.c 包含有 app_main() 函数的定义</span></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;CMAKE_PROJECT_NAME&#125;</span>.elf main.c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提供 idf_import_components 及 idf_link_components 函数</span></span><br><span class="line"><span class="keyword">include</span>($ENV&#123;IDF_PATH&#125;/tools/cmake/idf_functions.cmake)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为 idf_import_components 做一些配置</span></span><br><span class="line"><span class="comment"># 使能创建构件（不是每个项目都必须）</span></span><br><span class="line"><span class="keyword">set</span>(IDF_BUILD_ARTIFACTS <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(IDF_PROJECT_EXECUTABLE <span class="variable">$&#123;CMAKE_PROJECT_NAME&#125;</span>.elf)</span><br><span class="line"><span class="keyword">set</span>(IDF_BUILD_ARTIFACTS_DIR <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># idf_import_components 封装了 add_subdirectory()，为组件创建库目标，然后使用给定的变量接收“返回”的库目标。</span></span><br><span class="line"><span class="comment"># 在本例中，返回的库目标被保存在“component”变量中。</span></span><br><span class="line">idf_import_components(components $ENV&#123;IDF_PATH&#125; esp-idf)</span><br><span class="line"></span><br><span class="line"><span class="comment"># idf_link_components 封装了 target_link_libraries()，将被 idf_import_components 处理过的组件链接到目标</span></span><br><span class="line">idf_link_components(<span class="variable">$&#123;CMAKE_PROJECT_NAME&#125;</span>.elf <span class="string">&quot;$&#123;components&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>示例项目的目录树结构可能如下所示：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">- myProject/ <span class="comment">#主目录</span></span><br><span class="line">             - CMakeLists.txt <span class="comment">#全局CMAke文档，用于配置项目CMake</span></span><br><span class="line">             - sdkconfig <span class="comment">#项目配置文件，可用menuconfig生成</span></span><br><span class="line">             - components/ - component1/ - CMakeLists.txt <span class="comment">#组件的CMake文档，用于配置组件CMake</span></span><br><span class="line">                                         - Kconfig <span class="comment">#用于定义menuconfig时展示的组件配置选项</span></span><br><span class="line">                                         - src1.c</span><br><span class="line">                           - component2/ - CMakeLists.txt</span><br><span class="line">                                         - Kconfig</span><br><span class="line">                                         - src1.c</span><br><span class="line">                                         - <span class="keyword">include</span>/ - component2.h</span><br><span class="line">             - main/ <span class="comment">#可以将main目录看作特殊的伪组件       - src1.c</span></span><br><span class="line">                           - src2.c</span><br><span class="line">             - build/ <span class="comment">#用于存放输出文件</span></span><br></pre></td></tr></table></figure>

<p><code>main</code> 目录是一个特殊的“伪组件”，包含项目本身的源代码。<code>main</code> 是默认名称，CMake 变量 <code>COMPONENT_DIRS</code> 默认包含此组件，但您可以修改此变量。或者，您也可以在顶层 CMakeLists.txt 中设置 <code>EXTRA_COMPONENT_DIRS</code> 变量以查找其他指定位置处的组件。如果项目中源文件较多，建议将其归于组件中，而不是全部放在 <code>main</code> 中。</p>
<h2 id="全局CMake编写"><a href="#全局CMake编写" class="headerlink" title="全局CMake编写"></a>全局CMake编写</h2><p>全局CMake文档应该至少包含如下三个部分：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>) <span class="comment">#必须放在第一行，设置构建该项目所需CMake的最小版本号</span></span><br><span class="line"><span class="keyword">include</span>($ENV&#123;IDF_PATH&#125;/tools/cmake/<span class="keyword">project</span>.cmake) <span class="comment">#用于导入CMake的其余功能来完成配置项目、检索组件等任务</span></span><br><span class="line"><span class="keyword">project</span>(myProject) <span class="comment">#指定项目名称并创建项目，改名成蕙作为最终输出的bin文件或elf文件的名字</span></span><br></pre></td></tr></table></figure>

<p><strong>每个 CMakeLists 文件只能定义一个项目</strong></p>
<p>还可以包含以下可选部分</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">COMPONENT_DIRS <span class="comment">#组件搜索目录，默认为$&#123;IDF_PATH&#125;/components、$&#123;PROJECT_PATH&#125;/components和EXTRA_COMPONENT_DIRS</span></span><br><span class="line">COMPONENTS <span class="comment">#要构建进项目中的组件名称列表，默认为COMPONENT_DIRS目录下检索到的所有组件</span></span><br><span class="line">EXTRA_COMPONENT_DIRS <span class="comment">#用于搜索组件的其它可选目录列表，可以是绝对路径也可以是相对路径</span></span><br><span class="line">COMPONENT_REQUIRES_COMMON <span class="comment">#每个组件都需要的通用组件列表，这些通用组件会自动添加到每个组件的COMPONENT_PRIV_REQUIRES列表和项目的COMPONENTS列表中</span></span><br></pre></td></tr></table></figure>

<p>使用set命令来设置以上变量，如下所示</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(COMPONENTS <span class="string">&quot;COMPONENTx&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>注意：<strong>set命令需要放在include之前，cmake_minimum_required之后</strong></p>
<p>特别地，可以重命名main组件，分为两种情况</p>
<ol>
<li><p>main组件处于正常位置<code>$&#123;PROJECT_PATH&#125;/main</code>，则会被自动添加到构建系统中，其他组件<strong>自动成为main的依赖项</strong>，方便处理依赖关系</p>
</li>
<li><p>main组件被重命名为xxx，需要在全局CMake设定中设置EXTRA_COMPONENT_DIRS=${PROJECT_PATH}/xxx，并在组件CMake目录中设置COMPONENT_REQUIRES或COMPONENT_PRIV_REQUIRES以指定依赖项</p>
</li>
</ol>
<h2 id="组件CMake编写"><a href="#组件CMake编写" class="headerlink" title="组件CMake编写"></a>组件CMake编写</h2><p>每个项目都包含一个或多个组件，这些组件可以是 ESP-IDF 的一部分，可以是项目自身组件目录的一部分，也可以从自定义组件目录添加</p>
<p>组件是<strong>COMPONENT_DIRS列表中包含CMakeLists.txt文件的任何目录</strong></p>
<p>ESP-IDF会搜索COMPONENT_DIRS中的目录列表来查找项目的组件此列表中的目录可以是组件自身（即包含CMakeLists.txt文件的目录），也可以是子目录为组件的顶级目录；搜索顺序：【ESP-IDF内部组件】-【项目组件】-【EXTRA_COMPONENT_DIRS】中的组件，如果这些目录中的两个或者多个包含具有相同名字的组件，则<strong>使用搜索到的最后一个位置的组件</strong>，允许将组件复制到项目目录中再修改以覆盖ESP-IDF组件</p>
<p>最小的组件CMakeLists如下</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(COMPONENT_SRCS <span class="string">&quot;foo.c&quot;</span> <span class="string">&quot;k.c&quot;</span>) <span class="comment">#用空格分隔的源文件列表</span></span><br><span class="line"><span class="keyword">set</span>(COMPONENT_ADD_INCLUDEDIRS <span class="string">&quot;include&quot;</span>) <span class="comment">#用空格分隔的目录列表，里面的路径会被添加到所有需要该组件的组件（包括 main 组件）全局 include 搜索路径中</span></span><br><span class="line">register_component() <span class="comment">#构建生成与组件同名的库，并最终被链接到应用程序中</span></span><br></pre></td></tr></table></figure>

<p>有以下预设变量，不建议修改</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">COMPONENT_PATH <span class="comment">#组件目录，是包含CMakeLists.txt文件的绝对路径，注意路径中不能包含空格</span></span><br><span class="line">COMPONENT_NAME <span class="comment">#组件名，等同于组件目录名</span></span><br><span class="line">COMPONENT_TARGET <span class="comment">#库目标名，由CMake在内部自动创建</span></span><br></pre></td></tr></table></figure>

<p>有以下项目级别的变量，不建议修改，但可以在组件CMake文档中使用</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">PROJECT_NAME <span class="comment">#项目名，在全局CMake文档中设置</span></span><br><span class="line">PROJECT_PATH <span class="comment">#项目目录（包含项目 CMakeLists 文件）的绝对路径，与CMAKE_SOURCE_DIR相同</span></span><br><span class="line">COMPONENTS <span class="comment">#此次构建中包含的所有组件的名称</span></span><br><span class="line">CONFIG_* <span class="comment">#项目配置中的每个值在cmake中都对应一个以CONFIG_开头的变量</span></span><br><span class="line">IDF_VER <span class="comment">#ESP-IDF的git版本号，由git describe命令生成</span></span><br><span class="line">IDF_TARGET <span class="comment">#项目的硬件目标名称，一般是ESP32</span></span><br><span class="line">PROJECT_VER <span class="comment">#项目版本号</span></span><br><span class="line"></span><br><span class="line">COMPONENT_ADD_INCLUDEDIRS <span class="comment">#相对于组件目录的相对路径，会被添加到所有需要该组件的其他组件的全局include搜索路径中</span></span><br><span class="line">COMPONENT_REQUIRES <span class="comment">#用空格分隔的组件列表，列出了当前组件依赖的其他组件</span></span><br></pre></td></tr></table></figure>

<p>【摘自官网】如果一个组件仅需要额外组件的头文件来编译其源文件（而不是全局引入它们的头文件），则这些被依赖的组件需要在 <code>COMPONENT_PRIV_REQUIRES</code> 中指出</p>
<p>有以下可选的组件特定变量，用于控制某组件的行为</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">COMPONENT_SRCS <span class="comment">#要编译进当前组件的源文件的路径，推荐使用此方法向构建系统中添加源文件</span></span><br><span class="line"></span><br><span class="line">COMPONENT_PRIV_INCLUDEDIRS <span class="comment">#相对于组件目录的相对路径，仅会被添加到该组件的include搜索路径中</span></span><br><span class="line">COMPONENT_PRIV_REQUIRES <span class="comment">#以空格分隔的组件列表，用于编译或链接当前组件的源文件</span></span><br><span class="line">COMPONENT_SRCDIRS <span class="comment">#相对于组件目录的源文件目录路径，用于搜索源文件，匹配成功的源文件会替代COMPONENT_SRCS中指定的源文件</span></span><br><span class="line">COMPONENT_SRCEXCLUDE <span class="comment">#需要从组件中 剔除 的源文件路径</span></span><br><span class="line">COMPONENT_ADD_LDFRAGMENTS <span class="comment">#组件使用的链接片段文件的路径，用于自动生成链接器脚本文件</span></span><br></pre></td></tr></table></figure>

<h2 id="组件配置文件Kconfig"><a href="#组件配置文件Kconfig" class="headerlink" title="组件配置文件Kconfig"></a>组件配置文件Kconfig</h2><p>每个组件都可以包含一个Kconfig文件，和CMakeLists.txt放在同一目录下</p>
<p>Kconfig文件中包含要添加到该组件配置菜单中的一些配置设置信息，运行menuconfig时，可以在Component Settings菜单栏下找到这些设置</p>
<h1 id="有手就行的入门"><a href="#有手就行的入门" class="headerlink" title="有手就行的入门"></a>有手就行的入门</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sdkconfig.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"><span class="comment">//固定需要include的头文件</span></span><br><span class="line"><span class="comment">//用于freertos支持和输出调试信息</span></span><br></pre></td></tr></table></figure>

<p>以下内容头文件包含部分会省略这些</p>
<p>一般程序的入口是app_main()函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="点灯"><a href="#点灯" class="headerlink" title="点灯"></a>点灯</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driver/gpio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLINK_GPIO CONFIG_BLINK_GPIO</span></span><br><span class="line"><span class="comment">/*Kconfig.projbuild文件内容如下</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">menu &quot;Example Configuration&quot;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    config BLINK_GPIO</span></span><br><span class="line"><span class="comment">        int &quot;Blink GPIO number&quot;</span></span><br><span class="line"><span class="comment">        range 0 34</span></span><br><span class="line"><span class="comment">        default 5</span></span><br><span class="line"><span class="comment">        help</span></span><br><span class="line"><span class="comment">            GPIO number (IOxx) to blink on and off.</span></span><br><span class="line"><span class="comment">            Some GPIOs are used for other purposes (flash connections, etc.) and cannot be used to blink.</span></span><br><span class="line"><span class="comment">            GPIOs 35-39 are input-only so cannot be used as outputs.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">endmenu</span></span><br><span class="line"><span class="comment">这个文件的内容是在c预编译器之前进行的替换，会把CONFIG_BLINK_GPIO变成default的值（5）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gpio_pad_select_gpio(BLINK_GPIO);<span class="comment">//选择的引脚</span></span><br><span class="line">    gpio_set_direction(BLINK_GPIO,GPIO_MODE_OUTPUT);<span class="comment">//设置输入输出方向</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Turning off the LED\n&quot;</span>);<span class="comment">//串口打印信息</span></span><br><span class="line">        gpio_set_level(BLINK_GPIO, <span class="number">0</span>);<span class="comment">//GPIO寄存器清零</span></span><br><span class="line">        vTaskDelay(<span class="number">1000</span> / portTICK_PERIOD_MS);<span class="comment">//vTaskDelay()用于任务中的延时，下面会提到这其实是将任务转入阻塞态</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Turning on the LED\n&quot;</span>);</span><br><span class="line">        gpio_set_level(BLINK_GPIO, <span class="number">1</span>);<span class="comment">//GPIO寄存器置位</span></span><br><span class="line">        vTaskDelay(<span class="number">1000</span> / portTICK_PERIOD_MS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h2><p>官方给出的配置步骤为：</p>
<ol>
<li>设置uart_config_t配置结构体</li>
<li>通过ESP_ERROR_CHECK(uart_param_config(uart_num, &amp;uart_config));应用设置</li>
<li>设置引脚</li>
<li>安装驱动，设置buffer和事件处理函数等</li>
<li>配置FSM并运行UART</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_system.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driver/uart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driver/gpio.h&quot;</span></span></span><br><span class="line"><span class="comment">//include uart库和gpio库来实现相应功能</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UART_init</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">//uart初始化函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uart_config_t</span> uart_config =</span><br><span class="line">    &#123;</span><br><span class="line">        .baud_rate = <span class="number">115200</span>,</span><br><span class="line">        .data_bits = UART_DATA_8_BITS,</span><br><span class="line">        .parity = UART_PARITY_DISABLE,</span><br><span class="line">        .stop_bits = UART_STOP_BITS_1,</span><br><span class="line">        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,</span><br><span class="line">        .source_clk = UART_SCLK_APB,</span><br><span class="line">    &#125;;<span class="comment">//配置uart设置</span></span><br><span class="line">    ESP_ERROR_CHECK(uart_param_config(UART_NUM_1, &amp;uart_config));<span class="comment">//应用设置</span></span><br><span class="line">    <span class="comment">//设置uart引脚</span></span><br><span class="line">    ESP_ERROR_CHECK(uart_set_pin(UART_NUM_1, TXD_PIN, RXD_PIN, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE));</span><br><span class="line">    <span class="comment">//使用buffer的情况,使用freertos提供的设备驱动</span></span><br><span class="line">    ESP_ERROR_CHECK(uart_driver_install(UART_NUM_1, RX_BUF_SIZE * <span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UART_send_data</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* TAG, <span class="keyword">const</span> <span class="keyword">char</span>* data)</span><span class="comment">//发送数据函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> length = uart_write_bytes(UART_NUM_1, data, <span class="built_in">strlen</span>(data));</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Wrote %d bytes&quot;</span>, length);</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UART_read_data</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* TAG, <span class="keyword">const</span> <span class="keyword">char</span>* buffer)</span><span class="comment">//收取数据函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">	ESP_ERROR_CHECK(uart_get_buffered_data_len(UART_NUM_1, (<span class="keyword">size_t</span>*)&amp;length));</span><br><span class="line">	length = uart_read_bytes(UART_NUM_1,buffer,length,<span class="number">100</span>);</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Read %d bytes&quot;</span>, length);</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UART_init();<span class="comment">//初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//分别配置发送和接收串口信息的任务</span></span><br><span class="line">    xTaskCreate(rx_task, <span class="string">&quot;uart_rx_task&quot;</span>, <span class="number">1024</span>*<span class="number">2</span>, <span class="literal">NULL</span>, configMAX_PRIORITIES, <span class="literal">NULL</span>);</span><br><span class="line">    xTaskCreate(tx_task, <span class="string">&quot;uart_tx_task&quot;</span>, <span class="number">1024</span>*<span class="number">2</span>, <span class="literal">NULL</span>, configMAX_PRIORITIES<span class="number">-1</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="console控制台"><a href="#console控制台" class="headerlink" title="console控制台"></a>console控制台</h2><p>ESP提供了一个console用于串口调试，可以实现类似shell的操作</p>
<p>在固件中加入console相关组件后烧录，在串口中打出help就可以查看相关帮助</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register_system</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">//系统相关指令</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    register_free();</span><br><span class="line">    register_heap();</span><br><span class="line">    register_version();</span><br><span class="line">    register_restart();</span><br><span class="line">    register_deep_sleep();</span><br><span class="line">    register_light_sleep();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> WITH_TASKS_INFO</span></span><br><span class="line">    register_tasks();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件中两个目录 ：cmd_nvs用于指令的识别；cmd_system用于系统指令的实现（这部分功能需要与RTOS配合才行）</p>
<h2 id="NVS-FLASH"><a href="#NVS-FLASH" class="headerlink" title="NVS FLASH"></a>NVS FLASH</h2><p>NVS即Non-volatile storage非易失性存储</p>
<p>它相当于把ESP32的关键数据以<strong>键值格式</strong>存储在FLASH里，NVS通过<code>spi_flash_&#123;read|write|erase&#125;</code>三个API进行操作，NVS使用主flash的一部分。管理方式类似数据库的表，在NVS里面可以存储很多个不同的表，每个表下面有不同的键值，每个键值可以存储8位、16位、32位等等不同的数据类型，但<strong>不能是浮点数</strong></p>
<ol>
<li>使用接口函数nvs_flash_init();进行初始化，如果失败可以使用nvs_flash_erase();先擦除再初始化</li>
<li>应用程序可以使用nvs_open();选用NVS表中的分区或通过nvs_open_from_part()指定其名称后使用其他分区</li>
</ol>
<p>注意：<strong>NVS分区被截断时，其内容应该被擦除</strong></p>
<h3 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nvs_get_i8(my_handle,<span class="comment">//表的句柄</span></span><br><span class="line">           <span class="string">&quot;nvs_i8&quot;</span>,<span class="comment">//键值</span></span><br><span class="line">           &amp;nvs_i8);<span class="comment">//对应变量的指针</span></span><br><span class="line"><span class="comment">//使用这个API来读取8位数据，同理还有i16、u32等版本的API可用</span></span><br><span class="line"></span><br><span class="line">nvs_set_i8(my_handle,<span class="comment">//表的句柄</span></span><br><span class="line">           <span class="string">&quot;nvs_i8&quot;</span>,<span class="comment">//键值</span></span><br><span class="line">           nvs_i8);<span class="comment">//对应的变量</span></span><br><span class="line"><span class="comment">//使用这个API来写入8位数据，同理还有i16、u32等版本的API可用</span></span><br></pre></td></tr></table></figure>

<h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nvs_open(<span class="string">&quot;List&quot;</span>,<span class="comment">//表名</span></span><br><span class="line">         NVS_READWRITE,<span class="comment">//读写模式，可选读写模式或只读模式</span></span><br><span class="line">         &amp;my_handle);<span class="comment">//表的句柄</span></span><br><span class="line"><span class="comment">//打开表</span></span><br><span class="line"></span><br><span class="line">nvs_commit(my_handle);<span class="comment">//提交表</span></span><br><span class="line">nvs_close(my_handle);<span class="comment">//关闭表</span></span><br></pre></td></tr></table></figure>

<h3 id="NVS初始化示例程序"><a href="#NVS初始化示例程序" class="headerlink" title="NVS初始化示例程序"></a>NVS初始化示例程序</h3><p>官方给出的示例程序中一般以以下形式初始化NVS</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Initialize NVS</span></span><br><span class="line"><span class="keyword">esp_err_t</span> ret = nvs_flash_init();<span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">if</span> (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND)<span class="comment">//如果初始化未成功</span></span><br><span class="line">&#123;</span><br><span class="line">	ESP_ERROR_CHECK(nvs_flash_erase());<span class="comment">//擦除NVS并查错</span></span><br><span class="line">	ret = nvs_flash_init();<span class="comment">//再次初始化</span></span><br><span class="line">&#125;</span><br><span class="line">ESP_ERROR_CHECK(ret);<span class="comment">//查错</span></span><br></pre></td></tr></table></figure>

<h1 id="ESPIDF提供的常用库函数"><a href="#ESPIDF提供的常用库函数" class="headerlink" title="ESPIDF提供的常用库函数"></a>ESPIDF提供的常用库函数</h1><h2 id="ESP-LOG打印系统日志到串口"><a href="#ESP-LOG打印系统日志到串口" class="headerlink" title="ESP_LOG打印系统日志到串口"></a>ESP_LOG打印系统日志到串口</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_err.h&quot;</span></span></span><br><span class="line"><span class="comment">//用于打印错误信息</span></span><br></pre></td></tr></table></figure>

<ul>
<li> ESP_LOGE - 错误日志 (最高优先级)</li>
<li>ESP_LOGW - 警告日志</li>
<li>ESP_LOGI - 信息级别的日志</li>
<li>ESP_LOGD - 用于调试的日志</li>
<li>ESP_LOGV - 仅仅用于提示的日志{最低优先级)</li>
</ul>
<p>这些日志可以在menuconfig设置中打开或关闭，也可以在代码中手动设置关闭</p>
<h2 id="RTOS操作"><a href="#RTOS操作" class="headerlink" title="RTOS操作"></a>RTOS操作</h2><ol>
<li>vTaskDelay将任务置为阻塞状态，期间CPU继续运行其它任务</li>
</ol>
<p>持续时间由参数xTicksToDelay指定，<strong>单位是系统节拍时钟周期</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vTaskDelay</span><span class="params">(portTickTypexTicksToDelay)</span></span></span><br></pre></td></tr></table></figure>

<p>常量portTickTypexTicksToDelay用来辅助计算真实时间，此值是系统节拍时钟中断的周期，单位是ms</p>
<p>在文件FreeRTOSConfig.h中，宏INCLUDE_vTaskDelay 必须设置成1，此函数才能有效</p>
<ol start="2">
<li>xTaskCreate创建新的任务并添加到任务队列</li>
</ol>
<p>注意：<strong>所有任务应当为死循环且永远不会返回，即嵌套在while(1)内</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">xTaskCreate(pdTASK_CODE pvTaskCode,<span class="comment">//指向任务的入口函数</span></span><br><span class="line">            <span class="keyword">const</span> portCHAR * <span class="keyword">const</span> pcName,<span class="comment">//任务名</span></span><br><span class="line">            <span class="keyword">unsigned</span> portSHORT usStackDepth,<span class="comment">//任务堆栈大小</span></span><br><span class="line">            <span class="keyword">void</span> *pvParameters,<span class="comment">//任务参数指针</span></span><br><span class="line">            <span class="keyword">unsigned</span> portBASE_TYPE uxPriority,<span class="comment">//任务优先级</span></span><br><span class="line">            xTaskHandle *pvCreatedTask)<span class="comment">//任务句柄，用于引用创建的任务</span></span><br></pre></td></tr></table></figure>

<p>注意，<strong>任务优先级0为最低，数字越大优先级越高</strong></p>
<ol start="3">
<li>FreeRTOS的神奇之处</li>
</ol>
<p>一句话概论：<strong>RTOS就是彳亍</strong>，FreeRTOS可以实现任务之间的时间片轮转调度，两个任务可以你执行一会我执行一会，高优先级任务还能抢占低优先级任务，让它马上爪巴，高优先级任务先运行</p>
<ul>
<li>FreeRTOS的底层实现还没看明白，过一阵子再学，反正效果和RTThread差不多，先把作业肝完再说 =)</li>
</ul>
<p>这种神奇的操作靠的就是上面两个API</p>
<p>需要注意的是：<strong>所有任务应当为死循环且永远不会返回</strong>（两次强调）</p>
<p>不过如果实在不想写死循环，可以在任务末尾加上</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vTaskDelete();<span class="comment">//用于删除执行结束的任务</span></span><br></pre></td></tr></table></figure>

<p>不过只执行一次的任务大多是在初始化阶段完成的，用的时候尽量小心些</p>
<ol start="4">
<li>事件event</li>
</ol>
<p>事件是一种实现任务间通信的机制，主要用于实现多任务间的同步，但事件通信只能是事件类型的通信，无数据传输。事件可以实现一对多和多对多的传输：一个任务可以等待多个事件的发生：可以是任意一个事件发生时唤醒任务进行事件处理；也可以是几个事件都发生后才唤醒任务进行事件处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_event.h&quot;</span></span></span><br><span class="line"><span class="comment">//include 这个文件才能使用event</span></span><br></pre></td></tr></table></figure>

<p>事件使用<strong>事件循环</strong>来管理，事件循环分别为默认事件循环和自定义事件循环</p>
<p>默认事件循环不需要传入事件循环句柄；但自定义循环需要</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">esp_event_loop_create(<span class="keyword">const</span> <span class="keyword">esp_event_loop_args_t</span> *event_loop_args,<span class="comment">//事件循环参数</span></span><br><span class="line">                      <span class="keyword">esp_event_loop_handle_t</span> *event_loop)<span class="comment">//事件循环句柄</span></span><br><span class="line"><span class="comment">//用于创建一个事件循环   </span></span><br><span class="line">esp_event_loop_delete(<span class="keyword">esp_event_loop_handle_t</span> event_loop)<span class="comment">//删除事件循环</span></span><br></pre></td></tr></table></figure>

<p>事件需要<strong>注册</strong>到事件循环</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 注册事件到事件循环 */</span></span><br><span class="line">esp_event_handler_instance_register(<span class="keyword">esp_event_base_t</span> event_base,<span class="comment">//事件基本ID</span></span><br><span class="line">                                    <span class="keyword">int32_t</span> event_id,<span class="comment">//事件ID</span></span><br><span class="line">                                    <span class="keyword">esp_event_handler_t</span> event_handler,<span class="comment">//事件回调函数指针（句柄）</span></span><br><span class="line">                                    <span class="keyword">void</span> *event_handler_arg,<span class="comment">//事件回调函数参数</span></span><br><span class="line">                                    <span class="keyword">esp_event_handler_instance_t</span> *instance)</span><br><span class="line"><span class="comment">//如果事件回调函数在事件删除之前还没有被注册，需要在这里注册来进行调用</span></span><br><span class="line">    </span><br><span class="line">esp_event_handler_instance_register_with(<span class="keyword">esp_event_loop_handle_t</span> event_loop,<span class="comment">//事件循环句柄</span></span><br><span class="line">                                         <span class="keyword">esp_event_base_t</span> event_base,<span class="comment">//事件基本ID</span></span><br><span class="line">                                         <span class="keyword">int32_t</span> event_id,<span class="comment">//事件ID</span></span><br><span class="line">                                         <span class="keyword">esp_event_handler_t</span> event_handler,<span class="comment">//事件回调函数指针（句柄）</span></span><br><span class="line">                                         <span class="keyword">void</span> *event_handler_arg,<span class="comment">//事件回调函数参数</span></span><br><span class="line">                                         <span class="keyword">esp_event_handler_instance_t</span> *instance)</span><br><span class="line"><span class="comment">//如果事件回调函数在事件删除之前还没有被注册，需要在这里注册来进行调用</span></span><br><span class="line">    </span><br><span class="line">esp_event_handler_register(<span class="keyword">esp_event_base_t</span> event_base,<span class="comment">//事件基本ID</span></span><br><span class="line">                           <span class="keyword">int32_t</span> event_id,<span class="comment">//事件ID</span></span><br><span class="line">                           <span class="keyword">esp_event_handler_t</span> event_handler,<span class="comment">//事件句柄</span></span><br><span class="line">                           <span class="keyword">void</span> *event_handler_arg)<span class="comment">//事件参数</span></span><br><span class="line">    </span><br><span class="line">esp_event_handler_register_with(<span class="keyword">esp_event_loop_handle_t</span> event_loop,<span class="comment">//事件循环句柄</span></span><br><span class="line">                                <span class="keyword">esp_event_base_t</span> event_base,<span class="comment">//事件基本ID</span></span><br><span class="line">                                <span class="keyword">int32_t</span> event_id,<span class="comment">//事件ID</span></span><br><span class="line">                                <span class="keyword">esp_event_handler_t</span> event_handler,<span class="comment">//事件回调函数指针（句柄）</span></span><br><span class="line">                                <span class="keyword">void</span> *event_handler_arg)<span class="comment">//事件回调函数的参数</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 取消注册 */</span></span><br><span class="line">esp_event_handler_unregister(<span class="keyword">esp_event_base_t</span> event_base,</span><br><span class="line">                             <span class="keyword">int32_t</span> event_id,</span><br><span class="line">                             <span class="keyword">esp_event_handler_t</span> event_handler)</span><br><span class="line">esp_event_handler_unregister_with(<span class="keyword">esp_event_loop_handle_t</span> event_loop,</span><br><span class="line">                                  <span class="keyword">esp_event_base_t</span> event_base,</span><br><span class="line">                                  <span class="keyword">int32_t</span> event_id,</span><br><span class="line">                                  <span class="keyword">esp_event_handler_t</span> event_handler)</span><br></pre></td></tr></table></figure>

<p>默认事件循环default event loop是系统的基础事件循环，用于传递系统事件（如WiFi等），但是也可以注册用户事件，一般的蓝牙+WiFi用这一个循环就足够了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">esp_event_loop_create_default(<span class="keyword">void</span>)<span class="comment">//创建默认事件循环</span></span><br><span class="line">esp_event_loop_delete_default(<span class="keyword">void</span>)<span class="comment">//删除默认事件循环</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">esp_event_loop_run(<span class="keyword">esp_event_loop_handle_t</span> event_loop,<span class="comment">//事件循环句柄</span></span><br><span class="line">                   TickType_t ticks_to_run)<span class="comment">//运行时间</span></span><br></pre></td></tr></table></figure>

<p>默认事件和自定义事件之间可以进行<strong>发送</strong>操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">esp_event_post(<span class="keyword">esp_event_base_t</span> event_base, <span class="keyword">int32_t</span> event_id, <span class="keyword">void</span> *event_data, <span class="keyword">size_t</span> event_data_size, TickType_t ticks_to_wait)</span><br></pre></td></tr></table></figure>

<p>使用宏</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ESP_EVENT_DECLARE_BASE()</span><br><span class="line">ESP_EVENT_DEFINE_BASE()</span><br></pre></td></tr></table></figure>

<p>来声明和定义事件，同时事件的ID应该用enum枚举变量来指出，如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 头文件 */</span></span><br><span class="line"><span class="comment">// Declarations for event source 1: periodic timer</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMER_EXPIRIES_COUNT<span class="comment">// number of times the periodic timer expires before being stopped</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMER_PERIOD                1000000  <span class="comment">// period of the timer event source in microseconds</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">esp_timer_handle_t</span> g_timer;           <span class="comment">// the periodic timer object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare an event base</span></span><br><span class="line">ESP_EVENT_DECLARE_BASE(TIMER_EVENTS);        <span class="comment">// declaration of the timer events family</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span><span class="comment">// declaration of the specific events under the timer event family</span></span><br><span class="line">    TIMER_EVENT_STARTED,                     <span class="comment">// raised when the timer is first started</span></span><br><span class="line">    TIMER_EVENT_EXPIRY,                      <span class="comment">// raised when a period of the timer has elapsed</span></span><br><span class="line">    TIMER_EVENT_STOPPED                      <span class="comment">// raised when the timer has been stopped</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declarations for event source 2: task</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_ITERATIONS_COUNT        5       <span class="comment">// number of times the task iterates</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_ITERATIONS_UNREGISTER   3       <span class="comment">// count at which the task event handler is unregistered</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_PERIOD                  500     <span class="comment">// period of the task loop in milliseconds</span></span></span><br><span class="line"></span><br><span class="line">ESP_EVENT_DECLARE_BASE(TASK_EVENTS);         <span class="comment">// declaration of the task events family</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    TASK_ITERATION_EVENT,                    <span class="comment">// raised during an iteration of the loop within the task</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 头文件 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 源文件 */</span></span><br><span class="line">ESP_EVENT_DEFINE_BASE(TIMER_EVENTS);</span><br><span class="line"><span class="comment">/* 源文件 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 枚举定义的事件名应该放在头文件，宏函数应该放在源文件 */</span></span><br></pre></td></tr></table></figure>

<p>可使用API esp_event_loop_create_default()来创建事件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">esp_event_loop_create_default()</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32_IDF学习4【SPI与外部存储器】</title>
    <url>/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A04%E3%80%90SPI%E4%B8%8E%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%91/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>注意：<strong>所有SPI相关的API都不能在中断服务函数或上下文切换期间使用，因为SPI相关的API都调用了互斥量，可能会造成系统错误</strong></p>
<h1 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h1><p>调用<code>#include &quot;driver/spi_master.h&quot;</code>或<code>#include &quot;driver/spi_slave.h&quot;</code>来使用API组件</p>
<p>ESP32集成了<strong>4个SPI外设</strong></p>
<p>SPI0和SPI1通过总线仲裁器共享一条信号总线，用于在模组内部访问FLASH（SoC FLASH），不会对用户开放</p>
<p>SPI2和SPI3是<strong>通用SPI控制器</strong>，有时也被称为HSPI和VSPI，这里的HSPI和VSPI没有实际区别，只是为了标识两个SPI，他们都既可以作为主机使用也可以作为从机使用。SPI控制器拥有独立的信号总线，每条总线都有三条片选（CS）信号，也就是说每个控制器都能驱动最多3个SPI从器件。这两个SPI控制器对用户开放</p>
<p>相关概念参考SPI协议，以下内容默认读者学习过SPI、QSPI基础知识。</p>
<span id="more"></span>

<p>表格翻译自官网</p>
<table>
<thead>
<tr>
<th>概念</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Host</strong></td>
<td>作为SPI主设备使用的ESP32片上SPI外设，目前只能使用SPI2或SPI3</td>
</tr>
<tr>
<td><strong>Device</strong></td>
<td>片外SPI从设备</td>
</tr>
<tr>
<td><strong>Bus</strong></td>
<td>SPI信号总线，通常包括MISO、MOSI、SCLK、多条CS线、可选的QUADWP和QUADHD线</td>
</tr>
<tr>
<td><strong>MISO</strong></td>
<td>Master in Slave out</td>
</tr>
<tr>
<td><strong>MOSI</strong></td>
<td>Master in Slave out</td>
</tr>
<tr>
<td><strong>SCLK</strong></td>
<td>同步时钟</td>
</tr>
<tr>
<td><strong>CS</strong></td>
<td>片选信号</td>
</tr>
<tr>
<td><strong>QUADWP</strong></td>
<td>写保护信号，当且仅当使用QSPI时启用</td>
</tr>
<tr>
<td><strong>QUADHD</strong></td>
<td>保持信号，当且仅当使用QSPI时启用</td>
</tr>
<tr>
<td><strong>Assertion</strong></td>
<td>启用某条信号线的行为；相反的行为称为<em>de-assertion</em>.</td>
</tr>
<tr>
<td><strong>Transaction</strong></td>
<td>启动片选、传输数据、结束传输、断开片选这一系列传输过程称为一次传输。传输是原子性的，不能被中断</td>
</tr>
<tr>
<td><strong>Launch edge</strong></td>
<td>源寄存器触发<em>launches</em>信号到总线的时钟边沿</td>
</tr>
<tr>
<td><strong>Latch edge</strong></td>
<td>源寄存器触发<em>latches in</em>信号刀纵线的时钟边沿</td>
</tr>
</tbody></table>
<p>对应的SPI-GPIO映射表如下所示</p>
<table>
<thead>
<tr>
<th>引脚对应的GPIO</th>
<th>SPI2</th>
<th>SPI3</th>
</tr>
</thead>
<tbody><tr>
<td>CS0*</td>
<td>15</td>
<td>5</td>
</tr>
<tr>
<td>SCLK</td>
<td>14</td>
<td>18</td>
</tr>
<tr>
<td>MISO</td>
<td>12</td>
<td>19</td>
</tr>
<tr>
<td>MOSI</td>
<td>13</td>
<td>23</td>
</tr>
<tr>
<td>QUADWP</td>
<td>2</td>
<td>22</td>
</tr>
<tr>
<td>QUADHD</td>
<td>4</td>
<td>21</td>
</tr>
</tbody></table>
<h2 id="SPI-Master"><a href="#SPI-Master" class="headerlink" title="SPI Master"></a>SPI Master</h2><p>ESP32内部的SPI控制器可设置为主模式（Master），基本特点如下</p>
<ul>
<li>适应多线程环境</li>
<li>可配置DMA辅助传输</li>
<li>在同一信号线上自动分配时间处理来自不同设备的的多路数据</li>
</ul>
<p>但是SPI控制器不是永远安全的，用户最好<strong>重构代码来让每个SPI外设在同一时间只被一个任务访问（避免临界区出现）</strong>或<strong>使用互斥量来处理临界区</strong></p>
<p>临界区相关的处理参考RTOS部分</p>
<h3 id="SPI传输时序"><a href="#SPI传输时序" class="headerlink" title="SPI传输时序"></a>SPI传输时序</h3><p>SPI的传输格式有以下五个组成部分</p>
<ol>
<li>指令数据段</li>
</ol>
<p>主机发送0-16位指令</p>
<ol start="2">
<li>地址数据段</li>
</ol>
<p>主机发送0-64位地址</p>
<ol start="3">
<li>写入数据</li>
</ol>
<p>主机向外设发送数据，允许附带可选的指令和地址数据，但这些数据无法从电器层面区分</p>
<ol start="4">
<li>空段</li>
</ol>
<p>用于同步时序</p>
<ol start="5">
<li>读取数据</li>
</ol>
<p>外设向主机发送数据</p>
<p>物理层传输属性由spi_bus_config_t结构体、spi_transaction_t结构体和spi_device_interface_config_t结构体设置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//spi_bus_config_t用于配置GPIO的SPI复用引脚和SPI控制器</span></span><br><span class="line"><span class="comment">//注意：如果不使用QSPI可以直接不初始化quadwp_io_num和quadhd_io_num，总线会自动关闭未被配置的信号线</span></span><br><span class="line"><span class="comment">//如果不使用某线应将其设置为-1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_bus_config_t</span>=</span>&#123;</span><br><span class="line">	.miso_io_num,<span class="comment">//MISO信号线，可复用为QSPI的D0</span></span><br><span class="line">	.mosi_io_num,<span class="comment">//MOSI信号线，可复用为QSPI的D1</span></span><br><span class="line">	.sclk_io_num,<span class="comment">//SCLK信号线</span></span><br><span class="line">	.quadwp_io_num,<span class="comment">//WP信号线，专用于QSPI的D2</span></span><br><span class="line">	.quadhd_io_num,<span class="comment">//HD信号线，专用于QSPI的D3</span></span><br><span class="line">	.max_transfer_sz,<span class="comment">//最大传输数据大小，单位字节，默认为4094</span></span><br><span class="line">    .intr_flags,<span class="comment">//中断指示位</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//spi_transaction_t用于配置SPI的数据格式</span></span><br><span class="line"><span class="comment">//注意：这个结构体只定义了一种SPI传输格式，如果需要多种SPI传输则需要定义多个结构体并进行实例化</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_transaction_t</span>=</span>&#123;</span><br><span class="line">    .cmd,<span class="comment">//指令数据，其长度在spi_device_interface_config_t中的command_bits设置</span></span><br><span class="line">    .addr,<span class="comment">//地址数据，其长度在spi_device_interface_config_t中的address_bits设置</span></span><br><span class="line">	.length,<span class="comment">//数据总长度，单位：比特</span></span><br><span class="line">    .rxlength,<span class="comment">//接收到的数据总长度，应小于length，如果设置为0则默认设置为length</span></span><br><span class="line">	.flags,<span class="comment">//SPI传输属性设置</span></span><br><span class="line">	.user,<span class="comment">//用户定义变量，可以用来存储传输ID等注释信息</span></span><br><span class="line">    .tx_buffer,<span class="comment">//发送数据缓存区指针</span></span><br><span class="line">    .tx_data,<span class="comment">//发送数据</span></span><br><span class="line">    .rx_buffer,<span class="comment">//接收数据缓存区指针，如果启用DMA则需要至少4个字节</span></span><br><span class="line">    .rx_data<span class="comment">//如果设置了SPI_TRANS_USE_RXDATA，数据会被这个变量直接接收</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//spi_device_interface_config_t用于配置SPI协议情况</span></span><br><span class="line"><span class="comment">//需要根据从设备的数据手册进行设置</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_device_interface_config_t</span>=</span>&#123;</span><br><span class="line">	.command_bits,<span class="comment">//默认控制位长度，设置为0-16</span></span><br><span class="line">    .address_bits,<span class="comment">//默认地址位长度，设置为0-64</span></span><br><span class="line">    .dummy_bits,<span class="comment">//在地址和数据位段之间插入的dummy位长度，用于匹配时序，一般可以保持默认</span></span><br><span class="line">	.clock_speed_hz,<span class="comment">//时钟频率，设置的是80MHz的分频系数，单位为Hz</span></span><br><span class="line">	.mode,<span class="comment">//SPI模式，设置为0-3</span></span><br><span class="line">    .duty_cycle_pos,<span class="comment">//</span></span><br><span class="line">    .cs_ena_pretrans,<span class="comment">//传输前CS信号的建立时间，只在半双工模式下有用</span></span><br><span class="line">    .cs_ena_posttrans,<span class="comment">//传输时CS信号的保持时间</span></span><br><span class="line">    .input_delay_ns,<span class="comment">//从机的最大合法数据传输时间</span></span><br><span class="line">	.spics_io_num,<span class="comment">//设置GPIO复用为CS引脚</span></span><br><span class="line">	.queue_size,<span class="comment">//传输队列大小，决定了等待传输数据的数量</span></span><br><span class="line">	.flags,<span class="comment">//SPI设备属性设置</span></span><br><span class="line">	.pre_cb,<span class="comment">//传输开始时的回调函数</span></span><br><span class="line">	.post_cb,<span class="comment">//传输结束时的回调函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>SPI主机可以发起全双工/半双工的通信，全双工通信中，<strong>总传输数据长度由spi_device_interface_config_t::command_bits、spi_device_interface_config_t::address_bits、spi_transaction_t::length决定</strong>，spi_transaction_t::rxlength仅决定了缓存区接收数据的长度；但半双工通信中，读写不同步，<strong>总传输数据长度由只spi_transaction_t::length和spi_transaction_t::rxlength决定</strong></p>
<p>指令和地址数据段是可选的，不是所有SPI设备都需要指令和/或数据，所以在spi_device_interface_config_t结构体中，如果设置command_bits和address_bits为0，就不会发送指令和数据</p>
<p>读写数据段也是可选的，如果rx_buffer设置为NULL，SPI_TRANS_USE_RXDATA没有定义，则读取数据段会被跳过；同理，如果tx_buffer设置为NULL，SPI_TRANS_USE_TXDATA没有定义，则写入数据段会被跳过</p>
<p>ESP32的驱动提供了两种传输方式：</p>
<ol>
<li>中断传输：发送、接收时触发中断</li>
<li>轮询传输：轮询SPI设备状态，如果空闲则可以调用函数</li>
</ol>
<p>两种模式也可以同时使用，但是实现代码较复杂</p>
<p>官网给出解释为</p>
<blockquote>
<h3 id="Notes-on-Sending-Mixed-Transactions-to-the-Same-Device"><a href="#Notes-on-Sending-Mixed-Transactions-to-the-Same-Device" class="headerlink" title="Notes on Sending Mixed Transactions to the Same Device"></a>Notes on Sending Mixed Transactions to the Same Device</h3><p>To reduce coding complexity, send only one type of transactions  (interrupt or polling) to one Device. However, you still can send both  interrupt and polling transactions alternately. The notes below explain  how to do this.</p>
<p>The polling transactions should be initiated only after all the polling and interrupt transactions are finished.</p>
<p>Since an unfinished polling transaction blocks other transactions, please do not forget to call the function <a href="https://docs.espressif.com/projects/esp-idf/zh_CN/release-v4.1/api-reference/peripherals/spi_master.html#_CPPv422spi_device_polling_end19spi_device_handle_t10TickType_t"><code>spi_device_polling_end()</code></a> after <a href="https://docs.espressif.com/projects/esp-idf/zh_CN/release-v4.1/api-reference/peripherals/spi_master.html#_CPPv424spi_device_polling_start19spi_device_handle_tP17spi_transaction_t10TickType_t"><code>spi_device_polling_start()</code></a> to allow other transactions or to allow other Devices to use the bus.  Remember that if there is no need to switch to other tasks during your  polling transaction, you can initiate a transaction with <a href="https://docs.espressif.com/projects/esp-idf/zh_CN/release-v4.1/api-reference/peripherals/spi_master.html#_CPPv427spi_device_polling_transmit19spi_device_handle_tP17spi_transaction_t"><code>spi_device_polling_transmit()</code></a> so that it will be ended automatically.</p>
<p>In-flight polling transactions are disturbed by the ISR operation to  accommodate interrupt transactions. Always make sure that all the  interrupt transactions sent to the ISR are finished before you call <a href="https://docs.espressif.com/projects/esp-idf/zh_CN/release-v4.1/api-reference/peripherals/spi_master.html#_CPPv424spi_device_polling_start19spi_device_handle_tP17spi_transaction_t10TickType_t"><code>spi_device_polling_start()</code></a>. To do that, you can keep calling <a href="https://docs.espressif.com/projects/esp-idf/zh_CN/release-v4.1/api-reference/peripherals/spi_master.html#_CPPv427spi_device_get_trans_result19spi_device_handle_tPP17spi_transaction_t10TickType_t"><code>spi_device_get_trans_result()</code></a> until all the transactions are returned.</p>
<p>To have better control of the calling sequence of functions, send  mixed transactions to the same Device only within a single task.</p>
</blockquote>
<p>也就是说轮询模式下的两个API相当于开关，一个让CPU进入轮询状态，一个让CPU退出轮询状态，需要配合使用；中断模式下的API相当于一个指令，让SPI控制器在发送/接收完毕时发出中断告知CPU，CPU接收到中断后执行中断服务函数；轮询状态下应当保证没有中断，否则会影响实时性，但是中断状态下CPU可以干别的事</p>
<h3 id="SPI传输模式"><a href="#SPI传输模式" class="headerlink" title="SPI传输模式"></a>SPI传输模式</h3><h4 id="中断传输"><a href="#中断传输" class="headerlink" title="中断传输"></a>中断传输</h4><p>中断传输期间，CPU可以执行其他任务。传输结束时，SPI外设触发中断，CPU调用任务处理函数进行处理</p>
<p>注意：一个任务可以排列多个传输序列，驱动程序会自动在中断服务程序（ISR）中对传输结果进行处理；但是中断传输会导致很多中断，如果设置中断任务太多还会影响日常任务运行降低实时性能</p>
<h4 id="轮询传输"><a href="#轮询传输" class="headerlink" title="轮询传输"></a>轮询传输</h4><p>轮询传输会轮询SPI外设的状态寄存器（官网原文为状态位）直到传输完成</p>
<p>轮询传输可以节约ISR队列挂起等待和线程（任务）上下文切换所需时间，但是会导致CPU占用</p>
<p>使用API spi_device_polling_end()来进行轮询，这个API至少需要1us时间解除对其他任务的阻塞；官方推荐使用spi_device_acquire_bus()和spi_device_release_bus()来进行调度</p>
<h3 id="SPI使用"><a href="#SPI使用" class="headerlink" title="SPI使用"></a>SPI使用</h3><ol>
<li>设定并初始化GPIO复用为SPI</li>
</ol>
<p>调用spi_bus_initialize()来初始化SPI总线，使用spi_bus_config_t结构体设置GPIO引脚</p>
<p><strong>注意不使用的信号线要设置为-1</strong></p>
   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">spi_bus_initialize</span><span class="params">(<span class="keyword">spi_host_device_t</span> host,<span class="comment">//SPI设备号</span></span></span></span><br><span class="line"><span class="params"><span class="function">                           	 <span class="keyword">const</span> <span class="keyword">spi_bus_config_t</span> *bus_config,<span class="comment">//总线GPIO设置</span></span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">int</span> dma_chan)</span><span class="comment">//使用的DMA通道</span></span></span><br><span class="line"><span class="function"><span class="comment">//总线初始化API</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果使能了DMA通道，所有传输和使用的数据接收缓冲区都应该在支持DMA访问的内存区域中申请</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">spi_host_device_t</span></span>=&#123;</span><br><span class="line">	SPI1_HOST=<span class="number">0</span>,</span><br><span class="line">	SPI2_HOST,</span><br><span class="line">	SPI3_HOST,</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">//dma_chan只能设置为0，1，2；设置为0则不启用DMA</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用spi_bus_add_device()设置SPI控制器设备</li>
</ol>
<p>该步骤的目的是通知FreeRTOS驱动有一个SPI设备连接到了总线上</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">spi_bus_add_device</span><span class="params">(<span class="keyword">spi_host_device_t</span> host,<span class="comment">//SPI设备号</span></span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">const</span> <span class="keyword">spi_device_interface_config_t</span> *dev_config,<span class="comment">//数据格式设置</span></span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">spi_device_handle_t</span> *handle)</span><span class="comment">//设备句柄   </span></span></span><br></pre></td></tr></table></figure>

<p>这个API会根据spi_device_interface_config_t结构体初始化一个SPI外设并规定具体的时序</p>
<p>注意不要过度使用：<strong>ESP32只有2个可用的SPI控制器，一个SPI控制器只有三个CS信号线，最多能控制6个从设备</strong></p>
<p>全双工下，SPI最高速度可达80MHz，一般使用40Mhz；而半双工下，最高只能达到26MHz</p>
<ol start="3">
<li><p>设置一个或多个spi_transaction_t结构体来配置传输的数据格式</p>
<p>注意：<strong>需要等待当前传输完成后再发起新的传输</strong></p>
<ol>
<li>中断模式</li>
</ol>
<p>使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">spi_device_queue_trans</span><span class="params">(<span class="keyword">spi_device_handle_t</span> handle,<span class="comment">//SPI设备句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">spi_transaction_t</span> *trans_desc,<span class="comment">//要执行的传输</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                 TickType_t ticks_to_wait)</span><span class="comment">//等待时间，如果设置为MAX_DELAY则会等待到队满</span></span></span><br><span class="line"><span class="function"><span class="comment">//将要执行的传输放入SPI传输队列</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">spi_device_get_trans_result</span><span class="params">(<span class="keyword">spi_device_handle_t</span> handle,<span class="comment">//SPI设备句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">spi_transaction_t</span> **trans_desc,<span class="comment">//之前执行的传输的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                      TickType_t ticks_to_wait)</span><span class="comment">//等待时间</span></span></span><br><span class="line"><span class="function"><span class="comment">//获取此前由spi_device_queue_trans发起传输的结果</span></span></span><br></pre></td></tr></table></figure>

<p>来将一个传输加入待传输队列</p>
<p>可以通过spi_device_get_trans_result()查询传输结果；也可以将所有结果放入以下API，使用中断处理函数和FSM来设定各种传输结果对应的操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">spi_device_transmit</span><span class="params">(<span class="keyword">spi_device_handle_t</span> handle,<span class="comment">//SPI设备句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">spi_transaction_t</span> *trans_desc)</span><span class="comment">//要执行的传输</span></span></span><br><span class="line"><span class="function"><span class="comment">//发起一次SPI传输，等待完成并返回结果，该函数和spi_device_queue_trans+spi_device_get_trans_result共同使用等价</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>轮询模式</li>
</ol>
<p>使用以下API来发起轮询模式的传输</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">spi_device_polling_transmit</span><span class="params">(<span class="keyword">spi_device_handle_t</span> handle,<span class="comment">//SPI设备句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">spi_transaction_t</span> *trans_desc)</span><span class="comment">//要执行的传输  </span></span></span><br><span class="line"><span class="function"><span class="comment">//发起一次轮询模式下的传输，等待完成后返回结果</span></span></span><br><span class="line"><span class="function"><span class="comment">//此函数和spi_device_polling_start+spi_device_polling_end共同使用等价</span></span></span><br></pre></td></tr></table></figure>

<p>如果需要再发送传输中间插入其他代码，可以使用以下两个API</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">spi_device_polling_start</span><span class="params">(<span class="keyword">spi_device_handle_t</span> handle,<span class="comment">//SPI设备句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">spi_transaction_t</span> *trans_desc,<span class="comment">//要执行的传输</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                   TickType_t ticks_to_wait)</span><span class="comment">//等待时间</span></span></span><br><span class="line"><span class="function"><span class="comment">//立刻发起一次轮询模式传输</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">spi_device_polling_end</span><span class="params">(<span class="keyword">spi_device_handle_t</span> handle,<span class="comment">//SPI设备句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                 TickType_t ticks_to_wait)</span><span class="comment">//等待时间</span></span></span><br><span class="line"><span class="function"><span class="comment">//使CPU保持轮询直到传输完成，这个任务直到成功完成才能结束且是非阻塞的——其他线程（任务）可以在传输期间占用CPU（当然会降低效率）</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>发送/接收数据</p>
</li>
</ol>
<p>可以使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">spi_device_acquire_bus</span><span class="params">(<span class="keyword">spi_device_handle_t</span> device, TickType_t wait)</span></span>;<span class="comment">//释放总线</span></span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spi_device_release_bus</span><span class="params">(<span class="keyword">spi_device_handle_t</span> dev)</span></span>;<span class="comment">//释放总线</span></span><br></pre></td></tr></table></figure>

<p>来让主设备一直占用总线，可以在两个API调用期间间断地发送数据</p>
<p>可以使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">spi_bus_remove_device</span><span class="params">(<span class="keyword">spi_device_handle_t</span> handle)</span></span></span><br><span class="line"><span class="function"><span class="comment">//将设备从SPI总线上移除</span></span></span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">spi_bus_free</span><span class="params">(<span class="keyword">spi_host_device_t</span> host)</span></span></span><br><span class="line"><span class="function"><span class="comment">//释放总线</span></span></span><br></pre></td></tr></table></figure>

<p>来解除目标设备对SPI总线的占用，并释放系统资源</p>
<h3 id="传输速率"><a href="#传输速率" class="headerlink" title="传输速率"></a>传输速率</h3><p>SPI传输速率与以下因素有关：</p>
<ul>
<li>传输间隔</li>
<li>SPI时钟频率（主要因素）</li>
<li>SPI控制函数与回调函数的执行延迟</li>
</ul>
<p>典型的传输间隔如下所示：</p>
<table>
<thead>
<tr>
<th></th>
<th>典型传输时间 (us)</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>中断模式</td>
<td>轮询模式</td>
</tr>
<tr>
<td>使用DMA</td>
<td>24</td>
<td>8</td>
</tr>
<tr>
<td>不使用DMA</td>
<td>22</td>
<td>7</td>
</tr>
</tbody></table>
<h2 id="SPI-Slave"><a href="#SPI-Slave" class="headerlink" title="SPI Slave"></a>SPI Slave</h2><p>SPI从设备驱动负责处理ESP32作为从设备的情况</p>
<p>SPI2和SPI3也能独立地作为从设备使用，支持全双工四线SPI、半双工DSPI、半双工QSPI，支持收发64字节数据和使能DMA传输</p>
<h3 id="从模式的基本配置"><a href="#从模式的基本配置" class="headerlink" title="从模式的基本配置"></a>从模式的基本配置</h3><p>使用spi_slave_interface_config_t结构体来设置SPI从模式的物理接口</p>
<p>使用spi_slave_transaction_t结构体设置从模式下的数据格式和数据缓冲区大小等</p>
<p>使用spi_transaction_t结构体配置单独收取/单独发送等特殊情况的传输数据格式</p>
<p>结构体原型如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置</span></span><br><span class="line"><span class="keyword">spi_device_interface_config_t</span> devcfg=&#123;</span><br><span class="line">	.command_bits=<span class="number">0</span>,</span><br><span class="line">    .address_bits=<span class="number">0</span>,</span><br><span class="line">	.dummy_bits=<span class="number">0</span>,</span><br><span class="line">    .clock_speed_hz=<span class="number">5000000</span>,</span><br><span class="line">	.duty_cycle_pos=<span class="number">128</span>, <span class="comment">//50% duty cycle</span></span><br><span class="line">    .mode=<span class="number">0</span>,</span><br><span class="line">	.spics_io_num=GPIO_CS,</span><br><span class="line">	.cs_ena_posttrans=<span class="number">3</span>,</span><br><span class="line"><span class="comment">//Keep the CS low 3 cycles after transaction, to stop slave from missing the last bit when CS has less propagation delay than CLK</span></span><br><span class="line">    .queue_size=<span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于配置SPI从机接口的spi_slave_interface_config_t结构体</span></span><br><span class="line"><span class="keyword">spi_slave_interface_config_t</span> slvcfg=&#123;</span><br><span class="line">	.mode,<span class="comment">//SPI模式，配置为0-3</span></span><br><span class="line">	.spics_io_num,<span class="comment">//片选信号线复用IO</span></span><br><span class="line">	.queue_size,<span class="comment">//传输队列大小，设置同时最多有多少挂起的传输</span></span><br><span class="line">	.flags,<span class="comment">//接口属性，使用位或运算符|连接各属性参数</span></span><br><span class="line">	.post_setup_cb,<span class="comment">//SPI寄存器加载新数据时调用的回调函数</span></span><br><span class="line">	.post_trans_cb<span class="comment">//传输完成回调函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//描述一次SPI传输的结构体</span></span><br><span class="line"><span class="keyword">spi_slave_transaction_t</span></span><br><span class="line">&#123;</span><br><span class="line">    .length,<span class="comment">//总数据长度</span></span><br><span class="line">    .trans_len,<span class="comment">//传输数据长度</span></span><br><span class="line">    .tx_buffer,<span class="comment">//数据发送缓冲区指针</span></span><br><span class="line">    .rx_buffer,<span class="comment">//数据接收缓冲区指针</span></span><br><span class="line">	.user<span class="comment">//用户定义变量，一般用于存储本次传输的ID</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意：上述长度的单位是比特</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于配置SPI总线的spi_bus_config_t结构体</span></span><br><span class="line"><span class="keyword">spi_bus_config_t</span> buscfg=&#123;</span><br><span class="line">	.mosi_io_num=GPIO_MOSI,</span><br><span class="line">	.miso_io_num=GPIO_MISO,</span><br><span class="line">    .sclk_io_num=GPIO_SCLK,</span><br><span class="line">    .quadwp_io_num = <span class="number">-1</span>,</span><br><span class="line">	.quadhd_io_num = <span class="number">-1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//未使用的参数应设置为-1</span></span><br></pre></td></tr></table></figure>

<p>如果spi_slave_interface_config_t::rx_buffer=NULL，则跳过读取数据段；如果spi_slave_interface_config_t::tx_buffer=NULL，则跳过写入数据段</p>
<p>传输开始前，应当配置好一个或以上的spi_slave_transaction_t结构体</p>
<p>注意：<strong>如果传输的数据大于32字节，需要使能DMA通道1或通道2</strong>，如果<strong>不使用DMA，应将dma_chan参数设置为0</strong></p>
<h3 id="传输相关API与使用步骤"><a href="#传输相关API与使用步骤" class="headerlink" title="传输相关API与使用步骤"></a>传输相关API与使用步骤</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//所有形式的SPI设备都需要调用这个API来进行初始化</span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">spi_bus_initialize</span><span class="params">(<span class="keyword">spi_host_device_t</span> host,<span class="comment">//SPI设备号</span></span></span></span><br><span class="line"><span class="params"><span class="function">                           	 <span class="keyword">const</span> <span class="keyword">spi_bus_config_t</span> *bus_config,<span class="comment">//总线GPIO设置</span></span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">int</span> dma_chan)</span><span class="comment">//使用的DMA通道</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//SPI从设备初始化</span></span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">spi_slave_initialize</span><span class="params">(<span class="keyword">spi_host_device_t</span> host,<span class="comment">//SPI设备号</span></span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">const</span> <span class="keyword">spi_bus_config_t</span> *bus_config,<span class="comment">//SPI总线设置</span></span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">const</span> <span class="keyword">spi_slave_interface_config_t</span> *slave_config,<span class="comment">//SPI接口设置</span></span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">int</span> dma_chan)</span><span class="comment">//使用的DMA通道</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//卸载SPI从设备驱动</span></span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">spi_slave_free</span><span class="params">(<span class="keyword">spi_host_device_t</span> host)</span><span class="comment">//SPI设备号</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//发起SPI从设备队列传输数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">spi_slave_queue_trans</span><span class="params">(<span class="keyword">spi_host_device_t</span> host,<span class="comment">//SPI设备号</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">const</span> <span class="keyword">spi_slave_transaction_t</span> *trans_desc,<span class="comment">//传输的数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                TickType_t ticks_to_wait)</span><span class="comment">//等待时间</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 将一条SPI消息挂到SPI传输队列，并等待发送 */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//获取队列传输数据的结果</span></span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">spi_slave_get_trans_result</span><span class="params">(<span class="keyword">spi_host_device_t</span> host,<span class="comment">//SPI设备号</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">spi_slave_transaction_t</span> **trans_desc,<span class="comment">//传输数据指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                     TickType_t ticks_to_wait)</span><span class="comment">//等待时间  </span></span></span><br><span class="line"><span class="function"><span class="comment">/* 在使用spi_slave_queue_trans到使用spi_slave_get_trans_result之间，CPU会轮询传输结果，使用该API获取结果 */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//发起一次SPI传输</span></span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">spi_slave_transmit</span><span class="params">(<span class="keyword">spi_host_device_t</span> host,<span class="comment">//SPI设备号</span></span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">spi_slave_transaction_t</span> *trans_desc,<span class="comment">//传输的数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">                             TickType_t ticks_to_wait)</span><span class="comment">//等待时间</span></span></span><br><span class="line"><span class="function"><span class="comment">//该函数与连用spi_slave_queue_trans和spi_slave_get_trans_result效果相同</span></span></span><br></pre></td></tr></table></figure>

<ol>
<li>使用spi_bus_config_t结构体和spi_bus_initialize()函数创建SPI总线</li>
<li>使用spi_device_interface_config_t结构体和spi_bus_add_device()函数向SPI总线上添加新设备</li>
<li>使用spi_slave_queue_trans、spi_slave_get_trans_result、spi_slave_transmit三个API进行传输数据</li>
<li>如果需要卸载SPI从设备驱动，使用spi_slave_free</li>
</ol>
<p>注意：<strong>如果使用了DMA，需要保证使用pvPortMallocCaps(size, MALLOC_CAP_DMA)为缓冲区开辟内存，这样可以保障DMA能够访问到这些缓冲区</strong></p>
<p>DMA和初始化API的配置与主模式类似，驱动函数的使用方法也类似，在此不做介绍，关注API即可</p>
<h2 id="目前存在的DMA缺陷（摘自官网）"><a href="#目前存在的DMA缺陷（摘自官网）" class="headerlink" title="目前存在的DMA缺陷（摘自官网）"></a>目前存在的DMA缺陷（摘自官网）</h2><blockquote>
<h2 id="Restrictions-and-Known-Issues"><a href="#Restrictions-and-Known-Issues" class="headerlink" title="Restrictions and Known Issues"></a>Restrictions and Known Issues</h2><ol>
<li><p>If DMA is enabled, the rx buffer should be word-aligned (starting from a 32-bit boundary and having a length of multiples of 4 bytes).  Otherwise, DMA may write incorrectly or not in a boundary aligned  manner. The driver reports an error if this condition is not satisfied.</p>
<p>Also, a Host should write lengths that are multiples of 4 bytes. The data with inappropriate lengths will be discarded.</p>
</li>
<li><p>Furthermore, DMA requires SPI modes 1 and 3. For SPI modes 0 and  2, the MISO signal has to be launched half a clock cycle earlier to meet the timing. The new timing is as follows:</p>
</li>
</ol>
<blockquote>
<p><img src="https://docs.espressif.com/projects/esp-idf/zh_CN/release-v4.1/_images/spi_slave_miso_dma.png" alt="../../_images/spi_slave_miso_dma.png"></p>
</blockquote>
<p>If DMA is enabled, a Device’s launch edge is half of an SPI clock  cycle ahead of the normal time, shifting to the Master’s actual latch  edge. In this case, if the GPIO matrix is bypassed, the hold time for  data sampling is 68.75 ns and no longer a half of an SPI clock cycle. If the GPIO matrix is used, the hold time will increase to 93.75 ns. The  Host should sample the data immediately at the latch edge or communicate in SPI modes 1 or 3. If your Host cannot meet these timing  requirements, initialize your Device without DMA.</p>
</blockquote>
<ol>
<li>启用DMA时应当将收发缓存设定为字对齐模式（是4字节的倍数）</li>
<li>从机模式的DMA需要主机时钟的保持时间足够长才能工作，如果主机无法满足只能放弃使用DMA</li>
</ol>
<h1 id="SPI使用例"><a href="#SPI使用例" class="headerlink" title="SPI使用例"></a>SPI使用例</h1><p>参考esp-idf/example/peripheral/spi/部分示例</p>
<h1 id="SPI-FLASH组件"><a href="#SPI-FLASH组件" class="headerlink" title="SPI FLASH组件"></a>SPI FLASH组件</h1><p>以下内容部分摘自官网原文，黑体部分为强调和个人理解</p>
<p>SPI Flash 组件提供外部 flash 数据读取、写入、擦除和内存映射相关的 API 函数，同时也提供了更高层级的、面向分区的 API 函数（定义在分区表部分）</p>
<p>注意：<strong>ESP-IDF V4.0后饿FLASH API不再是原子的，如果 flash 操作地址有重叠，且写操作与读操作同时执行，读操作可能会返回一部分写入之前的数据，返回一部分写入之后的数据</strong></p>
<h2 id="FLASH设备的使用"><a href="#FLASH设备的使用" class="headerlink" title="FLASH设备的使用"></a>FLASH设备的使用</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>设置方式类似基本的SPI API调用，具体步骤如下</p>
<ol>
<li>调用spi_bus_initialize()初始化SPI总线</li>
<li>调用spi_bus_add_flash_device()将片外FLASH作为从设备挂载到SPI总线，并分配内存、填充esp_flash_t结构体、初始化CS信号线</li>
<li>调用esp_flash_init()与芯片进行通信（注意：目前多个FLASH芯片可以连接到同意总线，但尚不支持在同一个SPI总线上使用esp_flash_*和spi_device_*设备）</li>
</ol>
<h3 id="访问FLASH"><a href="#访问FLASH" class="headerlink" title="访问FLASH"></a>访问FLASH</h3><p>一般来说应尽量避免对主SPI flash芯片直接使用原始SPI flash函数，如需对主SPI flash芯片进行操作应使用分区表API</p>
<p>使用以下API访问片外SPI FLASH</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_flash_read</span><span class="params">(<span class="keyword">esp_flash_t</span> *chip,<span class="comment">//指向已识别FLASH对象地指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">void</span> *buffer,<span class="comment">//读取数据缓冲区指针，当保存在RAM且字对齐时具有更好的使用性能</span></span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">uint32_t</span> address,<span class="comment">//待读取数据的FLASH地址，必须小于chip-&gt;size</span></span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">uint32_t</span> length)</span></span>;<span class="comment">//待读取的数据长度</span></span><br><span class="line"><span class="comment">//将数据无对齐地从flash读取到RAM</span></span><br><span class="line"><span class="comment">//chip需要用esp_flash_init()初始化过才能使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_flash_write</span><span class="params">(<span class="keyword">esp_flash_t</span> *chip,<span class="comment">//指向已识别FLASH对象地指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">const</span> <span class="keyword">void</span> *buffer,<span class="comment">//写入数据缓冲区指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">uint32_t</span> address,<span class="comment">//待写入数据的FLASH地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">uint32_t</span> length)</span></span>;<span class="comment">//待写入的数据长度</span></span><br><span class="line"><span class="comment">//将数据无对齐地从RAM写入到 flash</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_flash_write_encrypted</span><span class="params">(<span class="keyword">esp_flash_t</span> *chip,<span class="comment">//指向已识别FLASH对象地指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">uint32_t</span> address,<span class="comment">//待写入数据的FLASH地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">const</span> <span class="keyword">void</span> *buffer,<span class="comment">//写入数据缓冲区指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">uint32_t</span> length)</span></span>;<span class="comment">//待写入的数据长度</span></span><br><span class="line"><span class="comment">//使用片上硬件FLASH加密外设，加密写入数据</span></span><br><span class="line"><span class="comment">//注意：地址和数据长度都应该是16位对齐</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_flash_read_encrypted</span><span class="params">(<span class="keyword">esp_flash_t</span> *chip,<span class="comment">//指向已识别FLASH对象地指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">uint32_t</span> address,<span class="comment">//待读取数据的FLASH地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">void</span> *out_buffer,<span class="comment">//读取数据缓冲区指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">uint32_t</span> length)</span></span>;<span class="comment">//待读取的数据长度</span></span><br><span class="line"><span class="comment">//使用片上硬件FLASH加密外设，加密读取数据</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_flash_erase_region</span><span class="params">(<span class="keyword">esp_flash_t</span> *chip,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">uint32_t</span> start,<span class="comment">//起始地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">uint32_t</span> len)</span></span>;<span class="comment">//擦除长度</span></span><br><span class="line"><span class="comment">//擦除 flash 中指定区域的数据</span></span><br><span class="line"><span class="comment">//注意：擦除的地址一定要和扇区对齐！！！</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_flash_erase_chip</span><span class="params">(<span class="keyword">esp_flash_t</span> *chip)</span></span>;<span class="comment">//擦除整个 flash</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_flash_get_size</span><span class="params">(<span class="keyword">esp_flash_t</span> *chip,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">uint32_t</span> *out_size)</span></span>;</span><br><span class="line"><span class="comment">//根据FLASH ID检测FLASH容量（以字节为单位）</span></span><br></pre></td></tr></table></figure>

<p>FLASH容量存储在<strong>引导程序映像头不烧录偏移量为0x1000的一个字段</strong></p>
<p>默认情况下烧录引导程序时，esptool会自动检测SPI FLASH容量并使用正确容量更新引导程序的头部；但是也可以设置CONFIG_ESPTOOLPY_FLASHSIZE生成固定FLASH容量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">esp_flash_t</span>//描述片外<span class="title">FLASH</span>的结构体，应当使用<span class="title">esp_flash_init</span>()进行初始化</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">spi_flash_host_driver_t</span> *host,<span class="comment">//SPI驱动结构体句柄</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">spi_flash_chip_t</span> *chip_drv,<span class="comment">//FLASH驱动“适配”结构体</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">esp_flash_os_functions_t</span> *os_func,</span><br><span class="line">    <span class="comment">//RTOS钩子函数，使用esp_flash_init_os_functions()设置</span></span><br><span class="line">    os_func_data,</span><br><span class="line">    <span class="comment">//RTOS钩子函数的参数</span></span><br><span class="line">	<span class="keyword">esp_flash_io_mode_t</span> read_mode,<span class="comment">//配置FLASH读取模式</span></span><br><span class="line">	<span class="keyword">uint32_t</span> size,<span class="comment">//FLASH容量，如果设置为0则会在初始化期间检测</span></span><br><span class="line">    <span class="keyword">uint32_t</span> chip_id<span class="comment">//检测FLASH ID</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SPI驱动结构体，配置主机驱动和上下文</span></span><br><span class="line"><span class="comment">//使用了c面向对象的方式，将方法（或者说是成员函数）用函数指针封装在结构体对象</span></span><br><span class="line"><span class="comment">//上面提到的那些API基本都被归纳进了这个结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_flash_host_driver_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *driver_data,<span class="comment">//驱动数据</span></span><br><span class="line">    <span class="keyword">esp_err_t</span> (*dev_config)(<span class="keyword">spi_flash_host_driver_t</span> *driver),<span class="comment">//设备驱动寄存器设置方法</span></span><br><span class="line">    <span class="keyword">esp_err_t</span> (*common_command)(<span class="keyword">spi_flash_host_driver_t</span> *driver, <span class="keyword">spi_flash_trans_t</span> *t),</span><br><span class="line">    <span class="comment">//用户定义传输指令方法</span></span><br><span class="line">    <span class="keyword">esp_err_t</span> (*read_id)(<span class="keyword">spi_flash_host_driver_t</span> *driver, <span class="keyword">uint32_t</span> *id),<span class="comment">//读取FLASH ID的方法</span></span><br><span class="line">    <span class="keyword">void</span> (*erase_chip)(<span class="keyword">spi_flash_host_driver_t</span> *driver),<span class="comment">//全片擦除方法</span></span><br><span class="line">    <span class="keyword">void</span> (*erase_sector)(<span class="keyword">spi_flash_host_driver_t</span> *driver, <span class="keyword">uint32_t</span> start_address),<span class="comment">//扇区擦除方法</span></span><br><span class="line">    <span class="keyword">void</span> (*erase_block)(<span class="keyword">spi_flash_host_driver_t</span> *driver, <span class="keyword">uint32_t</span> start_address),<span class="comment">//块擦除方法</span></span><br><span class="line">    <span class="keyword">esp_err_t</span> (*read_status)(<span class="keyword">spi_flash_host_driver_t</span> *driver, <span class="keyword">uint8_t</span> *out_sr),<span class="comment">//读取FLASH状态方法</span></span><br><span class="line">    <span class="keyword">esp_err_t</span> (*set_write_protect)(<span class="keyword">spi_flash_host_driver_t</span> *driver, <span class="keyword">bool</span> wp),<span class="comment">//关闭写保护方法</span></span><br><span class="line">    <span class="keyword">void</span> (*program_page)(<span class="keyword">spi_flash_host_driver_t</span> *driver,</span><br><span class="line">                         <span class="keyword">const</span> <span class="keyword">void</span> *buffer,</span><br><span class="line">                         <span class="keyword">uint32_t</span> address,</span><br><span class="line">                         <span class="keyword">uint32_t</span> length),</span><br><span class="line">    <span class="comment">//按页写入FLASH并检查最大写入字节数方法</span></span><br><span class="line">    <span class="keyword">bool</span> (*supports_direct_write)(<span class="keyword">spi_flash_host_driver_t</span> *driver, <span class="keyword">const</span> <span class="keyword">void</span> *p),</span><br><span class="line">    <span class="comment">//检查写入中是否需要申请新的页方法</span></span><br><span class="line">    <span class="keyword">bool</span> (*supports_direct_read)(<span class="keyword">spi_flash_host_driver_t</span> *driver, <span class="keyword">const</span> <span class="keyword">void</span> *p),</span><br><span class="line">    <span class="comment">//检查读取中是否需要申请新的页方法</span></span><br><span class="line">    <span class="keyword">int</span> max_write_bytes,<span class="comment">//每页的最大写入字节数</span></span><br><span class="line">	<span class="keyword">esp_err_t</span> (*read)(<span class="keyword">spi_flash_host_driver_t</span> *driver,</span><br><span class="line">                      <span class="keyword">void</span> *buffer,</span><br><span class="line">                      <span class="keyword">uint32_t</span> address,</span><br><span class="line">                      <span class="keyword">uint32_t</span> read_len)</span><br><span class="line">	<span class="comment">//从FLASH中读取数据并检查最大读取字节数方法</span></span><br><span class="line">	<span class="keyword">int</span> max_read_bytes,<span class="comment">//最大读取字节数</span></span><br><span class="line">    <span class="keyword">bool</span> (*host_idle)(<span class="keyword">spi_flash_host_driver_t</span> *driver),<span class="comment">//检查SPI主机是否空闲方法</span></span><br><span class="line">    <span class="keyword">esp_err_t</span> (*configure_host_io_mode)(<span class="keyword">spi_flash_host_driver_t</span> *driver,</span><br><span class="line">                                        <span class="keyword">uint32_t</span> command,</span><br><span class="line">                                        <span class="keyword">uint32_t</span> addr_bitlen,</span><br><span class="line">                                        <span class="keyword">int</span> dummy_bitlen_base,</span><br><span class="line">                                        <span class="keyword">esp_flash_io_mode_t</span> io_mode),</span><br><span class="line">    <span class="comment">//设置主机工作在不同的读取模式，响应补偿时间、设置IO模式方法</span></span><br><span class="line">    <span class="keyword">void</span> (*poll_cmd_done)(<span class="keyword">spi_flash_host_driver_t</span> *driver),<span class="comment">//使硬件保持轮询直到操作完毕方法</span></span><br><span class="line">    <span class="keyword">esp_err_t</span> (*flush_cache)(<span class="keyword">spi_flash_host_driver_t</span> *driver,</span><br><span class="line">                             <span class="keyword">uint32_t</span> addr,</span><br><span class="line">                             <span class="keyword">uint32_t</span> size)</span><br><span class="line">	<span class="comment">//清空主机（如SPI1）所用的缓存区方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化外部FLASH的示例如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">esp_flash_t</span>* <span class="title">example_init_ext_flash</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">spi_bus_config_t</span> bus_config = &#123;</span><br><span class="line">        .mosi_io_num = VSPI_IOMUX_PIN_NUM_MOSI,</span><br><span class="line">        .miso_io_num = VSPI_IOMUX_PIN_NUM_MISO,</span><br><span class="line">        .sclk_io_num = VSPI_IOMUX_PIN_NUM_CLK,</span><br><span class="line">        .quadwp_io_num = <span class="number">-1</span>,</span><br><span class="line">        .quadhd_io_num = <span class="number">-1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">esp_flash_spi_device_config_t</span> device_config = &#123;</span><br><span class="line">        .host_id = VSPI_HOST,</span><br><span class="line">        .cs_id = <span class="number">0</span>,</span><br><span class="line">        .cs_io_num = VSPI_IOMUX_PIN_NUM_CS,</span><br><span class="line">        .io_mode = SPI_FLASH_DIO,</span><br><span class="line">        .speed = ESP_FLASH_40MHZ</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;初始化外部SPI FLASH&quot;</span>);</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;引脚设定:&quot;</span>);</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;MOSI: %2d   MISO: %2d   SCLK: %2d   CS: %2d&quot;</span>,</span><br><span class="line">        bus_config.mosi_io_num, bus_config.miso_io_num,</span><br><span class="line">        bus_config.sclk_io_num, device_config.cs_io_num</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化SPI总线</span></span><br><span class="line">    ESP_ERROR_CHECK(spi_bus_initialize(VSPI_HOST, &amp;bus_config, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//将FLASH设备添加到SPI总线</span></span><br><span class="line">    <span class="keyword">esp_flash_t</span>* ext_flash;</span><br><span class="line">    ESP_ERROR_CHECK(spi_bus_add_flash_device(&amp;ext_flash, &amp;device_config));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接、检查FLASH并进行初始化</span></span><br><span class="line">    <span class="keyword">esp_err_t</span> err = esp_flash_init(ext_flash);</span><br><span class="line">    <span class="keyword">if</span> (err != ESP_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">&quot;连接外部FLASH失败: %s (0x%x)&quot;</span>, esp_err_to_name(err), err);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行 输出ID和大小 任务</span></span><br><span class="line">    <span class="keyword">uint32_t</span> id;</span><br><span class="line">    ESP_ERROR_CHECK(esp_flash_read_id(ext_flash, &amp;id));</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Initialized external Flash, size=%d KB, ID=0x%x&quot;</span>, ext_flash-&gt;size / <span class="number">1024</span>, id);</span><br><span class="line">    <span class="keyword">return</span> ext_flash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32_IDF学习5【SPIFFS与数据加密】</title>
    <url>/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A05%E3%80%90SPIFFS%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E3%80%91/</url>
    <content><![CDATA[<h1 id="VFS虚拟文件系统"><a href="#VFS虚拟文件系统" class="headerlink" title="VFS虚拟文件系统"></a>VFS虚拟文件系统</h1><p>虚拟文件系统 (VFS) 组件可为一些驱动提供一个统一接口。有了该接口，用户可像操作普通文件一样操作虚拟文件。这类驱动程序可以是 FAT、SPIFFS 等真实文件系统，也可以是有文件类接口的设备驱动程序——官方文档</p>
<span id="more"></span>

<p>说人话就是<strong>ESP32可以支持运行嵌入式文件系统</strong></p>
<p>目前ESP-IDF实现的功能如下：</p>
<ul>
<li>按名读取/写入文件</li>
<li>兼容POSIX和C库函数文件操作</li>
<li>不会对路径中的点<code>.</code>或<code>..</code>进行特殊处理（不会将其视为对当前目录或上一级目录的引用）</li>
</ul>
<p>已注册的VFS驱动程序均有一个路径前缀与之关联，此路径前缀即为分区的挂载点。如果挂载点中嵌套了其他挂载点，则在打开文件时使用<strong>具有最长匹配路径前缀的挂载点</strong>。挂载点名称必须以路径分隔符<code>/</code>开头，且分隔符后至少包含一个字符</p>
<p><strong>执行打开文件操作时，FS驱动程序仅得到文件的相对路径</strong></p>
<h2 id="标准IO流"><a href="#标准IO流" class="headerlink" title="标准IO流"></a>标准IO流</h2><p>如果在menuconfig中没有将<code>UART for console output</code>设置为<code>None</code>，则<code>stdin</code>、<code>stdout</code>和<code>stderr</code>将<strong>默认从UART读取或写入</strong>。<strong>UART0或UART1都可以用作标准IO</strong>。因此可以直接调用stdio.h中的相关库函数。<em>默认情况下，UART0使用115200波特率，TX管脚为 GPIO1，RX管脚为GPIO3；VFS使用简单的函数对UART进行读写操作</em>，也可以在menuconfig中更改参数。</p>
<p>所有IO数据放进UART的FIFO前，写操作将处于忙等待busy-wait（阻塞）状态，读操作处于非阻塞，仅返回FIFO中已有数据。由于读操作为非阻塞，高层级的C库函数调用（如 fscanf(“%d\n”, &amp;var)等）可能获取不到所需结果。如果应用程序使用UART驱动，则可以调用 <code>esp_vfs_dev_uart_use_driver</code>函数来让VFS使用驱动中断、读写阻塞功能等。也可以调用<code>esp_vfs_dev_uart_use_nonblocking</code>来使用非阻塞函数</p>
<p>此外，VFS还为输入和输出提供可选的换行符转换功能，可以通过menuconfig来设置输出结尾的换行符</p>
<h3 id="标准流IO与移植的FreeRTOS"><a href="#标准流IO与移植的FreeRTOS" class="headerlink" title="标准流IO与移植的FreeRTOS"></a>标准流IO与移植的FreeRTOS</h3><p><strong>stdin、stdout和stderr的FILE指针（对象句柄）在所有FreeRTOS任务之间共享</strong>，指向这些对象的指针分别存储在每个任务的<code>struct _reent</code>中</p>
<p>为了处理各个任务之间的文件指针临界区，预处理器把如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fprintf(stderr, &quot;42\n&quot;);</span><br></pre></td></tr></table></figure>

<p>解释为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fprintf(__getreent()-&gt;_stderr, &quot;42\n&quot;);</span><br></pre></td></tr></table></figure>

<p>__getreent函数返回一个指向struct _reent的指针</p>
<p><strong>每个任务的TCB都拥有一个struct _reent结构体，用于在本任务内处理文件而不影响其他任务</strong></p>
<h1 id="FATFS文件系统"><a href="#FATFS文件系统" class="headerlink" title="FATFS文件系统"></a>FATFS文件系统</h1><p>ESP-IDF使用FatFs库来实现FAT文件系统</p>
<p>在文件中调用<code>#include &quot;esp_vfs_fat.h&quot;</code>和<code>#include &quot;esp_vfs.h&quot;</code>后可以在FLASH中通过C标准库和POSIX的API经过VFS使用FatFs库的大多数功能</p>
<p>经由这一功能可以实现SD卡的读取</p>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol>
<li>调用esp_vfs_fat_register()指定挂载文件系统的<strong>路径前缀</strong>、<strong>FatFs驱动编号</strong>和一个<strong>用于接收指向FATFS结构指针的变量</strong></li>
<li>调用ff_diskio_register()为上述步骤中的驱动编号<strong>注册磁盘I/O驱动</strong></li>
<li>调用 FatFs 函数f_mount，或f_fdisk，f_mkfs，并使用<strong>与传递到esp_vfs_fat_register()相同的驱动编号挂载文件系统</strong></li>
<li>调用 <strong>C 标准库和 POSIX API</strong> 对路径中带有步骤 1 中所述前缀的文件执行打开、读取、写入、擦除、复制等操作</li>
<li><strong>关闭</strong>所有打开的<strong>文件</strong></li>
<li>调用f_mount并使用NULL FATFS<em>参数为与上述编号相同的驱动*<em>卸载文件系统</em></em></li>
<li>调用FatFs函数 ff_diskio_register()并使用NULL ff_diskio_impl_t<em>参数和相同的驱动编号来*<em>释放注册的磁盘I/O驱动</em></em></li>
<li>调用esp_vfs_fat_unregister_path()并使用文件系统挂载的路径<strong>将 FatFs 从 NVS 中移除</strong>，并<strong>释放步骤 1 中分配的 FatFs 结构</strong></li>
</ol>
<p>除了需要提前注册、挂载文件系统外，其他操作和正常的FATFS使用没有区别</p>
<h2 id="磨损均衡"><a href="#磨损均衡" class="headerlink" title="磨损均衡"></a>磨损均衡</h2><p>ESP32使用的FLASH具备扇区结构，每个扇区仅允许有限次数的擦除/修改操作，ESP-IDF提供磨损均衡组件用于平衡各个扇区之间的损耗。提供两种模式：1. 性能模式（先将数据保存在RAM中，擦除扇区，然后将数据存储回FLASH）；2. 安全模式（数据先保存在FLASH中空余扇区，擦除扇区后，数据即存储回去）</p>
<p><strong>设备默认使用性能模式且将扇区大小定为512字节</strong>。磨损均衡组件<strong>不会</strong>将数据缓存在RAM中。写入和擦除函数直接修改FLASH，函数返回后，FLASH即完成修改。</p>
<p>常用API如下：</p>
<ul>
<li><p><code>wl_mount(const esp_partition_t *partition, wl_handle_t *out_handle)</code></p>
<p>为指定分区挂载并初始化磨损均衡模块，通过out_handle传出句柄</p>
</li>
<li><p><code>wl_unmount(wl_handle_t handle)</code></p>
<p>卸载分区并释放磨损均衡模块</p>
</li>
<li><p><code>wl_erase_range(wl_handle_t handle, size_t start_addr, size_t size)</code></p>
<p>擦除FLASH中从start_addr开始大小为size的地址范围</p>
</li>
<li><p><code>wl_write(wl_handle_t handle, size_t dest_addr, const void *src, size_t size)</code></p>
<p>将数据用指针src引用后写入分区从dest_addr开始大小为size的区域</p>
</li>
<li><p><code>wl_read(wl_handle_t handle, size_t src_addr, void *dest, size_t size)</code></p>
<p>从分区读取从src_addr开始大小为size的数据</p>
</li>
<li><p><code>wl_size(wl_handle_t handle)</code></p>
<p>返回可用内存的大小（以字节为单位）</p>
</li>
<li><p><code>wl_sector_size(wl_handle_t handle)</code></p>
<p>返回一个扇区的大小</p>
</li>
</ul>
<p>上面的wl_handle_t为WL句柄，可通过wl_mount的output参数传出</p>
<p>结合使用磨损均衡与FATFS示例如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">wl_handle_t</span> s_wl_handle = WL_INVALID_HANDLE;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *base_path = <span class="string">&quot;/spiflash&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化VFS-FATFS</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">esp_vfs_fat_mount_config_t</span> mount_config = &#123;</span><br><span class="line">            .max_files = <span class="number">4</span>,</span><br><span class="line">            .format_if_mount_failed = <span class="literal">true</span>,</span><br><span class="line">            .allocation_unit_size = CONFIG_WL_SECTOR_SIZE</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//挂载FATFS</span></span><br><span class="line">    <span class="keyword">esp_err_t</span> err = esp_vfs_fat_spiflash_mount(base_path, <span class="string">&quot;storage&quot;</span>, &amp;mount_config, &amp;s_wl_handle);</span><br><span class="line">    <span class="keyword">if</span> (err != ESP_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">&quot;Failed to mount FATFS (%s)&quot;</span>, esp_err_to_name(err));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//打开文件并写入</span></span><br><span class="line">    FILE *f = fopen(<span class="string">&quot;/spiflash/hello.txt&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">&quot;Failed to open file for writing&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(f, <span class="string">&quot;written using ESP-IDF %s\n&quot;</span>, esp_get_idf_version());</span><br><span class="line">    fclose(f);</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;File written&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开文件并读取</span></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Reading file&quot;</span>);</span><br><span class="line">    f = fopen(<span class="string">&quot;/spiflash/hello.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">&quot;Failed to open file for reading&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">128</span>];</span><br><span class="line">    fgets(line, <span class="keyword">sizeof</span>(line), f);</span><br><span class="line">    fclose(f);</span><br><span class="line">    <span class="comment">// strip newline</span></span><br><span class="line">    <span class="keyword">char</span> *pos = <span class="built_in">strchr</span>(line, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pos)</span><br><span class="line">    &#123;</span><br><span class="line">        *pos = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Read from file: &#x27;%s&#x27;&quot;</span>, line);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//卸载FATFA</span></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Unmounting FAT filesystem&quot;</span>);</span><br><span class="line">    ESP_ERROR_CHECK( esp_vfs_fat_spiflash_unmount(base_path, s_wl_handle));</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Done&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用外部FLASH挂载FATFS示例如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_flash.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_flash_spi_init.h&quot;</span><span class="comment">//外部FLASH</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_partition.h&quot;</span><span class="comment">//加载额外分区表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_vfs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_vfs_fat.h&quot;</span><span class="comment">//VFS-FATFS</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_system.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">wl_handle_t</span> s_wl_handle = WL_INVALID_HANDLE;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *base_path = <span class="string">&quot;/extflash&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">esp_flash_t</span>* <span class="title">init_ext_flash</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">esp_partition_t</span>* <span class="title">add_partition</span><span class="params">(<span class="keyword">esp_flash_t</span>* ext_flash, <span class="keyword">const</span> <span class="keyword">char</span>* partition_label)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">list_data_partitions</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">mount_fatfs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* partition_label)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">get_fatfs_usage</span><span class="params">(<span class="keyword">size_t</span>* out_total_bytes, <span class="keyword">size_t</span>* out_free_bytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">esp_flash_t</span>* flash = init_ext_flash();<span class="comment">//初始化SPI总线及外部FLASH</span></span><br><span class="line">    <span class="keyword">if</span> (flash == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将外部FLASH加入分区表</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *partition_label = <span class="string">&quot;storage&quot;</span>;</span><br><span class="line">    add_partition(flash, partition_label);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//列出当前分区</span></span><br><span class="line">    list_data_partitions();</span><br><span class="line">    <span class="comment">//在分区内挂载FATFS</span></span><br><span class="line">    <span class="keyword">if</span> (!mount_fatfs(partition_label))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示FATFS大小信息</span></span><br><span class="line">    <span class="keyword">size_t</span> bytes_total, bytes_free;</span><br><span class="line">    get_fatfs_usage(&amp;bytes_total, &amp;bytes_free);</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;FAT FS: %d kB total, %d kB free&quot;</span>, bytes_total / <span class="number">1024</span>, bytes_free / <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建文件</span></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Opening file&quot;</span>);</span><br><span class="line">    FILE *f = fopen(<span class="string">&quot;/extflash/hello.txt&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">&quot;Failed to open file for writing&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(f, <span class="string">&quot;Written using ESP-IDF %s\n&quot;</span>, esp_get_idf_version());</span><br><span class="line">    fclose(f);</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;File written&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取文件</span></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Reading file&quot;</span>);</span><br><span class="line">    f = fopen(<span class="string">&quot;/extflash/hello.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">&quot;Failed to open file for reading&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">128</span>];</span><br><span class="line">    fgets(line, <span class="keyword">sizeof</span>(line), f);</span><br><span class="line">    fclose(f);</span><br><span class="line">    <span class="keyword">char</span> *pos = <span class="built_in">strchr</span>(line, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pos)</span><br><span class="line">    &#123;</span><br><span class="line">        *pos = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Read from file: &#x27;%s&#x27;&quot;</span>, line);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">esp_flash_t</span>* <span class="title">init_ext_flash</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化SPI总线</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">spi_bus_config_t</span> bus_config = &#123;</span><br><span class="line">        .mosi_io_num = VSPI_IOMUX_PIN_NUM_MOSI,</span><br><span class="line">        .miso_io_num = VSPI_IOMUX_PIN_NUM_MISO,</span><br><span class="line">        .sclk_io_num = VSPI_IOMUX_PIN_NUM_CLK,</span><br><span class="line">        .quadwp_io_num = <span class="number">-1</span>,</span><br><span class="line">        .quadhd_io_num = <span class="number">-1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">	<span class="comment">//初始化SPI FLASH设备</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">esp_flash_spi_device_config_t</span> device_config = &#123;</span><br><span class="line">        .host_id = VSPI_HOST,</span><br><span class="line">        .cs_id = <span class="number">0</span>,</span><br><span class="line">        .cs_io_num = VSPI_IOMUX_PIN_NUM_CS,</span><br><span class="line">        .io_mode = SPI_FLASH_DIO,</span><br><span class="line">        .speed = ESP_FLASH_40MHZ</span><br><span class="line">    &#125;;</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Initializing external SPI Flash&quot;</span>);</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Pin assignments:&quot;</span>);</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;MOSI: %2d   MISO: %2d   SCLK: %2d   CS: %2d&quot;</span>,</span><br><span class="line">        bus_config.mosi_io_num, bus_config.miso_io_num,</span><br><span class="line">        bus_config.sclk_io_num, device_config.cs_io_num</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//应用设置</span></span><br><span class="line">    ESP_ERROR_CHECK(spi_bus_initialize(VSPI_HOST, &amp;bus_config, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//将设备挂载到SPI总线</span></span><br><span class="line">    <span class="keyword">esp_flash_t</span>* ext_flash;</span><br><span class="line">    ESP_ERROR_CHECK(spi_bus_add_flash_device(&amp;ext_flash, &amp;device_config));</span><br><span class="line">    <span class="comment">//初始化外部FLASH设备</span></span><br><span class="line">    <span class="keyword">esp_err_t</span> err = esp_flash_init(ext_flash);</span><br><span class="line">    <span class="keyword">if</span> (err != ESP_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">&quot;Failed to initialize external Flash: %s (0x%x)&quot;</span>, esp_err_to_name(err), err);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出ID和空间大小进行检测</span></span><br><span class="line">    <span class="keyword">uint32_t</span> id;</span><br><span class="line">    ESP_ERROR_CHECK(esp_flash_read_id(ext_flash, &amp;id));</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Initialized external Flash, size=%d KB, ID=0x%x&quot;</span>, ext_flash-&gt;size / <span class="number">1024</span>, id)</span><br><span class="line">    <span class="keyword">return</span> ext_flash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">esp_partition_t</span>* <span class="title">add_partition</span><span class="params">(<span class="keyword">esp_flash_t</span>* ext_flash, <span class="keyword">const</span> <span class="keyword">char</span>* partition_label)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Adding external Flash as a partition, label=\&quot;%s\&quot;, size=%d KB&quot;</span>, partition_label, ext_flash-&gt;size / <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">esp_partition_t</span>* fat_partition;</span><br><span class="line">    <span class="comment">//注册外部分区表</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_partition_register_external(ext_flash, <span class="number">0</span>, ext_flash-&gt;size, partition_label, ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_DATA_FAT, &amp;fat_partition));</span><br><span class="line">    <span class="keyword">return</span> fat_partition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">list_data_partitions</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取当前删去句柄</span></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Listing data partitions:&quot;</span>);</span><br><span class="line">    <span class="keyword">esp_partition_iterator_t</span> it = esp_partition_find(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_ANY, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//以链表形式遍历扇区</span></span><br><span class="line">    <span class="keyword">for</span> (; it != <span class="literal">NULL</span>; it = esp_partition_next(it))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">esp_partition_t</span> *part = esp_partition_get(it);</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;- partition &#x27;%s&#x27;, subtype %d, offset 0x%x, size %d kB&quot;</span>,</span><br><span class="line">        part-&gt;label, part-&gt;subtype, part-&gt;address, part-&gt;size / <span class="number">1024</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//释放当前分区迭代器</span></span><br><span class="line">    esp_partition_iterator_release(it);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">mount_fatfs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* partition_label)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//挂载FAT文件系统到外部FLASH</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">esp_vfs_fat_mount_config_t</span> mount_config = &#123;</span><br><span class="line">            .max_files = <span class="number">4</span>,</span><br><span class="line">            .format_if_mount_failed = <span class="literal">true</span>,</span><br><span class="line">            .allocation_unit_size = CONFIG_WL_SECTOR_SIZE</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">esp_err_t</span> err = esp_vfs_fat_spiflash_mount(base_path, partition_label, &amp;mount_config, &amp;s_wl_handle);</span><br><span class="line">    <span class="keyword">if</span> (err != ESP_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">&quot;Failed to mount FATFS (%s)&quot;</span>, esp_err_to_name(err));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">get_fatfs_usage</span><span class="params">(<span class="keyword">size_t</span>* out_total_bytes, <span class="keyword">size_t</span>* out_free_bytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FATFS *fs;<span class="comment">//文件系统指针</span></span><br><span class="line">    <span class="keyword">size_t</span> free_clusters;</span><br><span class="line">    <span class="keyword">int</span> res = f_getfree(<span class="string">&quot;0:&quot;</span>, &amp;free_clusters, &amp;fs);</span><br><span class="line">    assert(res == FR_OK);</span><br><span class="line">    <span class="keyword">size_t</span> total_sectors = (fs-&gt;n_fatent - <span class="number">2</span>) * fs-&gt;csize;</span><br><span class="line">    <span class="keyword">size_t</span> free_sectors = free_clusters * fs-&gt;csize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//假设扇区总大小&lt;4GB，对SPI FLASH应为真</span></span><br><span class="line">    <span class="keyword">if</span> (out_total_bytes != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *out_total_bytes = total_sectors * fs-&gt;ssize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (out_free_bytes != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *out_free_bytes = free_sectors * fs-&gt;ssize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="SPIFFS文件系统"><a href="#SPIFFS文件系统" class="headerlink" title="SPIFFS文件系统"></a>SPIFFS文件系统</h1><p>SPIFFS 是一个用于 SPI NOR flash 设备的嵌入式文件系统，支持磨损均衡、文件系统一致性检查等功能——官方文档。</p>
<p>目前位置SPIFFS还是一个不完全的文件系统：不支持目录，只能生成扁平结构；不是实时栈，每次写操作耗时不等；不支持检测或处理已损坏的块等</p>
<p>但是这玩意确实很好用</p>
<p>使用spiffsgen.py工具就可以配置SPIFFS，shell中使用格式如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python spiffsgen.py &lt;image_size&gt; &lt;base_dir&gt; &lt;output_file&gt;</span><br></pre></td></tr></table></figure>

<p>其中image_size为分区大小，<strong>base_dir为SPIFFS映像所在目录，output_file为SPIFFS映像输出文件</strong></p>
<p>也可以使用CMake工具进行配置：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">spiffs_create_partition_image(&lt;partition&gt; &lt;base_dir&gt; [FLASH_IN_PROJECT] [DEPENDS dep dep dep...])</span><br><span class="line"></span><br><span class="line">//使用例</span><br><span class="line">spiffs_create_partition_image(my_spiffs_partition my_folder FLASH_IN_PROJECT)</span><br></pre></td></tr></table></figure>

<p>CMake配置自动传递给spiffsgen.py工具生成映像。单独调用 <code>spiffsgen.py</code> 时需要用到 <em>image_size</em> 参数，但在CMake中调用<code>spiffs_create_partition_image</code>时仅需要 <em>partition</em> 参数，<strong>映像大小将直接从当前工程的分区表中获取</strong>。</p>
<p>注意：在CMake中使用<code>spiffs_create_partition_image</code>，需从组件CMakeLists.txt文件调用</p>
<p>下面是一个标准的SPIFFS分区表示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Name,   Type, SubType, Offset,  Size, Flags</span><br><span class="line"># Note: if you have increased the bootloader size, make sure to update the offsets to avoid overlap</span><br><span class="line">nvs,      data, nvs,     0x9000,  0x6000,</span><br><span class="line">phy_init, data, phy,     0xf000,  0x1000,</span><br><span class="line">factory,  app,  factory, 0x10000, 1M,</span><br><span class="line">storage,  data, spiffs,  ,        0xF0000, </span><br></pre></td></tr></table></figure>

<p><strong>需要使用SubType=spiffs标识出某一分区是SPIFFS存储分区</strong></p>
<h2 id="SPIFFS配置与API参考"><a href="#SPIFFS配置与API参考" class="headerlink" title="SPIFFS配置与API参考"></a>SPIFFS配置与API参考</h2><p>在文件中调用<code>#include &quot;esp_spiffs.h&quot;</code>就可以使用相关API</p>
<p>使用以下API初始化SPIFFS到虚拟文件系统</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_vfs_spiffs_register</span><span class="params">(<span class="keyword">const</span> <span class="keyword">esp_vfs_spiffs_conf_t</span> *conf)</span></span></span><br></pre></td></tr></table></figure>

<p>esp_vfs_spiffs_conf_t是SPIFFS文件系统初始化结构体，应如下配置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">esp_vfs_spiffs_conf_t</span> conf = &#123;</span><br><span class="line">	.base_path = <span class="string">&quot;/spiffs&quot;</span>,<span class="comment">//根目录</span></span><br><span class="line">	.partition_label = <span class="literal">NULL</span>,<span class="comment">//分区表的标签</span></span><br><span class="line">	.max_files = <span class="number">5</span>,<span class="comment">//该目录下能存储的最大文件数目</span></span><br><span class="line">	.format_if_mount_failed = <span class="literal">true</span><span class="comment">//如果挂载失败则会格式化文件系统</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>更多API如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_vfs_spiffs_unregister</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *partition_label)</span></span>;<span class="comment">//取消VFS上的SPIFFS初始化</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">esp_spiffs_mounted</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *partition_label)</span></span>;<span class="comment">//检查文件系统是否挂载</span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_spiffs_format</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *partition_label)</span></span>;<span class="comment">//格式化当前分区的文件系统</span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_spiffs_info</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *partition_label, <span class="keyword">size_t</span> *total_bytes, <span class="keyword">size_t</span> *used_bytes)</span></span>;<span class="comment">//获取某分区文件系统的参数    </span></span><br></pre></td></tr></table></figure>

<h2 id="用C库函数进行SPIFFS文件读写"><a href="#用C库函数进行SPIFFS文件读写" class="headerlink" title="用C库函数进行SPIFFS文件读写"></a>用C库函数进行SPIFFS文件读写</h2><p>可以使用POSIX和C库函数在SPIFFS写入和读取数据</p>
<p>下面是官方给出的使用例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化SPIFFS</span></span><br><span class="line">    <span class="keyword">esp_vfs_spiffs_conf_t</span> conf = &#123;</span><br><span class="line">      .base_path = <span class="string">&quot;/spiffs&quot;</span>,</span><br><span class="line">      .partition_label = <span class="literal">NULL</span>,</span><br><span class="line">      .max_files = <span class="number">5</span>,</span><br><span class="line">      .format_if_mount_failed = <span class="literal">true</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">esp_err_t</span> ret = esp_vfs_spiffs_register(&amp;conf);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检测SPIFFS初始化是否正常</span></span><br><span class="line">    <span class="keyword">if</span> (ret != ESP_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ret == ESP_FAIL)</span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGE(TAG, <span class="string">&quot;Failed to mount or format filesystem&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ret == ESP_ERR_NOT_FOUND)</span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGE(TAG, <span class="string">&quot;Failed to find SPIFFS partition&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGE(TAG, <span class="string">&quot;Failed to initialize SPIFFS (%s)&quot;</span>, esp_err_to_name(ret));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> total = <span class="number">0</span>, used = <span class="number">0</span>;</span><br><span class="line">    ret = esp_spiffs_info(conf.partition_label, &amp;total, &amp;used);</span><br><span class="line">    <span class="keyword">if</span> (ret != ESP_OK)</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">&quot;Failed to get SPIFFS partition information (%s)&quot;</span>, esp_err_to_name(ret));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;Partition size: total: %d, used: %d&quot;</span>, total, used);</span><br><span class="line"></span><br><span class="line">    FILE* f = fopen(<span class="string">&quot;/spiffs/hello.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);<span class="comment">//打开文件</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">&quot;Failed to open file for writing&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(f, <span class="string">&quot;Hello World!\n&quot;</span>);<span class="comment">//写入文件</span></span><br><span class="line">    fclose(f);<span class="comment">//关闭文件</span></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;File written&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (stat(<span class="string">&quot;/spiffs/foo.txt&quot;</span>, &amp;st) == <span class="number">0</span>)<span class="comment">//检测文件是否存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        unlink(<span class="string">&quot;/spiffs/foo.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rename(<span class="string">&quot;/spiffs/hello.txt&quot;</span>, <span class="string">&quot;/spiffs/foo.txt&quot;</span>) != <span class="number">0</span>)<span class="comment">//重命名</span></span><br><span class="line">    &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">&quot;Rename failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f = fopen(<span class="string">&quot;/spiffs/foo.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);<span class="comment">//打开文件</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">&quot;Failed to open file for reading&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">64</span>];</span><br><span class="line">    fgets(line, <span class="keyword">sizeof</span>(line), f);<span class="comment">//读取文件</span></span><br><span class="line">    fclose(f);<span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">char</span>* pos = <span class="built_in">strchr</span>(line, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pos)</span><br><span class="line">    &#123;</span><br><span class="line">        *pos = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Read from file: &#x27;%s&#x27;&quot;</span>, line);</span><br><span class="line"></span><br><span class="line">    esp_vfs_spiffs_unregister(conf.partition_label);<span class="comment">//解除SIFFS挂载</span></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;SPIFFS unmounted&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="FLASH加密"><a href="#FLASH加密" class="headerlink" title="FLASH加密"></a>FLASH加密</h1><p>FLASH加密功能用于加密与ESP32搭载使用的SPI Flash中的内容。启用FLASH加密功能后，物理读取SPI FLASH便无法恢复大部分FLASH内容。通过明文数据烧录ESP32可应用加密功能，<strong>若已启用加密功能，引导加载程序会在首次启动时对数据进行加密</strong>。</p>
<p>FLASH加密功能与密钥同样稳固，但并非所有数据都是加密存储且无法防止攻击者获取FLASH的高层次布局信息</p>
<p><strong>为了防止攻击者直接恶意修改固件，推荐搭配使用FLASH加密与安全启动</strong>，但启用安全启动时，OTA</p>
<p>启用FLASH加密后，系统将默认加密下列类型的FLASH数据：</p>
<ul>
<li>BootLoader</li>
<li>分区表</li>
<li>所有app类型的分区</li>
</ul>
<p>其他类型的FLASH数据将视情况进行加密：</p>
<ul>
<li>如果已启用安全启动，则会加密安全启动引导加载程序摘要</li>
<li>分区表中标有加密标记的分区</li>
</ul>
<p>注意：<strong>启用 Flash 加密将限制后续 ESP32 更新</strong></p>
<p>FLASH加密分为两种模式：开发模式和生产模式</p>
<h2 id="使用FLASH加密"><a href="#使用FLASH加密" class="headerlink" title="使用FLASH加密"></a>使用FLASH加密</h2><p>一般地，<strong>只要在menuconfig中设置使用加密并使用加密方式烧录即可使用FLASH加密</strong></p>
<ol>
<li><p>开发模式：可使用 ESP32 内部生成的密钥或外部主机生成的密钥在开发中运行FLASH加密</p>
</li>
<li><p>生产模式：使用ESP32生成的FLASH加密密钥</p>
</li>
</ol>
<p>在程序中使用<code>#include &quot;esp_flash_encrypt.h&quot;</code>、<code>#include &quot;esp_efuse_table.h&quot;</code>、<code>#include &quot;esp_efuse.h&quot;</code>、<code>#include &quot;soc/efuse_reg.h&quot;</code>后可以使用相关API</p>
<p>分区表如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># Name,   Type, SubType, Offset,  Size, Flags</span><br><span class="line">nvs,        data, nvs,      <span class="number">0x9000</span>,  <span class="number">0x6000</span>,</span><br><span class="line"># Extra partition to demonstrate reading/writing of encrypted flash</span><br><span class="line">storage,    data, <span class="number">0xff</span>,     <span class="number">0xf000</span>,  <span class="number">0x1000</span>, encrypted</span><br><span class="line">factory,    app,  factory,  <span class="number">0x10000</span>, <span class="number">1</span>M,</span><br></pre></td></tr></table></figure>

<p>如果所有分区都需以加密格式更新，则可使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idf.py encrypted-flash monitor</span><br></pre></td></tr></table></figure>

<p>只要 <code>FLASH_CRYPT_CNT</code> eFuse 设置为奇数位的值，所有通过MMU的FLASH缓存访问的FLASH内容都将被透明解密：MMU FLASH缓存将无条件解密所有数据</p>
<ol start="3">
<li>释放模式下，UART引导加载程序无法执行FLASH加密操作，<strong>只能使用OTA</strong>下载已经加密过的映像</li>
</ol>
<p>可通过调用函数esp_flash_encryption_enabled()来确认当前是否已启用FLASH加密</p>
<p>可通过调用函数esp_get_flash_encryption_mode()来识别使用的FLASH加密模式</p>
<p>使用分区读取函数esp_partition_read()来读取加密分区的数据</p>
<p>下面是使用FLASH加密的示例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;soc/efuse_reg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_efuse.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_system.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_spi_flash.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_partition.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_flash_encrypt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_efuse_table.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_IDF_TARGET_ESP32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TARGET_CRYPT_CNT_EFUSE  ESP_EFUSE_FLASH_CRYPT_CNT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TARGET_CRYPT_CNT_WIDTH  7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> CONFIG_IDF_TARGET_ESP32S2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TARGET_CRYPT_CNT_EFUSE ESP_EFUSE_SPI_BOOT_CRYPT_CNT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TARGET_CRYPT_CNT_WIDTH  3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_flash_encryption_status</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//输出FLASH加密状态</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print_flash_encryption_status();<span class="comment">//像函数中使用API才能访问加密分区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_flash_encryption_status</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> flash_crypt_cnt = <span class="number">0</span>;</span><br><span class="line">    esp_efuse_read_field_blob(TARGET_CRYPT_CNT_EFUSE, &amp;flash_crypt_cnt, TARGET_CRYPT_CNT_WIDTH);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FLASH_CRYPT_CNT eFuse value is %d\n&quot;</span>, flash_crypt_cnt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">esp_flash_enc_mode_t</span> mode = esp_get_flash_encryption_mode();</span><br><span class="line">    <span class="keyword">if</span> (mode == ESP_FLASH_ENC_MODE_DISABLED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Flash encryption feature is disabled\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Flash encryption feature is enabled in %s mode\n&quot;</span>,</span><br><span class="line">            mode == ESP_FLASH_ENC_MODE_DEVELOPMENT ? <span class="string">&quot;DEVELOPMENT&quot;</span> : <span class="string">&quot;RELEASE&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sdkconfig中的相关条目如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CONFIG_SECURE_FLASH_ENC_ENABLED=y</span><br><span class="line">CONFIG_SECURE_FLASH_ENCRYPTION_MODE_DEVELOPMENT=y</span><br><span class="line">CONFIG_SECURE_BOOT_ALLOW_ROM_BASIC=y</span><br><span class="line">CONFIG_SECURE_BOOT_ALLOW_JTAG=y</span><br><span class="line">CONFIG_SECURE_FLASH_UART_BOOTLOADER_ALLOW_ENC=y</span><br><span class="line">CONFIG_SECURE_FLASH_UART_BOOTLOADER_ALLOW_DEC=y</span><br><span class="line">CONFIG_SECURE_FLASH_UART_BOOTLOADER_ALLOW_CACHE=y</span><br><span class="line">CONFIG_SECURE_FLASH_REQUIRE_ALREADY_ENABLED=y</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32_IDF学习3【经典蓝牙与BLE】</title>
    <url>/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A03%E3%80%90%E7%BB%8F%E5%85%B8%E8%93%9D%E7%89%99%E4%B8%8EBLE%E3%80%91/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>在这里着重记述低功耗蓝牙BLE相关内容，库函数部分翻译自乐鑫官网文档</p>
<h1 id="低功耗蓝牙（BLE）协议栈"><a href="#低功耗蓝牙（BLE）协议栈" class="headerlink" title="低功耗蓝牙（BLE）协议栈"></a>低功耗蓝牙（BLE）协议栈</h1><p>低功耗蓝牙协议是蓝牙通信协议的一种，BLE协议栈就是实现低功耗蓝牙协议的代码</p>
<span id="more"></span>

<h2 id="层次协议"><a href="#层次协议" class="headerlink" title="层次协议"></a>层次协议</h2><p>蓝牙协议规定了两个层次的协议，分别为<strong>蓝牙核心协议</strong>（Bluetooth Core）和<strong>蓝牙应用层协议</strong>（Bluetooth Application）</p>
<p>蓝牙核心协议就是对蓝牙技术本身的规范，不涉及其应用方式</p>
<p>蓝牙应用层协议是在蓝牙核心协议的基础上，根据具体的应用需求定义出的特定策略</p>
<p>蓝牙协议栈框图如下所示：</p>
<p><img src="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A03%E3%80%90%E7%BB%8F%E5%85%B8%E8%93%9D%E7%89%99%E4%B8%8EBLE%E3%80%91/653161-20191204145125985-356995077.png" alt="https://img2018.cnblogs.com/blog/653161/201912/653161-20191204145125985-356995077.png"></p>
<h2 id="蓝牙核心协议（Bluetooth-Core）"><a href="#蓝牙核心协议（Bluetooth-Core）" class="headerlink" title="蓝牙核心协议（Bluetooth Core）"></a>蓝牙核心协议（Bluetooth Core）</h2><p>蓝牙核心协议包含BLE Controller和BLE Host两部分</p>
<p>Controller负责定义RF、Baseband等偏硬件的规范</p>
<p>Host负责在逻辑链路的基础上，进行更为友好的封装，这样就可以屏蔽掉蓝牙技术的细节，让Bluetooth Application更为方便的使用</p>
<p><strong>Controller是工作在物理层、数据链路层、网络层、传输层的协议，Host则是工作在传输层 、会话层、表示层、应用层的协议，Host将Controller封装成可被配置为函数的形式供程序使用</strong></p>
<p><img src="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A03%E3%80%90%E7%BB%8F%E5%85%B8%E8%93%9D%E7%89%99%E4%B8%8EBLE%E3%80%91/653161-20191204145156859-489087209.png" alt="https://img2018.cnblogs.com/blog/653161/201912/653161-20191204145156859-489087209.png"></p>
<h3 id="包含的层次简介"><a href="#包含的层次简介" class="headerlink" title="包含的层次简介"></a>包含的层次简介</h3><ol>
<li>物理层（PHY）</li>
</ol>
<p>用于指定BLE所用的无线频段、调制解调方式和方法等</p>
<p>BLE工作在1Mbps自适应跳频的GFSK射频，免于许可证的2.4GHz ISM（工业、课学、医疗）频段</p>
<p><strong>可以直观理解为规定了BLE的天线部分</strong></p>
<ol start="2">
<li>链路层（LL——Link Layer）</li>
</ol>
<p><strong>BLE协议栈的核心</strong></p>
<p><strong>相当于TCP/IP协议中的数据链路层（负责选择哪个射频通道，管理当前链路）+网络层（负责识别和发送空中数据包）+传输层（负责保证数据包安全、完整的发送、接收、重传等）</strong></p>
<ol start="3">
<li>主机控制接口层（HCI——Host Controller Interface）</li>
</ol>
<p>这一层是<strong>可选</strong>的，HCI主要用于2颗IC实现BLE协议栈的场合，用于贵方两者的通信协议和通信命令等</p>
<h2 id="蓝牙应用协议（Bluetooth-Application）"><a href="#蓝牙应用协议（Bluetooth-Application）" class="headerlink" title="蓝牙应用协议（Bluetooth Application）"></a>蓝牙应用协议（Bluetooth Application）</h2><h3 id="包含的层次简介-1"><a href="#包含的层次简介-1" class="headerlink" title="包含的层次简介"></a>包含的层次简介</h3><ol start="4">
<li>通用访问配置文件层（GAP——Generic access profile）</li>
</ol>
<p><strong>实际配置中常接触到的一层</strong></p>
<p>GAP是对LL层有效数据包（payload）进行解析的两种方式中最简单的一种，主要用于<strong>广播、扫描、发起连接</strong>这些具体行为</p>
<ol start="5">
<li>逻辑链路控制及自适应协议层（L2CAP——Logical Link Control and Adaptation Protocol）</li>
</ol>
<p>这一层是对LL的简单封装，在L2CAP中区分出是使用加密通道还是普通通道，同时负责连接间隔的管理</p>
<ol start="6">
<li>安全管理层（SM——Security Manager）</li>
</ol>
<p>负责管理BLE连接的加密、安全，需要兼顾安全性和用户使用的便利性</p>
<ol start="7">
<li>属性协议层（ATT——Attribute protocol）</li>
</ol>
<p><strong>实际配置中最常接触到的一层</strong></p>
<p>负责定义用户命令和命令操作的数据（如读写数据等）</p>
<p>详细内容见后文【BLE的两种模式】和【ATT简述】</p>
<ol start="8">
<li>通用属性配置文件层（GATT——Generic Attribute profile）</li>
</ol>
<p><strong>实际配置中常接触到的一层</strong></p>
<p>用于规范attribute中的数据内容（attribute见后文【BLE的两种模式】），并使用分组（group）来对attribute进行分类管理</p>
<p>一般地，BLE在没有GATT的情况下也能跑，只不过互联互通会出现问题</p>
<p>BLE<strong>需要在GATT和各种应用profile的支持</strong>下才能实现最便捷高效稳定的通信</p>
<h1 id="BT与BLE的区别"><a href="#BT与BLE的区别" class="headerlink" title="BT与BLE的区别"></a>BT与BLE的区别</h1><p>当前的蓝牙协议分为基础率/增强数据率（BR/EDR）和低耗能（LE）两种技术类型</p>
<p>经典蓝牙统称BT，低功耗蓝牙称为BLE</p>
<h2 id="经典蓝牙模块（BT）"><a href="#经典蓝牙模块（BT）" class="headerlink" title="经典蓝牙模块（BT）"></a>经典蓝牙模块（BT）</h2><blockquote>
<p>泛指支持蓝牙协议在4.0以下的模块，一般用于数据量比较大的传输。</p>
</blockquote>
<p><strong>经典蓝牙模块</strong>可再细分为：<strong>传统蓝牙模块和高速蓝牙模块</strong>。</p>
<p><strong>传统蓝牙模块</strong>在2004年推出，主要代表是支持蓝牙2.1协议的模块，在智能手机爆发的</p>
<p>时期得到广泛支持。</p>
<p><strong>高速蓝牙模块</strong>在2009年推出，速率提高到约24Mbps，是传统蓝牙模块的八倍。</p>
<h2 id="低功耗蓝牙模块（BLE）"><a href="#低功耗蓝牙模块（BLE）" class="headerlink" title="低功耗蓝牙模块（BLE）"></a>低功耗蓝牙模块（BLE）</h2><blockquote>
<p>指支持蓝牙协议4.0或更高的模块，也称为BLE模块（Bluetooth Low Energy Module）,最大的特点是成功和功耗的降低。</p>
</blockquote>
<p>蓝牙低功耗技术采用可变连接时间间隔，这个间隔根据具体应用可以设置为几毫秒到几秒不等。</p>
<p>另外，因为BLE技术采用非常快速的连接方式，因此可以处于“非连接”状态（节省能源），此时链路两端相互间仅能知晓对方，必要时可以才开启链路，然后在尽可能短的时间内关闭链路。</p>
<h2 id="其他分类"><a href="#其他分类" class="headerlink" title="其他分类"></a>其他分类</h2><p>按用途来分：蓝牙模块有<strong>数据</strong>蓝牙模块，<strong>语音</strong>蓝牙模块，<strong>串口</strong>蓝牙模块和<strong>车载</strong>蓝牙模块</p>
<p>按芯片设计来分：蓝牙模块有flash版本和ROM版本。前者一般是BGA封装（球栅阵列封装），外置flash；后者一般是LCC封装（表面贴装型封装），外接EEPROM。</p>
<h1 id="BLE的两种模式"><a href="#BLE的两种模式" class="headerlink" title="BLE的两种模式"></a>BLE的两种模式</h1><ol>
<li>客户端 Client</li>
</ol>
<p>请求数据服务</p>
<p><strong>客户端</strong>可以主动搜索并连接附近的服务端</p>
<p>客户端类似蹭网的</p>
<ol start="2">
<li>服务端Server</li>
</ol>
<p>提供数据服务</p>
<p><strong>服务端</strong>不需要进行主动设置，只要开启广播就可以让附近的客户端搜索到，并提供连接</p>
<p>服务端类似被蹭网的wifi</p>
<p>如果想要让ESP处于别人随时可以搜索连接的情况要配置为服务端；如果想让ESP通过扫描连接周围可连接的蓝牙设备，需要把它设置成客户端，<strong>正好和WiFi模式的设定相反</strong></p>
<p>Server通过<strong>characteristic</strong>对数据进行封装，多个characteristic组成一个Service——Server是一个基本的BLE应用，如果某个<em>Service</em>是一个蓝牙联盟定义的标准服务，也可以称其为<em>profile</em></p>
<p>要具体了解这些内容需要先了解属性协议层ATT</p>
<h2 id="ATT简述"><a href="#ATT简述" class="headerlink" title="ATT简述"></a>ATT简述</h2><p><img src="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A03%E3%80%90%E7%BB%8F%E5%85%B8%E8%93%9D%E7%89%99%E4%B8%8EBLE%E3%80%91/653161-20191204145156859-489087209.png" alt="https://img2018.cnblogs.com/blog/653161/201912/653161-20191204145156859-489087209.png"></p>
<p>属性协议层ATT（Attribute Protocol）是GATT和GAP的基础，它定义了BLE协议栈上层的数据结构和组织方式；在层内，它定义了属性（Attribute）的内容，规定了访问属性的方法和权限</p>
<p>属性是一个数据结构，<strong>它包括了数据类型和数据值，可以像C语言的结构体那样构造</strong></p>
<p>属性包括三种类型：<strong>服务项</strong>、<strong>特征值</strong>和<strong>描述符</strong>，三者呈包含关系：服务项包含一个或多个特征值，特征值包含一个或多个描述符，多个服务项组织在一起，构成<strong>属性规范（Attribute Profile）</strong></p>
<h3 id="属性的种类和分组"><a href="#属性的种类和分组" class="headerlink" title="属性的种类和分组"></a>属性的种类和分组</h3><p>属性大致可以分为三种类型：<strong>服务项Profile</strong>、<strong>特征值Characteristic</strong>和<strong>描述符Descriptor</strong></p>
<p>最顶级为Profile, 下面是多个服务项(Service), 服务项下面是多个特征值(Characteristic), 特征值下面是多个描述符(Descriptor)</p>
<p>每个设备都包含以下必要的特征值和服务项：</p>
<p>PROFILE</p>
<ul>
<li>Generic Access Service（Primary Service）<ul>
<li>Device Name（Characteristic）</li>
<li>Appearance（Characteristic）</li>
</ul>
</li>
<li>Generic Attribute Service（Primary Service）<ul>
<li>Service Changed（Characteristic）<ul>
<li>CCCD（Descriptor）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="服务项Service"><a href="#服务项Service" class="headerlink" title="服务项Service"></a>服务项Service</h3><p>服务项这种类型本身并不包含数据，仅仅相当于是一个<strong>容器</strong>，用来<strong>容纳特征值</strong></p>
<h3 id="特征值characteristic"><a href="#特征值characteristic" class="headerlink" title="特征值characteristic"></a>特征值characteristic</h3><p>特征值用于<strong>保存用户数据</strong>，但它也有自己的UUID——可以把它看作一个变量，变量里存着数据（用户数据），也有自己的地址信息（UUID）</p>
<p>使用特征值时，也要遵循“先声明再赋值”的步骤——先声明特征值自身，再声明它的项</p>
<p>一个characteristic包含三种条目：</p>
<ol>
<li>characteristic声明：每个characteristic的分界符，解析时一旦遇到一个声明，就可以认为接下来又是一个新的characteristic；声明还包含了接下来characteristic值的读写属性等</li>
<li>characteristic值：数据的值</li>
<li>characteristic描述符：数据的额外信息</li>
</ol>
<p>一般BLE的属性体系在系统中以GattDB表示，即<strong>属性数据库</strong>，gattDB是BLE协议栈在内存中开辟的一段专有区域，会在特定的时候写入Flash进行保存，并在启动时读取出来回写到内存中去，但<strong>并非所有的BLE数据通信是操作gattDB</strong></p>
<p>characteristic用<strong>Attribute</strong>数据结构来实现</p>
<h3 id="属性Attribute的数据结构"><a href="#属性Attribute的数据结构" class="headerlink" title="属性Attribute的数据结构"></a>属性Attribute的数据结构</h3><p>Attribute由四部分组成：</p>
<ol>
<li><p>属性句柄Attribute handle：可以视为<strong>指向属性实体的指针</strong>，对端设备通过属性句柄来访问某个属性，大小2字节，起始于0x0001，系统初始化时，各属性的句柄逐步+1，但最大不超过0xFFFF</p>
</li>
<li><p>属性类型Attribute type：用以区分当前属性是服务项或是特征值等，用通用唯一识别码（<strong>UUID</strong>）标识的16字节十六进制字符串（形如f6257d37-34e5-41dd-8f40-e308210498b4，从网上抄来的示例，如有雷同那就是雷同）表示。一个合法的UUID，一定是随机的、全球唯一的，不应该出现两个相同的UUID。属性类型分类如下：</p>
<ul>
<li>首要服务项Primary Service</li>
<li>次要服务项Secondary Service</li>
<li>包含服务项Include</li>
<li>特征值Characteristic</li>
</ul>
<p>他们与UUID的映射关系如下：</p>
<ul>
<li>0x1800 – 0x26FF ：服务项类型</li>
<li>0x2700 – 0x27FF ：单位</li>
<li>0x2800 – 0x28FF ：属性类型</li>
<li>0x2900 – 0x29FF ：描述符类型</li>
<li>0x2A00 – 0x7FFF ：特征值类型</li>
</ul>
<p>为了减少传输的数据量，BLE协议做了一个转换约定，给定一个固定的16字节模板，只设置2个字节为变化量，其他为常量，2字节的UUID在系统内部会被替换，进而转换成标准的16字节UUID；反之，如果一个特征值的UUID是16字节的，在系统内部它的属性类型也可能写成第3、4字节组成的双字节</p>
<p>示例如下：</p>
<p>UUID模板为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000XXXX-0000-1000-8000-00805F9B34FB</span><br></pre></td></tr></table></figure>

<p>其中从左数第3、4个字节“XXXX”就是变化位，其他为固定位。如：UUID=0x2A00在系统内部会转换成00002A00-0000-1000-8000-00805F9B34FB。</p>
</li>
<li><p>属性值Attribute value：真正的数据值，大小为0-512字节。如果该属性是服务项类型或者是特征值声明类型，那么它的属性值就是UUID等信息；如果是普通的特征值，则属性值是用户的数据，属性值需要预留空间以保存用户数据，<strong>可以将属性值的预留空间看做I2C的数据空间，操作特征值里的用户数据，就是对那块内存空间进行读写</strong>，==所以启用蓝牙后会占用额外的内存==</p>
</li>
<li><p>属性权限Attribute permissions：Attribute的权限属性，主要有四种：</p>
<ul>
<li>访问权限（Access Permission）：只读或只写或读写</li>
<li>加密权限（Encryption Permission）：加密或不加密</li>
<li>认证权限（Authentication Permission）：需要认证或无需认证。指相互确认对方身份，BLE中所说的“认证”过程就是设备配对</li>
<li>授权权限（Authorization Permission）：需要授权或无需授权。指对授信设备开放权利</li>
</ul>
<p>授权的管控等级要高于认证，认证的设备未必被授权，授权的设备一定是认证的——<strong>认证是授权的充分不必要条件</strong>。认证是设备配对，两边都符合协议规定就行，但是授权取决于Server设备对Client设备的主动许可。</p>
<p>一个没有经过认证的设备，被称为<strong>未知设备（Unknown Device）</strong>；经过了认证，该设备会在绑定信息中被标记为Untrusted，被称为<strong>不可信设备（Untrusted Device）</strong>；经过了认证，并且在绑定信息中被标记为Trusted的设备被称为<strong>可信设备（Trusted Device）</strong></p>
<p>具体的权限示例如下所示：</p>
<ul>
<li>Open（随意读写）</li>
<li>No Access（禁止读写）</li>
<li>Authentication（需要配对才能读写，分成很多子类型用于适配配对的类型）</li>
<li>Authorization（允许应用在回调函数中读写）</li>
<li>Signed（签名后才能随意读写）</li>
</ul>
</li>
</ol>
<h3 id="属性协议ATT-PDU"><a href="#属性协议ATT-PDU" class="headerlink" title="属性协议ATT PDU"></a>属性协议ATT PDU</h3><p>拥有一组属性的设备称为服务端（Server）；读写该属性值的设备称为客户端（Client）</p>
<p>Client和Server之间通过<strong>ATT PDU</strong>通信</p>
<p>属性协议ATT PDU共有6种，如下表所示：</p>
<table>
<thead>
<tr>
<th>ATT PDU种类</th>
<th>发送方向</th>
<th>触发响应</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Command</td>
<td>Client -&gt; Server</td>
<td>–</td>
<td>客户端发送Command，服务器无需任何返回</td>
</tr>
<tr>
<td>Request</td>
<td>Client -&gt; Server</td>
<td>Response</td>
<td>客户端发送Request，服务器需要返回一个Response，表明服务器收到</td>
</tr>
<tr>
<td>Response</td>
<td>Server -&gt; Client</td>
<td>–</td>
<td></td>
</tr>
<tr>
<td>Notification</td>
<td>Server -&gt; Client</td>
<td>–</td>
<td>服务器发送Notification，户端无需任何返回</td>
</tr>
<tr>
<td>Indication</td>
<td>Server -&gt; Client</td>
<td>Confirmation</td>
<td>服务器发送Indication，客户端需要返回一个Confirmation，表明客户端收到</td>
</tr>
<tr>
<td>Confirmation</td>
<td>Client -&gt; Server</td>
<td>–</td>
<td></td>
</tr>
</tbody></table>
<p>BLE下，所有命令都是“必达”的，每个命令发送完毕后，发送者会等待ACK信息（类似I2C），如果收到了ACK包，发起方认为命令完成；否则发起方会一直重传该命令直到超时导致BLE连接断开（类似CAN的出错重发机制），可以说<strong>只要数据包放到了协议栈射频FIFO中，蓝牙协议栈就能保证该数据包“必达”对方</strong>，但是没有回复相对有回复就是“不太可靠”，这时候就需要特殊的“有回复属性”</p>
<h3 id="Request后缀"><a href="#Request后缀" class="headerlink" title="Request后缀"></a>Request后缀</h3><p>特别地，如果一个命令需要response，那么可以在相应命令后面加上request后缀，这个response包<strong>在应用层有回调事件</strong>，可以用于触发特殊的功能，这是默认的协议ACK恢复不具有的，采用request/response方式，应用层可以按顺序地发送一些数据包；如果一个命令只需要ACK而不需要response，那么它的后面就不会带request</p>
<p>然而Request/response会大大降低通信的吞吐率，因为request/response必须在不同的连接间隔中出现，这就导致两个连接间隔最多只能发一个数据包，而不带request后缀的ATT命令就没有这个问题——一般情况下，在同一个连接间隔中可以同时发多个数据包，这样将大大提高数据的吞吐率</p>
<p>常用的带request命令：所有read命令，writerequest，indication等</p>
<p>常用的不带request命令：write command，notification等</p>
<h2 id="通用属性协议GATT简述"><a href="#通用属性协议GATT简述" class="headerlink" title="通用属性协议GATT简述"></a>通用属性协议GATT简述</h2><p>GATT(Generic Attribute Profile)，描述了一种使用ATT的服务框架。该框架定义了服务(Server)和服务属性(characteristic)的过程(Procedure)及格式，负责处理具体数据段通过蓝牙连接的发送和接收</p>
<p><strong>现在的BLE大多建立在GATT协议之上</strong>，GATT建立在ATT和L2CAP之上，GATT需要使用通用访问协议GAP来确定设备的连接</p>
<p><img src="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A03%E3%80%90%E7%BB%8F%E5%85%B8%E8%93%9D%E7%89%99%E4%B8%8EBLE%E3%80%91/653161-20191204145156859-489087209.png" alt="https://img2018.cnblogs.com/blog/653161/201912/653161-20191204145156859-489087209.png"></p>
<h3 id="通用访问协议GAP"><a href="#通用访问协议GAP" class="headerlink" title="通用访问协议GAP"></a>通用访问协议GAP</h3><p>GAP 使设备被其他设备可见，并决定了当前设备是否可以或者怎样与合同设备进行交互</p>
<p>GAP中，设备被分为<strong>外围设备Peripheral</strong>和<strong>中心设备Central</strong></p>
<p>外围设备：性能相对较弱、功耗相对低的设备，他们通常被连接到更加强大的中心设备</p>
<p>中心设备：性能相对较强、功耗较高的设备</p>
<h4 id="GAP广播"><a href="#GAP广播" class="headerlink" title="GAP广播"></a>GAP广播</h4><p>GAP 中外围设备不停向外广播以让中心设备知道它的存在。通过两种方式向外广播数据： </p>
<p>广播数据（Advertising Data Payload）：<em>必须的</em>，外设需要以此来和中心设备取得连接</p>
<p>扫描回复（Scan Response Data Payload）：<em>可选的</em>，中心设备可以向外围设备请求扫描回复，向其提供一些设备的额外信息</p>
<p>外围设备会设定一个广播建个，每个间隔中，它会重新发送自己的广播数据，<strong>广播间隔越长约省电，但同时更不容易被扫描到</strong></p>
<p>基于GATT广播的BLE连接只能是<strong>一个外围设备连接一个中心设备</strong>，可以理解成一个蓝牙耳机只能连接一台手机，不能同时连接两台手机</p>
<h4 id="GATT协议"><a href="#GATT协议" class="headerlink" title="GATT协议"></a>GATT协议</h4><p>GATT协议建立在ATT协议的基础上。将ATT协议中的Service、Characteristic 及对应数据都保存在一个查找表中，查找表使用16位的ID作为索引。建立GATT连接前必须先经过GAP协议</p>
<p><strong>GATT连接是独占的</strong>，也就是说同一个BLE外设（外部设备）同时只能被一个中心设备连接，一旦外设被连接，它就会停止GAP广播，对其它设备不可见；当设备断开时它又开始广播。</p>
<p>如果中心设备和外设<strong>需要双向通信，唯一的方式就是建立GATT连接</strong>，GAP通信是单向的，只能让中心设备向外设发送信息</p>
<p>GATT通信双方是C/S关系，外设作为GATT的Server，维持ATT查找表、Service、Characteristic定义；中心设备作为GATT的Client，向Server发起请求，所有通信事件都由中心设备Client发起，从Server接收响应。一旦连接建立，外设将会给中心设备建议一个<strong>连接间隔</strong>，中心设备<em>可以选择</em>在每个连接间隔尝试重新连接，检查是否有新数据，不过这个间隔只是建议，中心设备可以不严格按照这个间隔执行请求。</p>
<h4 id="GATT结构"><a href="#GATT结构" class="headerlink" title="GATT结构"></a>GATT结构</h4><p>GATT结构建立在ATT的属性Attribute数据结构之上（其实和ATT的那些东西一模一样）</p>
<p><strong>Attribute结构体组成种类不同的Characteristic，多个Characteristic被封装在Servce容器中，Characteristic和Service容器都有着自己的UUID（有官方认证的16位UUID和自定义的128位UUID），各种常用的Service集合成Profile</strong></p>
<p>BLE外设的通信主要通过Characteristic，通过在Characteristic中读写数据就实现了双向通信，也可以通过实现类似串口的Service来配置TxCharacteristic和RxCharacteristic，这些都是具体项目的选择了</p>
<h1 id="BLE从初始化到建立连接的过程简述"><a href="#BLE从初始化到建立连接的过程简述" class="headerlink" title="BLE从初始化到建立连接的过程简述"></a>BLE从初始化到建立连接的过程简述</h1><ol>
<li>外围设备开始广播，发送完一个广播包后T_IFS，开启射频Rx窗口接收来自中心设备的数据包</li>
<li>中心设备扫描到广播，在收取此广播T_IFS后如果开启了中心设备的扫描回复，中心设备将向外设发送回复</li>
<li>外设收取到中心设备的回复，做好接收准备，并返回ACK包</li>
<li>如果ACK包未被中心设备接收到，中心设备将一直发送回复直到超时，此期间内只要外设返回过一次ACK包就算连接成功</li>
<li>开始建立通信，后续中心设备将以收取到外设广播的时间为原点，以Connection Interval为周期向外设发送数据包，数据包将具有两个作用：<strong>同步两设备时钟</strong>和<strong>建立主从模式通信</strong></li>
</ol>
<p>外设每收到中心设备的一个包，就会把自己的时序原点重新设置，以和中心设备同步（Service向Client同步）</p>
<p>BLE通信在建立成功后变为主从模式，<strong>中心设备Central变为Master，外设Peripheral变为Slave</strong>，Slave只能在Master向它发送了一个包以后才能在规定的时间内把自己的数据回传给Master</p>
<ol start="6">
<li>连接建立成功</li>
<li>外设自动停止广播，其他设备无法再查找到该外设</li>
<li>按照以下时序进行通信，在中心设备发送包的间隔内，外设可以发送多个包</li>
</ol>
<p><img src="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A03%E3%80%90%E7%BB%8F%E5%85%B8%E8%93%9D%E7%89%99%E4%B8%8EBLE%E3%80%91/20190726193026779.png" alt="在这里插入图片描述"></p>
<ol start="8">
<li>需要连接断开时只需要中心设备停止连接（停止发送包）即可</li>
<li>中心设备可以将外设的addr写入Flash或SRAM等存储器件，保持监听此addr，当再次收到外设广播时就可以建立通信。BLE Server设备为了省电，当一段时间内没有数据要发送时，可以不再发送包，双方就会因为连接超时（connection timeout）断开，这时需要中心设备启动监听，这样，当BLE Server设备需要发送数据时，就可以再次连接</li>
</ol>
<h1 id="ESP的蓝牙外设配置"><a href="#ESP的蓝牙外设配置" class="headerlink" title="ESP的蓝牙外设配置"></a>ESP的蓝牙外设配置</h1><h2 id="蓝牙配置相关库函数"><a href="#蓝牙配置相关库函数" class="headerlink" title="蓝牙配置相关库函数"></a>蓝牙配置相关库函数</h2><h3 id="相关头文件及其作用"><a href="#相关头文件及其作用" class="headerlink" title="相关头文件及其作用"></a>相关头文件及其作用</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;bt.h&quot;</span><span class="comment">//蓝牙控制器和VHCI设置头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_gap_ble_api.h&quot;</span><span class="comment">//GAP设置头文件，广播和连接相关参数配置</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_gatts_api.h&quot;</span><span class="comment">//GATT配置头文件，创建Service和Characteristic</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;esp_bt_main.h&quot;</span><span class="comment">//蓝牙栈空间的初始化头文件</span></span></span><br></pre></td></tr></table></figure>

<h3 id="蓝牙控制器"><a href="#蓝牙控制器" class="headerlink" title="蓝牙控制器"></a>蓝牙控制器</h3><p>使用esp_bt_controller_init()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">esp_bt_controller_init(<span class="keyword">esp_bt_controller_config_t</span> *cfg);<span class="comment">//esp_bt_controller_config_t是蓝牙控制器配置结构体</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">esp_bt_controller_config_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> controller_task_stack_size;<span class="comment">//蓝牙控制器栈大小</span></span><br><span class="line">    <span class="keyword">uint8_t</span> controller_task_prio;<span class="comment">//蓝牙控制器任务优先级</span></span><br><span class="line">    <span class="keyword">uint8_t</span> hci_uart_no;<span class="comment">//使用哪个UART作为HCI的IO，仅能选择UART1或UART2串口</span></span><br><span class="line">	<span class="keyword">uint32_t</span> hci_uart_baudrate;<span class="comment">//HCI串口波特率</span></span><br><span class="line">    <span class="keyword">uint8_t</span> scan_duplicate_mode;<span class="comment">//重复扫描模式</span></span><br><span class="line">    <span class="keyword">uint8_t</span> scan_duplicate_type;<span class="comment">//重复扫描类型</span></span><br><span class="line">    <span class="keyword">uint16_t</span> normal_adv_size;<span class="comment">//普通广播报文大小</span></span><br><span class="line">    <span class="keyword">uint16_t</span> mesh_adv_size;<span class="comment">//mesh广播报文大小</span></span><br><span class="line">    <span class="keyword">uint16_t</span> send_adv_reserved_size;<span class="comment">//蓝牙控制器最小的内存大小（保留出发送报文所需的内存大小）</span></span><br><span class="line">    <span class="keyword">uint32_t</span> controller_debug_flag;<span class="comment">//蓝牙控制器debug log的属性</span></span><br><span class="line">    <span class="keyword">uint8_t</span> mode;<span class="comment">//BR/EDR/BLE/Dual模式选择</span></span><br><span class="line">	<span class="keyword">uint8_t</span> ble_max_conn;<span class="comment">//BLE模式最多连接个数</span></span><br><span class="line">    <span class="keyword">uint8_t</span> bt_max_acl_conn;<span class="comment">//BR或EDR最大的ACL连接个数</span></span><br><span class="line">    <span class="keyword">uint8_t</span> bt_sco_datapath;<span class="comment">//SCO数据路径 用于HCI或PCM模块</span></span><br><span class="line">	<span class="keyword">bool</span> auto_latency;<span class="comment">//BLE自动延迟，用于降低传统蓝牙的功耗</span></span><br><span class="line">    <span class="keyword">bool</span> bt_legacy_auth_vs_evt;<span class="comment">//BR/EDR传统的授权完毕事件，用于防止BIAS攻击</span></span><br><span class="line">    <span class="keyword">uint8_t</span> bt_max_sync_conn;<span class="comment">//BR/EDR最多的ACL连接数目，也可以在menuconfig中配配置</span></span><br><span class="line">    <span class="keyword">uint8_t</span> ble_sca;<span class="comment">//BLE晶振准确度指数</span></span><br><span class="line">    <span class="keyword">uint8_t</span> pcm_role;<span class="comment">//PCM角色，选择master或slave</span></span><br><span class="line">    <span class="keyword">uint8_t</span> pcm_polar;<span class="comment">//PCM触发极性，选择下降沿或上升沿</span></span><br><span class="line">    <span class="keyword">uint32_t</span> magic;<span class="comment">//神奇数字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化蓝牙控制器，<strong>此函数只能被调用一次，且必须在其他蓝牙功能被调用之前调用</strong></p>
<p>使用esp_bt_controller_deinit()来取消初始化，用于关闭蓝牙并清除其占用的内存，还会将蓝牙任务删除</p>
<p>下面是蓝牙控制器的常用API</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">esp_bt_controller_enable(<span class="keyword">esp_bt_mode_t</span> mode);<span class="comment">//使能蓝牙控制器，mode是蓝牙模式，如果想要动态改变蓝牙模式不能直接调用该函数，应该先用下面的disable关闭蓝牙再使用该API来改变蓝牙模式</span></span><br><span class="line">esp_bt_controller_disable(<span class="keyword">void</span>);<span class="comment">//关闭蓝牙控制器</span></span><br><span class="line">sp_bt_controller_get_status(<span class="keyword">void</span>);<span class="comment">//获取蓝牙控制器状态</span></span><br><span class="line">esp_bt_get_mac(<span class="keyword">void</span>);<span class="comment">//获取蓝牙MAC地址</span></span><br><span class="line"></span><br><span class="line">esp_bt_controller_mem_release(<span class="keyword">esp_bt_mode_t</span> mode);<span class="comment">//释放蓝牙控制器的所有内存，包括BSS、数据和其他蓝牙使用的堆栈空间</span></span><br><span class="line"><span class="comment">//这个API仅仅应该再esp_bt_controller_init()或after esp_bt_controller_deinit()之前被调用</span></span><br><span class="line">esp_bt_mem_release(<span class="keyword">esp_bt_mode_t</span> mode);</span><br><span class="line"><span class="comment">//释放蓝牙控制器和蓝牙数据的所有内存，比esp_bt_controller_mem_release()更彻底</span></span><br><span class="line">esp_bt_sleep_enable(<span class="keyword">void</span>);<span class="comment">//让蓝牙进入睡眠模式，这个函数应该在esp_bt_controller_enable()被调用之后再调用</span></span><br></pre></td></tr></table></figure>

<p>特别地，官方文档中给出了一套在线升级蓝牙设备软件时的关闭流程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">esp_bluedroid_disable();</span><br><span class="line">esp_bluedroid_deinit();</span><br><span class="line">esp_bt_controller_disable();</span><br><span class="line">esp_bt_controller_deinit();</span><br><span class="line">esp_bt_mem_release(ESP_BT_MODE_BTDM);</span><br></pre></td></tr></table></figure>

<h3 id="经典蓝牙"><a href="#经典蓝牙" class="headerlink" title="经典蓝牙"></a>经典蓝牙</h3><p>用于蓝牙运行的API如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">esp_bluedroid_get_status(<span class="keyword">void</span>);<span class="comment">//获取蓝牙当前状态</span></span><br><span class="line"><span class="comment">//可能的状态如下所示</span></span><br><span class="line">ESP_BLUEDROID_STATUS_UNINITIALIZED==<span class="number">0</span><span class="comment">//未初始化</span></span><br><span class="line">ESP_BLUEDROID_STATUS_INITIALIZED<span class="comment">//已被初始化但是未开启</span></span><br><span class="line">ESP_BLUEDROID_STATUS_ENABLED<span class="comment">//初始化并开启</span></span><br><span class="line">    </span><br><span class="line">esp_bluedroid_enable(<span class="keyword">void</span>);<span class="comment">//使能蓝牙</span></span><br><span class="line">esp_bluedroid_disable(<span class="keyword">void</span>);<span class="comment">//关闭蓝牙</span></span><br><span class="line">esp_bluedroid_init(<span class="keyword">void</span>);<span class="comment">//初始化蓝牙并分配系统资源，它应该被第一个调用</span></span><br><span class="line">esp_bluedroid_deinit(<span class="keyword">void</span>);<span class="comment">//取消初始化蓝牙并将系统资源释放，用于蓝牙结束工作后的收尾</span></span><br></pre></td></tr></table></figure>

<p>用于设备蓝牙配置的API如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">esp_bt_dev_get_address(<span class="keyword">void</span>);<span class="comment">//获取当前设备蓝牙地址</span></span><br><span class="line">esp_bt_dev_set_device_name(<span class="keyword">const</span> <span class="keyword">char</span> *name);<span class="comment">//设置设备名</span></span><br></pre></td></tr></table></figure>

<p>这些函数都应该在蓝牙启用后被调用</p>
<h2 id="BLE-GAP相关库函数"><a href="#BLE-GAP相关库函数" class="headerlink" title="BLE-GAP相关库函数"></a>BLE-GAP相关库函数</h2><h3 id="外围设备库函数"><a href="#外围设备库函数" class="headerlink" title="外围设备库函数"></a>外围设备库函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">esp_ble_gap_start_advertising(<span class="keyword">esp_ble_adv_params_t</span> *adv_params);<span class="comment">//开始广播</span></span><br><span class="line">esp_ble_gap_stop_advertising(<span class="keyword">void</span>);<span class="comment">//停止广播</span></span><br><span class="line"></span><br><span class="line">esp_ble_gap_config_adv_data(<span class="keyword">esp_ble_adv_data_t</span> *adv_data);<span class="comment">//广播数据参数设置</span></span><br><span class="line"><span class="comment">//adv_data数据结构如下</span></span><br><span class="line"><span class="keyword">bool</span> set_scan_rsp<span class="comment">//设置是否需要扫描response</span></span><br><span class="line"><span class="keyword">bool</span> include_name<span class="comment">//广播内容是否包括设备名</span></span><br><span class="line"><span class="keyword">bool</span> include_txpower<span class="comment">//广播数据是否包括发射功率</span></span><br><span class="line"><span class="keyword">int</span> min_interval<span class="comment">//最小广播时间间隔</span></span><br><span class="line"><span class="comment">//计算公式：connIntervalmin = Conn_Interval_Min * 1.25 ms</span></span><br><span class="line"><span class="comment">//Conn_Interval_Min在0x0006到0x0C80之间，0xFFFF就是没有特定的最小值</span></span><br><span class="line"><span class="keyword">int</span> max_interval<span class="comment">//最大广播间隔</span></span><br><span class="line"><span class="comment">//计算公式：connIntervalmax = Conn_Interval_Max * 1.25 ms</span></span><br><span class="line"><span class="comment">//Conn_Interval_Max在0x0006到0x0C80之间，Conn_Interval_Max应大于等于Conn_Interval_Min</span></span><br><span class="line"><span class="comment">//0xFFFF代表没有特定的最大值</span></span><br><span class="line"><span class="keyword">int</span> appearance<span class="comment">//设备外形（External appearance）</span></span><br><span class="line"><span class="keyword">uint16_t</span> manufacturer_len<span class="comment">//生产商数据长度</span></span><br><span class="line"><span class="keyword">uint8_t</span> *p_manufacturer_data<span class="comment">//生产商数据指针</span></span><br><span class="line"><span class="keyword">uint16_t</span> service_data_len<span class="comment">//Service数据长度</span></span><br><span class="line"><span class="keyword">uint8_t</span> *p_service_data<span class="comment">//Service数据指针</span></span><br><span class="line"><span class="keyword">uint16_t</span> service_uuid_len<span class="comment">//Service的UUID长度</span></span><br><span class="line"><span class="keyword">uint8_t</span> *p_service_uuid<span class="comment">//Service的UUID数组指针</span></span><br><span class="line"><span class="keyword">uint8_t</span> flag<span class="comment">//广播属性（flag）</span></span><br><span class="line">    </span><br><span class="line">esp_ble_gap_config_adv_data_raw(<span class="keyword">uint8_t</span> *raw_data, <span class="keyword">uint32_t</span> raw_data_len);<span class="comment">//设置空的广播数据包，用户需要自行设置包的内容</span></span><br></pre></td></tr></table></figure>

<h3 id="中心设备库函数"><a href="#中心设备库函数" class="headerlink" title="中心设备库函数"></a>中心设备库函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">esp_ble_gap_start_scanning(<span class="keyword">uint32_t</span> duration);<span class="comment">//使用该函数让设备扫描附近正在广播的外设，duration为扫描间隔</span></span><br><span class="line">esp_ble_gap_stop_scanning(<span class="keyword">void</span>);<span class="comment">//停止扫描</span></span><br><span class="line"></span><br><span class="line">esp_ble_gap_set_scan_params(<span class="keyword">esp_ble_scan_params_t</span> *scan_params);<span class="comment">//设置扫描参数</span></span><br><span class="line">esp_ble_gap_register_callback(<span class="keyword">esp_gap_ble_cb_t</span> callback)<span class="comment">//间隔回调函数</span></span><br><span class="line">    </span><br><span class="line">esp_ble_gap_set_pkt_data_len(<span class="keyword">esp_bd_addr_t</span> remote_device, <span class="keyword">uint16_t</span> tx_data_length);<span class="comment">//设置最大数据包大小</span></span><br><span class="line"></span><br><span class="line">esp_ble_gap_set_prefer_conn_params(<span class="keyword">esp_bd_addr_t</span> bd_addr, <span class="keyword">uint16_t</span> min_conn_int, <span class="keyword">uint16_t</span> max_conn_int, <span class="keyword">uint16_t</span> slave_latency, <span class="keyword">uint16_t</span> supervision_tout);<span class="comment">//设置当默认连接参数无法使用时的优先连接参数，这个库函数只能用在中心设备master上</span></span><br><span class="line"></span><br><span class="line">esp_ble_gap_config_scan_rsp_data_raw(<span class="keyword">uint8_t</span> *raw_data, <span class="keyword">uint32_t</span> raw_data_len);<span class="comment">//设置空的response数据包，用户需要自行设置数据</span></span><br><span class="line"></span><br><span class="line">esp_ble_gap_read_rssi(<span class="keyword">esp_bd_addr_t</span> remote_addr);<span class="comment">//读取远程设备的RSSI，结果会在间隔回调函数中随ESP_GAP_BLE_READ_RSSI_COMPLETE_EVT事件返回</span></span><br></pre></td></tr></table></figure>

<h3 id="连接配置库函数"><a href="#连接配置库函数" class="headerlink" title="连接配置库函数"></a>连接配置库函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">esp_ble_gap_update_conn_params(<span class="keyword">esp_ble_conn_update_params_t</span> *params);<span class="comment">//在连接建立后更新连接参数</span></span><br><span class="line">esp_ble_gap_clear_rand_addr(<span class="keyword">void</span>);<span class="comment">//清空应用的随机地址</span></span><br><span class="line"></span><br><span class="line">esp_ble_gap_update_whitelist(<span class="keyword">bool</span> add_remove, <span class="keyword">esp_bd_addr_t</span> remote_bda, <span class="keyword">esp_ble_wl_addr_type_t</span> wl_addr_type);<span class="comment">//新建或移除白名单中的设备</span></span><br><span class="line">esp_ble_gap_get_whitelist_size(<span class="keyword">uint16_t</span> *length);<span class="comment">//获取白名单的大小</span></span><br><span class="line"></span><br><span class="line">esp_ble_gap_set_device_name(<span class="keyword">const</span> <span class="keyword">char</span> *name);<span class="comment">//设置本机设备名</span></span><br><span class="line">esp_ble_gap_get_local_used_addr(<span class="keyword">esp_bd_addr_t</span> local_used_addr, <span class="keyword">uint8_t</span> *addr_type);<span class="comment">//获取本机设备地址</span></span><br></pre></td></tr></table></figure>

<h2 id="GATT-Server的配置"><a href="#GATT-Server的配置" class="headerlink" title="GATT Server的配置"></a>GATT Server的配置</h2><h3 id="Server-Master"><a href="#Server-Master" class="headerlink" title="Server-Master"></a>Server-Master</h3><h4 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">esp_err_t</span> ret;<span class="comment">//用于debug</span></span><br><span class="line"><span class="keyword">esp_bt_controller_config_t</span> bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();<span class="comment">//设置蓝牙为默认参数</span></span><br><span class="line"></span><br><span class="line">ret = nvs_flash_init();<span class="comment">//初始化NVS</span></span><br><span class="line"><span class="keyword">if</span> (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND)</span><br><span class="line">&#123;</span><br><span class="line">	ESP_ERROR_CHECK(nvs_flash_erase());</span><br><span class="line">	ret = nvs_flash_init();</span><br><span class="line">&#125;</span><br><span class="line">ESP_ERROR_CHECK(ret);</span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;%s init NVS finished\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">ESP_ERROR_CHECK(esp_bt_controller_mem_release(ESP_BT_MODE_BLE));<span class="comment">//释放蓝牙所需空间</span></span><br><span class="line"></span><br><span class="line">ret = esp_bt_controller_init(&amp;bt_cfg);<span class="comment">//初始化蓝牙控制器</span></span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line">	ESP_LOGE(TAG, <span class="string">&quot;%s enable controller failed: %s\n&quot;</span>, __func__, esp_err_to_name(ret));</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ret = esp_bt_controller_enable(ESP_BT_MODE_BLE);<span class="comment">//使能蓝牙控制器</span></span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line">	ESP_LOGE(TAG, <span class="string">&quot;%s enable controller failed: %s\n&quot;</span>, __func__, esp_err_to_name(ret));</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ret = esp_bluedroid_init();<span class="comment">//初始化蓝牙栈bluedroid stack</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">蓝牙栈bluedroid stack包括了BT和BLE使用的基本的define和API</span></span><br><span class="line"><span class="comment">初始化蓝牙栈以后并不能直接使用蓝牙功能，</span></span><br><span class="line"><span class="comment">还需要用FSM管理蓝牙连接情况</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line">	ESP_LOGE(TAG, <span class="string">&quot;%s init bluetooth failed: %s\n&quot;</span>, __func__, esp_err_to_name(ret));</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ret = esp_bluedroid_enable();<span class="comment">//使能蓝牙栈</span></span><br><span class="line"><span class="keyword">if</span> (ret) </span><br><span class="line">&#123;</span><br><span class="line">	ESP_LOGE(TAG, <span class="string">&quot;%s enable bluetooth failed: %s\n&quot;</span>, __func__, esp_err_to_name(ret));</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ESP_LOGI(TAG, <span class="string">&quot;%s init bluetooth finished\n&quot;</span>, __func__);</span><br><span class="line"><span class="comment">//建立蓝牙的FSM</span></span><br><span class="line"><span class="comment">//这里使用回调函数来控制每个状态下的响应，需要将其在GATT和GAP层的回调函数注册</span></span><br><span class="line">ret = esp_ble_gatts_register_callback(BLE_gatts_event_handler);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line">	ESP_LOGE(TAG, <span class="string">&quot;gatts register error, error code = %x&quot;</span>, ret);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ret = esp_ble_gap_register_callback(BLE_gap_event_handler);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line">	ESP_LOGE(TAG, <span class="string">&quot;gap register error, error code = %x&quot;</span>, ret);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*BLE_gatts_event_handler和BLE_gap_event_handler处理蓝牙栈可能发生的所有情况，达到FSM的效果*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面创建了两个BLE GATT profile，相当于两个独立的应用程序</span></span><br><span class="line">ret = esp_ble_gatts_app_register(GATT_APP_A_ID);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line">	ESP_LOGE(TAG, <span class="string">&quot;gatts app register error, error code = %x&quot;</span>, ret);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ret = esp_ble_gatts_app_register(GATT_APP_B_ID);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line">	ESP_LOGE(TAG, <span class="string">&quot;gatts app register error, error code = %x&quot;</span>, ret);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有限状态机FSM（finite state machine），或者说状态机SM（state machine）是一种特殊的控制算法，能够根据<strong>控制信号</strong>按照<strong>预先设定的状态</strong>进行状态转移</p>
<p>若输出只和状态有关而与输入无关，则称为Moore状态机；若输出不仅和状态有关而且和输入有关系，则称为Mealy状态机</p>
<p>控制蓝牙的状态机一般为Moore状态机，随蓝牙所处的状态进行不同的操作（代码中通过switch语句进行控制）</p>
<p>Server的profile利用一个结构体来定义，结构体成员取决于在这个profile中执行的service和characteristic，如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gatts_profile_inst</span> &#123;</span></span><br><span class="line">    <span class="keyword">esp_gatts_cb_t</span> gatts_cb;<span class="comment">//GATT回调函数</span></span><br><span class="line">    <span class="keyword">uint16_t</span> gatts_if;<span class="comment">//GATT接口</span></span><br><span class="line">    <span class="keyword">uint16_t</span> app_id;<span class="comment">//应用的ID</span></span><br><span class="line">    <span class="keyword">uint16_t</span> conn_id;<span class="comment">//连接的ID</span></span><br><span class="line">    <span class="keyword">uint16_t</span> service_handle;<span class="comment">//Service句柄</span></span><br><span class="line">    <span class="keyword">esp_gatt_srvc_id_t</span> service_id;<span class="comment">//Service ID</span></span><br><span class="line">    <span class="keyword">uint16_t</span> char_handle;<span class="comment">//Characteristic句柄</span></span><br><span class="line">    <span class="keyword">esp_bt_uuid_t</span> char_uuid;<span class="comment">//Characteristic的UUID</span></span><br><span class="line">    <span class="keyword">esp_gatt_perm_t</span> perm;<span class="comment">//属性Attribute 授权</span></span><br><span class="line">    <span class="keyword">esp_gatt_char_prop_t</span> property;<span class="comment">//Characteristic的优先级</span></span><br><span class="line">    <span class="keyword">uint16_t</span> descr_handle;<span class="comment">//Client的Characteristic配置句柄</span></span><br><span class="line">    <span class="keyword">esp_bt_uuid_t</span> descr_uuid;<span class="comment">//Client的Characteristic UUID</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以将这个结构体进一步组合为结构体数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gatts_profile_inst</span> <span class="title">gl_profile_tab</span>[<span class="title">PROFILE_NUM</span>] =</span> &#123;</span><br><span class="line">    [PROFILE_A_APP_ID] = &#123;</span><br><span class="line">        .gatts_cb = gatts_profile_a_event_handler,</span><br><span class="line">        .gatts_if = ESP_GATT_IF_NONE,</span><br><span class="line">    [PROFILE_B_APP_ID] = &#123;</span><br><span class="line">        .gatts_cb = gatts_profile_b_event_handler,</span><br><span class="line">        .gatts_if = ESP_GATT_IF_NONE,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样使用类似<code>gl_profile_tab[i].gatts_if</code>的语句就可以访问结构体的成员，i用于指示第（i+1）个profile</p>
<p>使用上面的结构体数组来定义每个profile对应的GATT回调函数（gatts_profile_a_event_handler()、gatts_profile_b_event_handler()），就使得每个不同的profile使用不同的接口；初始化时，将gatts_if = ESP_GATT_IF_NONE，在之后通过各自的处理函数将profile连接到接口</p>
<p>最后使用esp_ble_gatts_app_register()这个API将应用的ID注册到GATT</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ret = esp_ble_gatts_app_register(GATT_APP_A_ID);<span class="comment">//run GATT app A register</span></span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line">	ESP_LOGE(TAG, <span class="string">&quot;gatts app register error, error code = %x&quot;</span>, ret);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ret = esp_ble_gatts_app_register(GATT_APP_B_ID);<span class="comment">//run GATT app B register</span></span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line">	ESP_LOGE(TAG, <span class="string">&quot;gatts app register error, error code = %x&quot;</span>, ret);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="GAP设置"><a href="#GAP设置" class="headerlink" title="GAP设置"></a>GAP设置</h4><p>使用esp_ble_adv_data_t结构体来配置GAP广播情况，并使用esp_ble_gap_config_adv_data()函数进行广播</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> set_scan_rsp;<span class="comment">//是否作为扫描的回应信号广播</span></span><br><span class="line">    <span class="keyword">bool</span> include_name;<span class="comment">//是否包括设备名</span></span><br><span class="line">    <span class="keyword">bool</span> include_txpower;<span class="comment">//是否包括信号的发射功率</span></span><br><span class="line">    <span class="keyword">int</span> min_interval;<span class="comment">//广播数据显示slave设备的连接最小时间间隔</span></span><br><span class="line">    <span class="keyword">int</span> max_interval;<span class="comment">//广播数据显示slave设备的连接最大时间间隔</span></span><br><span class="line">    <span class="keyword">int</span> appearance;<span class="comment">//设备外观（？）</span></span><br><span class="line">    <span class="keyword">uint16_t</span> manufacturer_len;<span class="comment">//附加数据长度</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *p_manufacturer_data;<span class="comment">//附加数据指针</span></span><br><span class="line">    <span class="keyword">uint16_t</span> service_data_len;<span class="comment">//Service数据长度</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *p_service_data;<span class="comment">//Service数据指针</span></span><br><span class="line">    <span class="keyword">uint16_t</span> service_uuid_len;<span class="comment">//Servic UUID长度</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *p_service_uuid;<span class="comment">//Servic UUID指针</span></span><br><span class="line">    <span class="keyword">uint8_t</span> flag;<span class="comment">//广播的发现模式，可选BLE_ADV_DATA_FLAG枚举值</span></span><br><span class="line">&#125; <span class="keyword">esp_ble_adv_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置示例</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">esp_ble_adv_data_t</span> adv_data = &#123;</span><br><span class="line">    .set_scan_rsp = <span class="literal">false</span>,</span><br><span class="line">    .include_name = <span class="literal">true</span>,</span><br><span class="line">    .include_txpower = <span class="literal">false</span>,</span><br><span class="line">    .min_interval = <span class="number">0x0006</span>, <span class="comment">//slave connection min interval, Time = min_interval * 1.25 msec=7.5ms</span></span><br><span class="line">    .max_interval = <span class="number">0x0010</span>, <span class="comment">//slave connection max interval, Time = max_interval * 1.25 msec=20ms</span></span><br><span class="line">    .appearance = <span class="number">0x00</span>,</span><br><span class="line">    .manufacturer_len = <span class="number">0</span>, <span class="comment">//TEST_MANUFACTURER_DATA_LEN</span></span><br><span class="line">    .p_manufacturer_data = <span class="literal">NULL</span>, <span class="comment">//&amp;test_manufacturer[0]</span></span><br><span class="line">    .service_data_len = <span class="number">0</span>,</span><br><span class="line">    .p_service_data = <span class="literal">NULL</span>,</span><br><span class="line">    .service_uuid_len = <span class="keyword">sizeof</span>(adv_service_uuid128),</span><br><span class="line">    .p_service_uuid = adv_service_uuid128,</span><br><span class="line">    .flag = (ESP_BLE_ADV_FLAG_GEN_DISC | ESP_BLE_ADV_FLAG_BREDR_NOT_SPT),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一个广播的有效数据是31字节，如果超过会导致超出部分被截掉</p>
<p>使用esp_ble_gap_config_adv_data_raw()和esp_ble_gap_config_scan_rsp_data_raw()函数可以广播自定义的空数据</p>
<p>广播数据设置完毕后，会自动进入ESP_GAP_BLE_ADV_DATA_SET_COMPLETE_EVT()或ESP_GAP_BLE_ADV_DATA_RAW_SET_COMPLETE_EVT状态，此时可以在gap_event_handler()中设置FSM控制程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BLE_gap_event_handler</span><span class="params">(<span class="keyword">esp_gap_ble_cb_event_t</span> event, <span class="keyword">esp_ble_gap_cb_param_t</span>* param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SET_RAW_ADV_DATA</span></span><br><span class="line">    <span class="keyword">case</span> ESP_GAP_BLE_ADV_DATA_RAW_SET_COMPLETE_EVT:</span><br><span class="line">        adv_config_done &amp;= (~adv_config_flag);</span><br><span class="line">        <span class="keyword">if</span> (adv_config_done == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            esp_ble_gap_start_advertising(&amp;adv_params);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ESP_GAP_BLE_SCAN_RSP_DATA_RAW_SET_COMPLETE_EVT:</span><br><span class="line">        adv_config_done &amp;= (~scan_rsp_config_flag);</span><br><span class="line">        <span class="keyword">if</span> (adv_config_done == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            esp_ble_gap_start_advertising(&amp;adv_params);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">case</span> ESP_GAP_BLE_ADV_DATA_SET_COMPLETE_EVT:</span><br><span class="line">        adv_config_done &amp;= (~adv_config_flag);</span><br><span class="line">        <span class="keyword">if</span> (adv_config_done == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            esp_ble_gap_start_advertising(&amp;adv_params);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ESP_GAP_BLE_SCAN_RSP_DATA_SET_COMPLETE_EVT:</span><br><span class="line">        adv_config_done &amp;= (~scan_rsp_config_flag);</span><br><span class="line">        <span class="keyword">if</span> (adv_config_done == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            esp_ble_gap_start_advertising(&amp;adv_params);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">case</span> ESP_GAP_BLE_ADV_START_COMPLETE_EVT:</span><br><span class="line">        <span class="comment">//advertising start complete event to indicate advertising start successfully or failed</span></span><br><span class="line">        <span class="keyword">if</span> (param-&gt;adv_start_cmpl.status != ESP_BT_STATUS_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGE(TAG, <span class="string">&quot;Advertising start failed\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ESP_GAP_BLE_ADV_STOP_COMPLETE_EVT:</span><br><span class="line">        <span class="keyword">if</span> (param-&gt;adv_stop_cmpl.status != ESP_BT_STATUS_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGE(TAG, <span class="string">&quot;Advertising stop failed\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGI(TAG, <span class="string">&quot;Stop adv successfully\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ESP_GAP_BLE_UPDATE_CONN_PARAMS_EVT:</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;update connection params status = %d, min_int = %d, max_int = %d,conn_int = %d,latency = %d, timeout = %d&quot;</span>,</span><br><span class="line">            param-&gt;update_conn_params.status,</span><br><span class="line">            param-&gt;update_conn_params.min_int,</span><br><span class="line">            param-&gt;update_conn_params.max_int,</span><br><span class="line">            param-&gt;update_conn_params.conn_int,</span><br><span class="line">            param-&gt;update_conn_params.latency,</span><br><span class="line">            param-&gt;update_conn_params.timeout);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要使用了esp_ble_gap_start_advertising()函数，GATT Server就会开始广播，在此之前还需要用esp_ble_adv_params_t结构体配置相关的参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//广播参数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> adv_int_min;</span><br><span class="line">	<span class="comment">//非定向和循环定向广播的最小时间间隔</span></span><br><span class="line">    <span class="comment">//间隔设置在0x0020到0x4000，默认0x0800（1.28s），实际时间=N * 0.625 ms，时间范围在20ms到10.24s</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint16_t</span> adv_int_max;</span><br><span class="line">    <span class="comment">//非定向和循环定向广播的最大时间间隔</span></span><br><span class="line">    <span class="comment">//间隔设置在0x0020到0x4000，默认0x0800（1.28s），实际时间=N * 0.625 ms，时间范围在20ms到10.24s</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">esp_ble_adv_type_t</span> adv_type;<span class="comment">//广播类型</span></span><br><span class="line">    <span class="keyword">esp_ble_addr_type_t</span> own_addr_type;<span class="comment">//拥有者的蓝牙设备地址类型</span></span><br><span class="line">    <span class="keyword">esp_bd_addr_t</span> peer_addr;<span class="comment">//附近的蓝牙设备地址</span></span><br><span class="line">    <span class="keyword">esp_ble_addr_type_t</span> peer_addr_type;<span class="comment">//附近的蓝牙设备地址类型</span></span><br><span class="line">    <span class="keyword">esp_ble_adv_channel_t</span> channel_map;<span class="comment">//广播通道映射</span></span><br><span class="line">    <span class="keyword">esp_ble_adv_filter_t</span> adv_filter_policy;<span class="comment">//广播过滤器设置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">esp_ble_adv_params_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置示例</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">esp_ble_adv_params_t</span> adv_params = &#123;</span><br><span class="line">    .adv_int_min        = <span class="number">0x20</span>,<span class="comment">//最小时间间隔</span></span><br><span class="line">    .adv_int_max        = <span class="number">0x40</span>,<span class="comment">//最大时间间隔</span></span><br><span class="line">    .adv_type           = ADV_TYPE_IND,</span><br><span class="line">    .own_addr_type      = BLE_ADDR_TYPE_PUBLIC,<span class="comment">//公共地址</span></span><br><span class="line">    <span class="comment">//.peer_addr            =默认</span></span><br><span class="line">    <span class="comment">//.peer_addr_type       =默认</span></span><br><span class="line">    .channel_map        = ADV_CHNL_ALL,<span class="comment">//全通道</span></span><br><span class="line">    .adv_filter_policy = ADV_FILTER_ALLOW_SCAN_ANY_CON_ANY,<span class="comment">//扫描所有连接</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>设置完毕后，可以使用esp_ble_gap_start_advertising()进行广播</p>
<p>注意：<strong>esp_ble_gap_config_adv_data()使用esp_ble_adv_data_t结构体进行设置，配置的是广播出去的数据；而esp_ble_gap_start_advertising()使用esp_ble_adv_params_t结构体进行设置，配置的是该怎样广播</strong></p>
<h1 id="经典蓝牙的子集SPP"><a href="#经典蓝牙的子集SPP" class="headerlink" title="经典蓝牙的子集SPP"></a>经典蓝牙的子集SPP</h1><p>蓝牙串口协议Serial Port Profile简写为SPP，SPP就是一种能在蓝牙设备之间创建串口进行数据传输的协议，最终目的是在两个不同设备（通信的两端）上的应用之间保证一条完整的通信路径</p>
<p>SPP的协议栈示意图如下</p>
<p><img src="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A03%E3%80%90%E7%BB%8F%E5%85%B8%E8%93%9D%E7%89%99%E4%B8%8EBLE%E3%80%91/image-20210205162726034.png" alt="image-20210205162726034"></p>
<h3 id="连接流程"><a href="#连接流程" class="headerlink" title="连接流程"></a>连接流程</h3><ol>
<li>创建虚拟连接</li>
<li>接受虚拟串口连接</li>
<li>在本地SDP数据上注册服务</li>
</ol>
<h3 id="SPP协议与GATT协议的对比"><a href="#SPP协议与GATT协议的对比" class="headerlink" title="SPP协议与GATT协议的对比"></a>SPP协议与GATT协议的对比</h3><table>
<thead>
<tr>
<th>经典蓝牙BT-SPP</th>
<th>低功耗蓝牙BLE-GATT</th>
</tr>
</thead>
<tbody><tr>
<td>速率高</td>
<td>灵活多变、集成很多profile</td>
</tr>
<tr>
<td>兼容性好</td>
<td>高速率传输时兼容性难以保障</td>
</tr>
<tr>
<td>对IOS不友好</td>
<td>对IOS很友好</td>
</tr>
<tr>
<td>APP编程不方便</td>
<td>开发资源丰富、接口多</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32_IDF学习7【ESP32上的FreeRTOS】</title>
    <url>/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A07%E3%80%90ESP32%E4%B8%8A%E7%9A%84FreeRTOS%E3%80%91/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="Bootloader"><a href="#Bootloader" class="headerlink" title="Bootloader"></a>Bootloader</h1><p>ESP32的Bootloader（引导加载程序）主要执行以下任务：</p>
<span id="more"></span>

<ol>
<li>内部模块的基础初始化配置</li>
<li>根据<strong>分区表</strong>和<strong>ota_data</strong>（如果存在）选择需要引导的应用程序（app）分区</li>
<li>将应用程序映像加载到 RAM（IRAM和DRAM）中</li>
<li>完成以上工作后把控制权转交给应用程序</li>
</ol>
<p><strong>引导加载程序位于Flash的偏移地址0x1000处</strong></p>
<h2 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h2><p>每片ESP32的flash可以包含多个应用程序，以及多种不同类型的数据（例如校准数据、文件系统数据、参数存储器数据等），使用<strong>分区表</strong>对这些程序和数据进行规划</p>
<p>ESP32 在flash的<strong>默认偏移地址0x8000</strong>处烧写一张分区表</p>
<p>该分区表的长度为0xC00字节，<strong>最多可以保存95条分区表条目</strong>。分区表数据后还保存着该表的MD5校验和用于验证分区表的完整性。此外，如果芯片使能了安全启动功能，该分区表后还会保存签名信息</p>
<p>分区表中的每个条目都包括以下几个部分：Name（标签）、Type（app、data 等）、SubType 以及在flash中的偏移量（分区的加载地址）</p>
<p>烧写到ESP32中的分区表采用二进制格式，而不是CSV文件本身。ESP-IDF提供了gen_esp32part.py工具来配置、构建分区表</p>
<h2 id="默认分区表"><a href="#默认分区表" class="headerlink" title="默认分区表"></a>默认分区表</h2><p>menuconfig中自带了两套分区表，如果编写大程序会经常遇到空间不足的问题（特别是当你像我一样买了16MB超大FLASH的白金纪念典藏款ESP32-WROOM-32E，甚至还想外挂一个W25Q128（16MB）时会经常感觉默认分区表把FLASH都浪费了），但是很适合学习开发使用</p>
<ul>
<li>Single factory app, no OTA</li>
<li>Factory app, two OTA definitions</li>
</ul>
<p>两个选项，都将出厂应用程序烧录至flash的0x10000偏移地址处，但是一个没有OTA分区，一个有OTA分区</p>
<p>它们都在0x10000 (64KB)偏移地址处存放一个标记为 “factory” 的二进制应用程序，且Bootloader将默认加载这个应用程序</p>
<p>分区表中还定义了两个数据区域，分别用于存储NVS库专用分区和PHY初始化数据</p>
<p>带OTA分区的<code>Factory app, two OTA definitions</code>里还新增了otadata的数据分区，用于保存OTA升级所需的数据，Bootloader还会查询该分区的数据来 判断从哪个OTA应用程序分区加载程序，如果这个分区为空则会执行出厂程序</p>
<h2 id="自定义分区表"><a href="#自定义分区表" class="headerlink" title="自定义分区表"></a>自定义分区表</h2><p>在menuconfig里选择了“自定义分区表”选项后，输入该分区表的路径和完整文件名就可以使用自定义分区表了</p>
<p>分区表以CSV的格式书写，用“#”注释；offset字段可以为空，程序会自动计算并填充该分区的偏移地址，但size字段一定要填写好</p>
<p>说明如下（抄自官网文档）</p>
<ul>
<li><p>Name字段可以是任何有意义的名称，但不能超过 16 个字符（之后的内容将被截断）</p>
</li>
<li><p>Type 字段可以指定为app (0) 或data (1)，也可以直接使用数字0-254（或者十六进制 0x00-0xFE）；但<strong>0x00-0x3F不得使用</strong>（预留给 esp-idf 的核心功能）；bootloader将忽略 app (0) 和 data (1) 以外的其他分区类型</p>
</li>
<li><p>SubType 字段长度为8位，内容与具体Type有关。目前esp-idf仅仅规定了“app”和“data”两种子类型</p>
<ul>
<li>当 Type 定义为 <code>app</code> 时，SubType 字段可以指定为 factory (0)，ota_0 (0x10) … ota_15 (0x1F) 或者 test (0x20)</li>
<li>当 Type 定义为 <code>data</code> 时，SubType 字段可以指定为 ota (0)，phy (1)，nvs (2) 或者 nvs_keys (4)</li>
</ul>
<p>其中factory (0) 是Bootloader默认跳转到的app分区；ota(0)是OTA数据分区；nvs(2)是NVS专用的分区，最好分配至少0x3000字节的空间；nvs_keys(4)是密钥分区，用于NVS加密相关功能；phy(1)是用于存放PHY初始化数据的分区，默认配置下phy分区并不启用，会直接将phy初始化数据编译至应用程序中，使能CONFIG_ESP32_PHY_INIT_DATA_IN_PARTITION后才能使用该分区</p>
</li>
<li><p>分区若为指定偏移地址，则会紧跟着前一个分区之后开始。若此分区为首个分区，则将紧跟着分区表开始。app 分区的偏移地址必须要与 0x10000 (64K) 对齐，如果将偏移字段留空，<code>gen_esp32part.py</code> 工具会自动计算得到一个满足对齐要求的偏移地址。如果 app 分区的偏移地址没有与 0x10000 (64K) 对齐，则该工具会报错</p>
</li>
<li><p>Flags 分区当前仅支持 <code>encrypted</code> 标记。如果 Flags 字段设置为 <code>encrypted</code>，且已启用Flash Encryption（FLASH加密）功能，则该分区将会被加密</p>
</li>
</ul>
<p>通过改动示例分区表就能配置新的分区表</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Name,   Type, SubType, Offset,   Size, Flags</span></span><br><span class="line"><span class="comment"># 注意，如果你增大了引导加载程序的大小，请确保更新偏移量，避免和其它分区发生重叠</span></span><br><span class="line">nvs,      data, nvs,     <span class="number">0</span>x9000,   <span class="number">0</span>x4000 <span class="comment"># NVS分区</span></span><br><span class="line">otadata,  data, ota,     <span class="number">0</span>xd000,   <span class="number">0</span>x2000 <span class="comment"># OTA数据分区</span></span><br><span class="line">phy_init, data, phy,     <span class="number">0</span>xf000,   <span class="number">0</span>x1000 <span class="comment"># 初始化分区</span></span><br><span class="line">factory,  <span class="number">0</span>,    <span class="number">0</span>,       <span class="number">0</span>x10000,  <span class="number">1</span>M <span class="comment"># 工厂分区</span></span><br><span class="line"><span class="keyword">test</span>,     <span class="number">0</span>,    <span class="keyword">test</span>,    ,         <span class="number">512</span>K <span class="comment"># 保留分区</span></span><br><span class="line">ota_0,    <span class="number">0</span>,    ota_0,   ,         <span class="number">512</span>K <span class="comment"># 第一OTA分区，一般用于OTA烧录</span></span><br><span class="line">ota_1,    <span class="number">0</span>,    ota_1,   ,         <span class="number">512</span>K <span class="comment"># 第二OTA分区，一般用于OTA回滚或备份</span></span><br></pre></td></tr></table></figure>

<h2 id="出厂程序"><a href="#出厂程序" class="headerlink" title="出厂程序"></a>出厂程序</h2><p>出厂程序就是按下复位按钮后从串口喷涌而出的那一堆自检信息</p>
<p>自定义出厂程序还可以把自己想要的图标通过字符画的形式扔进去，开机的时候就会刷出来，比如可以刷个Ubuntu字符画假装移植了linux（误）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                         ./+o+-</span><br><span class="line">                 yyyyy- -yyyyyy+</span><br><span class="line">              ://+//////-yyyyyyo</span><br><span class="line">          .++ .:/++++++/-.+sss/`</span><br><span class="line">        .:++o:  /++++++++/:--:/-</span><br><span class="line">       o:+o+:++.`..```.-/oo+++++/</span><br><span class="line">      .:+o:+o/.          `+sssoo+/</span><br><span class="line"> .++/+:+oo+o:`             /sssooo.</span><br><span class="line">/+++//+:`oo+o               /::--:.</span><br><span class="line">\+/+o+++`o++o               ++////.</span><br><span class="line"> .++.o+++oo+:`             /dddhhh.</span><br><span class="line">      .+.o+oo:.          `oddhhhh+</span><br><span class="line">       \+.++o+o``-````.:ohdhhhhh+</span><br><span class="line">        `:o+++ `ohhhhhhhhyo++os:</span><br><span class="line">          .o:`.syhhhhhhh/.oo++o`</span><br><span class="line">              /osyyyyyyo++ooo+++/</span><br><span class="line">                  ````` +oo+++o\:</span><br><span class="line">                         `oo++.</span><br></pre></td></tr></table></figure>

<h2 id="恢复出厂设置"><a href="#恢复出厂设置" class="headerlink" title="恢复出厂设置"></a>恢复出厂设置</h2><p>通过设置CONFIG_BOOTLOADER_FACTORY_RESET来使能GPIO触发恢复出厂设置</p>
<p>恢复出厂设置时将进行以下操作：</p>
<ol>
<li>清除所有数据分区</li>
<li>从工厂分区启动</li>
</ol>
<h2 id="自定义Bootloader"><a href="#自定义Bootloader" class="headerlink" title="自定义Bootloader"></a>自定义Bootloader</h2><p>用户可以自定义当前的Bootloader</p>
<ol>
<li>复制<code>/esp-idf/components/bootloader</code>文件夹到项目目录</li>
<li>编辑<code>/your_project/components/bootloader/subproject/ain/bootloader_main.c</code>文件</li>
</ol>
<p>注意：<strong>在引导加载程序的代码中，用户不可以使用驱动和其他组件提供的函数</strong>，如果确实需要，应该将该功能的实现部分放在bootloader目录中（会增加引导程序的大小）</p>
<p>目前，引导程序被限制在了分区表之前的区域（分区表位于0x8000地址处）</p>
<h1 id="应用级程序追踪"><a href="#应用级程序追踪" class="headerlink" title="应用级程序追踪"></a>应用级程序追踪</h1><p>ESP-IDF提供实用的dubug功能，能够通过menuconfig开启，并通过调用库函数进行使用，可以通过JTAG在ESP32和主机之间传输debug logs，可用于：</p>
<ul>
<li>跟踪特定应用程序</li>
<li>记录日志到主机</li>
<li>基于SEGGEr SystemView进行系统行为分析</li>
</ul>
<p>在程序中<code>#incldue &quot;esp_app_trace.h&quot;</code>即可使用相关库函数</p>
<p>当前这个debug功能已经比较完善，可以用来做调试，但是因为它通过库函数进行数据发送，可能会对正常程序执行造成干扰，使用位置需要注意</p>
<h1 id="FreeRTOS简介"><a href="#FreeRTOS简介" class="headerlink" title="FreeRTOS简介"></a>FreeRTOS简介</h1><p><em>详细内容可以参考FreeRTOS相关教程</em></p>
<p><strong>以下内容应当由接触过RTOS的同学学习，如果你还没碰过RTOS，还像我这样遇上了老师发的离谱作业，千万不要慌，先去按照下面这些标题百度/google/bing一通，弄得差不多再读一读下面的API讲解应该就能糊弄过去了</strong></p>
<p>顾名思义，freeRTOS是free的RTOS，具有以下特点：</p>
<ul>
<li>FREE！FreeRTOS使用LGPL协议，开源且可用于商业，很自由（虽然FSF那帮人可能觉得LGPL不够自由）</li>
<li>小内核、模块化、扩展性强</li>
<li>高效、便于使用</li>
<li><strong>用户无需关心时间信息</strong>，内核中的相关模块会负责处理计时任务和线程调度</li>
</ul>
<h2 id="内核组成"><a href="#内核组成" class="headerlink" title="内核组成"></a>内核组成</h2><p>FreeRTOS是一个可裁剪、可剥夺型（也可根据用户需要裁剪为不可剥夺型）的多任务内核，<strong>不设置任务数限制</strong>。</p>
<p>内涵和基于硬件适配层实现跨平台移植</p>
<h3 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h3><p>这里参考的FreeRTOS源码是在<a href="https://freertos.org/">官网</a>上下载到的/freertos/FreeRTOSv10.4.1/FreeRTOS/Source目录下的部分</p>
<p>FreeRTOS-Plus包含kernal之外的系统常用功能组件</p>
<p>Source目录下才是kernal相关源码</p>
<ul>
<li>list.c任务链表模块</li>
<li>queue.c消息队列模块</li>
<li>tasks.c任务配置模块</li>
<li>timers.c系统定时器模块</li>
<li>event_groups.c事件集模块</li>
<li>include目录是各种头文件</li>
</ul>
<h3 id="任务管理（线程管理、线程调度）"><a href="#任务管理（线程管理、线程调度）" class="headerlink" title="任务管理（线程管理、线程调度）"></a>任务管理（线程管理、线程调度）</h3><h4 id="优先级抢占式调度算法"><a href="#优先级抢占式调度算法" class="headerlink" title="优先级抢占式调度算法"></a>优先级抢占式调度算法</h4><p>最低优先级是0，<strong>优先级数字越大，当前任务越优先</strong></p>
<p><strong>不同任务可以共用同一个优先级</strong></p>
<h3 id="时间管理（时钟节拍）"><a href="#时间管理（时钟节拍）" class="headerlink" title="时间管理（时钟节拍）"></a>时间管理（时钟节拍）</h3><p>FreeRTOS使用系统节拍（systick）确定其运行时钟，这个系统节拍由硬件定时器中断引起</p>
<p>使用<strong>configCPU_CLOCK_HZ</strong>设置当前硬件平台CPU的系统时钟，单位Hz</p>
<p>使用<strong>configTICK_RATE_HZ</strong>设置FreeRTOS的时间片频率（1秒钟可以切换多少次任务），单位Hz</p>
<h4 id="ESP32的硬件定时器"><a href="#ESP32的硬件定时器" class="headerlink" title="ESP32的硬件定时器"></a>ESP32的硬件定时器</h4><p>ESP32提供两组硬件定时器，每组包含两个64位通用定时器，共<strong>4个通用定时器</strong>，分别标记为TIMER0-3。</p>
<p>所有定时器均包括16位预分频器和64位自动重载向上/向下计数器</p>
<h5 id="定时器初始化"><a href="#定时器初始化" class="headerlink" title="定时器初始化"></a>定时器初始化</h5><p>使用timer_config_t结构体配置定时器参数，然后将这个结构体作为参数传递给timer_init()函数来进行定时器初始化</p>
<p>可设置的参数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_config_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">timer_alarm_t</span> alarm_en;<span class="comment">//是否使能报警</span></span><br><span class="line">	<span class="keyword">timer_start_t</span> counter_en;<span class="comment">//是否是能计数器</span></span><br><span class="line">    <span class="keyword">timer_intr_mode_t</span> intr_type;<span class="comment">//选择定时器警报上触发的中断类型</span></span><br><span class="line">    <span class="keyword">timer_count_dir_t</span> counter_dir;<span class="comment">//选择向上/向下计数</span></span><br><span class="line">    <span class="keyword">timer_autoreload_t</span> auto_reload;<span class="comment">//设置计数器是否在定时器警报上使用auto_reload自动重载首个计数值，或者继续递增/递减</span></span><br><span class="line">    <span class="keyword">uint32_t</span> divider;<span class="comment">//计数器分频器，可设置为2-65536，用作输入的80MHz APB_CLK时钟的分频系数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用timer_get_copnfig()获取定时器设置的当前值</p>
<h5 id="定时器控制"><a href="#定时器控制" class="headerlink" title="定时器控制"></a>定时器控制</h5><ol>
<li>开启定时器</li>
</ol>
<p>设置timer_config_t::counter_en位true后调用timer_init()初始化即可开启定时器</p>
<p>或者也可以直接调用timer_start()来开启定时器</p>
<p>调用timer_pause()随时暂停定时器</p>
<ol start="2">
<li>设置计数值</li>
</ol>
<p>可以通过调用timer_set_counter_value()来指定定时器的首个计数值</p>
<p>使用timer_get_counter_value()或timer_get_counter_time_sec()检查定时器的当前值</p>
<ol start="3">
<li>设置警报</li>
</ol>
<p>先调用函数timer_set_alarm_value()设置警报值，再调用timer_set_alarm()使能警报，或在初始化阶段通过设置初始化结构体来设置警报值并开启警报</p>
<p><strong>当警报使能且定时器到达警报值后，可以触发中断或重新加载</strong></p>
<p>如果auto_reload已使能，定时器的计数器将重新加载，从之前设置好的值重新计数，使用timer_set_counter_value()预先设置该值</p>
<p>如果已设置警报值且定时器已经超过该值，则将立即触发警报</p>
<p><strong>警报一旦触发，将自动关闭，需要重新使能以再次触发</strong></p>
<p>使用timer_get_alarm_value()来获取特定的警报值</p>
<p>调用函数timer_isr_register()来为特定定时器组和定时器注册中断服务程序</p>
<p>使用timer_group_intr_enable()来使能定时器组的中断程序，使用timer_enable_intr()使能某定时器的中断程序；使用timer_group_intr_disable()和timer_disable_intr()关闭对应的中断程序</p>
<p>在中断服务程序中处理中断时，需要明确地清除中断状态位，通过以下设置来清除某定时器的中断状态位</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIMERGN.int_clr_timers.tM = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TIMERGN中的N代表定时器组别编号，可设置0或1</span></span><br><span class="line"><span class="comment">//tM中的M代表定时器编号，可设置为0或1</span></span><br><span class="line"></span><br><span class="line">TIMERG0.int_clr_timers.t1 = <span class="number">1</span>;<span class="comment">//清除定时器组别0中定时器1的中断状态位</span></span><br></pre></td></tr></table></figure>

<h4 id="ESP32中的FreeRTOS时钟"><a href="#ESP32中的FreeRTOS时钟" class="headerlink" title="ESP32中的FreeRTOS时钟"></a>ESP32中的FreeRTOS时钟</h4><p>ESP32中的FreeRTOS使用任意硬件定时器通过开启警报中断模式来实现系统时钟（systick）</p>
<p>定时器计数器到达预设警报值后，将触发中断，调用相关API来让RTOS的系统时钟+1</p>
<p>一般这个API由PRO_CPU执行</p>
<h3 id="内存管理（内存堆）"><a href="#内存管理（内存堆）" class="headerlink" title="内存管理（内存堆）"></a>内存管理（内存堆）</h3><p>FreeRTOS可以使用四种内存分配方案</p>
<ol>
<li>heap1.c</li>
</ol>
<p>分配简单，时间确定，实时性强</p>
<p>只分配内存不回收内存，容易造成资源浪费</p>
<ol start="2">
<li>heap2.c</li>
</ol>
<p>链表式内存块结构分配</p>
<p>动态分配、最佳匹配</p>
<p>容易造成内存碎片且时间不可控</p>
<ol start="3">
<li>heap3.c</li>
</ol>
<p>调用标准库函数分配内存</p>
<p>速度较慢且内存分配时间不确定</p>
<ol start="4">
<li>heap4.c</li>
</ol>
<p>按照物理地址对内存进行排序</p>
<p>使相邻的内存空间可以合并</p>
<p>容易造成内存碎片且合并效率低</p>
<h3 id="通信管理（消息队列、事件集、信号量、互斥量）"><a href="#通信管理（消息队列、事件集、信号量、互斥量）" class="headerlink" title="通信管理（消息队列、事件集、信号量、互斥量）"></a>通信管理（消息队列、事件集、信号量、互斥量）</h3><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>使用FIFO队列的数据结构处理消息的存储和传输</p>
<p>消息发出后被缓存到FIFO队尾，其他任务可以调用接收消息的API接收队首的消息，该消息被接收后，后面的消息会自动前进</p>
<h3 id="事件集"><a href="#事件集" class="headerlink" title="事件集"></a>事件集</h3><p>用于取代全局变量标志，更加安全（但<strong>更慢</strong>）</p>
<h1 id="ESP32上的FreeRTOS"><a href="#ESP32上的FreeRTOS" class="headerlink" title="ESP32上的FreeRTOS"></a>ESP32上的FreeRTOS</h1><p>【翻译自官网】<code>普通的FreeRTOS运行在单核上，不彳亍！我们的ESP32-FreeRTOS能运行在双核，彳亍！</code></p>
<p>众所周知，ESP32是物美价廉的双核SoC，CPU0和CPU1同时运行、共享内存。乐鑫修改了普通的FreeRTOS，让它能够支持SMP（symmetric multiprocessing对称多处理），所以ESP32的FreeRTOS变成了基于FreeRTOS v8.2.0的Xtensa架构移植版SMP RTOS</p>
<p><strong>下面对移植版的FreeRTOS简称为SMP RTOS</strong>，</p>
<p>【补充】对称多处理（SMP）架构是一种两个或多个CPU共享同一内存公共链路的计算机体系结构</p>
<p><em>他改变了FreeRTOS</em></p>
<h2 id="backport"><a href="#backport" class="headerlink" title="backport"></a>backport</h2><p>v9.0版本的FreeRTOS特性被部分移植到了基于v8.0版本的ESP32-SMP-RTOS中</p>
<p>任务删除机制使用v9.0版本的：使用vTaskDelete()后任务会被立刻删除；如果任务在此时正好被另一个核心运行，那么释放内存的步骤会被交给空闲线程（空闲任务）</p>
<p>也引入了TLSP（Thread Local Storage Pointers线程本地存储指针）机制，当任务删除时删除回调函数会被自动执行，这个函数用于释放被TLSP指向的内存区域</p>
<ul>
<li><p>TLSP是指向TCB存储区的指针，它可以让每个任务都有自己独立的一套数据结构指针系统；SMP RTOS也提供了通过删除回调函数和TLSP执行的任务删除机制：当任务删除函数被调用，任务转到空闲线程后触发这个回调函数，可以配置为自动删除任务的内存空间，但是<strong>不要在这个回调函数中加入阻塞的、延时的、临界区等相关代码！尽可能让回调函数短小来确保系统实时性</strong></p>
</li>
<li><p>回调函数的类型是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*TlsDeleteCallbackFunction_t)(<span class="keyword">int</span>,<span class="keyword">void</span>*)</span><br></pre></td></tr></table></figure>

<p>这里针对c语言基础不太好的老哥解释一下：这是一个函数指针，它指向一个“以int型变量和任意指针为参数”，“无返回值”的函数</p>
<p>第一个参数是关联的TLSP的序号，第二个参数是TLSP自身（它本身就是个指针）</p>
<p>如果一个删除回调函数设置为空，那么用户需要在TLSP被删除之前手动释放指向关联的TLSP指向部分的内存，否则就会造成TLSP指向的部分内存变成“无主内存”，导致内存溢出</p>
</li>
</ul>
<h2 id="双核任务"><a href="#双核任务" class="headerlink" title="双核任务"></a>双核任务</h2><p>使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BaseType_t <span class="title">xTaskCreatePinnedToCore</span><span class="params">(TaskFunction_t pvTaskCode,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> pcName,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">const</span> <span class="keyword">uint32_t</span> usStackDepth,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">void</span> *<span class="keyword">const</span> pvParameters,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   UBaseType_t uxPriority,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   TaskHandle_t *<span class="keyword">const</span> pvCreatedTask,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">const</span> BaseType_t xCoreID)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">TaskHandle_t <span class="title">xTaskCreateStaticPinnedToCore</span><span class="params">(TaskFunction_t pvTaskCode,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> pcName,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="keyword">const</span> <span class="keyword">uint32_t</span> ulStackDepth,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="keyword">void</span> *<span class="keyword">const</span> pvParameters,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           UBaseType_t uxPriority,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           StackType_t *<span class="keyword">const</span> pxStackBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           StaticTask_t *<span class="keyword">const</span> pxTaskBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="keyword">const</span> BaseType_t xCoreID)</span></span></span><br></pre></td></tr></table></figure>

<p>创建SMP任务</p>
<p>最后的xCoreID设置为0或1，分别表示单独在PRO_CPU或APP_CPU上运行任务，也可以设置tskNO_AFINITY来允许任务在两个核心上运行</p>
<p>SMP RTOS使用<strong>轮询调度算法</strong>来进行任务调度，然而当两个相同优先级的任务同时处于就绪态时会被轮询算法跳过。应当通过任务阻塞或设置宽优先级的方式避免这种情况</p>
<p>任务挂起仅会对独立的核心起效，另一个核心上运行的任务不会受到任务挂起的影响</p>
<p>传统FreeRTOS的xTaskCreate()和xTaskCreateStatic()函数被以内联函数的形式重定义为上述两个函数，并默认使用tskNO_AFFINITY作为xCoreID的参数</p>
<p>每个任务控制块（TCB Task Control Block）将xCoreID作为一个成员存储起来，因此每个核心都会调用调度器来选择一个任务来运行，<strong>调度器会根据xCoreID成员变量决定是否让被核心请求运行的任务在该核心上运行</strong>（人话：核心请求运行某个任务，调度器会查看这个任务的xCoreID成员变量，如果符合这个核心，就让任务运行，否则会将任务放到任务链表尾并让当前核心尝试申请下一个任务）</p>
<h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>传统的FreeRTOS通过vTaskSwitchContext()函数执行线程调度。这个函数会从就绪任务链表（由处于就绪态的任务组成）中选取最高优先级的任务来运行。但在SMP RTOS中，每个核心都会独立调用vTaskSwitchContext()来从两个核心共用的就绪任务链表中选取任务来执行。SMP RTOS与传统FreeRTOS关于任务调度的区别如下所示：</p>
<ul>
<li><p>轮询调度算法：一般的FreeRTOS会在每个任务之间执行轮询调度，不会遗漏任何任务（一般通过遍历链表的方法进行轮询）；而SMP RTOS可能会在轮询调度多个相同优先级的就绪态任务中跳过其中的一部分</p>
<p>传统FreeRTOS中，使用pxReadyTasksList这个链表结构体来管理就绪态任务链表，相同优先级的任务被挂到相同链表上，这些链表被按照优先级从高到低挂到pxReadyTasksList链表中，pxIndex指针会指向刚刚被调用过的TCB</p>
<p>图示如下：</p>
</li>
</ul>
<p><img src="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A07%E3%80%90ESP32%E4%B8%8A%E7%9A%84FreeRTOS%E3%80%91/.%5CESP32_IDF%E5%AD%A6%E4%B9%A0_ESP32%E4%B8%8A%E7%9A%84FreeRTOS%5Cfreertos-ready-task-list.png"></p>
<p>然而在SMP RTOS中，就绪链表被两个核心共享，因此pxReadyTasksList会包含固定在两个不同核心上的任务，共用一个核心调用调度器时会发生抢占资源的情况，这种情况下资源调度器会查询TCB的xCoreID成员变量来决定一个任务是否被允许在当前请求执行的CPU上运行。虽然每个TCB都有一个xCoreID成员变量，但每个优先级链表中只有一个pxIndex，因此<strong>调度器从某个核心被调用并遍历链表时，他会跳过被标记为另一个核心才能执行的任务</strong>，如果另一个核心在此之后请求调度器分配任务，则pxIndex会从头开始遍历链表，来自另一个核心的上一个调度器并不会在当前核心的当前调度器的考虑范围内；当一个核心正在执行任务时，另一个核心请求分配任务，会从当前pxIndex的位置向后进行遍历。这就导致了一个问题：</p>
<p><img src="/2021/11/19/ESP32-IDF%E5%AD%A6%E4%B9%A07%E3%80%90ESP32%E4%B8%8A%E7%9A%84FreeRTOS%E3%80%91/.%5CESP32_IDF%E5%AD%A6%E4%B9%A0_ESP32%E4%B8%8A%E7%9A%84FreeRTOS.assets%5Cfreertos-ready-task-list-smp-pxIndex.png" alt="ESP-IDF pxIndex Behavior"></p>
<p>如上图所示，蓝色和橙色标明了由哪个CPU执行这个任务，当任务A被PRO_CPU执行时，APP_CPU申请分配任务，调度器自动从1向后遍历，找到了任务C；之后任务A完成，PRO_CPU请求分配任务，调度器从2向后遍历找到了任务3——这就导致任务B被跳过了！</p>
<p>解决的方法是<strong>确保每个任务都会进入一段时间的阻塞态来让他们从就绪任务链表中移除，或是让每个任务分配不同的优先级</strong></p>
<h2 id="中断同步"><a href="#中断同步" class="headerlink" title="中断同步"></a>中断同步</h2><p>CPU0和CPU1的中断不同步</p>
<p>不要想当然地用任务延迟函数来进行两个核心之间的任务同步，如果<strong>需要任务同步可以使用信号量</strong>来进行</p>
<ul>
<li>调度器阻塞：一般的FreeRTOS中，使用vTaskSuspendAll()来挂起调度器，这会阻止任务调度，但是中断服务函数ISR还是会运行；在SMP RTOS中，vTaskSuspendAll()只会阻止一个CPU的任务调度，另一个CPU还是会运行，这个机制很可能会引起数据阻塞、任务不同步等情况，所以最好不要使用vTaskSuspendAll()而是换用互斥量来保护临界区</li>
<li>SMP RTOS中，两个核心在相同的系统时钟下可能并没有运行在相同状态——两个核心的调度器、时钟控制等等都是独立的，<strong>时钟中断也是异步的</strong>；传统FreeRTOS中时钟中断会触发一个xTaskIncrementTick()的函数，使得系统时钟计数器+1，创造出了系统节拍，通过vTaskDelay()可以通过系统节拍进行延时等任务；但在SMP RTOS中使用PRO_CPU处理来自硬件定时器的中断，并创造出系统节拍（换句话说<strong>PRO_CPU是SMP RTOS的心脏</strong>），因为各种软硬件原因，中断并不会同时到达两个核心，因此两个核心任务很可能产生异步行为，<strong>延时函数绝对不应当被作为一种同步线程（任务）的方法</strong></li>
</ul>
<h2 id="临界区与互斥量"><a href="#临界区与互斥量" class="headerlink" title="临界区与互斥量"></a>临界区与互斥量</h2><p>SMP RTOS会使用互斥量访问临界区，流程如下</p>
<ol>
<li>某任务获取临界区互斥量</li>
<li>关闭线程调度器</li>
<li>关闭当前核心中断</li>
<li>完成任务</li>
<li>开启当前核心中断</li>
<li>开启线程调度器</li>
<li>释放互斥量</li>
<li>其他任务可以访问临界区</li>
</ol>
<p>在此期间如果另外核心的任务需要访问该资源，需要获取相同的互斥量，但它会被挂起直到当前持有互斥量的任务完成</p>
<p>详细内容可以参考官网</p>
<h2 id="硬件浮点运算的限制"><a href="#硬件浮点运算的限制" class="headerlink" title="硬件浮点运算的限制"></a>硬件浮点运算的限制</h2><p>ESP32支持单精度浮点运算硬件加速。但是使用硬件加速会受到一些SMP RTOS的行为限制。使用浮点数会被自动固定在单一CPU上运行，且浮点数不能在中断服务例程中使用</p>
<p>ESP32不支持双精度浮点数的硬件加速，因此双精度浮点数的运算时间可能比单精度的运算时间慢很多！</p>
<h2 id="可视化编辑"><a href="#可视化编辑" class="headerlink" title="可视化编辑"></a>可视化编辑</h2><p>可使用ESP-IDF的menuconfig可视化地配置SMP RTOS相关参数</p>
<h2 id="官方库中的事件处理函数"><a href="#官方库中的事件处理函数" class="headerlink" title="官方库中的事件处理函数"></a>官方库中的事件处理函数</h2><p>wifi、以太网、IP、蓝牙这些组件都使用事件event和状态机FSM让应用程序处理状态变化</p>
<p>esp_event库文件用于取代传统的事件循环，让ESP-IDF的事件处理更加方便。所有可能能事件类型和事件数据结构都需要在system_event_id_t枚举和system_event_info_t联合中定义；而在的事件循环</p>
<p>使用esp_event_loop_init()来处理事件循环，应用程序通常需要设置一个事件处理函数</p>
<p>传统的事件处理函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">event_handler</span><span class="params">(<span class="keyword">void</span> *ctx, <span class="keyword">system_event_t</span> *event)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>需要向esp_event_loop_init()传入一个专门的上下文指针，当使用wifi、以太网、IP协议栈时往往会产生事件，这些事件都会被保存在事件队列中等待收取，每个处理函数都会获取一个指向事件结构体的指针，这个指针用于描述现在队首的事件，这个事件被用联合标注：event_id、event_info，通常应用程序使用switch结构体与状态机来处理不同种类的事件</p>
<p>所以在wifi、蓝牙、IP协议栈相关代码中经常会看到大段的switch语句</p>
<p><strong>当需要将事件传送到其他任务中时，应用程序需要将全部结构体都复制下来并进行传输</strong></p>
<p>特别地，蓝牙通常使用回调函数来进行事件处理，这些回调函数可以用来收取、发送、处理特定的蓝牙协议栈消息；通常也配合各种结构体来使用</p>
<h1 id="ESP32移植FreeRTOS的API简介"><a href="#ESP32移植FreeRTOS的API简介" class="headerlink" title="ESP32移植FreeRTOS的API简介"></a>ESP32移植FreeRTOS的API简介</h1><p>这里以示例程序+API简介的方式介绍ESP32上的FreeRTOS特性，我对FreeRTOS也处在学习阶段（从RTThread和GNU/Linux入手的RTOS），可能会存在不少漏洞，见谅TAT</p>
<h2 id="系统控制"><a href="#系统控制" class="headerlink" title="系统控制"></a>系统控制</h2><p>FreeRTOS以任务为程序的最小执行单元，相当于RTT里的线程，拥有自己的上下文。使用信号量、事件集、队列进行线程间同步与通信</p>
<p>下面是一些控制系统常用的宏定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">configUSE_PREEMPTION<span class="comment">//选择1为抢占式调度器，0则是协作式调度器</span></span><br><span class="line">configCPU_CLOCK_HZ<span class="comment">//MCU内核的工作频率，单位Hz；对不同的移植代码也可能不使用这个参数</span></span><br><span class="line">configTICK_RATE_HZ<span class="comment">//FreeRTOS时钟心跳，也就是FreeRTOS用到的定时中断的产生频率</span></span><br><span class="line">configMAX_PRIORITIES<span class="comment">//程序中可以使用的最大优先级</span></span><br><span class="line">configMINIMAL_STACK_SIZE<span class="comment">//任务堆栈的最小大小</span></span><br><span class="line">configTOTAL_HEAP_SIZE<span class="comment">//堆空间大小；只有当程序中采用FreeRTOS提供的内存分配算法时才会用到</span></span><br><span class="line">configMAX_TASK_NAME_LEN<span class="comment">//任务名称最大的长度，包括最后的&#x27;\0&#x27;结束字节，单位字节</span></span><br><span class="line">    </span><br><span class="line">configUSE_COUNTING_SEMAPHORES<span class="comment">//是否使用信号量</span></span><br><span class="line">configUSE_RECURSIVE_MUTEXES<span class="comment">//是否使用互斥量递归持有</span></span><br><span class="line">configUSE_MUTEXES<span class="comment">//是否使用互斥量</span></span><br><span class="line">configUSE_TIMERS<span class="comment">//是否使用软件定时器</span></span><br><span class="line"></span><br><span class="line">configTIMER_TASK_PRIORITY<span class="comment">//设置软件定时器任务的优先级</span></span><br><span class="line">configTIMER_QUEUE_LENGTH<span class="comment">//设置软件定时器任务中用到的命令队列的长度</span></span><br><span class="line">configTIMER_TASK_STACK_DEPTH<span class="comment">//设置软件定时器任务需要的任务堆栈大小</span></span><br></pre></td></tr></table></figure>

<h2 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个在单核心运行的任务</span></span><br><span class="line"><span class="function">BaseType_t <span class="title">xTaskCreatePinnedToCore</span><span class="params">(TaskFunction_t pvTaskCode,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> pcName,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">const</span> <span class="keyword">uint32_t</span> usStackDepth,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">void</span> *<span class="keyword">const</span> pvParameters,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   UBaseType_t uxPriority,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   TaskHandle_t *<span class="keyword">const</span> pvCreatedTask,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">const</span> BaseType_t xCoreID)</span><span class="comment">//固定执行该任务的核心，不需要则填tskNO_AFFINITY</span></span></span><br><span class="line"><span class="function"><span class="comment">//用于一般地创建任务，这个API被内联到了双核心交替运行任务的API上</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BaseType_t <span class="title">xTaskCreate</span><span class="params">(TaskFunction_t pvTaskCode,<span class="comment">//任务入口函数指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> pcName,<span class="comment">//任务名</span></span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">const</span> <span class="keyword">uint32_t</span> usStackDepth,<span class="comment">//任务堆栈大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">void</span> *<span class="keyword">const</span> pvParameters,<span class="comment">//任务创建时传入的参数，如果任务入口函数没有参数则填NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">                              UBaseType_t uxPriority,<span class="comment">//任务优先级，数字越大优先级越高</span></span></span></span><br><span class="line"><span class="params"><span class="function">                              TaskHandle_t *<span class="keyword">const</span> pvCreatedTask)</span><span class="comment">//任务回传句柄，如果没有任务回传值则设置为NULL</span></span></span><br></pre></td></tr></table></figure>

<p>除了这两个API用于创建动态任务外，还可以使用以下API创建静态任务</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">TaskHandle_t <span class="title">xTaskCreateStaticPinnedToCore</span><span class="params">(TaskFunction_t pvTaskCode, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> pcName, <span class="keyword">const</span> <span class="keyword">uint32_t</span> ulStackDepth, <span class="keyword">void</span> *<span class="keyword">const</span> pvParameters, UBaseType_t uxPriority, StackType_t *<span class="keyword">const</span> pxStackBuffer, StaticTask_t *<span class="keyword">const</span> pxTaskBuffer, <span class="keyword">const</span> BaseType_t xCoreID)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> TaskHandle_t <span class="title">xTaskCreateStatic</span><span class="params">(TaskFunction_t pvTaskCode, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> pcName, <span class="keyword">const</span> <span class="keyword">uint32_t</span> ulStackDepth, <span class="keyword">void</span> *<span class="keyword">const</span> pvParameters, UBaseType_t uxPriority, StackType_t *<span class="keyword">const</span> pxStackBuffer, StaticTask_t *<span class="keyword">const</span> pxTaskBuffer)</span></span></span><br></pre></td></tr></table></figure>

<p>下面是创建任务的例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task</span><span class="params">(<span class="keyword">void</span>* pvPar)</span><span class="comment">//这个任务传入了参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m %s\r\n&quot;</span>,(<span class="keyword">char</span> *)pvPar);<span class="comment">//传入的参数在这里调用</span></span><br><span class="line">        </span><br><span class="line">		vTaskDelay(<span class="number">1000</span>/portTICK_PERIOD_MS);<span class="comment">//将任务转入阻塞态一段时间来达到延时效果</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vTaskDelay(pdMS_TO_TICKS(<span class="number">100</span>));<span class="comment">//等待系统初始化</span></span><br><span class="line"></span><br><span class="line">    xTaskCreatePinnedToCore(task,<span class="comment">//任务入口函数名作为函数指针调用</span></span><br><span class="line">    		               <span class="string">&quot;task1&quot;</span>,<span class="comment">//任务名</span></span><br><span class="line">			                <span class="number">2048</span>,<span class="comment">//任务栈</span></span><br><span class="line">			               <span class="string">&quot;task1&quot;</span>,<span class="comment">//传给任务函数的参数</span></span><br><span class="line">			                <span class="number">2</span>,<span class="comment">//任务优先级</span></span><br><span class="line">			               <span class="literal">NULL</span>,<span class="comment">//任务回传句柄</span></span><br><span class="line">			               tskNO_AFFINITY);<span class="comment">//这个任务将不会固定在某个核心上执行</span></span><br><span class="line">    xTaskCreate(task,<span class="string">&quot;task2&quot;</span>,<span class="number">2048</span>,<span class="string">&quot;task2&quot;</span>,<span class="number">2</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//创建不固定在某个核心上运行的任务，如果对双核利用没有要求，一般情况下可以直接使用这个函数</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        vTaskDelay(<span class="number">1000</span>/portTICK_PERIOD_MS);<span class="comment">//app_main()也被看作一个任务，所以需要设置任务切换</span></span><br><span class="line">    &#125;</span><br><span class="line">    vTaskDelete();<span class="comment">//不会执行到此，但如果不加上面的死循环则必须用这个指令删除任务防止内存溢出或程序跑飞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用下面的API进行任务延时</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使当前任务挂起xTicksToDelay的时间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vTaskDelay</span><span class="params">(<span class="keyword">const</span> TickType_t xTicksToDelay)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//根据系统时间向后延迟到pxPreviousWakeTime</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vTaskDelayUntil</span><span class="params">(TickType_t *<span class="keyword">const</span> pxPreviousWakeTime,<span class="comment">//任务开始挂起的时间, 第一次使用时必须用当前时间初始化</span></span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">const</span> TickType_t xTimeIncrement)</span><span class="comment">//每次进入挂起的时间</span></span></span><br></pre></td></tr></table></figure>

<p>两个API的不同点在于vTaskDelay()从当前时间开始xTicksToDelay的时间延迟；vTaskDelayUntil()根据pxPreviousWakeTime和xTimeIncrement计算延迟的时间，延迟到系统时钟为pxPreviousWakeTime时，每次进入延迟的时间为xTimeIncrement</p>
<p>下面是使用例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vTaskDelay(<span class="number">10</span>);<span class="comment">//直接延迟10个时钟周期</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用下面的函数可以完成恒定频率的任务</span></span><br><span class="line"><span class="keyword">const</span> TickType_t xFrequency=<span class="number">10</span>;</span><br><span class="line">TickType_t xLastWakeTime=xTaskGetTickCount();<span class="comment">//获取当前系统时间</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	vTaskDelayUntil(&amp;xLastWakeTime,xFrequency);<span class="comment">//重复xFrequency延迟</span></span><br></pre></td></tr></table></figure>

<p>vTaskDelayUntil()可能不太好理解，建议写几个程序验证一下</p>
<h2 id="任务调度-1"><a href="#任务调度-1" class="headerlink" title="任务调度"></a>任务调度</h2><p>使用以下API控制任务调度</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vTaskStartScheduler();<span class="comment">//启动任务调度器</span></span><br><span class="line">vTaskEndScheduler();<span class="comment">//停止使用任务调度器，这将释放所有内核分配的内存资源，但不会释放由程序分配的资源</span></span><br></pre></td></tr></table></figure>

<h2 id="队列通信与空闲任务"><a href="#队列通信与空闲任务" class="headerlink" title="队列通信与空闲任务"></a>队列通信与空闲任务</h2><p><strong>队列（消息队列）是任务通信的主要形式</strong></p>
<p>队列用于在任务和任务之间以及任务和中断之间发送消息。队列消息会使用线程安全FIFO进行传输</p>
<p>可以使用队列API函数指定阻塞时间，阻塞时间代表任务进入阻塞状态，等待队列中数据或者等待队列空间变为可以使用时的最大系统节拍数。当一个以上任务在同一个队列中被阻塞时，高优先级的任务先解除阻塞</p>
<p>使用<code>#include &quot;queue.h&quot;</code>来使用队列相关的API</p>
<p>项目（消息）在队列中传送时，通过复制而不是引用进入FIFO，需要在传递项目到队列时为每个项目分配同样的大小</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建新队列，返回这个队列的句柄</span></span><br><span class="line"><span class="function">xQueueHandle <span class="title">xQueueCreate</span> <span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> portBASE_TYPE uxQueueLength,<span class="comment">//队列中包含最大项目数量</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> portBASE_TYPE uxItemSize<span class="comment">//队列中每个项目所需的字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传递项目到队列</span></span><br><span class="line"><span class="function">portBASE_TYPE <span class="title">xQueueSend</span> <span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">    xQueueHandle xQueue,<span class="comment">//要传进的队列 </span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> <span class="keyword">void</span> * pvItemToQueue,<span class="comment">//要传项目的指针 </span></span></span></span><br><span class="line"><span class="params"><span class="function">    portTickType xTicksToWait<span class="comment">//等待的最大时间量（单位：系统时钟） </span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从队列接收一个项目</span></span><br><span class="line"><span class="function">portBASE_TYPE <span class="title">xQueueReceive</span> <span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">    xQueueHandle xQueue,<span class="comment">//项目所在队列的句柄 </span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">void</span> *pvBuffer,<span class="comment">//指向缓冲区的指针，接收的项目会被复制进去 </span></span></span></span><br><span class="line"><span class="params"><span class="function">    portTickType xTicksToWait<span class="comment">//任务中断并等待队列中可用空间的最大时间 </span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从中断传递项目到一个队列中的后面</span></span><br><span class="line"><span class="function">portBASE_TYPE <span class="title">xQueueSendFromISR</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	xQueueHandle pxQueue,<span class="comment">//将项目传进的队列</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> <span class="keyword">void</span> *pvItemToQueue,<span class="comment">//项目的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">	portBASE_TYPE *pxHigherPriorityTaskWoken<span class="comment">//因空间数据问题被挂起的任务是否解锁</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">/* 如果传进队列而导致因空间数据问题被挂起的任务解锁，并且解锁的任务的优先级高于当前运行任务，</span></span><br><span class="line"><span class="comment">xQueueSendFromISR 将设置 *pxHigherPriorityTaskWoken 到 pdTRUE</span></span><br><span class="line"><span class="comment">当pxHigherPriorityTaskWoken被设置为pdTRUE 时，则在中断退出之前将请求任务切换 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//中断时从队列接收一个项目</span></span><br><span class="line"><span class="function">portBASE_TYPE <span class="title">xQueueReceiveFromISR</span> <span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">    xQueueHandle pxQueue,<span class="comment">//发送项目的队列的句柄 </span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">void</span> *pvBuffer,<span class="comment">//指向缓冲区的指针，接收的项目会被复制进去 </span></span></span></span><br><span class="line"><span class="params"><span class="function">    portBASE_TYPE *pxTaskWoken<span class="comment">//任务将被锁住来等待队列中的可用空间</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vQueueUnregisterQueue</span> <span class="params">(xQueueHandle xQueue)</span></span>;<span class="comment">//要移除队列的句柄</span></span><br></pre></td></tr></table></figure>

<h2 id="信号量与互斥量"><a href="#信号量与互斥量" class="headerlink" title="信号量与互斥量"></a>信号量与互斥量</h2><p>使用<code>#include &quot;semphr.h&quot;</code>后才能使用信号量相关API</p>
<p>互斥量是特殊的信号量，一般可以用信号量/互斥量替代裸机编程中的全局变量标志</p>
<p>信号量的两种典型应用</p>
<h3 id="事件计数"><a href="#事件计数" class="headerlink" title="事件计数"></a>事件计数</h3><p>事件处理程序在每次事件发生时发送信号量；任务处理程序会在每次处理事件时请求信号量</p>
<p>这样一边递增信号量，一边递减信号量，计数值为事件发生和事件处理两者间的差值</p>
<p>若计数值为正，则存在没有处理的事件</p>
<p>一般此时将信号量计数值初始化为0</p>
<h3 id="资源管理（临界区）"><a href="#资源管理（临界区）" class="headerlink" title="资源管理（临界区）"></a>资源管理（临界区）</h3><p>如果系统中存在临界区（多个线程/应用程序同时需要使用的硬件资源）时，一般使用信号量来进行管理</p>
<p>使用信号量计数值指示出可用的资源数量，当计数值降为0时表示没有空闲资源</p>
<p>任务使用临界区时申请信号量，而不再访问临界区前返还信号量</p>
<p>这种情况下应该将信号量的计数值初始化为临界区系统资源的值</p>
<h3 id="互斥量与二值信号量"><a href="#互斥量与二值信号量" class="headerlink" title="互斥量与二值信号量"></a>互斥量与二值信号量</h3><p>互斥量是一种特殊的二值信号量，又被称为<strong>互斥锁</strong></p>
<p><strong>二值信号量</strong>就是只有两个可用值的信号量，比如一个只包含了0和1的信号量</p>
<p>互斥锁包含一个优先级继承机制，而信号量没有。这个特点决定了二值信号量适合实现线程间（任务间）同步；互斥锁更适合实现简单的互斥</p>
<p>当有另外一个具有更高优先级的任务试图获取同一个互斥锁时，已经获得互斥锁的任务的优先级会被提升，已经获得互斥锁的任务将继承试图获取同一互斥锁的任务的优先级。这意味着互斥锁必须总是要返还的，否则高优先级的任务将永远也不能获取互斥锁，而低优先级的任务将不会放弃优先级的继承。这就避免了出现互斥锁卡死的bug</p>
<p>二值信号量并不需要在得到后立即释放，任务同步可以通过一个任务/中断持续释放信号量而另外一个持续获得信号量来实现</p>
<p>互斥锁与二元信号量均赋值为xSemaphoreHandle类型，可以在任何此类型参数的API 函数中使用</p>
<p>注意：<strong>互斥类型的信号量不能在中断服务程序中使用</strong></p>
<p>下面介绍互斥量和信号量的相关API</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建递归的互斥锁</span></span><br><span class="line"><span class="function">xSemaphoreHandle <span class="title">xSemaphoreCreateRecursiveMutex</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一个递归的互斥锁可以重复地被其所有者“获取”</span></span><br><span class="line"><span class="comment">在其所有者为每次的成功“获取”请求调用xSemaphoreGiveRecursive()前，此互斥锁不会再次可用</span></span><br><span class="line"><span class="comment">也就是说，一个任务重复获取同一个互斥锁n次，则需要在释放互斥锁n次后，其他任务才可以使用此互斥锁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取信号量与互斥锁</span></span><br><span class="line">xSemaphoreTake ( </span><br><span class="line">    xSemaphoreHandle xSemaphore,<span class="comment">//将被获得的信号量句柄</span></span><br><span class="line">    portTickType xBlockTime<span class="comment">//等待信号量可用的时钟滴答次数</span></span><br><span class="line">);<span class="comment">//获得信号量</span></span><br><span class="line"></span><br><span class="line">xSemaphoreTakeRecursive ( </span><br><span class="line">    xSemaphoreHandle xMutex,<span class="comment">//将被获得的互斥锁句柄</span></span><br><span class="line">    portTickType xBlockTime<span class="comment">//等待互斥锁可用的时钟滴答次数 </span></span><br><span class="line">);<span class="comment">//递归获得互斥锁信号量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//释放信号量</span></span><br><span class="line">xSemaphoreGive (xSemaphoreHandle xSemaphore);</span><br><span class="line"><span class="comment">//递归释放互斥锁信号量</span></span><br><span class="line">xSemaphoreGiveRecursive (xSemaphoreHandle xMutex);</span><br><span class="line"><span class="comment">//从中断释放信号量</span></span><br><span class="line">xSemaphoreGiveFromISR ( </span><br><span class="line">    xSemaphoreHandle xSemaphore,<span class="comment">//将被释放的信号量的句柄 </span></span><br><span class="line">    portBASE_TYPE *pxHigherPriorityTaskWoken<span class="comment">//因空间数据问题被挂起的任务是否解锁</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="事件集-1"><a href="#事件集-1" class="headerlink" title="事件集"></a>事件集</h2><p>FreeRTOS的事件可以理解为多个二值信号量的组合</p>
<p>事件只与任务相关联，事件之间相互独立；事件仅用于同步，不提供数据传输功能</p>
<p>事件无排队性，多次向任务设置同一事件，如果任务还未来得及读走，则等效于只设置一次；允许多个任务对同一事件进行读写操作</p>
<p><strong>事件通常可以用来替代裸机编程中的if/switch语句配合枚举/全局变量标志</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">EventGroupHandle_t <span class="title">xEventGroupCreate</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//创建事件标志组，返回事件标志组的句柄</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置事件标志位</span></span><br><span class="line"><span class="function">EventBits_t <span class="title">xEventGroupSetBits</span><span class="params">(EventGroupHandle_t xEventGroup,<span class="comment">//事件标志组句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">const</span> EventBits_t uxBitsToSet<span class="comment">//事件标志位</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;<span class="comment">//注意使用前一定要创建对应的事件标志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从中断服务程序中设置事件标志位</span></span><br><span class="line"><span class="function">BaseType_t <span class="title">EventGroupSetBitsFromISR</span><span class="params">(EventGroupHandle_t xEventGroup,<span class="comment">//事件标志组句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">const</span> EventBits_t uxBitsToSet,<span class="comment">//事件标志位设置</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                    BaseType_t *pxHigherPriorityTaskWoken<span class="comment">//高优先级任务是否被唤醒的状态保存</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="ESP-IDF中的事件循环库"><a href="#ESP-IDF中的事件循环库" class="headerlink" title="ESP-IDF中的事件循环库"></a>ESP-IDF中的事件循环库</h3><p>为了处理wifi、蓝牙、网络接口等外设中大量的状态变化，一般会使用状态机（FSM），而指示状态就需要用到事件集。ESP-IDF中提供了可用的<strong>事件循环</strong>。向默认事件循环发送事件相当于事件的handler依次执行队列中的命令</p>
<p>事件循环被囊括在<strong>事件循环库</strong>（event loop library）中。事件循环库允许组件将事件发布到事件循环，而当其他组件被注册到事件循环且设置了对应的处理函数时，程序会自动地在事件发生时执行处理程序。</p>
<p>在ESP32的魔改版FreeRTOS中很少使用正经的事件集，而是使用ESP-IDF提供的更方便的事件循环</p>
<p>使用<code>#include &quot;esp_event.h&quot;</code>即可开启事件循环库功能</p>
<p>使用流程如下：</p>
<ol>
<li><p>用户定义一个事件处理函数，该函数被必须与esp_event_handler_t具有相同的结构（也就是说该函数是esp_event_handler_t类型的函数指针）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span></span></span><br><span class="line"><span class="function"><span class="title">void</span> <span class="params">(*<span class="keyword">esp_event_handler_t</span>)</span><span class="params">(<span class="keyword">void</span> *event_handler_arg,<span class="comment">//事件处理函数的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">esp_event_base_t</span> event_base,<span class="comment">//指向引发事件子程序的特殊指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">int32_t</span> event_id,<span class="comment">//事件的ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">void</span> *event_data)</span><span class="comment">//事件数据</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>esp_event_loop_create()</code>函数创建一个事件循环，该API会传回一个esp_event_loop_handle_t类型的指针用于指向事件循环。每个用该API创建的事件循环都被称为<strong>用户事件循环</strong>；除此之外，还可以使用一种称为<strong>默认事件循环</strong>的特殊事件循环（默认事件循环是系统自带的事件循环，实际上只使用默认事件循环就足够了，相关内容在之后叙述）</p>
</li>
<li><p>使用<code>esp_event_handler_register_with()</code>函数将事件处理函数<strong>注册</strong>到事件循环（注意：一个处理函数可以被注册到多个不同的事件循环中！）</p>
</li>
<li><p>开始运行程序</p>
</li>
<li><p>使用<code>esp_event_post_to</code>发送一个事件到目标事件循环</p>
</li>
<li><p>事件处理函数收取该事件并进行处理</p>
</li>
<li><p>使用<code>esp_event_handler_unregister_with</code>来取消注册某个事件处理函数</p>
</li>
<li><p>使用<code>esp_event_loop_delete</code>删除不再需要的事件循环</p>
</li>
</ol>
<p>官方给出的流程代码描述如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.定义事件处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run_on_event</span><span class="params">(<span class="keyword">void</span>* handler_arg, <span class="keyword">esp_event_base_t</span> base, <span class="keyword">int32_t</span> id, <span class="keyword">void</span>* event_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//2.配置esp_event_loop_args_t结构体来配置事件循环</span></span><br><span class="line">    <span class="keyword">esp_event_loop_args_t</span> loop_args = &#123;</span><br><span class="line">        .queue_size = ...,</span><br><span class="line">        .task_name = ...</span><br><span class="line">        .task_priority = ...,</span><br><span class="line">        .task_stack_size = ...,</span><br><span class="line">        .task_core_id = ...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个用户事件循环</span></span><br><span class="line">    <span class="keyword">esp_event_loop_handle_t</span> loop_handle;</span><br><span class="line">    esp_event_loop_create(&amp;loop_args, &amp;loop_handle);</span><br><span class="line">    <span class="comment">//3.注册事件处理函数</span></span><br><span class="line">    esp_event_handler_register_with(loop_handle, MY_EVENT_BASE, MY_EVENT_ID, run_on_event, ...);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//4.事件源使用以下API将事件发送到事件循环，随后事件处理函数会根据其中的逻辑进行处理</span></span><br><span class="line">    <span class="comment">//这一系列操作可以跨任务使用</span></span><br><span class="line">    esp_event_post_to(loop_handle, MY_EVENT_BASE, MY_EVENT_ID, ...)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//5.解除注册一个事件处理函数</span></span><br><span class="line">    esp_event_handler_unregister_with(loop_handle, MY_EVENT_BASE, MY_EVENT_ID, run_on_event);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//6.删除一个不需要的事件循环</span></span><br><span class="line">    esp_event_loop_delete(loop_handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用如下函数来声明和定义事件</p>
<p>一个事件由两部分标识组成：<strong>事件类型</strong>和<strong>事件ID</strong></p>
<p>事件类型标识了一个独立的事件组；事件ID区分在该组内的事件</p>
<p><em>可以将事件类型视为人的姓，事件ID是人的名</em></p>
<p>使用以下两个宏函数来声明、定义事件类型。一般地，在程序中使用XXX_EVENT的形式来定义一个事件类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ESP_EVENT_DECLARE_BASE(EVENT_BASE)<span class="comment">//声明事件类型</span></span><br><span class="line">ESP_EVENT_DEFINE_BASE(EVENT_BASE)<span class="comment">//定义事件类型</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//事件类型举例：WIFI_EVENT</span></span><br></pre></td></tr></table></figure>

<p>一般使用枚举变量来定义事件ID，如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    EVENT_ID_1,</span><br><span class="line">    EVENT_ID_2,</span><br><span class="line">    EVENT_ID_3,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当注册一个事件处理函数到不同事件循环后，<strong>事件循环可以根据不同的事件类型和事件ID来区分应该执行哪一个事件处理函数</strong></p>
<p>可以使用ESP_EVENT_ANY_BASE和ESP_EVENT_ANY_ID作为注册事件处理函数的参数，这样事件处理函数就可以处理发到当前注册事件循环上的任何事件</p>
<h3 id="默认事件循环"><a href="#默认事件循环" class="headerlink" title="默认事件循环"></a>默认事件循环</h3><p>默认事件循环是一种系统事件（如wifi、蓝牙事件等）使用的特殊事件循环。特殊的一点是它的句柄被隐藏起来，用户无法直接使用。用户只能通过一系列固定的API来操作这个事件循环</p>
<p>API如下表所示</p>
<table>
<thead>
<tr>
<th>用户事件循环</th>
<th>默认事件循环</th>
<th>事件循环API</th>
</tr>
</thead>
<tbody><tr>
<td>esp_event_loop_create()</td>
<td>esp_event_loop_create_default()</td>
<td>创建</td>
</tr>
<tr>
<td>esp_event_loop_delete()</td>
<td>esp_event_loop_delete_default()</td>
<td>删除</td>
</tr>
<tr>
<td>esp_event_handler_register_with()</td>
<td>esp_event_handler_register()</td>
<td>注册处理函数</td>
</tr>
<tr>
<td>esp_event_handler_unregister_with()</td>
<td>esp_event_handler_unregister()</td>
<td>取消注册处理函数</td>
</tr>
<tr>
<td>esp_event_post_to()</td>
<td>esp_event_post()</td>
<td>事件源发送事件到事件循环</td>
</tr>
</tbody></table>
<p>除了API区别和系统事件会自动发送到默认事件循环外，<strong>两者并没有更多差别</strong>，所以说用户可以将自定义的事件直接发送到默认事件循环，这比用户定义的事件循环更节约内存且<strong>更方便</strong>！</p>
<p><strong>任务、队列和事件循环是ESP32中最常用也是最特殊的SMP FreeRTOS API</strong></p>
<h3 id="事件循环库API简介"><a href="#事件循环库API简介" class="headerlink" title="事件循环库API简介"></a>事件循环库API简介</h3><p>使用以下API控制事件循环</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_event_loop_create_default</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//创建默认事件循环</span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_event_loop_delete_default</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//删除默认事件循环</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建用户事件循环</span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_event_loop_create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">esp_event_loop_args_t</span> *event_loop_args,<span class="comment">//事件循环参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">esp_event_loop_handle_t</span> *event_loop)</span></span>;<span class="comment">//事件循环句柄</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//删除用户事件循环</span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_event_loop_delete</span><span class="params">(<span class="keyword">esp_event_loop_handle_t</span> event_loop)</span></span>;<span class="comment">//事件循环</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_event_loop_run</span><span class="params">(<span class="keyword">esp_event_loop_handle_t</span> event_loop, TickType_t ticks_to_run)</span></span>;</span><br><span class="line"><span class="comment">//将时间分配到一个事件循环，不常用，注意事项一大堆懒得看了——总之详细用法请参考官网API简介    </span></span><br></pre></td></tr></table></figure>

<p>使用以下API来注册/注销事件处理函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将事件处理程序注册到系统事件循环</span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_event_handler_register</span><span class="params">(<span class="keyword">esp_event_base_t</span> event_base,<span class="comment">//事件类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">int32_t</span> event_id,<span class="comment">//事件ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">esp_event_handler_t</span> event_handler,<span class="comment">//事件处理函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">void</span> *event_handler_arg)</span></span>;<span class="comment">//事件处理函数的参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将事件处理程序注册到用户事件循环</span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_event_handler_register_with</span><span class="params">(<span class="keyword">esp_event_loop_handle_t</span> event_loop,<span class="comment">//要注册到的事件循环</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="keyword">esp_event_base_t</span> event_base,<span class="comment">//事件类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="keyword">int32_t</span> event_id,<span class="comment">//事件ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="keyword">esp_event_handler_t</span> event_handler,<span class="comment">//事件处理函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="keyword">void</span> *event_handler_arg)</span></span>;<span class="comment">//事件处理函数的参数</span></span><br><span class="line"><span class="comment">//取消注册（系统事件循环）</span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_event_handler_unregister</span><span class="params">(<span class="keyword">esp_event_base_t</span> event_base,<span class="comment">//事件类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="keyword">int32_t</span> event_id,<span class="comment">//事件ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="keyword">esp_event_handler_t</span> event_handler)</span></span>;<span class="comment">//事件处理函数</span></span><br><span class="line"><span class="comment">//取消注册（用户事件循环）</span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_event_handler_unregister_with</span><span class="params">(<span class="keyword">esp_event_loop_handle_t</span> event_loop,<span class="comment">//要取消注册的事件循环</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="keyword">esp_event_base_t</span> event_base,<span class="comment">//事件类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="keyword">int32_t</span> event_id,<span class="comment">//事件ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="keyword">esp_event_handler_t</span> event_handler)</span></span>;<span class="comment">//事件处理函数</span></span><br></pre></td></tr></table></figure>

<p>可以使用ESP_EVENT_ANY_BASE 和ESP_EVENT_ANY_ID来取消注册所有事件循环上的事件处理函数</p>
<p>使用以下API来发送事件到事件循环</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送事件到系统事件循环</span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_event_post</span><span class="params">(<span class="keyword">esp_event_base_t</span> event_base,<span class="comment">//事件类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">int32_t</span> event_id,<span class="comment">//事件ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">void</span> *event_data,<span class="comment">//事件数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">size_t</span> event_data_size,<span class="comment">//事件数据的大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">                         TickType_t ticks_to_wait)</span></span>;<span class="comment">//等待时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//发送事件到用户事件循环</span></span><br><span class="line"><span class="function"><span class="keyword">esp_err_t</span> <span class="title">esp_event_post_to</span><span class="params">(<span class="keyword">esp_event_loop_handle_t</span> event_loop,<span class="comment">//要发送到的用户事件循环的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">esp_event_base_t</span> event_base,<span class="comment">//事件类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">int32_t</span> event_id,<span class="comment">//事件ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">void</span> *event_data,<span class="comment">//事件数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">size_t</span> event_data_size,<span class="comment">//事件数据的大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            TickType_t ticks_to_wait)</span><span class="comment">//等待时间</span></span></span><br></pre></td></tr></table></figure>

<p>事件循环库函数会保留事件数据的副本并自动控制副本的存活时间</p>
]]></content>
      <tags>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenWrt简单软件配置</title>
    <url>/2021/11/19/OpenWrt%E7%AE%80%E5%8D%95%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="OpenWrt软件配置"><a href="#OpenWrt软件配置" class="headerlink" title="OpenWrt软件配置"></a>OpenWrt软件配置</h1><p>上一篇讲述过如何在硬件设备中部署OpenWrt并进行基础的网络使用，这里重点介绍OpenWrt的软件配置</p>
<span id="more"></span>

<h2 id="配置路由器"><a href="#配置路由器" class="headerlink" title="配置路由器"></a>配置路由器</h2><p>在笔者的项目中，需要实现以下功能：</p>
<ul>
<li>可以通过WAN口连接外网</li>
<li>可以通过连接互联网下载软件包</li>
<li>通过LAN口连接的设备直接可以直接在静态地址基础上建立tcp连接</li>
<li>内网设备可以通过路由器连接互联网</li>
</ul>
<p>因此选择了对内（LAN口之间）配置为交换机模式，对外（WAN口）配置为路由器模式</p>
<p>通过luci界面就可以很方便地进行配置，这就是折腾OpenWrt的优势——有点折腾但不是太折腾。</p>
<p>基本步骤如下：</p>
<ol>
<li><p>重置所有端口为默认状态</p>
</li>
<li><p>设置当前连接LAN口的IP地址、子网掩码等参数（192.168.0.1、255.255.255.0，老生常谈的东西）</p>
</li>
<li><p>重启OpenWrt设备并确保以自己设置的LAN口ip能ping通</p>
</li>
<li><p>切到“交换机”界面，如下图所示和指导进行配置</p>
<p> 其中Port 1、2、3、4都是LAN口，Port5是WAN口</p>
<p> 将第一行Port1、2、3、4都设置为<strong>不关联</strong>；将第一行Port5设置为<strong>关</strong>；将第二行Port1、2、3、4都设置为<strong>关</strong>；将第二行Port5设置为<strong>不关联</strong>；将两行的CPU（eth0）都设置为<strong>关联</strong></p>
<p> 这是为了划分出两个VLAN，便于服务器联网</p>
<p> <img src="/2021/11/19/OpenWrt%E7%AE%80%E5%8D%95%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/image-20210929003040969.png" alt="image-20210929003040969"></p>
</li>
<li><p>切换到OpenWrt设置界面，调整防火墙策略，关闭所有LAN口的防火墙，只保留WAN口的防火墙；同时注意不要保留LAN口上的“桥接”</p>
</li>
<li><p>设置完毕，保存退出重启即可</p>
</li>
</ol>
<blockquote>
<p>这一套操作花了我将近三天时间，从中得出最好的经验就是有图形界面的情况下千万不要去动配置文件，否则会死得很惨——天知道你什么时候就把文件改炸了——而且一定要<strong>记得备份！记得备份！记得备份！</strong></p>
<p>同时需要注意：这个方法仅适用于连接到LAN口的设备使用静态ip并且<strong>静态ip一定要设置在同一个网段内</strong>，否则很容易ping不通，因为dhcp服务器会完全随机地在网段内分配ip，如果连接到的设备内部ip已经被占用，很可能会导致无法分配ip或查找不到对应ip</p>
</blockquote>
<h2 id="网络摄像头"><a href="#网络摄像头" class="headerlink" title="网络摄像头"></a>网络摄像头</h2><p>如果想要在OpenWrt上搭载网络摄像头，需要提前安装一下内核驱动和软件包：</p>
<ul>
<li>usbutils：用于lsusb命令支持，使用它可查看USB摄像头是否已经接入</li>
<li>kmod-i2c-core：IIC总线驱动，用于支持数字摄像头的SCCB总线</li>
<li>kmod-video-core、kmod-video-uvc、kmod-video-videobuf2、libv4l：免驱摄像头必须安装的驱动库</li>
<li>mjpg-streamer：使用该软件进行推流</li>
</ul>
<p>如果OpenWrt版本较新，可以考虑使用luci-app-mjpg-streamer，这是mjpg-streamer的luci界面支持软件，可以更方便的在luci界面中进行mjpg-streamer的配置</p>
<p>连接usb摄像头（最好是免驱摄像头），使用<code>lsusb</code>，查看设备是否连接成功</p>
<p>使用指令 <code>ls /dev/</code>查看里面是否存在video开头的设备</p>
<p>修改<code>/etc/config/mjpg-streamer</code>来配置软件参数</p>
<p>配置完成后，只需要使用<code>/etc/init.d/mjpg-streamer start</code>运行程序就可以进行推流</p>
<p>默认使用设备的8080端口，ip地址根据设备地址变化，例如打开<code>http://192.168.1.1:8080/?action=stream</code>访问摄像头图像</p>
<blockquote>
<p>项目中最后并没有采用这个方案</p>
<p>原因是设备硬件无法兼容Linux的摄像头内核驱动，或者说：19.04版本的驱动得不到兼容，但可以安装mjpg-streamer；14.08版本的驱动可以兼容，但是无法安装mjpg-streamer和负责串口转发的ser2net软件。为了保证设备的基本运行，不得不将摄像头转移到了另一个嵌入式linux平台，串口转发倒是挺正常的——虽然说也给我造成了很大麻烦</p>
</blockquote>
<h2 id="网口-串口转发"><a href="#网口-串口转发" class="headerlink" title="网口-串口转发"></a>网口-串口转发</h2><p><code>ser2net</code>是一个Linux下常用的TCP-串口透传应用程序，使用<code>sudo apt install ser2net</code>即可安装</p>
<p>通过修改<code>/etc/ser2net.conf</code>进行配置</p>
<p>基本参数如下：</p>
<ul>
<li><strong>最高支持115200波特率</strong></li>
<li>支持tcp报文（字节）、telnet协议通讯</li>
<li>根据硬件可支持硬件流控来驱动rs485总线</li>
</ul>
<p>在它的配置文件里头部会标注很多内容，其中参数说明就在头部注释的最后一段</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">            Sets  operational  parameters  <span class="keyword">for</span> the serial port.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            Options 300, 1200, 2400, 4800, 9600, 19200, 38400,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            57600, 115200 <span class="built_in">set</span> the various baud rates.  EVEN,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            ODD, NONE <span class="built_in">set</span> the parity.  1STOPBIT, 2STOPBITS <span class="built_in">set</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">            the number of stop bits.  7DATABITS, 8DATABITS <span class="built_in">set</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">            the number of data bits.  [-]XONXOFF turns on (-</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            off) XON/XOFF support.  [-]RTSCTS turns on (- off)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            hardware flow control, [-]LOCAL turns off (- on)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            monitoring of the modem lines, and</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            [-]HANGUP_WHEN_DONE turns on (- off) lowering the</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            modem control lines when the connextion is <span class="keyword">done</span>.</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">            NOBREAK disables automatic setting of the <span class="built_in">break</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">            setting of the serial port.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            The <span class="string">&quot;remctl&quot;</span> option allow remote control (ala RFC</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            2217) of serial-port configuration.  A banner name</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            may also be specified, that banner will be printed</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            <span class="keyword">for</span> the line.  If no banner is given, <span class="keyword">then</span> no</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            banner is printed.</span></span><br></pre></td></tr></table></figure>

<p>使用示例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1234:raw:0:/dev/ttyS0:115200 8DATABITS NONE 1STOPBIT -RTSCTS -XONXOFF LOCAL</span><br></pre></td></tr></table></figure>

<p>使用1234端口以TCP报文的形式转发ttyS0收到的串口数据，串口配置为115200波特率、8数据位、无奇偶校验位、1停止位、关闭硬件流控</p>
<p>之后将其添加到<code>/etc/rc.local</code>中即可实现开机自启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/sbin/ser2net -c /etc/ser2net.conf &amp;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>笔者在初次使用该程序时，为了追求效率将串口波特率拉到了921600，发现上传数据一直出错，但是一直没有怀疑是串口软件的问题，排查了将近一周才发现这个软件<strong>不支持115200以上波特率</strong>串口的转发</p>
<p>这个问题也经常被大家忽视——很多低性能设备默认串口速率较低，不会提供更高速串口的支持。如果在需要高速转发的情况下，很可能就必须要换用其他协议或者选择性地放弃部分速度</p>
<p>在笔者的项目里，为了节省改动时间，就直接把串口速率降低到了115200</p>
</blockquote>
]]></content>
      <tags>
        <tag>IoT</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32深入学习【RCC】</title>
    <url>/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90RCC%E3%80%91/</url>
    <content><![CDATA[<h1 id="复位"><a href="#复位" class="headerlink" title="复位"></a>复位</h1><h2 id="系统复位"><a href="#系统复位" class="headerlink" title="系统复位"></a>系统复位</h2><p>系统复位将所有寄存器复位，<strong>除了时钟控制寄存器CSR中的复位标志和备份域寄存器</strong></p>
<p>复位条件：</p>
<ol>
<li><p><strong>外部复位：NRST引脚电平拉低</strong></p>
</li>
<li><p>WWDG复位：窗口看门狗计数结束</p>
</li>
<li><p>IWDG复位：独立看门狗计数结束</p>
</li>
<li><p><strong>软件复位(内核软复位)：将Cortex-M4内核的应用中断和复位控制寄存器(SCB_AIRCR)中的SYSRESEREQ(sys_reset_eq)位 置1</strong></p>
<p> 在以下三种情况下会产生<strong>内核复位</strong>：</p>
<ol>
<li>上电复位：MCU通电时内核自动将所有组成部件复位</li>
<li>系统复位：只复位处理器和外设，不会复位内核debug部分（常用来进行debug）</li>
<li>处理器复位：仅复位处理器</li>
</ol>
<p> 上电复位和系统复位持续时间取决于MCU设计，在一些情况下，复位会持续数毫秒来等待晶振时钟稳定。在复位后、处理器运行程序之前，Cortex-M处理器将从内存中读取前两个字，即 位于中断向量表之前的<strong>主栈顶指针(MSP Main Stack Pointer)<strong>和</strong>复位向量</strong>初始值，其中复位向量就是复位句柄的起始地址。在这两个字被处理器读取以后，处理器会以这两个值建立主堆栈指针MSP和程序计数器PC</p>
 <span id="more"></span>

<p> 提前建立MSP的原因：上电后可能会出现系统错误以至于处理器调用NMI或硬件错误相关服务函数，就需要栈内存和MSP把一些处理器状态信息压栈来处理系统错误相关的中断</p>
<p> 注意：Cortex-M4的SP初始化和传统ARM核的初始化不相同，它必须被在软件中初始化，而中断向量表存储的是中断向量的地址，因为M4的栈是自顶向下生长的，初始化的SP值应该被设置到栈顶以下的第一个内存，如下图所示：<strong>中断向量表之前的SP初始值是一个指向栈顶的指针</strong></p>
<p> <img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90RCC%E3%80%91/image-20210111171431355.png" alt="image-20210111171431355"></p>
<p> 下面是arm提供的core_cm4.h文件中有关系统复位的程序,以C内嵌汇编代码写成</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__STATIC_INLINE <span class="keyword">void</span> <span class="title">NVIC_SystemReset</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __DSB();<span class="comment">/* Ensure all outstanding memory accesses included</span></span><br><span class="line"><span class="comment">  			buffered write are completed before reset */</span></span><br><span class="line">  SCB-&gt;AIRCR  = (<span class="keyword">uint32_t</span>)((<span class="number">0x5FA</span>UL &lt;&lt; SCB_AIRCR_VECTKEY_Pos)    |</span><br><span class="line">                           (SCB-&gt;AIRCR &amp; SCB_AIRCR_PRIGROUP_Msk) |</span><br><span class="line">                            SCB_AIRCR_SYSRESETREQ_Msk    );<span class="comment">/* Keep priority group unchanged */</span></span><br><span class="line">  __DSB();<span class="comment">/* Ensure completion of memory access */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;)<span class="comment">/* wait until reset */</span></span><br><span class="line">  &#123;</span><br><span class="line">    __NOP();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>低功耗管理复位</p>
<p> 引发低功耗复位的方式：</p>
<ol>
<li>进入待机时复位：清零用户选项字节中的nRST_STDBY位。使能后，只要成功执行进入待机模式序列，MCU就不会进入待机，而是进行复位</li>
<li>进入停止模式时产生复位：清零用户选项字节中的nRST_STOP位。使能后，只要成功执行进入停止模式序列，MCU就不会进入停止模式，而是进行复位</li>
</ol>
</li>
</ol>
<h2 id="电源复位"><a href="#电源复位" class="headerlink" title="电源复位"></a>电源复位</h2><p>将<strong>除备份域内的寄存器外</strong>，其他所有寄存器复位</p>
<p>MCU内部的复位信号会在NRST引脚上输出，脉冲发生器会确保每个内部复位源的<strong>复位脉冲都至少持续20us</strong></p>
<p>条件：</p>
<ol>
<li>上电/掉电/欠压复位</li>
<li>退出待机模式复位</li>
</ol>
<p>复位电路如下：</p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90RCC%E3%80%91/image-20210111181028844.png" alt="image-20210111181028844"></p>
<h2 id="备份域复位"><a href="#备份域复位" class="headerlink" title="备份域复位"></a>备份域复位</h2><p>备份域复位会将<strong>所有RTC寄存器和RCC_BDCR寄存器复位</strong>，但<strong>BKPSRAM不受影响</strong></p>
<p>BKPSRAM的<strong>唯一</strong>复位方式是通过FLASH接口将FLASH保护等级从1切换到0</p>
<p>复位条件：</p>
<ol>
<li>软件复位：将RCC备份域控制寄存器(RCC_BDCR)中的BDRST位 置1</li>
<li>在$V_{DD}$和$V_{BAT}$都掉电后，其中任意一个又再上电</li>
</ol>
<p>即 备份域靠$V_{BAT}$来维持断电情况下的运行，但如果$V_{BAT}$掉电则备份域无法保存数据</p>
<h1 id="时钟控制-RCC"><a href="#时钟控制-RCC" class="headerlink" title="时钟控制(RCC)"></a>时钟控制(RCC)</h1><p>ARM核的SoC底层都采用了同步时序电路和时钟门控技术。外设控制寄存器使用D触发器构成，在时钟信号的变沿触发，这就导致了想配置外设寄存器就必须供给其时钟，而时钟又是片上资源消耗较多的一个功能实现，所以stm32采用了时钟门控技术，可以独立开启/关闭某个外设的时钟，在不需要时可以关闭一个外设的时钟来实现低功耗</p>
<h2 id="时钟源"><a href="#时钟源" class="headerlink" title="时钟源"></a>时钟源</h2><p>系统时钟由<strong>HSI时钟、HSE时钟、主PLL时钟</strong>三者之一来驱动</p>
<p>同时，MCU可接入**32kHz低速内部RC(LSI RC)<strong>驱动IWDG，也可用于RTC在停机/待机模式下的自动唤醒；还可接入</strong>32.768kHz低速外部晶振(LSE晶振)**来驱动RTC时钟</p>
<p>每个时钟源都可以独立打开或关闭，同时开启的时钟源越少，功耗越低</p>
<h2 id="时钟树"><a href="#时钟树" class="headerlink" title="时钟树"></a>时钟树</h2><p>stm32f4的内部时钟相当复杂，呈多输入-多输出的树形结构，可分为以下几个主要组成部分</p>
<h3 id="总线时钟"><a href="#总线时钟" class="headerlink" title="总线时钟"></a>总线时钟</h3><p>所有内部总线都可以通过多个预分频器进行时钟配置</p>
<p>AHB最大频率168MHz</p>
<p>高速APB2最大频率84MHz</p>
<p>低速APB1最大频率42MHz</p>
<h3 id="特殊外设时钟"><a href="#特殊外设时钟" class="headerlink" title="特殊外设时钟"></a>特殊外设时钟</h3><table>
<thead>
<tr>
<th>外设</th>
<th>频率</th>
<th>时钟源</th>
<th>时钟源频率</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>USB OTG FS</td>
<td>=48MHz</td>
<td>特定PLL输出</td>
<td>48MHz</td>
<td>PLL48CLK</td>
</tr>
<tr>
<td>RNG</td>
<td>&lt;=48MHz</td>
<td>特定PLL输出</td>
<td>48MHz</td>
<td>PLL48CLK</td>
</tr>
<tr>
<td>SDIO</td>
<td>&lt;=48MHz</td>
<td>特定PLL输出</td>
<td>48MHz</td>
<td>PLL48CLK</td>
</tr>
<tr>
<td>I2S时钟</td>
<td>数据包位宽*2*音频采样频率</td>
<td>特定PLL输出 或 I2S_CKIN引脚的外部时钟</td>
<td></td>
<td>PLL I2S</td>
</tr>
<tr>
<td>USB OTG HS</td>
<td>=60MHz</td>
<td>外部USB2.0 PHY</td>
<td>24-60MHz</td>
<td>USB HS ULPI</td>
</tr>
<tr>
<td>以太网</td>
<td>&gt;=25MHz</td>
<td>外部PHY提供的以太网MAC时钟</td>
<td>25-50MHz</td>
<td>MACRXCLK等</td>
</tr>
<tr>
<td>以太网</td>
<td></td>
<td>(包括TX、RX、RMII)</td>
<td></td>
<td>（见下图）</td>
</tr>
</tbody></table>
<p>下图为特殊外设时钟树</p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90RCC%E3%80%91/image-20210111183533164.png" alt="image-20210111183533164"></p>
<h3 id="系统定时器-SysTick-时钟"><a href="#系统定时器-SysTick-时钟" class="headerlink" title="系统定时器(SysTick)时钟"></a>系统定时器(SysTick)时钟</h3><p>使用<strong>8分频的AHB时钟(HCLK)<strong>或直接使用</strong>AHB时钟(HCLK)</strong></p>
<p>可在SysTick控制和状态寄存器中配置</p>
<h3 id="硬件定时器时钟"><a href="#硬件定时器时钟" class="headerlink" title="硬件定时器时钟"></a>硬件定时器时钟</h3><p>stm32f42xxx和43xxx的定时器时钟频率由<strong>硬件自动设置</strong></p>
<p>根据RCC_CFGR寄存器中TIIMPRE位的取值分为两种情况</p>
<ol>
<li><p>TIMPRE=0</p>
<p> APB预分频器分频系数为1，则设定定时器时钟TIMxCLK=PCLKx；否则，TIMxCLK=2*PCLKx</p>
</li>
<li><p>TIMPRE=1</p>
<p> APB预分频器分频系数为1、2或4，则设定定时器时钟TIMxCLK=HCLK；否则，TIMxCLK=4*PCLKx</p>
</li>
</ol>
<h3 id="内核自由运行时钟"><a href="#内核自由运行时钟" class="headerlink" title="内核自由运行时钟"></a>内核自由运行时钟</h3><p>由<strong>FCLK</strong>充当</p>
<h3 id="其他外设时钟"><a href="#其他外设时钟" class="headerlink" title="其他外设时钟"></a>其他外设时钟</h3><p>其他所有外设时钟均由系统时钟SYSCLK提供</p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90RCC%E3%80%91/image-20210111184430333.png" alt="image-20210111184430333"></p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90RCC%E3%80%91/image-20210111184357362.png" alt="image-20210111184357362"></p>
<h2 id="内部时钟信号"><a href="#内部时钟信号" class="headerlink" title="内部时钟信号"></a>内部时钟信号</h2><h3 id="高速外部时钟HSE-High-speed-Signal-Extern"><a href="#高速外部时钟HSE-High-speed-Signal-Extern" class="headerlink" title="高速外部时钟HSE(High-speed Signal Extern)"></a>高速外部时钟HSE(High-speed Signal Extern)</h3><p>==时钟源：HSE外部晶振 或 HSE外部用户时钟==</p>
<ol>
<li>外部源（HSE旁路）模式</li>
</ol>
<p>必须提供占空比约为50%的外部时钟信号来驱动OSC_IN引脚</p>
<p>信号可以是方波、正弦波或三角波之一</p>
<p>OSC_OUT引脚应保持高阻态</p>
<p><strong>将RCC_CR-&gt;HSEBYP=1和RCC_CR-&gt;HSEON=1可使用此模式</strong></p>
<ol start="2">
<li>外部晶振（HSE晶振）模式</li>
</ol>
<p>硬件要求：谐振器和负载电容必须尽可能靠近振荡器引脚来减少输出失真和起振稳定时间</p>
<p>RCC_CR-&gt;HSERDY标志位指示高速外部振荡器是否稳定，该标志位为1时才能使用该时钟</p>
<p>将RCC_CR-&gt;HSEON=1才能使用HSE晶振，即<strong>RCC_CR-&gt;HSEON=1和RCC_CR-&gt;HSERDY=1可使用此模式</strong></p>
<p>特别地，可以在RCC时钟中断寄存器RCC_CIR中使能中断来开启此模式下的中断</p>
<h3 id="高速内部时钟信号HSI-High-speed-Signal-Inner"><a href="#高速内部时钟信号HSI-High-speed-Signal-Inner" class="headerlink" title="高速内部时钟信号HSI(High-speed Signal Inner)"></a>高速内部时钟信号HSI(High-speed Signal Inner)</h3><p>==时钟源：内部16MHz频率RC振荡器==</p>
<p>可以直接用做系统时钟或用作PLL的输入</p>
<p>优点：成本低、起振速度较快    缺点：精度不如HSE</p>
<p>ST会对器件进行出厂较准，可达到$T_A=25+273K$下1%的精度；复位后，工厂校准值将加载到RCC_CR-&gt;HSICAL[7:0]位中，用户可通过RCC_CR-&gt;HSITRIM[4:0]位进行HSI频率微调以适应各种电压或温度</p>
<p>RCC_CR-&gt;HSIRDY标志位为1表示HSI RC稳定运行，只有此情况下，HSI才能使用</p>
<p>将RCC_CR-&gt;HSION=1可打开HSI RC</p>
<p><strong>RCC_CR-&gt;HSION=1和RCC_CR-&gt;HSIRDY=1可使用此模式</strong></p>
<p>特殊情况下，HSII信号可以作为备份时钟源使用，以防HSE晶振故障</p>
<h3 id="锁相环电路PLL-Phase-Lock-Loop"><a href="#锁相环电路PLL-Phase-Lock-Loop" class="headerlink" title="锁相环电路PLL(Phase Lock Loop)"></a>锁相环电路PLL(Phase Lock Loop)</h3><p>stm32f4xx具有2个PLL</p>
<ol>
<li><p>主PLL(PLL)</p>
<p> 由HSE或HSI提供时钟信号，具有两个不同的输出时钟</p>
<ol>
<li>高速系统时钟输出：最高可达168MHz</li>
<li>PLL48CLK输出：最高可达48MHz，用于提供USB OTG FS、RNG、SDIO时钟</li>
</ol>
<p> 通过RCC_PLLCFGR寄存器进行配置，有M、N、P、Q共4个分频系数位</p>
<p> <img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90RCC%E3%80%91/image-20210111191542166.png" alt="image-20210111191542166"></p>
</li>
<li><p>专用PLL(PLLI2S)</p>
<p> 由HSE或HSI提供时钟信号</p>
<p> 用于生成精确时钟来在I2S接口实现高品质音频性能</p>
<p> 通过RCC_CFGR寄存器进行配置，有使能/禁止位N和分频系数位R</p>
<p> <img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90RCC%E3%80%91/image-20210111191557599.png" alt="image-20210111191557599"></p>
</li>
</ol>
<p>==注意：使能PLL后，PLL配置参数不可再更改，应先对PLL进行配置，然后再使能==</p>
<p>进入停机或待机模式后，两个PLL将被硬件禁止；如将HSE或由HSE提供信号的PLL用作系统时钟时，HSE发生故障，则两个PLL也将由硬件禁止</p>
<h3 id="低速外部时钟信号LSE-Low-speed-Signal-Extern"><a href="#低速外部时钟信号LSE-Low-speed-Signal-Extern" class="headerlink" title="低速外部时钟信号LSE(Low-speed Signal Extern)"></a>低速外部时钟信号LSE(Low-speed Signal Extern)</h3><p>==时钟源：LSE外部晶振 或 LSE外部用户时钟==</p>
<ol>
<li>外部源（LSE旁路）模式</li>
</ol>
<p>必须提供占空比约为50%，最高频率不超过1MHz的外部时钟信号来驱动OSC32_IN引脚</p>
<p>信号可以是方波、正弦波或三角波之一</p>
<p>OSC32_OUT引脚应保持高阻态</p>
<p><strong>将RCC_CR-&gt;LSEBYP=1和RCC_CR-&gt;LSEON=1可使用此模式</strong></p>
<ol start="2">
<li>外部晶振（LSE晶振）模式</li>
</ol>
<p>硬件要求：使用32.768kHz晶体振荡器，精度较高、功耗较低，谐振器和负载电容必须尽可能靠近振荡器引脚来减少输出失真和起振稳定时间</p>
<p>RCC_BDCR-&gt;LSERDY标志位指示低速外部振荡器是否稳定，该标志位为1时才能使用该时钟</p>
<p>将RCC_CR-&gt;LSEON=1才能使用LSE晶振，即<strong>RCC_CR-&gt;LSEON=1和RCC_CR-&gt;LSERDY=1可使用此模式</strong></p>
<p>特别地，可以在RCC时钟中断寄存器RCC_CIR中使能中断来开启此模式下的中断</p>
<h3 id="低速内部时钟信号LSI-Low-speed-Signal-Inner"><a href="#低速内部时钟信号LSI-Low-speed-Signal-Inner" class="headerlink" title="低速内部时钟信号LSI(Low-speed Signal Inner)"></a>低速内部时钟信号LSI(Low-speed Signal Inner)</h3><p><strong>可用作低功耗时钟源再停机和待机模式下保持运行</strong></p>
<p>可供独立看门狗IWDG和自动唤醒单元AWU使用</p>
<p>时钟频率在32kHz左右</p>
<p>RCC_CSR-&gt;LSIRDY标志位指示低速内部振荡器是否稳定，该标志位为1时才能使用该时钟</p>
<p>将RCC_CR-&gt;LSION=1才能使用LSE RC，即<strong>RCC_CR-&gt;LSION=1和RCC_CR-&gt;LSIRDY=1可使用此模式</strong></p>
<p>可以在RCC时钟中断寄存器RCC_CIR中使能中断来开启此模式下的中断</p>
<h2 id="系统时钟-SYSCLK"><a href="#系统时钟-SYSCLK" class="headerlink" title="系统时钟(SYSCLK)"></a>系统时钟(SYSCLK)</h2><p>系统时钟：MCU内部的主时钟，为内核处理器提供运行时钟</p>
<p>系统复位后，默认系统时钟为HSI，且在直接使用HSI或通过PLL使用HSI时钟源来作为系统时钟时，该时钟源无法停止</p>
<p>只有目标时钟源已经就绪（时钟在启动延迟或PLL锁相后稳定时），才能从一个时钟源切换到另一个；如果选择了尚未就绪的时钟源，则切换在该时钟源就绪时才进行，就绪状态由RCC_CR寄存器中的状态标志位指示</p>
<h2 id="时钟安全系统-CSS"><a href="#时钟安全系统-CSS" class="headerlink" title="时钟安全系统(CSS)"></a>时钟安全系统(CSS)</h2><p>时钟检测器可以通过软件打开，激活后将在HSE振荡器启动延迟后使能，在此振荡器停止时被关闭</p>
<p><strong>负责监控HSE时钟信号</strong></p>
<p>HSE故障时，此振荡器将自动禁止，CSS会发送一个时钟故障时间到TIM1和TIM8的短路输入，并生成一个时钟安全系统中断CSSI来向软件通知该故障，CSSI直接和M4内核的NMI（不可屏蔽中断）异常向量链接</p>
<p>注意：如果HSE偶发故障，则CSS会生成一个中断，NMI将无限期执行，需要在NMI ISR中将CSS中断清零，即<strong>将RCC_CIR-&gt;CSSC=1</strong>才能避免这种情况</p>
<h2 id="RTC-AWU时钟"><a href="#RTC-AWU时钟" class="headerlink" title="RTC/AWU时钟"></a>RTC/AWU时钟</h2><p>一旦选定RTCCLK时钟源后只能通过复位电源域来修改</p>
<p>配置RCC_BDCR-&gt;RTCSEL[1:0]和RCC_CFGR-&gt;RTCPRE[4:0]进行选择时钟源</p>
<p>可用于RTC的时钟源：</p>
<ol>
<li>HSE 1MHz：系统电源掉电或内部调压器关闭后无法保证RTC状态</li>
<li>LSE：只要$V_{BAT}$工作即可让RTC工作</li>
<li>LSI：系统电源丢失后无法保证AWU状态</li>
</ol>
<h2 id="看门狗时钟"><a href="#看门狗时钟" class="headerlink" title="看门狗时钟"></a>看门狗时钟</h2><p>独立看门狗强制要求LSI RC开启且不可禁止，LSI稳定后将被用于IWDG</p>
<h2 id="时钟输出功能"><a href="#时钟输出功能" class="headerlink" title="时钟输出功能"></a>时钟输出功能</h2><ol>
<li>MCO1</li>
</ol>
<p>可以通过预分频器向MCO1(PA8)输出HSI、LSE、HSE、PLL时钟之一</p>
<p>通过RCC_CFGR-&gt;MCO1PRE[2:0]和MCO1[1:0]进行选择</p>
<ol start="2">
<li>MCO2</li>
</ol>
<p>可以通过预分频器向MCO2(PC9)输出HSE、PLL、SYSCLK、PLLI2S时钟之一</p>
<p>通过RCC_CFGR-&gt;MCO2PRE[2:0]和MCO2[1:0]进行选择</p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90RCC%E3%80%91/image-20210111194823355.png" alt="image-20210111194823355"></p>
<p><strong>注意：MCO输出时钟不得超过最大IO速度(一般为100MHz)</strong></p>
<p><strong>必须将对应引脚设置为复用模式才可使用时钟输出功能</strong></p>
<h2 id="时钟测量"><a href="#时钟测量" class="headerlink" title="时钟测量"></a>时钟测量</h2><p>所有时钟源的频率都可以通过TIM5channel4和TIM11channel1的输入捕获进行<strong>间接测量</strong></p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90RCC%E3%80%91/image-20210111195057781.png" alt="image-20210111195057781"></p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90RCC%E3%80%91/image-20210111195828703.png" alt="image-20210111195828703"></p>
<h3 id="TIM5channel4的测量"><a href="#TIM5channel4的测量" class="headerlink" title="TIM5channel4的测量"></a>TIM5channel4的测量</h3><p>TIM5具有一个输入捕获复用器，可选择输入捕获是由IO触发还是由内部时钟触发</p>
<p>通过设置TIM5_OR-&gt;TI4_RMP[1:0]位进行选择</p>
<p>借助待测信号连续边沿之间的比较信号计数数量即可对内部时钟周期进行测量</p>
<p>$待测信号周期=\frac{比较信号周期}{比较信号数量}$</p>
<p>比较信号和待测信号频率（周期）之比越大，得到的结果越精确</p>
<h3 id="TIM11channel1的测量"><a href="#TIM11channel1的测量" class="headerlink" title="TIM11channel1的测量"></a>TIM11channel1的测量</h3><p>TIM11自带一个输入复用器，可选择输入捕获是由IO触发还是由内部时钟触发</p>
<p>另外，HSE_RTC时钟(由一个可编程预分频器分频的HSE)连接到channel1输入捕获，可用来粗略指示外部晶振频率</p>
<h1 id="常用RCC库函数"><a href="#常用RCC库函数" class="headerlink" title="常用RCC库函数"></a>常用RCC库函数</h1><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>RCC_AHBPeriphClockCmd()</td>
<td>使能/失能AHB外设时钟</td>
</tr>
<tr>
<td>RCC_APB2PeriphClockCmd()</td>
<td>使能/失能APB2外设时钟</td>
</tr>
<tr>
<td>RCC_APB1PeriphClockCmd()</td>
<td>使能/失能APB1外设时钟</td>
</tr>
<tr>
<td>RCC_HSICmd()</td>
<td>使能/失能HSI晶振</td>
</tr>
<tr>
<td>RCC_PLLConfig()</td>
<td>设置PLL时钟源及倍频系数</td>
</tr>
<tr>
<td>RCC_PLLCmd()</td>
<td>使能/失能PLL输出</td>
</tr>
<tr>
<td>RCC_SYSCLKConfig()</td>
<td>设置系统时钟SYSCLK</td>
</tr>
<tr>
<td>RCC_HCLKConfig()</td>
<td>设置AHB总线时钟HCLK</td>
</tr>
<tr>
<td>RCC_PCLK1Config()</td>
<td>设置低速APB时钟PCLK1</td>
</tr>
<tr>
<td>RCC_PCLK2Config()</td>
<td>设置高速APB时钟PCLK2</td>
</tr>
<tr>
<td>RCC_USBCLKConfig()</td>
<td>设置USB时钟</td>
</tr>
<tr>
<td>RCC_ADCCLKConfig()</td>
<td>设置ADC时钟</td>
</tr>
<tr>
<td>RCC_LSEConfig()</td>
<td>设置LSE晶振</td>
</tr>
<tr>
<td>RCC_LSICmd()</td>
<td>使能/失能LSE晶振</td>
</tr>
<tr>
<td>RCC_RTCCLKConfig()</td>
<td>设置RTC时钟</td>
</tr>
<tr>
<td>RCC_RTCCLKCmd()</td>
<td>使能/失能RTC时钟</td>
</tr>
<tr>
<td>RCC_GetClocksFreq()</td>
<td>返回不同片上时钟的频率</td>
</tr>
<tr>
<td>RCC_BackupResetCmd()</td>
<td>强制/释放后备域复位</td>
</tr>
<tr>
<td>RCC_HSEConfig()</td>
<td>设置HSE晶振</td>
</tr>
<tr>
<td>RCC_GetSYSCLKSource()</td>
<td>返回用作系统时钟SYSCLK的时钟源</td>
</tr>
<tr>
<td>RCC_ITConfig()</td>
<td>使能/失能指定的RCC中断</td>
</tr>
<tr>
<td>RCC_GetITStatus()</td>
<td>检查指定的RCC中断是否发生</td>
</tr>
<tr>
<td>RCC_ClearITPendingBit()</td>
<td>清除RCC的中断待处理位</td>
</tr>
<tr>
<td>RCC_GetFlagStatus()</td>
<td>检查指定的RCC标志位是否设置</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket简介</title>
    <url>/2021/11/19/Socket%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><p>Socket即<strong>套接字</strong>，是由UNIX系统开发的网络通信接口，该接口API被纳入了POSIX标准，所有兼容POSIX的操作系统都可以使用该系列API，所以它成为了<strong>网络应用开发时最常用的API</strong></p>
<h2 id="Socket简介"><a href="#Socket简介" class="headerlink" title="Socket简介"></a>Socket简介</h2><p>Socket套接字是位于应用层和传输层之间的POSIX接口，应用程序可以直接通过Socket进行网络通信，然后由Socket将数据传递到传输层，Socket因此可以像文件一样以打开、读写、关闭的方式实现网络通信，这也是UNIX万物皆文件的思想体现。同时标准化的Socket接口使得应用程序具有良好的可移植性，目前不仅仅是Linux，一些RTOS像FreeRTOS、RT-Thread、uCOS和一些具有网络功能的SoC都实现了Socket API</p>
<p>需要注意：<strong>Socket和Websocket并不是一个东西</strong>，Socket是工作在传输控制层的应用程序接口，WebSocket则是一个应用层协议。Socket将协议簇下层的内容封装起来供上层应用程序调用；而WebSocket作为一个成熟的连接应用解决方案可以单独工作或与其他应用程序共同使用</p>
<span id="more"></span>

<h2 id="Socket-API简介"><a href="#Socket-API简介" class="headerlink" title="Socket API简介"></a>Socket API简介</h2><h3 id="创建socket描述符"><a href="#创建socket描述符" class="headerlink" title="创建socket描述符"></a>创建socket描述符</h3><p>根据属性设置创建Socket描述符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> protofamily, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数返回Socket描述符，这是一个int类型的数值，所有socket操作都基于描述符进行</p>
<p>其中protofamily表示协议簇，一般使用</p>
<ul>
<li>AF_INET：IPv4，使用32位IPv4地址与16位端口号组合</li>
<li>AF_INET6：IPv6，使用IPv6地址与端口号组合</li>
<li>AF_LOCAL（AF_UNIX）：UNIX域Socket，使用一个绝对路径作为地址</li>
<li>AF_ROUTE</li>
</ul>
<p>协议簇决定了Socket的地址类型，设置之后在通信中必须采用对应的地址</p>
<p>type则表示socket的类型，常用下面几种：</p>
<ul>
<li>SOCK_STREAM</li>
<li>SOCK_DGRAM</li>
<li>SOCK_RAW</li>
<li>SOCK_PACKET</li>
<li>SOCK_SEQPACKET</li>
</ul>
<p>protocol表示指定使用某传输协议，常用协议包括</p>
<ul>
<li>IPPROTO_TCP：TCP协议</li>
<li>IPPROTO_UDP：UDP协议</li>
<li>IPPROTO_SCTP：SCTP协议</li>
<li>IPPROTO_TIPC：TIPC协议</li>
</ul>
<p>注意：<strong>type和protocol不能随意组合</strong>，当protocol为0（NULL）时会自动选择type对应的默认协议</p>
<p>调用该函数创建一个Socket后，返回的套接字描述符描述它存在于某个对应协议簇空间中，并没有一个具体的地址，需要使用bind函数才能赋予描述符一个地址（即端口号），否则当调用connect()、listen()等函数时操作系统会自动随机分配一个端口给套接字</p>
<h3 id="绑定唯一端口号"><a href="#绑定唯一端口号" class="headerlink" title="绑定唯一端口号"></a>绑定唯一端口号</h3><p>每个应用程序想要使用网络功能，都要指定唯一的一个端口号，在Socket标准API中使用bind()函数为套接字绑定一个端口号，不过这个操作并不是必须的，在应用程序未使用bind指定端口号时，操作系统会自动分配一个随机的端口号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数返回int类型的指示符，如果为0则表示bind执行成功，返回<code>EADDRINUSE</code>表示端口号已被其他应用程序占用</p>
<p>参数中的sockfd就是通过socket()函数获得的socket描述符</p>
<p>addr则是指向要绑定给socket的协议地址的指针，这个地址结构体会根据地址创建socket时指定使用的地址协议簇的不同而不同：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//IPv4</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>	 	sin_familt;		<span class="comment">/* AF_INET地址协议簇 */</span></span><br><span class="line">    <span class="keyword">in_port_t</span>	 	sin_port; 		<span class="comment">/* 在网络字节序中的端口 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> 	<span class="title">sin_addr</span>;</span> 		<span class="comment">/* 网络地址结构体 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其中网络地址结构体如下所示</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>	 	s_addr; 		<span class="comment">/* 网络地址字节序中的地址 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IPv6</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>	 	sin6_familt;	<span class="comment">/* AF_INET6地址协议簇 */</span></span><br><span class="line">    <span class="keyword">in_port_t</span>	 	sin6_port;		<span class="comment">/* 在网络字节序中的端口 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> 		sin6_flowinfo;  <span class="comment">/* IPv6流信息 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> 		sin6_scope_id;  <span class="comment">/* Scope ID */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>		<span class="comment">/* 网络地址结构体 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其中网络地址结构体如下所示</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>	s6_addr[<span class="number">16</span>];	<span class="comment">/* IPv6地址 */</span>    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//UNIX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNIX_PATH_MAX 108</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> 	sun_family;		<span class="comment">/* AF_UNIX地址协议簇 */</span></span><br><span class="line">    <span class="keyword">char</span> 			sun_path[UNIX_PATH_MAX];	<span class="comment">/* 路径名 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中addrlen代表地址长度，也根据地址协议簇决定</p>
<h3 id="启动连接"><a href="#启动连接" class="headerlink" title="启动连接"></a>启动连接</h3><p>客户端会使用connect()函数来启用一个Socket连接，在使用TCP时，客户端需要连接到TCP服务器，成功后才能继续通信</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数返回0表示connect成功，否则返回错误码，错误码有以下几种：</p>
<ul>
<li>ETIMEDOUT：TCP客户端没有收到SYN分节相应</li>
<li>ECONNREFUSED：服务器主机在客户端指定的端口上没有进程在等待与之连接，属于发生硬错误（hard error）</li>
<li>EHOSTUNREACH或ENETUNREACH：客户端发出的SYN在中间某个路由器上引发了一个“目标地不可达”（destination unreachable）的ICMP错误，属于发生软错误（soft error）</li>
</ul>
<p>参数中sockfd为Socket描述符，addr表示绑定给sockfd的协议地址指针，addrlen为地址长度</p>
<h3 id="监听Socket"><a href="#监听Socket" class="headerlink" title="监听Socket"></a>监听Socket</h3><p>如果是作为服务器，在调用socket()和bind()后，会<strong>调用listen()来监听当前Socket</strong>，调用成功后<strong>如果有客户端调用connect()发起连接请求，服务器就会接收到这个请求</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数返回0表示成功，返回-1表示出错</p>
<p>参数中sockfd依旧为Socket描述符</p>
<p>backlog表示未完成连接队列和已完成连接队列的总和的最大值</p>
<p>内核会给任何给定的监听Socket套接字维护两个队列（FIFO），一个是客户端已经发出连接请求，而服务器正在等待完成响应的TCP三次握手过程队列（TCP三次握手模型为了解决在不可靠信道上建立可靠连接，一个直观的例子就是——客户端请求建立传输，请确认！收到，服务器允许建立传输，请确认！收到，可以建立传输！——三次握手就是发送三次包的过程，可以有效防止错误地建立不必要的传输，不过因此会导致一定延迟，计算机为了进行三次握手要在FIFO中缓存当前握手信息，这就占用了未完成连接队列）；另一个是已经完成三次握手，连接成功的客户端队列</p>
<p>一般来说对于专用服务器，这个数值应该定义得较大，即使超过操作系统内核能支持的最大值也无妨，操作系统会自动将偏大值改成自身支持的最大值</p>
<h3 id="处理连接"><a href="#处理连接" class="headerlink" title="处理连接"></a>处理连接</h3><p>由服务器调用accept()函数来<strong>处理</strong>从已完成连接队列对头返回的<strong>下一个已完成连接</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果服务器与客户端正确建立连接，accept()函数会返回一个全新的Socket套接字，服务器通过这个新的套接字来和客户端进行通信</p>
<p>里面的参数都和之前的一样，这里不再赘述</p>
<h3 id="收发Socket网络数据"><a href="#收发Socket网络数据" class="headerlink" title="收发Socket网络数据"></a>收发Socket网络数据</h3><p>使用read和write函数族来从网络收发数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, </span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">int</span> flags, <span class="keyword">const</span> struct sockaddr * dest_addr, <span class="keyword">socklen_t</span> adrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, </span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">int</span> flags, struct sockaddr * src_addr, <span class="keyword">socklen_t</span> adrlen)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct msghdr *msg, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvmsg</span><span class="params">(<span class="keyword">int</span> sockfd, struct msghdr *msg, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p>read系列函数将套接字视为文件，从套接字描述符中读取内容到缓存buf，读成功时，read返回实际所读的字节数，如果返回值为0，则表示已经读到文件末尾，小于0则表示出现错误，如果错误为EINTR，说明读错误是由中断引起 ，如果是ECONNREST，表示网络连接出现问题</p>
<p>write系列函数将buf中的nbytes字节内容写入套接字描述符，成功时返回写的字节数；失败时返回-1，并设置errno变量。入股write返回值大于0，表示写了部分或全部数据；如果返回值小于0，则表示出现错误，如果是EINTR则表示由中断引起；如果是EPIPE，表示网络连接出现问题（对方已关闭连接）</p>
<h3 id="关闭Socket"><a href="#关闭Socket" class="headerlink" title="关闭Socket"></a>关闭Socket</h3><p>使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>

<p>关闭套接字并终止TCP连接</p>
<p>该函数实际上的作用是将某个socket标记为已关闭并立即返回到调用进程。被关闭的描述字不能再由调用进程使用，也就是不能再作为read或write的第一个参数</p>
]]></content>
      <tags>
        <tag>IoT</tag>
      </tags>
  </entry>
  <entry>
    <title>vim操作简介</title>
    <url>/2021/11/19/vim%E6%93%8D%E4%BD%9C%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="vim输入模式介绍"><a href="#vim输入模式介绍" class="headerlink" title="vim输入模式介绍"></a>vim输入模式介绍</h1><p><strong>普通模式</strong>(esc)<br> 普通模式中，用户可执行一般的编辑器命令，如移动光标，删除文本等。这也是Vim启动后的默认模式。<br>普通模式命令往往需要一个操作符结尾。例如普通模式命令”dd”删除当前行，但是第一个”d”的后面可以跟另外的移动命令来代替第二个”d”，比如用移动到下一行的”j”键就可以删除当前行和下一行。另外还可以指定命令重复次数，“2dd”（重复”dd”两次），和”dj”的效果是一样的。<br> 在普通模式中，有很多方法可以进入插入模式。比较普通的方式是按<a>（append／追加）键或者<i>（insert／插入）键。</i></a></p>
<span id="more"></span>

<p>一般用i进入插入模式</p>
<p><strong>插入模式</strong>(i)<br> 在这个模式中，大多数按键都会向文本<strong>缓冲</strong>(buffer)中插入文本。<br> 在插入模式中，可以按<ESC>键回到普通模式。</ESC></p>
<p><strong>可视模式</strong>(v)<br>与普通模式相似。但移动命令会扩大高亮的文本区域。高亮区域可以是字符、行或者是一块文本。当执行一个非移动命令时，命令会被执行到这块高亮的区域上。</p>
<p>Vim的”文本对象”也能和移动命令一样用在这个模式中。</p>
<p>在普通模式中按<v>键进入可视模式<br>按<ctrl>+<V>进入可视块模式<br>按<shift>+<V>进入可视行模式</V></shift></V></ctrl></v></p>
<p><strong>选择模式</strong><br> 这个模式和无模式编辑器的行为比较相似（Windows标准文本控件的方式）。这个模式中，可以用鼠标或者光标键高亮选择文本，不过输入任何字符的话，Vim会用这个字符替换选择的高亮文本块，并且自动进入插入模式。</p>
<p>不常用</p>
<p><strong>命令行模式</strong><br>在普通模式使用&lt;:&gt;+[命令]进入命令行模式<br>命令行模式中可以输入会被解释成命令并执行的文本。</p>
<p>在命令执行之后，Vim返回到命令行模式之前的模式，通常是普通模式。</p>
<p><strong>Ex模式</strong><br> 这和命令行模式比较相似，在使用”:visual”命令离开Ex模式前，可以一次执行多条命令。</p>
<h3 id="【一般模式】"><a href="#【一般模式】" class="headerlink" title="【一般模式】"></a>【<strong>一般模式</strong>】</h3><h3 id="光标移动、复制粘贴、搜索替换"><a href="#光标移动、复制粘贴、搜索替换" class="headerlink" title="光标移动、复制粘贴、搜索替换"></a>光标移动、复制粘贴、搜索替换</h3><table>
<thead>
<tr>
<th>移动光标</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>h 或 向左箭头键(←)</td>
<td>光标向左移动一个字符</td>
</tr>
<tr>
<td>j 或 向下箭头键(↓)</td>
<td>光标向下移动一个字符</td>
</tr>
<tr>
<td>k 或 向上箭头键(↑)</td>
<td>光标向上移动一个字符</td>
</tr>
<tr>
<td>l 或 向右箭头键(→)</td>
<td>光标向右移动一个字符</td>
</tr>
<tr>
<td>如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。     如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键，     亦即加上想要进行的次数(数字)后，按下动作即可！</td>
<td></td>
</tr>
<tr>
<td>[Ctrl] + [f]</td>
<td>屏幕『向下』移动一页，相当于 [Page Down]按键     (常用)</td>
</tr>
<tr>
<td>[Ctrl] + [b]</td>
<td>屏幕『向上』移动一页，相当于 [Page Up] 按键     (常用)</td>
</tr>
<tr>
<td>[Ctrl] + [d]</td>
<td>屏幕『向下』移动半页</td>
</tr>
<tr>
<td>[Ctrl] + [u]</td>
<td>屏幕『向上』移动半页</td>
</tr>
<tr>
<td>+</td>
<td>光标移动到非空格符的下一行</td>
</tr>
<tr>
<td>-</td>
<td>光标移动到非空格符的上一行</td>
</tr>
<tr>
<td>n<space></space></td>
<td>那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n     个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</space></td>
</tr>
<tr>
<td>0 或功能键[Home]</td>
<td>这是数字『 0 』：移动到这一行的最前面字符处     (常用)</td>
</tr>
<tr>
<td>$ 或功能键[End]</td>
<td>移动到这一行的最后面字符处(常用)</td>
</tr>
<tr>
<td>H</td>
<td>光标移动到这个屏幕的最上方那一行的第一个字符</td>
</tr>
<tr>
<td>M</td>
<td>光标移动到这个屏幕的中央那一行的第一个字符</td>
</tr>
<tr>
<td>L</td>
<td>光标移动到这个屏幕的最下方那一行的第一个字符</td>
</tr>
<tr>
<td>G</td>
<td>移动到这个档案的最后一行(常用)</td>
</tr>
<tr>
<td>nG</td>
<td>n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20      行(可配合 :set nu)</td>
</tr>
<tr>
<td>gg</td>
<td>移动到这个档案的第一行，相当于 1G 啊！     (常用)</td>
</tr>
<tr>
<td>n<Enter></Enter></td>
<td>n 为数字。光标向下移动 n 行(常用)</td>
</tr>
<tr>
<td><strong>搜索替换</strong></td>
<td></td>
</tr>
<tr>
<td>/word</td>
<td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird      这个字符串，就输入 /vbird 即可！     (常用)</td>
</tr>
<tr>
<td>?word</td>
<td>向光标之上寻找一个字符串名称为 word 的字符串。</td>
</tr>
<tr>
<td>n</td>
<td>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说，     如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird      的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td>
</tr>
<tr>
<td>N</td>
<td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。     例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td>
</tr>
<tr>
<td>使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！</td>
<td></td>
</tr>
<tr>
<td>:n1,n2s/word1/word2/g</td>
<td>n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为     word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则：      『:100,200s/vbird/VBIRD/g』。(<em>常用</em>)</td>
</tr>
<tr>
<td>:1,$s/word1/word2/g 或 :%s/word1/word2/g</td>
<td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为     word2 ！(<em>常用</em>)</td>
</tr>
<tr>
<td>:1,$s/word1/word2/gc 或 :%s/word1/word2/gc</td>
<td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为     word2 ！且在取代前显示提示字符给用户确认 (confirm)     是否需要取代！(<em>常用</em>)</td>
</tr>
<tr>
<td><strong>删除、复制与贴上</strong></td>
<td></td>
</tr>
<tr>
<td>x, X</td>
<td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)，      X 为向前删除一个字符(相当于 [backspace] 亦即是退格键)     (常用)</td>
</tr>
<tr>
<td>nx</td>
<td>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符，     『10x』。</td>
</tr>
<tr>
<td>dd</td>
<td>删除游标所在的那一整行(<em>常用</em>)</td>
</tr>
<tr>
<td>ndd</td>
<td>n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行     (<em>常用</em>)</td>
</tr>
<tr>
<td>d1G</td>
<td>删除光标所在到第一行的所有数据</td>
</tr>
<tr>
<td>dG</td>
<td>删除光标所在到最后一行的所有数据</td>
</tr>
<tr>
<td>d$</td>
<td>删除游标所在处，到该行的最后一个字符</td>
</tr>
<tr>
<td>d0</td>
<td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td>
</tr>
<tr>
<td>yy</td>
<td>复制游标所在的那一行(常用)</td>
</tr>
<tr>
<td>nyy</td>
<td>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20     行(常用)</td>
</tr>
<tr>
<td>y1G</td>
<td>复制游标所在行到第一行的所有数据</td>
</tr>
<tr>
<td>yG</td>
<td>复制游标所在行到最后一行的所有数据</td>
</tr>
<tr>
<td>y0</td>
<td>复制光标所在的那个字符到该行行首的所有数据</td>
</tr>
<tr>
<td>y$</td>
<td>复制光标所在的那个字符到该行行尾的所有数据</td>
</tr>
<tr>
<td>p, P</td>
<td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！     举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后，     那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？     那么原本的第 20 行会被推到变成 30 行。     (常用)</td>
</tr>
<tr>
<td>J</td>
<td>将光标所在行与下一行的数据结合成同一行</td>
</tr>
<tr>
<td>c</td>
<td>重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td>
</tr>
<tr>
<td>u</td>
<td>复原前一个动作。(<em>常用</em>)</td>
</tr>
<tr>
<td>[Ctrl]+r</td>
<td>重做上一个动作。(<em>常用</em>)</td>
</tr>
<tr>
<td>.</td>
<td>重复前一个动作    (<em>常用</em>)</td>
</tr>
</tbody></table>
<h3 id="【编辑模式】"><a href="#【编辑模式】" class="headerlink" title="【编辑模式】"></a>【<strong>编辑模式</strong>】</h3><table>
<thead>
<tr>
<th>进入输入或取代的编辑模式</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>i, I</td>
<td>进入输入模式(Insert mode)：      i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。     (常用)</td>
</tr>
<tr>
<td>a, A</td>
<td>进入输入模式(Insert mode)：      a 为『从目前光标所在的下一个字符处开始输入』， A     为『从光标所在行的最后一个字符处开始输入』。(常用)</td>
</tr>
<tr>
<td>o, O</td>
<td>进入输入模式(Insert mode)：      这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』；     O 为在目前光标所在处的上一行输入新的一行！(常用)</td>
</tr>
<tr>
<td>r, R</td>
<td>进入取代模式(Replace mode)：      r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下     ESC 为止；(常用)</td>
</tr>
<tr>
<td>上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。想要在档案里面输入字符时一定要在左下角处看到 INSERT 或 REPLACE 才能输入！</td>
<td></td>
</tr>
<tr>
<td>[Esc]</td>
<td>退出编辑模式，回到一般模式中(常用)</td>
</tr>
</tbody></table>
<h3 id="【指令行模式】"><a href="#【指令行模式】" class="headerlink" title="【指令行模式】"></a>【<strong>指令行模式</strong>】</h3><table>
<thead>
<tr>
<th>指令行的储存、离开等指令</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>:w</td>
<td>将编辑的数据写入硬盘档案中(常用)</td>
</tr>
<tr>
<td>:w!</td>
<td>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入，     还是跟你对该档案的档案权限有关啊！</td>
</tr>
<tr>
<td>:q</td>
<td>离开 vi (常用)</td>
</tr>
<tr>
<td>:q!</td>
<td>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td>
</tr>
<tr>
<td>惊叹号 (!) 在 vim当中，常常具有『强制』的意思</td>
<td></td>
</tr>
<tr>
<td>:wq</td>
<td>储存后离开，若为 :wq! 则为强制储存后离开     (常用)</td>
</tr>
<tr>
<td>ZZ</td>
<td>这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于(保存并退出)</td>
</tr>
<tr>
<td>ZQ</td>
<td>不保存，强制退出。效果等同于 :q!。</td>
</tr>
<tr>
<td>:w [filename]</td>
<td>将编辑的数据储存成另一个档案（类似另存新档）</td>
</tr>
<tr>
<td>:r [filename]</td>
<td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』     这个档案内容加到游标所在行后面</td>
</tr>
<tr>
<td>:n1,n2 w [filename]</td>
<td>将 n1 到 n2 的内容储存成 filename 这个档案。</td>
</tr>
<tr>
<td>:! command</td>
<td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如      『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！</td>
</tr>
<tr>
<td><strong>vim 环境的变更</strong></td>
<td></td>
</tr>
<tr>
<td>:set nu</td>
<td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td>
</tr>
<tr>
<td>:set nonu</td>
<td>与 set nu 相反，为取消行号！</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>嵌入式Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA学习笔记2【基础概念】</title>
    <url>/2021/11/19/FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%E3%80%90%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E3%80%91/</url>
    <content><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>Xilinx系FPGA使用vivado全家桶进行开发</p>
<span id="more"></span>

<p>性价比/低功耗：Spartan系列，常见Spartan-6、Spartan-7</p>
<p>中端/性价比：Artix系列，常见Artix-6、Artix-7</p>
<p>中高端：Kintex系列，常见Kintex-7</p>
<p>旗舰：Virtex系列，常见Virtex-7</p>
<p>命名规则：以Spartan-7 xc7s15ftgb196-1为例</p>
<table>
<thead>
<tr>
<th>用途级别</th>
<th>哪一代产品</th>
<th>逻辑单元数</th>
<th>封装类型</th>
<th>RoHS</th>
<th>封装元件号</th>
<th>引脚数</th>
<th>速度等级</th>
</tr>
</thead>
<tbody><tr>
<td>xc</td>
<td>7</td>
<td>15</td>
<td>ft</td>
<td>g</td>
<td>b</td>
<td>196</td>
<td>-1</td>
</tr>
<tr>
<td>商业级</td>
<td>第7代</td>
<td>15k个逻辑单元（单位为k）</td>
<td>1mm</td>
<td>6/6</td>
<td></td>
<td>共196引脚</td>
<td>慢速</td>
</tr>
</tbody></table>
<p>速度等级如下</p>
<table>
<thead>
<tr>
<th>-1</th>
<th>-L1</th>
<th>-L2</th>
<th>-2</th>
<th>-3</th>
</tr>
</thead>
<tbody><tr>
<td>慢速</td>
<td>慢速低功耗</td>
<td>中等速度低功耗</td>
<td>中等速度</td>
<td>高速</td>
</tr>
</tbody></table>
<h2 id="FPGA内部资源简介"><a href="#FPGA内部资源简介" class="headerlink" title="FPGA内部资源简介"></a>FPGA内部资源简介</h2><p>常用可编程逻辑器件：</p>
<ul>
<li>CPLD：复杂可编程逻辑器件。基于<strong>乘积项</strong>的与或逻辑阵列，基于FLASH运行，逻辑写入后会一直保存，掉电不丢失</li>
<li>FPGA：现场可编程门阵列。基于<strong>查找表</strong>的CLB阵列，基于SRAM运行，采用CMOS工艺制造，逻辑写入后需要上电才能保存，掉电丢失</li>
</ul>
<p>这两种器件都只能编程数字电路，无法在其上建立模拟电路</p>
<p><strong>FPGA的编程数据实际上存储在其中的SRAM里</strong>，运行时将数据读出配置好片上硬件资源运行；很多FPGA会配有单独的PROM，在运行时先将PROM读入片内RAM，配置完成后，FPGA开始工作；掉电后FPGA内部逻辑关系清空</p>
<p><strong>FPGA可以反复使用</strong>，一块Artix传祖孙三代天天用都不成问题；如果使用外接PROM的方法，FPGA的编程不需要专用的FPGA编程器，只要用通用的PROM编程器编程即可</p>
<p>FPGA内部一般有以下硬件资源：</p>
<ul>
<li>可编程逻辑单元（Xilinx制造的FPGA中将其称为CLB可编程逻辑块，由多个基本的LUT查找表、REG寄存器、MUX多路选择器组成）</li>
<li>可编程IO单元（用于可编程逻辑与外部引脚的连接）</li>
<li>底层嵌入功能单元（包括但不限于PLL、ADC等数字/模拟电路器件）</li>
<li>嵌入式块RAM（用于存储内部数据和可编程的硬件逻辑）</li>
<li>布线资源（将各个功能模块之间连接起来）</li>
<li>硬核（只有一部分FPGA才会嵌入，一般功能比较专用）</li>
</ul>
<p>其中<strong>CLB是组成FPGA的基本逻辑单元</strong>，<strong>LUT则是FPGA中逻辑表达式的基础</strong></p>
<h2 id="常用电路结构"><a href="#常用电路结构" class="headerlink" title="常用电路结构"></a>常用电路结构</h2><p>FPGA不擅长顺序结构，更擅长并行结构，如果要使用FPGA处理顺序结构的算法，比较常用有限状态机模型（FSM）</p>
<h3 id="有限状态机FSM（Finite-State-Machine）"><a href="#有限状态机FSM（Finite-State-Machine）" class="headerlink" title="有限状态机FSM（Finite State Machine）"></a>有限状态机FSM（Finite State Machine）</h3><p>有限状态机：在有限个状态之间按一定规律转换的时序电路</p>
<p>在FPGA中经常使用<strong>mealy状态机，它由当前输入和当前状态共同决定其输出</strong></p>
<p>状态机内部使用状态寄存器来存储当前状态：<strong>状态寄存器</strong>由一组触发器组成，用于记忆状态机当前所处的状态，这个状态的改变一般只发生在时钟信号跳变沿</p>
<p>状态是否改变、如何改变都取决于当前输入和当前状态的组合逻辑F（<strong>F是当前状态和输入信号的函数</strong>）</p>
<p>状态机的输出则由当前输入和当前状态的输出组合逻辑G决定（<strong>G也是当前状态和输入信号的函数</strong>）</p>
<p>组合逻辑F是状态寄存器的激励，当时钟信号跳变时，组合逻辑被读入状态寄存器，同时当前状态被输出到组合逻辑G</p>
<p><strong>输出只取决于当前状态的状态机称为moore状态机</strong></p>
<h3 id="四段论法构建FSM"><a href="#四段论法构建FSM" class="headerlink" title="四段论法构建FSM"></a>四段论法构建FSM</h3><ol>
<li>定义状态空间</li>
</ol>
<p>主要任务是<strong>构建状态寄存器和输出寄存器</strong></p>
<p>所有状态的集合称为状态空间</p>
<p>使用verilog对状态进行编码，使用一组二进制数表示状态的过程即为定义状态空间</p>
<p>之后应当定义两个reg变量，分别用于存储当前状态和下一个状态；如果需要用到以前的状态，相关变量也应该在这时候进行定义</p>
<p>推荐使用<code>独热码</code>进行编码</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">parameter</span> a=<span class="number">4&#x27;b0001</span>;</span><br><span class="line"><span class="keyword">parameter</span> a=<span class="number">4&#x27;b0010</span>;</span><br><span class="line"><span class="keyword">parameter</span> a=<span class="number">4&#x27;b0100</span>;</span><br><span class="line"><span class="keyword">parameter</span> a=<span class="number">4&#x27;b1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] current_state;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] next_state;</span><br></pre></td></tr></table></figure>

<p>注意变量位宽与编码位宽一致</p>
<ol start="2">
<li>配置状态跳转规则（时序逻辑）</li>
</ol>
<p>主要任务是<strong>构建组合逻辑G的状态转移部分</strong></p>
<p>一般使用<code>always块</code>配合posedge、negedge进行控制，敏感列表以时钟信号和复位边沿信号的组合进行定义</p>
<p>在块中使用非阻塞赋值来保证电路实时性</p>
<ol start="3">
<li>判断下个状态（组合逻辑）</li>
</ol>
<p>主要任务是<strong>构建组合逻辑F的输出部分</strong></p>
<p>使用当前状态和输入信号组成always块的敏感列表</p>
<p>使用<code>case</code>语句通过当前状态的编码筛选出当前状态，<strong>在case语句内嵌套</strong><code>if..else...</code>语句，根据输入信号情况为下一状态进行赋值（注意：<strong>if和else一定要配对</strong>，否则可能产生latch）</p>
<p>在块中使用阻塞赋值来保证电路不会出现时序错误</p>
<ol start="4">
<li>设置各个状态下的动作（组合逻辑）</li>
</ol>
<p>主要任务是<strong>构建组合逻辑G的输出寄存器</strong></p>
<p>一般是使用<code>assign</code>语句或<code>always块</code>对动作进行赋值</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用assign语句</span></span><br><span class="line"><span class="keyword">wire</span> output_1;</span><br><span class="line"><span class="keyword">assign</span> output_1=(current_state == T) ? <span class="number">1&#x27;b0</span> :<span class="number">1&#x27;b1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用always块</span></span><br><span class="line"><span class="keyword">wire</span> output_1;</span><br><span class="line"><span class="keyword">always</span> @(current_state) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(current_state == T)</span><br><span class="line">        output_1=<span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        output_1=<span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>不管使用哪种形式都应该以当前状态为基准进行判断</p>
<p>第四个部分搭建的电路相当于在组合输出逻辑G后面再加了一层由clk为控制时钟的同步寄存器，可以将输出逻辑与外部电路隔离</p>
<p>不加第四个部分的电路相当于由三段法构建，加上第四个部分的电路才是完整的四段法状态机</p>
<p>第四个部分的作用如下：</p>
<ul>
<li>滤除组合逻辑输出的毛刺</li>
<li>更有效地进行时序计算与约束</li>
<li>更容易使总线数据对齐，减小总线数据间偏移（防止总线信号线到达时间的差距），减小接收端数据采样出错的频率</li>
</ul>
<h3 id="加法器与乘法器"><a href="#加法器与乘法器" class="headerlink" title="加法器与乘法器"></a>加法器与乘法器</h3><p>直接在verilog模块中使用普通加法、乘法运算，综合后就可以得到超前进位加法器、乘法器，可以通过设置综合优化项目获取更小面积或更高性能</p>
<h1 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h1><p>以点灯程序为例</p>
<h2 id="确定设计方向"><a href="#确定设计方向" class="headerlink" title="确定设计方向"></a>确定设计方向</h2><ol>
<li>设计控制LED的GPIO，引出到外部引脚</li>
<li>设计计数器，控制1s延时</li>
<li>系统由50MHz时钟控制</li>
<li>需要一个复位信号输入</li>
</ol>
<h2 id="使用vivado开发"><a href="#使用vivado开发" class="headerlink" title="使用vivado开发"></a>使用vivado开发</h2><p>vivado是xilinx推出的专用于自家FPGA、SoC的IDE，提供了包括可视化IDE、Tcl脚本、Tcl Shell、IDE内嵌Tcl控制台命令的使用方式。使用流程在vivado界面左端的目录中展示</p>
<p>提供Tcl、AXI4、IP-XACT、Synopsys设计约束（SDC）等业界标准支持，Verilog HDL、VHDL、SystemVerilog三种硬件描述语言的支持，SystemC、C、C++三种软件语言高层次综合（HLS）的支持</p>
<h3 id="vivado中的电路结构网表描述"><a href="#vivado中的电路结构网表描述" class="headerlink" title="vivado中的电路结构网表描述"></a>vivado中的电路结构网表描述</h3><p>网表由单元（Ceil）、引脚（Pin）、端口（Port）、网络（Net）组成</p>
<p><strong>单元</strong>即设计单元，包括设计模块/实体、元件库中的基本元素（如LUT、FF、RAM、DSP等）、硬件功能的类属技术表示和黑盒</p>
<p><strong>引脚</strong>是单元上的连接点</p>
<p><strong>端口</strong>是设计的顶层端口</p>
<p><strong>网络</strong>类似电路设计中的“节点”，连接引脚、端口</p>
<h3 id="工程数据的目录结构"><a href="#工程数据的目录结构" class="headerlink" title="工程数据的目录结构"></a>工程数据的目录结构</h3><p><strong>和其他软件IDE一样</strong>，vivado中所有用户工程数据保存在当前工程目录中</p>
<p>vivado将统一的数据模型贯穿于整个设计流程中，使用Design Checkpoint（包含逻辑网表、约束、物理数据）文件对开发进度进行管理，该文件会在开发过程中生成，后缀名为<code>.dcp</code></p>
<p>项目目录下会包含以下内容</p>
<ul>
<li><p>工程名.xpr</p>
<p>  工程设置文件</p>
</li>
<li><p>工程名.run目录</p>
<p>  包含所有运行数据</p>
</li>
<li><p>工程名.srcs目录</p>
<p>  包含所有导入的HDL源文件、网表和XDC文件</p>
<p>  这些是设计过程中主要编写的文件</p>
</li>
<li><p>工程名.data目录</p>
<p>  保存布局规划和网表数据</p>
</li>
</ul>
<p>除此之外，vivado还会生成以下两种文件</p>
<ul>
<li><p>Journal文件（Vivado.jou）</p>
<p>  只包含Vivado IDE中执行的Tcl命令</p>
<p>  该文件会被保存在用户主目录下（如${HOME}或C:\Users\Administrator\AppData\Roaming\Xilinx\Vivado）</p>
<p>  用这个文件实现类似shell中“记录历史命令”的功能</p>
</li>
<li><p>Log文件</p>
<p>  包含Vivado IDE中所产生的所有消息（也会包含Tcl命令和结果、警告/错误信息）</p>
<p>  一般会和Journal文件保存在一起</p>
</li>
</ul>
<h3 id="vivado项目文件夹"><a href="#vivado项目文件夹" class="headerlink" title="vivado项目文件夹"></a>vivado项目文件夹</h3><p>一个vivado项目的文件夹通常包含以下几项：</p>
<ul>
<li>.xpr文件：Vivado IDE项目文件</li>
<li>.runs目录：包含所有运行数据</li>
<li>.srcs目录：包含所有被引用的HDL源文件和约束文件（网表文件、XDC文件等）</li>
<li>.data目录：存储和网表数据</li>
<li>.xdc目录：单独存储所有约束文件</li>
<li>.sim目录：存储所有仿真文件和testbench</li>
</ul>
<h3 id="Vivado设计模式"><a href="#Vivado设计模式" class="headerlink" title="Vivado设计模式"></a>Vivado设计模式</h3><ol>
<li><p>工程模式</p>
<p> 就是上面所说的创建工程-按照左边的流程一点点完成</p>
</li>
<li><p>非工程模式</p>
<p> 这是<strong>基于Tcl脚本的编译风格方法</strong>，用户需要自己管理源文件和设计流程</p>
<p> 全部使用Tcl指令运行，可以精确到每一步，会很繁琐但可以精细控制设计过程</p>
</li>
</ol>
<h3 id="XDC文件"><a href="#XDC文件" class="headerlink" title="XDC文件"></a>XDC文件</h3><p><strong>Vivado的一个特殊点就是它使用Xilinx设计约束（XDC）格式，不再支持ISE曾使用的用户约束文件（UCF）格式</strong></p>
<p>XDC约束是业界标准Synopsys设计约束（SDC）和Xilinx专有物理约束的组合</p>
<p>XDC文件是遵循Tcl语法的命令，使用vivado内置的Tcl解释器可以直接分析这些命令</p>
<p>特别注意：XDC命令是<strong>顺序执行</strong>的</p>
<h3 id="开发流程-1"><a href="#开发流程-1" class="headerlink" title="开发流程"></a>开发流程</h3><p>使用外部晶振作为时钟</p>
<p>在高级应用中通常会再写一个分频器或倍频器用于稳定信号或用于控制电路频率</p>
<h4 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h4><p>外部时钟为50MHz</p>
<p>系统时钟部分</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> LED(</span><br><span class="line">    <span class="keyword">input</span> clk,<span class="comment">//外部晶振时钟输入</span></span><br><span class="line">    <span class="keyword">input</span> <span class="number">_</span>rst,<span class="comment">//复位引脚输入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">1</span>:<span class="number">0</span>] led<span class="comment">//输出引脚控制LED</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>计数器部分</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">25</span>:<span class="number">0</span>] counter;<span class="comment">//外部时钟50MHz，计时1s，需要26位计数器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> <span class="number">_</span>rst)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="number">_</span>rst)<span class="comment">//如果复位引脚接地（按下复位按键）</span></span><br><span class="line">        counter&lt;=<span class="number">26&#x27;d0</span>;<span class="comment">//计数寄存器清零（复位）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(counter&lt;<span class="number">26&#x27;d5000_0000</span>)</span><br><span class="line">        counter&lt;=counter+<span class="number">1&#x27;b1</span>;<span class="comment">//向上计数</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        counter&lt;=<span class="number">26&#x27;d0</span>;<span class="comment">//到达计数上限时清零</span></span><br></pre></td></tr></table></figure>

<p>LED状态控制部分</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> led=(counter&lt;<span class="number">26&#x27;d2500_0000</span>) ? <span class="number">2&#x27;b01</span> : <span class="number">2&#x27;b10</span>;</span><br><span class="line"><span class="comment">//计数器小于计数位置时输出01，否则输出10</span></span><br></pre></td></tr></table></figure>

<p>总文件如下所示</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//`timescale 1ns / 1ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> LED(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> <span class="number">_</span>rst,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">1</span>:<span class="number">0</span>] led</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//时钟寄存器</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">25</span>:<span class="number">0</span>] counter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IO输出部分</span></span><br><span class="line"><span class="keyword">assign</span> led=(counter&lt;<span class="number">26&#x27;d2500_0000</span>) ? <span class="number">2&#x27;b01</span> : <span class="number">2&#x27;b10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计数器部分</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> <span class="number">_</span>rst)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="number">_</span>rst)</span><br><span class="line">        counter&lt;=<span class="number">26&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(counter&lt;<span class="number">26&#x27;d5000_0000</span>)</span><br><span class="line">        counter&lt;=counter+<span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        counter&lt;=<span class="number">26&#x27;d0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h4 id="调用-自行配置IP、DSP等内部电路"><a href="#调用-自行配置IP、DSP等内部电路" class="headerlink" title="调用/自行配置IP、DSP等内部电路"></a>调用/自行配置IP、DSP等内部电路</h4><p>在vivado创建工程界面中常使用以下工程种类：</p>
<ol>
<li><p>RTL工程</p>
<p> 用户可以添加RTL源文件、Xilinx IP目录内的已有IP、用于层次化模块的EDIF网表、Vivado IP集成器内创建的块设计、数字信号处理的源文件到Vivado的<strong>RTL工程</strong>。其中使用已有IP可以包含Xilinx生成的XCI文件、由核生成器工具生成的已经过时的XCO文件、预编译的EDIF或者GNC格式的IP网表这些类型</p>
</li>
<li><p>Post-synthesis工程</p>
<p> 使用综合后的网表创建工程</p>
<p> 用户通过vivado、XST或第三方综合工具生成网表后选择这一工程选项，快速将其他平台的设计导入xilinx平台</p>
</li>
<li><p>I/O Planning工程</p>
<p> 创建一个空的I/O规划工程，先分配I/O和约束，再创建CSV、XDC和RTL输出文件。这些文件可用于创建原理图符号或印制PCB</p>
</li>
</ol>
<h4 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h4><p><strong>综合</strong>：将RTL级设计描述转换成门级描述的过程</p>
<p>vivado的综合是基于时间驱动的，为存储器利用率和性能做了优化。目前综合工具支持SystemVerilog、VHDL、Verilog三种语言及它们的混合，且支持XDC格式</p>
<p>综合工具需要使用XDC约束驱动综合优化，所以<strong>必须存在XDC文件</strong></p>
<h4 id="确定约束"><a href="#确定约束" class="headerlink" title="确定约束"></a>确定约束</h4><p>有两种类型的设计约束：</p>
<ul>
<li>物理约束：定义了引脚的位置和内部单元的绝对或相对位置，内部单元包括RAM、LUT、触发器和器件配置设置</li>
<li>时序约束：定义设计要求的频率。如果没有时序约束，Vivado仅会对布线长度和布局阻塞进行优化</li>
</ul>
<p>选择【Option】-【Strategy】右侧的下拉框中用于运行综合的预定义综合策略，设计者可以定义优化的方向</p>
<h4 id="执行综合"><a href="#执行综合" class="headerlink" title="执行综合"></a>执行综合</h4><p>RTL文件综合后将自动生成时序总结、时钟及其网络、DRC报告、噪声报告、利用率报告、功耗报告、原理图等选项，可以使用原理图查看综合后生成的完整网表结构</p>
<p>综合后，设计会表示为模块（Verilog中的module）、实体（VHDL中的Entity）的实例与基本元素（LUT、触发器、进位链元素、多路复用器MUX、块RAM、DSP单元、时钟元素、IO元素等）的网表集合</p>
<p>每个LUT表述的逻辑都能单独查看（真值表）</p>
<p>在windows下vivado的综合速度较慢，开始综合后需要等待一段时间</p>
<h4 id="行为级仿真"><a href="#行为级仿真" class="headerlink" title="行为级仿真"></a>行为级仿真</h4><p>在Simulation Sources目录下添加testbench文件，编写测试代码后就可以进行仿真</p>
<p>在左侧从窗口内找到SIMULATION选项并展开，点击【Run Simulation】-【Run Behavioral Simulation】就可以开始仿真</p>
<p>在Tcl Console中输入run命令可以控制仿真的运行时间；输入restart命令可以重新执行仿真</p>
<h4 id="实现约束"><a href="#实现约束" class="headerlink" title="实现约束"></a>实现约束</h4><h5 id="I-O规划"><a href="#I-O规划" class="headerlink" title="I/O规划"></a>I/O规划</h5><p>使用I/O Planning进行FPGA的输出引脚规划</p>
<p>可以使用Vivado的图形化界面添加引脚约束（点击I/O Planning选项），也可以在Constraints目录下添加约束文件并自行编写引脚约束</p>
<p>==注意约束文件使用XDC格式==</p>
<h5 id="设计实现"><a href="#设计实现" class="headerlink" title="设计实现"></a>设计实现</h5><p>在左侧选择【IMPLEMENTATION】，选择实现策略，可以自行调节设计实现优化的方向，包括以下内容：</p>
<ul>
<li>提高设计性能</li>
<li>减少LUT个数</li>
<li>添加整体功耗优化</li>
<li>修改流程步骤</li>
<li>减少阻塞和相关问题</li>
</ul>
<p>点击【Run Implementation】来执行设计实现</p>
<p>待完成后可以打开设计实现来查看FPGA内部布线及实际使用的逻辑资源</p>
<p>也可以查看相关报告</p>
<h4 id="静态时序分析STA"><a href="#静态时序分析STA" class="headerlink" title="静态时序分析STA"></a>静态时序分析STA</h4><p>一个器件的性能由构成设计单元的延迟决定，它可以通过静态时序分析（Static Timing Analysis，STA）验证</p>
<p>简单来说STA就是用来控制细化设备的延迟和时序的调试过程</p>
<h5 id="时序仿真"><a href="#时序仿真" class="headerlink" title="时序仿真"></a>时序仿真</h5><ol>
<li>选择需要使用的test-bench文件</li>
<li>选择vivado界面左侧【Run Simulation】-【Run Post-Implementation Timing Simulation】（运行实现后时序仿真）</li>
<li>执行时序仿真并观察仿真波形进行debug</li>
</ol>
<h4 id="生成比特流文件"><a href="#生成比特流文件" class="headerlink" title="生成比特流文件"></a>生成比特流文件</h4><p>比特流文件就是用于配置FPGA的编程文件，可以直接使用烧录器将比特流文件下载到目标FPGA中</p>
<ol>
<li><p>配置器件属性</p>
<p> 选择器件型号并进一步选择生成比特流文件的硬件约束</p>
</li>
<li><p>生成可编程文件</p>
<p> 在左侧窗口中选择【PROGRAM AND DEBUG】并右键选择【Bitstream Settings】即可打开比特流优化配置界面</p>
<p> 默认只生成一个二进制比特流<code>.bit</code>文件</p>
<p> 可以选择配置设定产生原始比特流<code>.rbt</code>文件、掩码文件、ASCII逻辑定位文件<code>.ll</code>、纯二进制文件<code>.bin</code>等选项</p>
</li>
</ol>
<h4 id="烧录使用"><a href="#烧录使用" class="headerlink" title="烧录使用"></a>烧录使用</h4><ol>
<li>开发板正常上电</li>
<li>开发板连接烧录器</li>
<li>将烧录器连接到PC并使用vivado连接烧录器（点击Auto Connect）</li>
<li>点击【Program Device】即可开始烧录</li>
</ol>
<h4 id="生成并烧录PROM文件"><a href="#生成并烧录PROM文件" class="headerlink" title="生成并烧录PROM文件"></a>生成并烧录PROM文件</h4><ol>
<li>除了生成比特流文件外还需要再选中“-bin_file”生成纯二进制文件</li>
<li>重新生成比特流文件和二进制文件</li>
<li>按照上面步骤连接开发板并在【Add Configuration Memory Part】-【Select Configuration Memory Part】中设置可用的SPI FLASH</li>
<li>正常烧录</li>
<li>配置开发板使PROM上电后自动将逻辑配置文件加载到FPGA</li>
</ol>
<h3 id="vivado支持的特殊开发方式"><a href="#vivado支持的特殊开发方式" class="headerlink" title="vivado支持的特殊开发方式"></a>vivado支持的特殊开发方式</h3><p>vivado是<strong>以IP为核心</strong>的设计工具</p>
<p>vivado具有一个<strong>共享的IP数据库</strong></p>
<h4 id="高层次综合"><a href="#高层次综合" class="headerlink" title="高层次综合"></a>高层次综合</h4><p>使用Vivado HLS软件可以将c、c++、system c语言编写的算法代码直接综合生成RTL代码</p>
<p>HLS从C语言中提取硬件结构的思路如下</p>
<ol>
<li>在顶层，从C代码中提取控制和数据通路</li>
<li>在顶层控制流的一些点将控制传递到子程序中</li>
<li>子程序可以与顶层或其他子程序并行执行</li>
<li>通过调度和绑定过程将C代码映射到硬件逻辑资源</li>
</ol>
<p>C代码的关键属性</p>
<ul>
<li><p>函数</p>
<p>  所有代码由函数组成，函数名被对应到RTL描述的模块</p>
</li>
<li><p>参数</p>
<p>  顶层函数的参数决定了硬件RTL本身的端口</p>
</li>
<li><p>类型</p>
<p>  变量类型越复杂，实现该变量所占用的面积越多</p>
</li>
<li><p>循环</p>
<p>  默认对于循环采用“回卷”的方式进行处理。对于每个C循环迭代，采用相同的状态或资源来实现。循环的处理分成三个部分：循环展开、循环平坦化和循环合并。默认情况下不展开循环，并将嵌套循环“平坦化”：将外层循环拆解为多个内层循环的组合；之后还会自动合并循环：将结果可以合并的多个循环在硬件层面上合并到统一的器件上</p>
</li>
<li><p>数组</p>
<p>  C代码中的数组常常被映射到FPGA中的BRAM资源，会因为存储器的读写操作具有互斥性而使得它会变成设备的性能瓶颈</p>
</li>
<li><p>操作符</p>
<p>  C代码中的操作符可能要求共享，通过共享可以在满足性能的前提下以控制面积或指定的硬件实现来满足并行化要求</p>
</li>
</ul>
<p>类似的，也可以使用C++算法描述并进行HLS</p>
<h4 id="IP集成库"><a href="#IP集成库" class="headerlink" title="IP集成库"></a>IP集成库</h4><p>Vivado提供了一个图形化界面用于调用自定义IP核，也可以使用代码方式调用IP核。IP核类似编程中的函数库，提供了数学运算加速器、硬件信号处理等电路，可以直接调用，非常方便</p>
<p>在左侧选择IP Catalog即可调用Vivado内置的一些IP核</p>
<p>点击即可调用，有些IP核需要自行下载</p>
<p>在弹出的窗口中调整IP核的相关约束，根据指示添加即可调用相关内容</p>
<p>用户也可以自行封装IP核以及自行连接已有IP核</p>
]]></content>
      <tags>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA学习笔记3【基于Vivado封装自定义IP】</title>
    <url>/2021/11/19/FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E3%80%90%E5%9F%BA%E4%BA%8EVivado%E5%B0%81%E8%A3%85%E8%87%AA%E5%AE%9A%E4%B9%89IP%E3%80%91/</url>
    <content><![CDATA[<h1 id="封装带AXI接口的自定义IP核"><a href="#封装带AXI接口的自定义IP核" class="headerlink" title="封装带AXI接口的自定义IP核"></a>封装带AXI接口的自定义IP核</h1><p>为了更方便地使用外部接口驱动或进行系统级的设计时，可以考虑将RTL设计打包制作成自定义的IP核，Vivado会自动生成相关的IP核接口；或者为了在ZYNQ中使用AXI总线将硬核与FPGA硬件部分互联，可以将FPGA部分的RTL设计打包成自定义IP核，Vivado会自动将生成的IP核的接口制作好，使用图形化界面就能快速实现SoC设计。特别地，可以使用这种方法在硬核外挂载软核</p>
<p>在Vivado的设计思想中，一个IP核就相当于一个函数，可以通过重用IP核做到模块化设计的效果</p>
<p>可以参考Xilinx Vivado封装自定义IP参考手册【代号ug1118】来获得更详细的操作指示</p>
<p>第一部分仅说明带AXI接口的自定义IP核封装方法</p>
<span id="more"></span>

<h2 id="创建与封装自定义IP的意义"><a href="#创建与封装自定义IP的意义" class="headerlink" title="创建与封装自定义IP的意义"></a>创建与封装自定义IP的意义</h2><p>在Vivado中含有一个IP Catalog流程，可以将下列源文档封装成自定义的IP</p>
<ul>
<li>RTL级HDL源文件</li>
<li>模拟模型文件</li>
<li>示例设计文件</li>
<li>Testbench</li>
<li>项目文件目录</li>
<li>Block Design</li>
</ul>
<p>同时Vivado也内置了Xilinx自制IP、第三方IP、用户定义IP的库</p>
<p>比起传统“Add Module”将RTL代码以中间级模块的方式例化添加到顶层模块，再封装出统一的顶层模块这样的操作流程，通过可视化的IP核管理可以更快速地实现项目模块化和后期完善修改流程</p>
<h2 id="创建自定义IP"><a href="#创建自定义IP" class="headerlink" title="创建自定义IP"></a>创建自定义IP</h2><p>示例程序使用自定义的IP实现LED呼吸灯效果</p>
<p>这个IP使用AXI接口与ZYNQ的硬核连接，可以使用软件控制IP核的“外设控制寄存器”来对自定义IP核的工作状况进行控制</p>
<h3 id="创建IP工程"><a href="#创建IP工程" class="headerlink" title="创建IP工程"></a>创建IP工程</h3><p>为了更好管理自定义IP核，通常将用户的RTL代码统一管理在独立目录下</p>
<p>在Vivado开始界面选择【Tasks】-【Manage IP】，选择新建一个IP核管理目录或打开已有目录，并新建项目</p>
<p>根据自己的硬件设备和习惯使用的HDL选择针对性的选项</p>
<p>完成创建后，选择【Tools】-【Create and Package New IP】</p>
<p><img src="/2021/11/19/FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E3%80%90%E5%9F%BA%E4%BA%8EVivado%E5%B0%81%E8%A3%85%E8%87%AA%E5%AE%9A%E4%B9%89IP%E3%80%91/image-20210511132753582.png" alt="image-20210511132753582"></p>
<p>如果准备创建一个单独的IP，可以直接Next，相关内容在下一部分介绍；在这里因为准备创建的项目需要使用到AXI4接口与硬核交互，所以选择最后这个选项</p>
<p>设置IP核名称后如下图进行AXI接口设置</p>
<p><img src="/2021/11/19/FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E3%80%90%E5%9F%BA%E4%BA%8EVivado%E5%B0%81%E8%A3%85%E8%87%AA%E5%AE%9A%E4%B9%89IP%E3%80%91/image-20210511162506573.png" alt="image-20210511162506573"></p>
<p>其中AXI接口有三种类型：</p>
<ul>
<li>Lite：适合数据量较小、速度较快的信号传输</li>
<li>Full：全规格的AXI总线，适合标准类型的数据传输</li>
<li>Stream：数据流传输，适合音视频信号等大规模数据的高速传输</li>
</ul>
<p>还有两种模式：</p>
<ul>
<li>Slave：从模式，IP接受外部数据控制</li>
<li>Master：主模式，IP控制外部设备</li>
</ul>
<p>完成设置后可以看到右侧User Repository中出现了自定义IP核</p>
<p><img src="/2021/11/19/FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E3%80%90%E5%9F%BA%E4%BA%8EVivado%E5%B0%81%E8%A3%85%E8%87%AA%E5%AE%9A%E4%B9%89IP%E3%80%91/image-20210511162609747.png" alt="image-20210511162609747"></p>
<p>这里右键IP核，选择【Edit in IP Packager】，之后Vivado会打开一个新界面用于管理IP核的RTL代码</p>
<p>自动生成的RTL代码分为两部分，一个是顶层模块，另一个是AXI总线接口逻辑；RTL代码中还默认生成了AXI总线相关逻辑的例化和提供给用户使用的区域（包括<strong>自定义参数</strong>、<strong>自定义端口</strong>、<strong>自定义顶层模块例化</strong>），但是需要注意：如果在AXI总线上开辟了独立的新端口，需要将相关代码单独添加到AXI总线逻辑的RTL代码中</p>
<h3 id="编写IP内部RTL代码"><a href="#编写IP内部RTL代码" class="headerlink" title="编写IP内部RTL代码"></a>编写IP内部RTL代码</h3><p>顶层例化代码如下所示：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 1 ns / 1 ps</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">module</span> breath_LED_IP_v1_0 #</span><br><span class="line">	(</span><br><span class="line">		<span class="comment">// Users to add parameters here</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// User parameters ends</span></span><br><span class="line">		<span class="comment">// Do not modify the parameters beyond this line</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// Parameters of Axi Slave Bus Interface S0_AXI</span></span><br><span class="line">		<span class="keyword">parameter</span> <span class="keyword">integer</span> C_S0_AXI_DATA_WIDTH	= <span class="number">32</span>,</span><br><span class="line">		<span class="keyword">parameter</span> <span class="keyword">integer</span> C_S0_AXI_ADDR_WIDTH	= <span class="number">4</span></span><br><span class="line">	)</span><br><span class="line">	(</span><br><span class="line">		<span class="comment">// Users to add ports here</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// User ports ends</span></span><br><span class="line">		<span class="comment">// Do not modify the ports beyond this line</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">// Ports of Axi Slave Bus Interface S0_AXI</span></span><br><span class="line">		<span class="keyword">input</span> <span class="keyword">wire</span>  s0_axi_aclk,</span><br><span class="line">		<span class="keyword">input</span> <span class="keyword">wire</span>  s0_axi_aresetn,</span><br><span class="line">		<span class="keyword">input</span> <span class="keyword">wire</span> [C_S0_AXI_ADDR_WIDTH-<span class="number">1</span> : <span class="number">0</span>] s0_axi_awaddr,</span><br><span class="line">		<span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">2</span> : <span class="number">0</span>] s0_axi_awprot,</span><br><span class="line">		<span class="keyword">input</span> <span class="keyword">wire</span>  s0_axi_awvalid,</span><br><span class="line">		<span class="keyword">output</span> <span class="keyword">wire</span>  s0_axi_awready,</span><br><span class="line">		<span class="keyword">input</span> <span class="keyword">wire</span> [C_S0_AXI_DATA_WIDTH-<span class="number">1</span> : <span class="number">0</span>] s0_axi_wdata,</span><br><span class="line">		<span class="keyword">input</span> <span class="keyword">wire</span> [(C_S0_AXI_DATA_WIDTH/<span class="number">8</span>)-<span class="number">1</span> : <span class="number">0</span>] s0_axi_wstrb,</span><br><span class="line">		<span class="keyword">input</span> <span class="keyword">wire</span>  s0_axi_wvalid,</span><br><span class="line">		<span class="keyword">output</span> <span class="keyword">wire</span>  s0_axi_wready,</span><br><span class="line">		<span class="keyword">output</span> <span class="keyword">wire</span> [<span class="number">1</span> : <span class="number">0</span>] s0_axi_bresp,</span><br><span class="line">		<span class="keyword">output</span> <span class="keyword">wire</span>  s0_axi_bvalid,</span><br><span class="line">		<span class="keyword">input</span> <span class="keyword">wire</span>  s0_axi_bready,</span><br><span class="line">		<span class="keyword">input</span> <span class="keyword">wire</span> [C_S0_AXI_ADDR_WIDTH-<span class="number">1</span> : <span class="number">0</span>] s0_axi_araddr,</span><br><span class="line">		<span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">2</span> : <span class="number">0</span>] s0_axi_arprot,</span><br><span class="line">		<span class="keyword">input</span> <span class="keyword">wire</span>  s0_axi_arvalid,</span><br><span class="line">		<span class="keyword">output</span> <span class="keyword">wire</span>  s0_axi_arready,</span><br><span class="line">		<span class="keyword">output</span> <span class="keyword">wire</span> [C_S0_AXI_DATA_WIDTH-<span class="number">1</span> : <span class="number">0</span>] s0_axi_rdata,</span><br><span class="line">		<span class="keyword">output</span> <span class="keyword">wire</span> [<span class="number">1</span> : <span class="number">0</span>] s0_axi_rresp,</span><br><span class="line">		<span class="keyword">output</span> <span class="keyword">wire</span>  s0_axi_rvalid,</span><br><span class="line">		<span class="keyword">input</span> <span class="keyword">wire</span>  s0_axi_rready</span><br><span class="line">	);</span><br><span class="line"><span class="comment">// Instantiation of Axi Bus Interface S0_AXI</span></span><br><span class="line">	breath_LED_IP_v1_0_S0_AXI # ( </span><br><span class="line">		<span class="variable">.C_S_AXI_DATA_WIDTH</span>(C_S0_AXI_DATA_WIDTH),</span><br><span class="line">		<span class="variable">.C_S_AXI_ADDR_WIDTH</span>(C_S0_AXI_ADDR_WIDTH)</span><br><span class="line">	) breath_LED_IP_v1_0_S0_AXI_inst (</span><br><span class="line">		<span class="variable">.led</span>(led),</span><br><span class="line">		<span class="variable">.S_AXI_ACLK</span>(s0_axi_aclk),</span><br><span class="line">		<span class="variable">.S_AXI_ARESETN</span>(s0_axi_aresetn),</span><br><span class="line">		<span class="variable">.S_AXI_AWADDR</span>(s0_axi_awaddr),</span><br><span class="line">		<span class="variable">.S_AXI_AWPROT</span>(s0_axi_awprot),</span><br><span class="line">		<span class="variable">.S_AXI_AWVALID</span>(s0_axi_awvalid),</span><br><span class="line">		<span class="variable">.S_AXI_AWREADY</span>(s0_axi_awready),</span><br><span class="line">		<span class="variable">.S_AXI_WDATA</span>(s0_axi_wdata),</span><br><span class="line">		<span class="variable">.S_AXI_WSTRB</span>(s0_axi_wstrb),</span><br><span class="line">		<span class="variable">.S_AXI_WVALID</span>(s0_axi_wvalid),</span><br><span class="line">		<span class="variable">.S_AXI_WREADY</span>(s0_axi_wready),</span><br><span class="line">		<span class="variable">.S_AXI_BRESP</span>(s0_axi_bresp),</span><br><span class="line">		<span class="variable">.S_AXI_BVALID</span>(s0_axi_bvalid),</span><br><span class="line">		<span class="variable">.S_AXI_BREADY</span>(s0_axi_bready),</span><br><span class="line">		<span class="variable">.S_AXI_ARADDR</span>(s0_axi_araddr),</span><br><span class="line">		<span class="variable">.S_AXI_ARPROT</span>(s0_axi_arprot),</span><br><span class="line">		<span class="variable">.S_AXI_ARVALID</span>(s0_axi_arvalid),</span><br><span class="line">		<span class="variable">.S_AXI_ARREADY</span>(s0_axi_arready),</span><br><span class="line">		<span class="variable">.S_AXI_RDATA</span>(s0_axi_rdata),</span><br><span class="line">		<span class="variable">.S_AXI_RRESP</span>(s0_axi_rresp),</span><br><span class="line">		<span class="variable">.S_AXI_RVALID</span>(s0_axi_rvalid),</span><br><span class="line">		<span class="variable">.S_AXI_RREADY</span>(s0_axi_rready)</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Add user logic here</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// User logic ends</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>默认生成的顶层代码大同小异，无非是AXI总线有无的区别</p>
<p>这里省略AXI总线逻辑代码（太长了）</p>
<p>注意改动代码时如果涉及到接口，需要同时修改顶层代码和AXI总线实现</p>
<p>其中比较常用的部分已经被Vivado自动空出来，如下所示：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在开头有这四行代码</span></span><br><span class="line">	<span class="comment">// Users to add parameters here</span></span><br><span class="line"><span class="comment">//中间可以存放自定义的参数</span></span><br><span class="line">	<span class="comment">// User parameters ends</span></span><br><span class="line">	......</span><br><span class="line">	<span class="comment">// Users to add ports here</span></span><br><span class="line"><span class="comment">//中间可以存放自定义的端口代码</span></span><br><span class="line">	<span class="comment">// User ports ends</span></span><br><span class="line">	......</span><br><span class="line"><span class="comment">//在末尾有这两行代码</span></span><br><span class="line">	<span class="comment">// Add user logic here</span></span><br><span class="line"><span class="comment">//中间就可以存放自定义的模块顶层例化代码</span></span><br><span class="line">	<span class="comment">// User logic ends</span></span><br></pre></td></tr></table></figure>

<p>右键点击【Design Sources】，选择添加新的HDL文件，编写呼吸灯控制代码，如下所示，并保存</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> breath_led(</span><br><span class="line">    <span class="keyword">input</span>          clk            , <span class="comment">//时钟信号</span></span><br><span class="line">    <span class="keyword">input</span>          <span class="number">_</span>rst           , <span class="comment">//复位信号</span></span><br><span class="line">    <span class="keyword">input</span>          sw_ctrl        , <span class="comment">//控制寄存器：呼吸灯开关控制信号 1：亮 0:灭</span></span><br><span class="line">    <span class="keyword">input</span>          led_en         , <span class="comment">//控制寄存器：设置呼吸灯频率设置使能信号</span></span><br><span class="line">    <span class="keyword">input</span>   [<span class="number">9</span>:<span class="number">0</span>]  set_freq_step  , <span class="comment">//控制寄存器：设置呼吸灯频率变化步长</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">output</span>         led              <span class="comment">//输出引脚，控制LED</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span>  START_FREQ_STEP = <span class="number">10&#x27;d100</span>; <span class="comment">//设置频率步长初始值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>  [<span class="number">15</span>:<span class="number">0</span>]  period_cnt  ;      <span class="comment">//周期计数器</span></span><br><span class="line"><span class="keyword">reg</span>  [<span class="number">9</span>:<span class="number">0</span>]   freq_step   ;      <span class="comment">//呼吸灯频率间隔步长</span></span><br><span class="line"><span class="keyword">reg</span>  [<span class="number">15</span>:<span class="number">0</span>]  duty_cycle  ;      <span class="comment">//设置高电平占空比的计数点</span></span><br><span class="line"><span class="keyword">reg</span>          inc_dec_flag;      <span class="comment">//用于表示高电平占空比的计数值,是递增还是递减</span></span><br><span class="line">                                <span class="comment">//为1时表示占空比递减,为0时表示占空比递增</span></span><br><span class="line"><span class="keyword">wire</span>         led_t       ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将周期信号计数值与占空比计数值进行比较，以输出驱动led的PWM信号</span></span><br><span class="line"><span class="keyword">assign</span> led_t = ( period_cnt &lt;= duty_cycle ) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span> ;</span><br><span class="line"><span class="keyword">assign</span> led = led_t &amp; sw_ctrl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//周期信号计数器在0-50_000之间计数</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="number">_</span>rst)</span><br><span class="line">        period_cnt &lt;= <span class="number">16&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!sw_ctrl)</span><br><span class="line">        period_cnt &lt;= <span class="number">16&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( period_cnt == <span class="number">16&#x27;d50_000</span> )</span><br><span class="line">        period_cnt &lt;= <span class="number">16&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        period_cnt &lt;= period_cnt + <span class="number">16&#x27;d1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置频率间隔</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="number">_</span>rst)</span><br><span class="line">        freq_step &lt;= START_FREQ_STEP;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(led_en)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(set_freq_step == <span class="number">0</span>)</span><br><span class="line">            freq_step &lt;= <span class="number">10&#x27;d1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(set_freq_step &gt;= <span class="number">10&#x27;d1_000</span>)</span><br><span class="line">            freq_step &lt;= <span class="number">10&#x27;d1_000</span>;</span><br><span class="line">        <span class="keyword">else</span>    </span><br><span class="line">            freq_step &lt;= set_freq_step;</span><br><span class="line">    <span class="keyword">end</span>        </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设定高电平占空比的计数值</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">_</span>rst == <span class="number">1&#x27;b0</span>)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        duty_cycle &lt;= <span class="number">16&#x27;d0</span>;</span><br><span class="line">        inc_dec_flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!sw_ctrl)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        duty_cycle &lt;= <span class="number">16&#x27;d0</span>; <span class="comment">//呼吸灯开关关闭时，信号清零</span></span><br><span class="line">        inc_dec_flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(period_cnt == <span class="number">16&#x27;d50_000</span>) <span class="comment">//每次计数完了一个周期，就调节占空比计数值</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(inc_dec_flag) <span class="comment">//占空比递减</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(duty_cycle == <span class="number">16&#x27;d0</span>)     </span><br><span class="line">                inc_dec_flag &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(duty_cycle &lt; freq_step)</span><br><span class="line">                duty_cycle &lt;= <span class="number">16&#x27;d0</span>;</span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                duty_cycle &lt;= duty_cycle - freq_step;</span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">        <span class="keyword">begin</span> <span class="comment">//占空比递增</span></span><br><span class="line">           	<span class="keyword">if</span>(duty_cycle &gt;= <span class="number">16&#x27;d50_000</span>)</span><br><span class="line">                inc_dec_flag &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                duty_cycle &lt;= duty_cycle + freq_step;</span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        duty_cycle &lt;= duty_cycle; <span class="comment">//未计数完一个周期时，占空比保持不变</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>在Vivado自动生成的AXI总线逻辑文件中如下编写例化：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Users to add parameters here</span></span><br><span class="line">		<span class="keyword">parameter</span>  START_FREQ_STEP = <span class="number">10&#x27;d100</span>, <span class="comment">//参数设置</span></span><br><span class="line"><span class="comment">// User parameters ends</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Users to add ports here</span></span><br><span class="line">		<span class="keyword">output</span> led, <span class="comment">//LED端口</span></span><br><span class="line"><span class="comment">// User ports ends</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Add user logic here</span></span><br><span class="line">	breath_led #(</span><br><span class="line">		<span class="variable">.START_FREQ_STEP</span> (START_FREQ_STEP) <span class="comment">//例化参数</span></span><br><span class="line">	)</span><br><span class="line">	u_breath_led(</span><br><span class="line">		<span class="variable">.clk</span>          	 (S_AXI_ACLK),		<span class="comment">//时钟信号</span></span><br><span class="line">		<span class="variable">._rst</span>         	 (S_AXI_ARESETN),	<span class="comment">//复位信号</span></span><br><span class="line">		<span class="variable">.sw_ctrl</span>      	 (slv_reg0[<span class="number">0</span>]),		<span class="comment">//AXI信号线0最低位为控制信号</span></span><br><span class="line">		<span class="variable">.led_en</span>       	 (slv_reg1[<span class="number">31</span>]),	<span class="comment">//AXI信号线1最高位为使能信号</span></span><br><span class="line">		<span class="variable">.set_freq_step</span>	 (slv_reg1[<span class="number">9</span>:<span class="number">0</span>]),	<span class="comment">//AXI信号线1第10位表示步长</span></span><br><span class="line">		<span class="variable">.led</span>			 (led)				<span class="comment">//输出信号</span></span><br><span class="line">	);</span><br><span class="line"><span class="comment">// User logic ends</span></span><br></pre></td></tr></table></figure>

<p>在Vivado自动生成的顶层文件中如下编写例化：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Users to add parameters here</span></span><br><span class="line">		<span class="keyword">parameter</span>  START_FREQ_STEP = <span class="number">10&#x27;d100</span>, <span class="comment">//初始参数值</span></span><br><span class="line"><span class="comment">// User parameters ends</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Users to add ports here</span></span><br><span class="line">		<span class="keyword">output</span> led, <span class="comment">//LED输出端口例化</span></span><br><span class="line"><span class="comment">// User ports end</span></span><br><span class="line"></span><br><span class="line">breath_LED_IP_v1_0_S0_AXI # ( </span><br><span class="line">		<span class="variable">.START_FREQ_STEP</span>(START_FREQ_STEP),  <span class="comment">//例化参数默认值</span></span><br><span class="line">		<span class="variable">.C_S_AXI_DATA_WIDTH</span>(C_S0_AXI_DATA_WIDTH),</span><br><span class="line">		<span class="variable">.C_S_AXI_ADDR_WIDTH</span>(C_S0_AXI_ADDR_WIDTH)</span><br><span class="line">	) breath_LED_IP_v1_0_S0_AXI_inst (</span><br><span class="line">		<span class="variable">.led</span>(led), <span class="comment">//例化LED输出端口</span></span><br><span class="line">		<span class="variable">.S_AXI_ACLK</span>(s0_axi_aclk),</span><br><span class="line">		<span class="variable">.S_AXI_ARESETN</span>(s0_axi_aresetn),</span><br><span class="line">		<span class="variable">.S_AXI_AWADDR</span>(s0_axi_awaddr),</span><br><span class="line">		<span class="variable">.S_AXI_AWPROT</span>(s0_axi_awprot),</span><br><span class="line">		<span class="variable">.S_AXI_AWVALID</span>(s0_axi_awvalid),</span><br><span class="line">		<span class="variable">.S_AXI_AWREADY</span>(s0_axi_awready),</span><br><span class="line">		<span class="variable">.S_AXI_WDATA</span>(s0_axi_wdata),</span><br><span class="line">		<span class="variable">.S_AXI_WSTRB</span>(s0_axi_wstrb),</span><br><span class="line">		<span class="variable">.S_AXI_WVALID</span>(s0_axi_wvalid),</span><br><span class="line">		<span class="variable">.S_AXI_WREADY</span>(s0_axi_wready),</span><br><span class="line">		<span class="variable">.S_AXI_BRESP</span>(s0_axi_bresp),</span><br><span class="line">		<span class="variable">.S_AXI_BVALID</span>(s0_axi_bvalid),</span><br><span class="line">		<span class="variable">.S_AXI_BREADY</span>(s0_axi_bready),</span><br><span class="line">		<span class="variable">.S_AXI_ARADDR</span>(s0_axi_araddr),</span><br><span class="line">		<span class="variable">.S_AXI_ARPROT</span>(s0_axi_arprot),</span><br><span class="line">		<span class="variable">.S_AXI_ARVALID</span>(s0_axi_arvalid),</span><br><span class="line">		<span class="variable">.S_AXI_ARREADY</span>(s0_axi_arready),</span><br><span class="line">		<span class="variable">.S_AXI_RDATA</span>(s0_axi_rdata),</span><br><span class="line">		<span class="variable">.S_AXI_RRESP</span>(s0_axi_rresp),</span><br><span class="line">		<span class="variable">.S_AXI_RVALID</span>(s0_axi_rvalid),</span><br><span class="line">		<span class="variable">.S_AXI_RREADY</span>(s0_axi_rready)</span><br><span class="line">	);</span><br></pre></td></tr></table></figure>

<p>编辑完成后即可退回原菜单</p>
<p>点击左侧流程中的【Run Synthesis】即可进行IP核的综合</p>
<h3 id="设置IP的可视化界面"><a href="#设置IP的可视化界面" class="headerlink" title="设置IP的可视化界面"></a>设置IP的可视化界面</h3><p>打开xml文件后即可在Vivado中进行编辑，</p>
<p>按顺序设置即可</p>
<p>其中在【Customization Parameters】菜单下会出现“更新参数”的选项提示，更新后会现多出一行自定义的参数，双击它如下图进行设置，即可将这个参数反映到IP可视化界面</p>
<p><img src="/2021/11/19/FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E3%80%90%E5%9F%BA%E4%BA%8EVivado%E5%B0%81%E8%A3%85%E8%87%AA%E5%AE%9A%E4%B9%89IP%E3%80%91/image-20210511201028511.png" alt="image-20210511201028511"></p>
<p>完成所有设置并确认无误后，即可在最后选项【Review and Package】中点击【Re-Package IP】即可封装IP</p>
<p>关闭项目后可以在原来的Vivado窗口中看到如下显示</p>
<p><img src="/2021/11/19/FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E3%80%90%E5%9F%BA%E4%BA%8EVivado%E5%B0%81%E8%A3%85%E8%87%AA%E5%AE%9A%E4%B9%89IP%E3%80%91/image-20210511201745806.png" alt="image-20210511201745806"></p>
<p>证明完成了IP封装</p>
<h2 id="使用自定义IP"><a href="#使用自定义IP" class="headerlink" title="使用自定义IP"></a>使用自定义IP</h2><h3 id="硬件部分"><a href="#硬件部分" class="headerlink" title="硬件部分"></a>硬件部分</h3><p>完成封装IP后，在任意工程中点击左侧【IP INTERGRATOR】-【Create Block Design】创建基于IP核的FPGA设计</p>
<p>但此时IP选项列表中没有自定义IP核，需要自己将IP核添加到工程</p>
<p>选择【Tools】-【Settings】-【IP】-【Repository】-【Add（加号+）】选择存放自定义IP的文件目录，即可将自定义的IP核添加到项目</p>
<p>如下图对IP核进行设置</p>
<p><img src="/2021/11/19/FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E3%80%90%E5%9F%BA%E4%BA%8EVivado%E5%B0%81%E8%A3%85%E8%87%AA%E5%AE%9A%E4%B9%89IP%E3%80%91/image-20210511204531656.png" alt="image-20210511204531656"></p>
<p>设置ZYNQ系统的DDR控制器和外设后，先进行自动生成原理图，再进行自动布线即可</p>
<p>注意要在led引脚处右键选择【Make External】生成一个引出的外部引脚，并将其改名为led</p>
<p><strong>生成外部引脚的过程就是使能逻辑块与IO块连接的过程</strong></p>
<p>接下来按照正常步骤生成硬件平台配置</p>
<p>由于led端口连接到PL部分，所以需要进行管脚约束才能使用</p>
<p>点击左侧综合按钮，综合后打开引脚设置（I/O Ports），将led_0的引脚映射到PL部分MIO上</p>
<p>根据手头的开发板选择引出引脚即可</p>
<p><img src="/2021/11/19/FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E3%80%90%E5%9F%BA%E4%BA%8EVivado%E5%B0%81%E8%A3%85%E8%87%AA%E5%AE%9A%E4%B9%89IP%E3%80%91/image-20210511210615915.png" alt="image-20210511210615915"></p>
<p>这里选用的是PL Bank的P15引脚</p>
<p>最后生成比特流并导出到硬件即可</p>
<h3 id="软件部分"><a href="#软件部分" class="headerlink" title="软件部分"></a>软件部分</h3><p>还是原来的步骤从.xsa文件导入配置到Vitis，并创建一个新应用程序</p>
<p>使用的软件代码如下所示</p>
<p>总体思路就是读写外设寄存器映射来的地址对外设寄存器进行操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;xparameters.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;xil_printf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;breath_led_ip.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;xil_io.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sleep.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LED_IP_BASEADDR   XPAR_BREATH_LED_IP_0_S0_AXI_BASEADDR</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LED_IP_REG0       BREATH_LED_IP_S0_AXI_SLV_REG0_OFFSET</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LED_IP_REG1       BREATH_LED_IP_S0_AXI_SLV_REG1_OFFSET</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> freq_flag;</span><br><span class="line">    <span class="keyword">int</span> led_state;</span><br><span class="line"></span><br><span class="line">	xil_printf(<span class="string">&quot;LED User IP Test!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">if</span>(freq_flag == <span class="number">0</span>)</span><br><span class="line">     	&#123;</span><br><span class="line">    		BREATH_LED_IP_mWriteReg(LED_IP_BASEADDR,LED_IP_REG1,<span class="number">0x800000ef</span>);</span><br><span class="line">        	freq_flag = <span class="number">1</span>;</span><br><span class="line">     	&#125;</span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">     	&#123;</span><br><span class="line">    	 	BREATH_LED_IP_mWriteReg(LED_IP_BASEADDR,LED_IP_REG1,<span class="number">0x8000002f</span>);</span><br><span class="line">         	freq_flag = <span class="number">0</span>;</span><br><span class="line">     	&#125;</span><br><span class="line">     	led_state = BREATH_LED_IP_mReadReg(LED_IP_BASEADDR,LED_IP_REG0);</span><br><span class="line"></span><br><span class="line">     	<span class="keyword">if</span>(led_state == <span class="number">0</span>)</span><br><span class="line">     	&#123;</span><br><span class="line">    	 	BREATH_LED_IP_mWriteReg (LED_IP_BASEADDR, LED_IP_REG0, <span class="number">1</span>);</span><br><span class="line">         	xil_printf(<span class="string">&quot;Breath LED ON\n&quot;</span>);</span><br><span class="line">     	&#125;</span><br><span class="line">     	sleep(<span class="number">5</span>);</span><br><span class="line">     	led_state = BREATH_LED_IP_mReadReg(LED_IP_BASEADDR,LED_IP_REG0);</span><br><span class="line">     	</span><br><span class="line">        <span class="keyword">if</span>(led_state == <span class="number">1</span>)</span><br><span class="line">     	&#123;</span><br><span class="line">    	 	BREATH_LED_IP_mWriteReg (LED_IP_BASEADDR, LED_IP_REG0, <span class="number">0</span>);</span><br><span class="line">         	xil_printf(<span class="string">&quot;Breath LED OFF\n&quot;</span>);</span><br><span class="line">     	&#125;</span><br><span class="line">     	sleep(<span class="number">1</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>烧录后LED呈呼吸灯效果，且可以看到呼吸灯闪烁频率变化</p>
<h1 id="封装不带AXI接口的IP核"><a href="#封装不带AXI接口的IP核" class="headerlink" title="封装不带AXI接口的IP核"></a>封装不带AXI接口的IP核</h1><p>Vivado支持将独立的RTL代码封装为IP核，方便以类似函数的方式重用IP核，同时可使用用户自定义的IP核接口协议</p>
<p>参考【ug1118】手册来获取详细信息</p>
<h2 id="创建自定义IP-1"><a href="#创建自定义IP-1" class="headerlink" title="创建自定义IP"></a>创建自定义IP</h2><h3 id="IP核逻辑封装"><a href="#IP核逻辑封装" class="headerlink" title="IP核逻辑封装"></a>IP核逻辑封装</h3><ol>
<li>创建一个RTL工程</li>
<li>编辑IP核的RTL代码</li>
<li>验证IP核逻辑并进行仿真</li>
<li>创建一个基于已有RTL代码的IP核封装</li>
<li>修改顶层文件</li>
<li>设置IP核端口和控制引脚端口输入输出模式（端口映射）</li>
<li>修改IP核的可视化界面配置进行封装</li>
<li>创建接口定义</li>
</ol>
<h3 id="接口封装"><a href="#接口封装" class="headerlink" title="接口封装"></a>接口封装</h3><ol>
<li>编辑接口协议的RTL实现</li>
<li>在IP核封装完成后在配置接口定义部分对接口进行相关设置</li>
<li>依次调整接口协议封装</li>
<li>添加接口协议的RTL文件</li>
<li>进行接口RTL文件的顶层文件端口映射</li>
<li>点击【Package IP】完成IP核封装</li>
</ol>
<h3 id="使用自定义IP核"><a href="#使用自定义IP核" class="headerlink" title="使用自定义IP核"></a>使用自定义IP核</h3><p>封装好的IP核如果出现适用设备相关的错误，可以直接删除对应的封装信息</p>
<p>使用IP核前需要先对IP核进行验证，可以选择编写testbench（普普通通的ZYNQ-7020板子配那么小的LUT规模直接烧就完事了！），也可以直接烧录到开发板（如果开发板很贵就别这样干了）</p>
<p>IP核验证完毕后就可以随意使用了</p>
<h3 id="封装IP核时可能遇到的问题"><a href="#封装IP核时可能遇到的问题" class="headerlink" title="封装IP核时可能遇到的问题"></a>封装IP核时可能遇到的问题</h3><ol>
<li><p>封装的IP核中包含了其他IP核</p>
<p> 如果包含了.xci文件（IP核的配置文件），Vivado会直接用新生成的子IP创建输出文件</p>
<p> 如果包含IP核的输出文件，Vivado则会从IP设置中生成HDL和XDC代码</p>
<p> 封装时推荐直接使用包含.xci文件的方式打包IP核，这样会方便重用IP和生成输出文件</p>
<p> 只要在打包当前IP的时候选择相关选项即可</p>
</li>
<li><p>如果在封装前分配好了引脚约束应该怎么办</p>
<p> 一般来说使用IP核的时候再进行引脚约束的过程会把之前的引脚约束覆盖掉</p>
<p> 但是为了保证不出错，一般在打包前或打包后将IP核的.xdc文件删除</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32深入学习【中断控制】</title>
    <url>/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E3%80%91/</url>
    <content><![CDATA[<h1 id="嵌套向量中断控制器NVIC"><a href="#嵌套向量中断控制器NVIC" class="headerlink" title="嵌套向量中断控制器NVIC"></a>嵌套向量中断控制器NVIC</h1><p>ARM内核标准规定了使用<strong>嵌套向量中断控制器NVIC</strong>控制异常和中断。对于STM32F407的Cortex-M4内核，NVIC具有16个可编程优先级、86个可屏蔽中断通道（ARM标准规定NVIC最多支持240个中断请求、1个不可屏蔽中断NMI、1个systick中断和多个系统异常，STM32只用到了一部分）</p>
<p>为了继续执行被中断的程序，异常流程需要利用一些手段来保存被中断程序的状态（保护现场），并在异常处理完成后自动恢复（恢复现场），这个过程一般有硬件实现，但是也可以由硬件、软件共同操作。<strong>对于M4内核，当异常被接受后，有些寄存器会被自动保存到栈中，并在返回流程中自动回复，因此可以将异常处理写作普通的C函数，这并不会带来额外的软件开销</strong></p>
<p>这段C函数就被称为<strong>中断服务程序</strong>（中断服务函数）</p>
<span id="more"></span>

<p>在STM32中实现了NVIC并设置了专门用于控制外部中断/事件的EXTI外设</p>
<h3 id="NVIC设备与EXTI设备的概念梳理"><a href="#NVIC设备与EXTI设备的概念梳理" class="headerlink" title="NVIC设备与EXTI设备的概念梳理"></a>NVIC设备与EXTI设备的概念梳理</h3><p>NVIC是位于M4核内部的设备，负责处理<strong>来自内核外界的所有中断信号</strong>和<strong>来自内核的异常信号</strong></p>
<p>这里的异常实际上是狭义的异常概念——广义上异常包括了中断：内部的异常信号称为狭义的异常，外部的异常信号称为中断</p>
<p>根据内核IP厂商的划分，通常会用很多不同的方式称呼这个东西，但是本质上都差不多</p>
<p>EXTI设备则是位于STM32的SoC中，并不在内核上，作为一个专门的外设用来处理来自片外和SoC中的异常、中断、事件信号</p>
<p>这里的三个概念都是狭义的：</p>
<p>异常指来自SoC内部的异常信号，中断指来自SoC外部（一般是GPIO）的异常信号，而事件则是指来自SoC内部或外部的特殊异常，一般是某个外设完成某个任务或某个FIFO已满时发出的中断信号</p>
<p>信号的流向是：外部异常-&gt;EXTI-&gt;NVIC-&gt;内核</p>
<p>内核在接收到NVIC发来的中断请求后自动执行中断处理的硬件程序，而在此之前的操作都归属于NVIC完成</p>
<p>详细的内核中断流程需要参考Cortex-M4内核相关参考手册或教程，这里不再赘述</p>
<h2 id="外部中断-事件控制器EXTI"><a href="#外部中断-事件控制器EXTI" class="headerlink" title="外部中断/事件控制器EXTI"></a>外部中断/事件控制器EXTI</h2><p>外部中断/事件控制器是NVIC内部专用于控制外部中断的设备，包含23个可用于产生事件/中断请求的边沿检测其，每根输入线都能单独配置、单独屏蔽</p>
<p>EXTI控制器具有以下特性</p>
<ul>
<li>每个中断/事件线上都具有独立的触发和屏蔽</li>
<li>每个中断线都具有专用的状态位</li>
<li>支持多达 23 个软件事件/中断请求</li>
<li>检测脉冲宽度低于 APB2 时钟宽度的外部信号</li>
</ul>
<p>EXTI控制器结构框图如下</p>
<p> <img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E3%80%91/image-20210513091957958.png" alt="image-20210513091957958"></p>
<p><strong>中断信号的捕获</strong>：输入线可以配置到其他外设（如GPIO），输入信号会先通过边沿检测电路，如果配置了跳变沿触发的外部中断，对应的跳变沿信号会将跳变沿触发选择寄存器置位，此时CPU就可以通过AMBA总线（一般是APB总线）访问EXTI外设中的对应寄存器，进而检测到中断信号</p>
<p><strong>中断事件屏蔽</strong>：当对中断屏蔽寄存器、软件中断事件寄存器置位时，信号会经过后续逻辑电路的处理：<em>跳变沿<strong>或</strong>软件中断事件出现</em>，或门就会输出1到后续的两个与门，<em>如果事件屏蔽寄存器对应位置1</em>，就会触发事件到脉冲发生器；<em>如果中断屏蔽寄存器对应位置1</em>，就会触发中断挂起请求，挂起请求寄存器置1，这个寄存器会直接被NVIC访问，实现直接对NVIC的中断控制，<em>CPU可访问该寄存器并清除对应位来恢复中断</em></p>
<h3 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h3><p>中断配置方法：</p>
<ol>
<li><p>配置并使能中断线</p>
<p> 根据需要的边缘检测设置2个触发寄存器，边沿检测电路就会按照配置进行外部输入信号的检测</p>
</li>
<li><p>在中断屏蔽寄存器要开启的控制位写1来使能中断请求</p>
</li>
</ol>
<p>事件的配置方法和上面一样，只不过需要把中断线改成对应事件线</p>
<p>中断/事件触发后，EXTI会产生中断请求，对应地挂起位会置1</p>
<p>在挂起寄存器的对应位写1会清除对应中断请求，<strong>在中断处理程序的开头一定要记得清除中断请求</strong>，否则中断会一直进行</p>
<h3 id="硬件中断-事件选择配置"><a href="#硬件中断-事件选择配置" class="headerlink" title="硬件中断/事件选择配置"></a>硬件中断/事件选择配置</h3><ol>
<li>配置中断线/事件线（各23根）的屏蔽位（EXTI_IMR和EXTI_EMR寄存器）</li>
<li>配置中断/事件线的触发选择位（EXTI_RTSR和EXTI_FTSR寄存器）</li>
<li>如果是配置外部中断，还需要配置到对应外部中断控制器EXTI的NVIC中断通道使能和屏蔽位，使得23个中断线中的请求可以被M4内核正确响应</li>
</ol>
<p>当然除了硬件中断外也可以单独配置软件中断/事件模式，大体流程和硬件的差不多，STM也提供了库函数（STP库和LL库有，HAL库就没有，当然用HAL库也不在意这些东西）</p>
<h3 id="外部中断-事件线映射"><a href="#外部中断-事件线映射" class="headerlink" title="外部中断/事件线映射"></a>外部中断/事件线映射</h3><p>详细的映射表可以查阅STM32F4xx参考手册，这里不列出</p>
<p>只需要注意一点：<strong>所有EXTI的映射都是固定的</strong>，千万不要弄错EXTI线与GPIO的端口对应，否则会导致中断用不了！</p>
<p>作者在刚学习STM32的时候曾经犯过这个错误，把RTC的EXTI直接接到了GPIO，然后发现中断没有任何效果，查了好久才明白EXTI线和GPIO的对应关系</p>
<h2 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h2><p>中断向量表是位于MCU的bootloader代码部分中用于声明中断跳转位置的一段代码</p>
<p>使用中断向量表保证MCU中断跳转不会跑飞</p>
<p>相关内容请参考bootloader相关材料或教程</p>
<h2 id="EXTI系统事件"><a href="#EXTI系统事件" class="headerlink" title="EXTI系统事件"></a>EXTI系统事件</h2><h3 id="唤醒事件"><a href="#唤醒事件" class="headerlink" title="唤醒事件"></a>唤醒事件</h3><p>STM32可以处理外部或内部事件对内核进行唤醒（WFE）</p>
<p>唤醒的途径有以下两种</p>
<ul>
<li><p>在外设控制寄存器处使能一个中断，但不在NVIC中使能；同时使能M4内核控制寄存器中的SEVONPEND位</p>
<p>  <strong>在MCU从WFE恢复时，一定要清除对应外设和外设NVIC的中断/中断通道挂起位</strong></p>
</li>
<li><p>配置一个外部或内部EXTI线为事件模式，当CPU从WFE恢复时，因为对应事件线的挂起位没有被置位，所以不必清除相应外设的中断挂起位或NVIC中断通道挂起位</p>
</li>
</ul>
<h3 id="RTC事件"><a href="#RTC事件" class="headerlink" title="RTC事件"></a>RTC事件</h3><p>STM32F4支持来自SoC内部的RTC中断唤醒，通过配置SoC唤醒中断就可以开启这个事件</p>
<p>RTC事件的中断线固定为22号</p>
<h2 id="NVIC与EXTI外设的库函数"><a href="#NVIC与EXTI外设的库函数" class="headerlink" title="NVIC与EXTI外设的库函数"></a>NVIC与EXTI外设的库函数</h2><p>库函数.c文件的前半部分简要说明了外部中断线的映射</p>
<blockquote>
<p>[..] External interrupt/event lines are mapped as following:<br>(#) All available GPIO pins are connected to the 16 external<br>    interrupt/event lines from EXTI0 to EXTI15.<br>(#) EXTI line 16 is connected to the PVD Output<br>(#) EXTI line 17 is connected to the RTC Alarm event<br>(#) EXTI line 18 is connected to the USB OTG FS Wakeup from suspend event<br>(#) EXTI line 19 is connected to the Ethernet Wakeup event<br>(#) EXTI line 20 is connected to the USB OTG HS (configured in FS) Wakeup event<br>(#) EXTI line 21 is connected to the RTC Tamper and Time Stamp events<br>(#) EXTI line 22 is connected to the RTC Wakeup event</p>
<p>外部中断线如下映射：</p>
<ul>
<li>所有GPIO引脚连接到从EXTI0到EXTI15的外部中断/事件线</li>
<li>EXTI16连接到PVD输出</li>
<li>EXTI17连接到RTC闹钟事件</li>
<li>EXTI18连接到USB OTG FS唤醒事件</li>
<li>EXTI19连接到以太网唤醒事件</li>
<li>EXTI20连接到USB OTG HS唤醒事件</li>
<li>EXTI21连接到RTC检测和时间戳事件</li>
<li>EXTI22连接到RTC唤醒事件</li>
</ul>
</blockquote>
<p>配置步骤如下：</p>
<ol>
<li>使用<code>RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE)</code>开启EXTI外设时钟</li>
<li>使用<code>GPIO_Init()</code>函数配置GPIO为输入模式</li>
<li>使用<code>SYSCFG_EXTILineConfig()</code>配置输入源连接到对应的EXTI线</li>
<li>使用EXTI外设配置结构体设置模式、触发选项，并使用<code>EXTI_Init()</code>应用设置</li>
<li>使用<code>NVIC_Init()</code>函数开启EXTI连接到NVIC中断通道</li>
</ol>
<h3 id="EXTI库函数参考"><a href="#EXTI库函数参考" class="headerlink" title="EXTI库函数参考"></a>EXTI库函数参考</h3><ol>
<li>将EXTI配置寄存器置0</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI_DeInit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  EXTI-&gt;IMR = <span class="number">0x00000000</span>;</span><br><span class="line">  EXTI-&gt;EMR = <span class="number">0x00000000</span>;</span><br><span class="line">  EXTI-&gt;RTSR = <span class="number">0x00000000</span>;</span><br><span class="line">  EXTI-&gt;FTSR = <span class="number">0x00000000</span>;</span><br><span class="line">  EXTI-&gt;PR = <span class="number">0x007FFFFF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>初始化EXTI初始化结构体和配置寄存器</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI_StructInit</span><span class="params">(EXTI_InitTypeDef* EXTI_InitStruct)</span> <span class="comment">//初始化EXTI配置结构体</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  EXTI_InitStruct-&gt;EXTI_Line = EXTI_LINENONE;</span><br><span class="line">  EXTI_InitStruct-&gt;EXTI_Mode = EXTI_Mode_Interrupt;</span><br><span class="line">  EXTI_InitStruct-&gt;EXTI_Trigger = EXTI_Trigger_Falling;</span><br><span class="line">  EXTI_InitStruct-&gt;EXTI_LineCmd = DISABLE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI_Init</span><span class="params">(EXTI_InitTypeDef* EXTI_InitStruct)</span> <span class="comment">//初始化EXTI配置寄存器（应用设置）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> tmp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_EXTI_MODE(EXTI_InitStruct-&gt;EXTI_Mode));</span><br><span class="line">  assert_param(IS_EXTI_TRIGGER(EXTI_InitStruct-&gt;EXTI_Trigger));</span><br><span class="line">  assert_param(IS_EXTI_LINE(EXTI_InitStruct-&gt;EXTI_Line));  </span><br><span class="line">  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct-&gt;EXTI_LineCmd));</span><br><span class="line"></span><br><span class="line">  tmp = (<span class="keyword">uint32_t</span>)EXTI_BASE;</span><br><span class="line">     </span><br><span class="line">  <span class="keyword">if</span> (EXTI_InitStruct-&gt;EXTI_LineCmd != DISABLE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Clear EXTI line configuration */</span></span><br><span class="line">    EXTI-&gt;IMR &amp;= ~EXTI_InitStruct-&gt;EXTI_Line;</span><br><span class="line">    EXTI-&gt;EMR &amp;= ~EXTI_InitStruct-&gt;EXTI_Line;</span><br><span class="line">    </span><br><span class="line">    tmp += EXTI_InitStruct-&gt;EXTI_Mode;</span><br><span class="line"></span><br><span class="line">    *(__IO <span class="keyword">uint32_t</span> *) tmp |= EXTI_InitStruct-&gt;EXTI_Line;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Clear Rising Falling edge configuration */</span></span><br><span class="line">    EXTI-&gt;RTSR &amp;= ~EXTI_InitStruct-&gt;EXTI_Line;</span><br><span class="line">    EXTI-&gt;FTSR &amp;= ~EXTI_InitStruct-&gt;EXTI_Line;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Select the trigger for the selected external interrupts */</span></span><br><span class="line">    <span class="keyword">if</span> (EXTI_InitStruct-&gt;EXTI_Trigger == EXTI_Trigger_Rising_Falling)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Rising Falling edge */</span></span><br><span class="line">      EXTI-&gt;RTSR |= EXTI_InitStruct-&gt;EXTI_Line;</span><br><span class="line">      EXTI-&gt;FTSR |= EXTI_InitStruct-&gt;EXTI_Line;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      tmp = (<span class="keyword">uint32_t</span>)EXTI_BASE;</span><br><span class="line">      tmp += EXTI_InitStruct-&gt;EXTI_Trigger;</span><br><span class="line"></span><br><span class="line">      *(__IO <span class="keyword">uint32_t</span> *) tmp |= EXTI_InitStruct-&gt;EXTI_Line;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    tmp += EXTI_InitStruct-&gt;EXTI_Mode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Disable the selected external lines */</span></span><br><span class="line">    *(__IO <span class="keyword">uint32_t</span> *) tmp &amp;= ~EXTI_InitStruct-&gt;EXTI_Line;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在选定的中断线上生成软件中断</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI_GenerateSWInterrupt</span><span class="params">(<span class="keyword">uint32_t</span> EXTI_Line)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_EXTI_LINE(EXTI_Line));</span><br><span class="line">  </span><br><span class="line">  EXTI-&gt;SWIER |= EXTI_Line;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>获取当前中断状态、清除中断标志位</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">FlagStatus <span class="title">EXTI_GetFlagStatus</span><span class="params">(<span class="keyword">uint32_t</span> EXTI_Line)</span> <span class="comment">//获取当前中断标志位状态</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FlagStatus bitstatus = RESET;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_GET_EXTI_LINE(EXTI_Line));</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ((EXTI-&gt;PR &amp; EXTI_Line) != (<span class="keyword">uint32_t</span>)RESET)</span><br><span class="line">  &#123;</span><br><span class="line">    bitstatus = SET;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    bitstatus = RESET;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bitstatus;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ITStatus <span class="title">EXTI_GetITStatus</span><span class="params">(<span class="keyword">uint32_t</span> EXTI_Line)</span> <span class="comment">//获取当前中断状态</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FlagStatus bitstatus = RESET;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_GET_EXTI_LINE(EXTI_Line));</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ((EXTI-&gt;PR &amp; EXTI_Line) != (<span class="keyword">uint32_t</span>)RESET)</span><br><span class="line">  &#123;</span><br><span class="line">    bitstatus = SET;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    bitstatus = RESET;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bitstatus;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI_ClearFlag</span><span class="params">(<span class="keyword">uint32_t</span> EXTI_Line)</span> <span class="comment">//清除中断标志位</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_EXTI_LINE(EXTI_Line));</span><br><span class="line">  </span><br><span class="line">  EXTI-&gt;PR = EXTI_Line;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI_ClearITPendingBit</span><span class="params">(<span class="keyword">uint32_t</span> EXTI_Line)</span> <span class="comment">//清除中断挂起标志</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_EXTI_LINE(EXTI_Line));</span><br><span class="line">  </span><br><span class="line">  EXTI-&gt;PR = EXTI_Line;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是一些定义在STP库头文件中结构体和宏函数的简述</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择事件触发还是中断触发</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  EXTI_Mode_Interrupt = <span class="number">0x00</span>,</span><br><span class="line">  EXTI_Mode_Event = <span class="number">0x04</span></span><br><span class="line">&#125;EXTIMode_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_EXTI_MODE(MODE) (((MODE) == EXTI_Mode_Interrupt) || ((MODE) == EXTI_Mode_Event))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//EXTI触发状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  EXTI_Trigger_Rising = <span class="number">0x08</span>,</span><br><span class="line">  EXTI_Trigger_Falling = <span class="number">0x0C</span>,  </span><br><span class="line">  EXTI_Trigger_Rising_Falling = <span class="number">0x10</span></span><br><span class="line">&#125;EXTITrigger_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_EXTI_TRIGGER(TRIGGER) (((TRIGGER) == EXTI_Trigger_Rising) || \</span></span><br><span class="line"><span class="meta">                                  ((TRIGGER) == EXTI_Trigger_Falling) || \</span></span><br><span class="line"><span class="meta">                                  ((TRIGGER) == EXTI_Trigger_Rising_Falling))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//EXTI配置结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> EXTI_Line; <span class="comment">//中断线号</span></span><br><span class="line">  EXTIMode_TypeDef EXTI_Mode; <span class="comment">//EXTI模式选择</span></span><br><span class="line">  EXTITrigger_TypeDef EXTI_Trigger; <span class="comment">//EXTI触发状态</span></span><br><span class="line">  FunctionalState EXTI_LineCmd; <span class="comment">//中断线使能</span></span><br><span class="line">&#125;EXTI_InitTypeDef;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是中断线的宏定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line0       ((uint32_t)0x00001)     <span class="comment">/*!&lt; External interrupt line 0 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line1       ((uint32_t)0x00002)     <span class="comment">/*!&lt; External interrupt line 1 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line2       ((uint32_t)0x00004)     <span class="comment">/*!&lt; External interrupt line 2 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line3       ((uint32_t)0x00008)     <span class="comment">/*!&lt; External interrupt line 3 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line4       ((uint32_t)0x00010)     <span class="comment">/*!&lt; External interrupt line 4 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line5       ((uint32_t)0x00020)     <span class="comment">/*!&lt; External interrupt line 5 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line6       ((uint32_t)0x00040)     <span class="comment">/*!&lt; External interrupt line 6 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line7       ((uint32_t)0x00080)     <span class="comment">/*!&lt; External interrupt line 7 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line8       ((uint32_t)0x00100)     <span class="comment">/*!&lt; External interrupt line 8 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line9       ((uint32_t)0x00200)     <span class="comment">/*!&lt; External interrupt line 9 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line10      ((uint32_t)0x00400)     <span class="comment">/*!&lt; External interrupt line 10 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line11      ((uint32_t)0x00800)     <span class="comment">/*!&lt; External interrupt line 11 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line12      ((uint32_t)0x01000)     <span class="comment">/*!&lt; External interrupt line 12 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line13      ((uint32_t)0x02000)     <span class="comment">/*!&lt; External interrupt line 13 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line14      ((uint32_t)0x04000)     <span class="comment">/*!&lt; External interrupt line 14 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line15      ((uint32_t)0x08000)     <span class="comment">/*!&lt; External interrupt line 15 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line16      ((uint32_t)0x10000)     <span class="comment">/*!&lt; External interrupt line 16 Connected to the PVD Output */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line17      ((uint32_t)0x20000)     <span class="comment">/*!&lt; External interrupt line 17 Connected to the RTC Alarm event */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line18      ((uint32_t)0x40000)     <span class="comment">/*!&lt; External interrupt line 18 Connected to the USB OTG FS Wakeup from suspend event */</span>                                    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line19      ((uint32_t)0x80000)     <span class="comment">/*!&lt; External interrupt line 19 Connected to the Ethernet Wakeup event */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line20      ((uint32_t)0x00100000)  <span class="comment">/*!&lt; External interrupt line 20 Connected to the USB OTG HS (configured in FS) Wakeup event  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line21      ((uint32_t)0x00200000)  <span class="comment">/*!&lt; External interrupt line 21 Connected to the RTC Tamper and Time Stamp events */</span>                                               </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTI_Line22      ((uint32_t)0x00400000)  <span class="comment">/*!&lt; External interrupt line 22 Connected to the RTC Wakeup event */</span>                                               </span></span><br><span class="line">                                          </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_EXTI_LINE(LINE) ((((LINE) &amp; (uint32_t)0xFF800000) == 0x00) &amp;&amp; ((LINE) != (uint16_t)0x00))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_GET_EXTI_LINE(LINE) (((LINE) == EXTI_Line0) || ((LINE) == EXTI_Line1) || \</span></span><br><span class="line"><span class="meta">                                ((LINE) == EXTI_Line2) || ((LINE) == EXTI_Line3) || \</span></span><br><span class="line"><span class="meta">                                ((LINE) == EXTI_Line4) || ((LINE) == EXTI_Line5) || \</span></span><br><span class="line"><span class="meta">                                ((LINE) == EXTI_Line6) || ((LINE) == EXTI_Line7) || \</span></span><br><span class="line"><span class="meta">                                ((LINE) == EXTI_Line8) || ((LINE) == EXTI_Line9) || \</span></span><br><span class="line"><span class="meta">                                ((LINE) == EXTI_Line10) || ((LINE) == EXTI_Line11) || \</span></span><br><span class="line"><span class="meta">                                ((LINE) == EXTI_Line12) || ((LINE) == EXTI_Line13) || \</span></span><br><span class="line"><span class="meta">                                ((LINE) == EXTI_Line14) || ((LINE) == EXTI_Line15) || \</span></span><br><span class="line"><span class="meta">                                ((LINE) == EXTI_Line16) || ((LINE) == EXTI_Line17) || \</span></span><br><span class="line"><span class="meta">                                ((LINE) == EXTI_Line18) || ((LINE) == EXTI_Line19) || \</span></span><br><span class="line"><span class="meta">                                ((LINE) == EXTI_Line20) || ((LINE) == EXTI_Line21) ||\</span></span><br><span class="line"><span class="meta">                                ((LINE) == EXTI_Line22))</span></span><br></pre></td></tr></table></figure>

<h3 id="使用库函数配置NVIC"><a href="#使用库函数配置NVIC" class="headerlink" title="使用库函数配置NVIC"></a>使用库函数配置NVIC</h3><p>在配置完EXTI后，还需要开启NVIC才能使用外部中断/事件；即使不使用外部中断，systick等SoC内部乃至内核异常都需要使能NVIC配置才行，ARM（这回不是ST了）提供了配置NVIC的库函数，保存在misc.c文件中</p>
<p>整套库函数都被包括在CMSIS标准中，这套标准可以在所有使用了ARM内核处理器的设备中通用，上到A53下到Cortex-M0都可以使用</p>
<p>因为这里主要讲述STM32F4相关的中断控制，对移植的操作不再赘述</p>
<p>软件配置NVIC主要是对中断优先级进行配置</p>
<p><strong>中断优先级分为抢占优先级和子优先级，抢占优先级高的中断可以对抢占优先级低的中断形成中断嵌套；如果抢占优先级相等，则子优先级更高的先执行；若两个中断优先级完全一致，则哪个先发生哪个先执行；数字越小，优先级越高</strong></p>
<p>使用库函数<code>NVIC_Init()</code>来配置中断优先级</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NVIC_Init</span><span class="params">(NVIC_InitTypeDef* NVIC_InitStruct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span> tmppriority = <span class="number">0x00</span>, tmppre = <span class="number">0x00</span>, tmpsub = <span class="number">0x0F</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct-&gt;NVIC_IRQChannelCmd));</span><br><span class="line">  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct-&gt;NVIC_IRQChannelPreemptionPriority));  </span><br><span class="line">  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct-&gt;NVIC_IRQChannelSubPriority));</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (NVIC_InitStruct-&gt;NVIC_IRQChannelCmd != DISABLE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Compute the Corresponding IRQ Priority --------------------------------*/</span>    </span><br><span class="line">    tmppriority = (<span class="number">0x700</span> - ((SCB-&gt;AIRCR) &amp; (<span class="keyword">uint32_t</span>)<span class="number">0x700</span>))&gt;&gt; <span class="number">0x08</span>;</span><br><span class="line">    tmppre = (<span class="number">0x4</span> - tmppriority);</span><br><span class="line">    tmpsub = tmpsub &gt;&gt; tmppriority;</span><br><span class="line"></span><br><span class="line">    tmppriority = NVIC_InitStruct-&gt;NVIC_IRQChannelPreemptionPriority &lt;&lt; tmppre;</span><br><span class="line">    tmppriority |=  (<span class="keyword">uint8_t</span>)(NVIC_InitStruct-&gt;NVIC_IRQChannelSubPriority &amp; tmpsub);</span><br><span class="line">        </span><br><span class="line">    tmppriority = tmppriority &lt;&lt; <span class="number">0x04</span>;</span><br><span class="line">        </span><br><span class="line">    NVIC-&gt;IP[NVIC_InitStruct-&gt;NVIC_IRQChannel] = tmppriority;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Enable the Selected IRQ Channels --------------------------------------*/</span></span><br><span class="line">    NVIC-&gt;ISER[NVIC_InitStruct-&gt;NVIC_IRQChannel &gt;&gt; <span class="number">0x05</span>] =</span><br><span class="line">      (<span class="keyword">uint32_t</span>)<span class="number">0x01</span> &lt;&lt; (NVIC_InitStruct-&gt;NVIC_IRQChannel &amp; (<span class="keyword">uint8_t</span>)<span class="number">0x1F</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Disable the Selected IRQ Channels -------------------------------------*/</span></span><br><span class="line">    NVIC-&gt;ICER[NVIC_InitStruct-&gt;NVIC_IRQChannel &gt;&gt; <span class="number">0x05</span>] =</span><br><span class="line">      (<span class="keyword">uint32_t</span>)<span class="number">0x01</span> &lt;&lt; (NVIC_InitStruct-&gt;NVIC_IRQChannel &amp; (<span class="keyword">uint8_t</span>)<span class="number">0x1F</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要特别注意的是：中断需要配置中断向量表才能使用——中断发生时处理器会根据中断向量表进行跳转</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NVIC_SetVectorTable</span><span class="params">(<span class="keyword">uint32_t</span> NVIC_VectTab, <span class="keyword">uint32_t</span> Offset)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));</span><br><span class="line">  assert_param(IS_NVIC_OFFSET(Offset));  </span><br><span class="line">   </span><br><span class="line">  SCB-&gt;VTOR = NVIC_VectTab | (Offset &amp; (<span class="keyword">uint32_t</span>)<span class="number">0x1FFFFF80</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置中断向量表的库函数一般不常用，中断向量表都会直接以汇编代码的形式写在bootloader中</p>
<p>ARM内核还具有中断分组机制，将所有中断分为0到4共5组</p>
<p>misc.c的描述如下：</p>
<table>
<thead>
<tr>
<th>NVIC分组</th>
<th>抢占优先级数目</th>
<th>子优先级数目</th>
<th>抢占优先级位数</th>
<th>子优先级位数</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0-15</td>
<td>0</td>
<td>4</td>
</tr>
<tr>
<td>1</td>
<td>0-1</td>
<td>0-7</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>0-3</td>
<td>0-3</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>0-7</td>
<td>0-1</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>0-15</td>
<td>0</td>
<td>4</td>
<td>0</td>
</tr>
</tbody></table>
<p>设置分组的原因是用户需求不同，但NVIC优先级控制寄存器位数有限，需要使用类似网络子网掩码的方式形成抢占优先级和子优先级分割，用户可以根据自己的需要选择合适的NVIC分组</p>
<p>使用库函数<code>NVIC_PriorityGroupConfig()</code>来配置中断分组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NVIC_PriorityGroupConfig</span><span class="params">(<span class="keyword">uint32_t</span> NVIC_PriorityGroup)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */</span></span><br><span class="line">  SCB-&gt;AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NVIC还支持低功耗唤醒的配置，使用下面的库函数配置低功耗唤醒源</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NVIC_SystemLPConfig</span><span class="params">(<span class="keyword">uint8_t</span> LowPowerMode, FunctionalState NewState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_NVIC_LP(LowPowerMode));</span><br><span class="line">  assert_param(IS_FUNCTIONAL_STATE(NewState));  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (NewState != DISABLE)</span><br><span class="line">  &#123;</span><br><span class="line">    SCB-&gt;SCR |= LowPowerMode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    SCB-&gt;SCR &amp;= (<span class="keyword">uint32_t</span>)(~(<span class="keyword">uint32_t</span>)LowPowerMode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NVIC配置结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint8_t</span> NVIC_IRQChannel; <span class="comment">//NVIC通道</span></span><br><span class="line">  <span class="keyword">uint8_t</span> NVIC_IRQChannelPreemptionPriority; <span class="comment">//抢占优先级</span></span><br><span class="line">  <span class="keyword">uint8_t</span> NVIC_IRQChannelSubPriority; <span class="comment">//子优先级</span></span><br><span class="line">  FunctionalState NVIC_IRQChannelCmd; <span class="comment">//NVIC中断使能状态</span></span><br><span class="line">&#125; NVIC_InitTypeDef;</span><br></pre></td></tr></table></figure>

<p>下面是一些关于中断的宏定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中断向量表基地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NVIC_VectTab_RAM             ((uint32_t)0x20000000)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NVIC_VectTab_FLASH           ((uint32_t)0x08000000)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_NVIC_VECTTAB(VECTTAB) (((VECTTAB) == NVIC_VectTab_RAM) || \</span></span><br><span class="line"><span class="meta">                                  ((VECTTAB) == NVIC_VectTab_FLASH))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//抢占优先级分组</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NVIC_PriorityGroup_0         ((uint32_t)0x700) <span class="comment">/*!&lt; 0 bits for pre-emption priority</span></span></span><br><span class="line"><span class="comment"><span class="meta">                                                            4 bits for subpriority */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NVIC_PriorityGroup_1         ((uint32_t)0x600) <span class="comment">/*!&lt; 1 bits for pre-emption priority</span></span></span><br><span class="line"><span class="comment"><span class="meta">                                                            3 bits for subpriority */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NVIC_PriorityGroup_2         ((uint32_t)0x500) <span class="comment">/*!&lt; 2 bits for pre-emption priority</span></span></span><br><span class="line"><span class="comment"><span class="meta">                                                            2 bits for subpriority */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NVIC_PriorityGroup_3         ((uint32_t)0x400) <span class="comment">/*!&lt; 3 bits for pre-emption priority</span></span></span><br><span class="line"><span class="comment"><span class="meta">                                                            1 bits for subpriority */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NVIC_PriorityGroup_4         ((uint32_t)0x300) <span class="comment">/*!&lt; 4 bits for pre-emption priority</span></span></span><br><span class="line"><span class="comment"><span class="meta">                                                            0 bits for subpriority */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PriorityGroup_0) || \</span></span><br><span class="line"><span class="meta">                                       ((GROUP) == NVIC_PriorityGroup_1) || \</span></span><br><span class="line"><span class="meta">                                       ((GROUP) == NVIC_PriorityGroup_2) || \</span></span><br><span class="line"><span class="meta">                                       ((GROUP) == NVIC_PriorityGroup_3) || \</span></span><br><span class="line"><span class="meta">                                       ((GROUP) == NVIC_PriorityGroup_4))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_NVIC_PREEMPTION_PRIORITY(PRIORITY)  ((PRIORITY) &lt; 0x10)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_NVIC_SUB_PRIORITY(PRIORITY)  ((PRIORITY) &lt; 0x10)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_NVIC_OFFSET(OFFSET)  ((OFFSET) &lt; 0x000FFFFF)</span></span><br></pre></td></tr></table></figure>

<p>misc中还有一些其他关于内核低功耗、systick时钟的库函数，这一部分不属于本文讨论范围，不再说明</p>
]]></content>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenWrt与嵌入式Linux</title>
    <url>/2021/11/19/OpenWrt%E4%B8%8E%E5%B5%8C%E5%85%A5%E5%BC%8FLinux/</url>
    <content><![CDATA[<h1 id="OpenWrt与嵌入式Linux"><a href="#OpenWrt与嵌入式Linux" class="headerlink" title="OpenWrt与嵌入式Linux"></a>OpenWrt与嵌入式Linux</h1><p>由于要接手学长留下来的一个项目，“被迫”要学习OpenWrt的配置方法——虽然对于一个five电工来说这事挺莫名其妙的，但还是硬着头皮上吧（我本想拒绝，但他给的是在太多了）</p>
<span id="more"></span>

<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在<a href="https://openwrt.org/">官网</a>中这样描述OpenWrt</p>
<blockquote>
<p>OpenWrt项目是一个针对嵌入式设备的Linux操作系统。OpenWrt不是一个单一且不可更改的固件，而是提供了具有软件包管理功能的完全可写的文件系统。这使您可以从供应商提供的应用范围和配置中解脱出来，并且让您通过使用适配任何应用的软件包来定制设备。对于开发人员来说，OpenWrt是一个无需围绕它构建完整固件就能开发应用程序的框架; 对于普通用户来说，这意味着拥有了完全定制的能力，能以意想不到的方式使用该设备。</p>
</blockquote>
<p>听上去很高大上，实际上OpenWrt就和Ubuntu、CentOS、Raspbian等<em>GNU/Linux发行版</em>一样，是一个基于Linux内核的操作系统。只不过它具有<strong>高度模块化可定制</strong>的特点，并且自带一系列<strong>网络组件</strong>，因此常常被用于路由器、工控、智能家居、小型交换机中。笔者接手的这个项目就是基于OpenWrt实现<strong>路由器</strong>-交换机的应用，并配置一个<strong>网络摄像头</strong>和一个<strong>网口数据转串口</strong></p>
<p>OpenWrt除了以上特点外，还有一个堪称嵌入式Linux杀手锏的特性：<em>超级大规模的开源社区</em>。可能是因为大家都很喜欢软路由，OpenWrt的软件包已经达到了好几千，这让它能秒掉一堆其他的嵌入式Linux发行版</p>
<h3 id="OpenWrt与桌面Linux操作系统"><a href="#OpenWrt与桌面Linux操作系统" class="headerlink" title="OpenWrt与桌面Linux操作系统"></a>OpenWrt与桌面Linux操作系统</h3><p>可能大家无法理解OpenWrt这种发行版的独特之处，请允许我在这里为大家重新介绍一下桌面Linux操作系统</p>
<p>一般的桌面操作系统都很难在低性能的嵌入式设备上运行，这是因为两点：</p>
<ol>
<li><p>它们需要占用大量的系统资源，尤其是内存用于支持各种deamon的运行</p>
<p> 一般的GNU/Linux发行版都采用Bash乃至更人性化也更占用资源的Zshell作为终端；而OpenWrt为了适应低性能的处理器，采用更简单的<strong>Ash</strong>作为默认shell。此外，OpenWrt使用的C库是<strong>uClibc</strong>而不是glibc，这是一个面向嵌入式系统的小型C标准库，也有很多RTOS比如FreeRTOS和RT-Thread都采用了这个C库</p>
</li>
<li><p>它们的体积都比较大，一个典型的桌面操作系统占用的存储空间至少在1GB以上</p>
<p> Ubuntu已经膨胀到了2GB，Debian也往往需要占据1GB的硬盘/SD卡/Flash空间；但OpenWrt具有很强的可裁减性，其内核、驱动、自带软件都可以方便地通过menuconfig进行配置，它的运行内存最小只要32M，存放代码数据的Flash空间最小只要8M，但支持使用完备的Linux内核，支持无线、有线网络应用</p>
</li>
</ol>
<p><strong>OpenWrt牺牲了兼容性</strong>，但是由于庞大的开源社区资源，他能够<strong>对大多数网络嵌入式设备提供支持</strong></p>
<p><strong>OpenWrt优化了效率和资源占用</strong>，然而因为难以支持更高性能开销的应用导致<strong>其工作范围局限在嵌入式领域</strong></p>
<h3 id="OpenWrt与一般的嵌入式Linux"><a href="#OpenWrt与一般的嵌入式Linux" class="headerlink" title="OpenWrt与一般的嵌入式Linux"></a>OpenWrt与一般的嵌入式Linux</h3><p>一般的嵌入式Linux都具有上面所说的特点，一些介于桌面Linux操作系统和嵌入式Linux操作系统之间并经过特殊优化的操作系统如Raspbian甚至能够提供更高的性能-资源占用比，但是OpenWrt相比一般的嵌入式Linux系统具有强大的多的网络应用：</p>
<ul>
<li><p>默认自带SSH</p>
</li>
<li><p>可选的图形化网络操作界面Luci（Lua Configuration Interface）</p>
<p>  这是一个使用Lua脚本语言编写的mvc架构的web框架，包含了openwrt的配置界面和一套扩展API。安装luci-core后只要在浏览器中输入OpenWrt设备的IP地址，即可出现其登录界面，可以通过安装luci扩展app实现对OpenWrt设备方方面面的管理</p>
<p>  这个操作界面是对OpenWrt没有图形界面的有效弥补，也是它不同于其他嵌入式Linux的特殊点，这也<strong>使OpenWrt相当好上手</strong></p>
</li>
<li><p>自带软路由模块和交换机模块，可配合硬件实现软/硬件路由功能</p>
</li>
<li><p>可选搭建VPN</p>
</li>
<li><p>可运行轻量级服务器软件</p>
</li>
<li><p>可运行轻量级流量整形与捕获分析软件</p>
<p>  OpenWrt常常被用于搭建软路由，很大程度上就是因为<strong>它支持各种控制网络流量和数据包的应用扩展</strong></p>
</li>
</ul>
<p>除了以上网络特性，OpenWrt还支持嵌入式Linux所具有的基本能力，包括对POSIX的兼容和VFS等</p>
<h3 id="OpenWrt与LEDE"><a href="#OpenWrt与LEDE" class="headerlink" title="OpenWrt与LEDE"></a>OpenWrt与LEDE</h3><p>LEDE是一个源于OpenWrt的分支嵌入式Linux系统，最初一批OpenWrt开发者觉得OpenWrt规则太老套，于是fork了OpenWrt的源码，然后创建了LEDE的分支，在里面添加了很多新开发流程和新功能，然后越来越多OpenWrt开发者转移到LEDE，最后二者又在2018年合并，形成了现在的OpenWrt</p>
<p>有的时候OpenWrt源里面会注明LEDE package，其实和OpenWrt一样，把它看成OpenWrt的某个版本即可</p>
<p>官网这样<a href="https://openwrt.org/zh/about">解释</a>：</p>
<blockquote>
<p>OpenWrt/LEDE是一个为嵌入式设备（通常是无线路由器）开发的高扩展度的GNU/Linux发行版。与许多其他路由器的发行版不同，OpenWrt是一个完全为嵌入式设备构建的功能全面、易于修改的由现代Linux内核驱动的操作系统。在实践中，这意味着您可以得到您需要的所有功能，却仍能避免臃肿。</p>
<p>在2016年，LEDE项目作为OpenWrt项目的副产品而诞生，与OpenWrt共享很多相同的目标。该项目旨在成为一个嵌入式Linux版本，能让开发者、系统管理员或其他Linux爱好者轻松的为嵌入式设备特别是无线路由器构建或定制软件。<em>LEDE</em>这一名称代表<em>Linux Embedded Development Environment</em>。</p>
<p>项目成员与OpenWrt社区活跃成员高度重合，他们计划通过建立一个高度透明、注重协作和去中心化的社区为嵌入式Linux的开发带来新生。</p>
<p>LEDE已公布的目标包括:</p>
<ul>
<li>构造一个的伟大的嵌入式Linux发行版，运行稳定且功能实用</li>
<li>伴随社区设备测试反馈，形成定期、可预期的版本迭代</li>
<li>通过广泛的社区参与和公开会议，建立透明的决策机制</li>
</ul>
<p>LEDE项目的形成是为解决那些被OpenWrt项目或社区认为无法解决的长远问题</p>
<ol>
<li> 活跃核心开发者数量一直很低，而且无法吸引新面孔加入项目。</li>
<li> 不可依赖的基础设施，内部不同意和单点故障阻碍了错误修复。</li>
<li> 在OpenWrt项目中缺少沟通交流、透明度和协调, 无论是在核心团队内部还是在核心团队和其他团队之间。</li>
<li> 没有足够拥有权限的人处理补丁来流，很少关注测试和定期版本。</li>
<li> 不重视对稳定性和文档。</li>
</ol>
<p>为解决这些问题，LEDE项目采用了与OpenWrt不同的组织架构：</p>
<ol>
<li> 所有交流频道均是公开的，对非成员只读的频道控制在一个很好的信噪比。</li>
<li> 决策过程更公开，拥有投票权的开发者和重度用户数量接近50比50。</li>
<li> 大大简化基础设施，确保减少我们的维护工作量。</li>
<li> 更开明的合并政策，基于我们在处理Github上OpenWrt软件包反馈信息的经验。</li>
<li> 高度重视与简化发布流程合并的自动化测试。</li>
</ol>
<p>2018年1月，OpenWrt和以前的LEDE项目同意以OpenWrt这一名称进行合并。</p>
<p>新的、统一的OpenWrt项目将按照 <a href="https://openwrt.org/zh/rules">由前LEDE项目建立的章程</a> 进行管理。以前的LEDE和OpenWrt项目的积极成员将继续在统一的OpenWrt上工作。</p>
</blockquote>
<h2 id="OpenWrt慢速上手"><a href="#OpenWrt慢速上手" class="headerlink" title="OpenWrt慢速上手"></a>OpenWrt慢速上手</h2><p>之所以这部分名叫《慢速上手》，是因为笔者要从底层开始到建立OpenWrt开发环境的全过程进行梳理，至于为什么——这就是我接手这个项目时遇到的窘境：学长跑路，给我留下了一堆残缺的资料，还有一个时灵时不灵的远程支援（虽然在前期的嵌入式开发debug部分确实给我帮了很大忙，但是怎么还在我滚挂系统的时候幸灾乐祸……这对青少年造成的坏影响，不可估量），于是只能从底层开始</p>
<p>所有我遇到的问题都会在</p>
<blockquote>
<p>引用栏</p>
</blockquote>
<p>中说明，避免后来者掉到坑里</p>
<h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><p>硬件设备使用的是海凌科的MT7621模块，基于联发科7621A SoC开发</p>
<ul>
<li>MIPS架构CPU 1004Kc，双核主频880MHz</li>
<li>256MB内存，32MB片上Flash，16位DDR2</li>
<li>自带片上、板载晶振</li>
<li>3.3V、500mA工作电压电流</li>
<li>JTAG调试接口</li>
<li>双WiFi接口</li>
<li>1个WAN口，4个LAN口，全千兆</li>
<li>2路SPI、1路IIC</li>
<li>I2S、PCM等组成的音频接口</li>
<li>2路USB2.0、3.0接口</li>
<li>3路UART接口</li>
<li>GPIO引出</li>
</ul>
<h4 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h4><p>手头的MT7621 SoC带有GPIO外设，可以通过控制<strong>GPIO_MODE寄存器</strong>来使能对应引脚，默认情况下会直接将GPIO复用到其他外设。GPIO是32位的，每个寄存器控制32个IO</p>
<p>常用寄存器如下所示：</p>
<ul>
<li>GPIO_CTRL_X 方向控制寄存器，用于控制GPIO状态为1输出，0输入，2高阻态</li>
<li>GPIO_POL_X 极性控制寄存器</li>
<li>GPIO_DATA_X 数据寄存器，通过读取这个寄存器来获取当前GPIO的值</li>
<li>GPIO_DSET_X 设置寄存器，置1进行使能GPIO</li>
<li>GPIO_DCLR_X 清除寄存器，置1进行失能GPIO</li>
</ul>
<p>使用方法如下：</p>
<ol>
<li><p>登录OpenWrt，使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">reg s 0</span><br><span class="line">reg w 60 0x48258</span><br></pre></td></tr></table></figure>

<p>读取GPIO_MODE寄存器值，<strong>将要配置为GPIO的引脚位设为1</strong></p>
<p>使用<code>reg r 60</code>查看是否配置成功</p>
</li>
<li><p>对应datasheet按照寄存器顺序使用指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">reg w &lt;寄存器位&gt; &lt;要写入的寄存器值&gt;</span><br></pre></td></tr></table></figure>

<p>进行配置</p>
</li>
</ol>
<p>特别地，有些系统中提供了脚本控制的方法，这会使GPIO配置异常简单：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;13&quot; &gt; /sys/class/gpio/export #要设置的引脚</span><br><span class="line">echo &quot;out&quot; &gt; /sys/class/gpio/gpio13/direction #引脚模式</span><br><span class="line">echo &quot;1&quot; &gt; /sys/class/gpio/fpio13/value #设置GPIO输出值</span><br></pre></td></tr></table></figure>

<p>当然如果你要给OpenWrt写一套串口驱动，那就必须按照Linux驱动标准来了，这里不再赘述</p>
<h4 id="SPI与IIC"><a href="#SPI与IIC" class="headerlink" title="SPI与IIC"></a>SPI与IIC</h4><p>OpenWrt是支持SPI、IIC的，只要硬件支持就可以调用这俩东西</p>
<p>相对应的驱动随设备不同而不同，甚至需要在编译时单独加入</p>
<p>特别地，很多屏幕需要使用SPI驱动；很多摄像头需要使用IIC驱动（用来支持SCCB接口），因此最好在编译内核的时候将二者添加进去（占用空间并不是很大）</p>
<h4 id="LAN口"><a href="#LAN口" class="headerlink" title="LAN口"></a>LAN口</h4><p>路由器LAN口用来连接局域网，也就是内网，路由器可以<strong>为LAN口设备提供互联网接入</strong>或<strong>将所有LAN口设备连接到一个VLAN实现交换机目的</strong></p>
<p>相关的内容等到之后的配置OpenWrt再说</p>
<h4 id="WAN口"><a href="#WAN口" class="headerlink" title="WAN口"></a>WAN口</h4><p>路由器WAN口用于连接外网，通常会通过某个外部路由器接入互联网</p>
<p>WAN口是路由器的灵魂，没有WAN口的路由器就是个死交换机，有了WAN口，它才能从外网下载程序、实现路由功能等</p>
<p>一般路由器的配置都是单WAN口多LAN口</p>
<p>这里使用的路由模块配备了1WAN口4LAN口</p>
<blockquote>
<p>很可惜，在硬件组装初期，笔者的路由器WAN口完全连不上，不仅仅无法ping通，甚至ifconfig根本看不到有这个接口</p>
<p>在这种情况下如果想安装软件包就必须使用LAN口，在路由器端使用SCP协议拉取上位机提供的软件包，然后用opkg进行安装（opkg是OpenWrt里面类似dpkg的一个软件包管理器，可以很方便地安装、更新、删除软件包、切换软件源）</p>
<p>解决方法在后文给出</p>
</blockquote>
<h4 id="网络变压器与Bob-Smith电路"><a href="#网络变压器与Bob-Smith电路" class="headerlink" title="网络变压器与Bob-Smith电路"></a>网络变压器与Bob-Smith电路</h4><p>在网络硬件设计中经常接触到RJ-45网口，现在的RJ45网口很多都自带了网络变压器，因此只要正常接入并记得使用75欧或50欧电阻进行阻抗匹配就可以了；但是对于这里的路由模块，它使用杜邦线-排针代替RJ45网口（别问为什么，问就是特殊领域），因此需要仔细设计网络变压器部分的电路，它被称为<strong>Bob-Smith电路</strong></p>
<p><img src="/2021/11/19/OpenWrt%E4%B8%8E%E5%B5%8C%E5%85%A5%E5%BC%8FLinux/image-20210817004039321.png" alt="image-20210817004039321"></p>
<p>他有如下几个关键作用：</p>
<ol>
<li><p>信号传输</p>
<p> Bob-Smith电路分为<strong>电流型</strong>和<strong>电压型</strong>，根据驱动网络变压器的是电流为主还是电压为主区分</p>
<p> 电流型：<strong>网络变压器输入侧</strong>（接PHY芯片或SoC的那一侧）<strong>需要在每个变压器抽头处上拉到电源</strong>，如果EMC要求更加严格，还会使用一个高频（75MHz-200MHz）电感跨接在抽头和电源之间，上拉电源可以是1.8、2.5、3.3等，这是为了<strong>增强网络变压器的驱动能力</strong></p>
<p> 同时需要在输入侧变压器正负端跨接50-100欧姆（常用75欧姆）的分流电阻，用于调整信号驱动强度</p>
<p> 电压型：<strong>输入侧变压器抽头接到一起再通过100nF电容到地</strong>，这是为了提高网络变压器的EMC性能；正负端则分别接入50-100欧分压电阻到PHY芯片或SoC，用于调整信号驱动强度</p>
</li>
<li><p>阻抗匹配</p>
<p> <strong>阻抗匹配</strong>：当传输路径上阻抗不连续时，会有反射发生，阻抗匹配的作用就是通过端接元器件时，保证传输路线上的阻抗连续以去除传输链路上产生的反射。</p>
<p> 网络变压器的输出端要接共模双绞线，双绞线上传输的是差分信号，因此需要使用100-150欧的阻抗匹配</p>
<p> <strong>网络变压器输出端的抽头都需要接50欧或75欧</strong>（根据线缆长度不同决定，也可以改为100欧，但25欧因为阻值太低不常用）<strong>到线缆，同时需要一个100nF的电容用于旁路</strong>（滤波）</p>
<p> 这几个电阻就起到了阻抗匹配作用，计算公式如下<br> $$<br> Z=\sqrt{R-j\frac{1}{\omega C}}<br> $$</p>
</li>
<li><p>波形修复</p>
<p> 输出端的旁路电容可以有效对外传输线路上的噪声实现滤除</p>
</li>
<li><p>抑制杂波</p>
<p> 电压型BS电路通过下拉到地的100nF滤波电容实现了滤出高频噪声的作用，而两个串联在变压器上的分压电阻配合变压器寄生电感可以提高电路对差模信号的抑制能力，从而滤除高频杂波，保证网口通信正常</p>
<p> 电流型BS电路则直接使用较高电流驱动的方式削弱从控制端输出的高频杂波影响。但是因为电流型电路会导致整体功耗较大，所以正在被电压型取代（不过在大功率信号传输的领域还是有一定应用）</p>
</li>
<li><p>隔离高压</p>
<p> 这一条也可以称为<strong>共模-差模防护</strong>，电路可以通过一系列泻放路径抵抗从网络变压器输出端而来的浪涌电压电流。</p>
<p> 具体实现出于篇幅所限不在这里列出，大致思路就是<em>共模浪涌会被变压器和输出端电阻自行抵消，最多可能付出电容被击穿的代价，并不会伤害到控制端；而差模信号会被变压器引入到输入端，之后直接通过抽头的电容或上拉电阻被滤除，能够很大程度地减少对输入端和信号的影响</em></p>
</li>
</ol>
<blockquote>
<p>在配置过程中发现：WAN口无法使用</p>
<p>重新刷入三次系统，反复调试一周后发现还是这样，基本上排除了所有可能的软件问题。于是决定回到硬件检查是否网络变压器或引脚出问题。首先用万用表通断档依次检测电容两端对地是否导通，发现WAN口的输入电容两端都对地为0——短路了；之后换用电阻档断电测量输入输出电阻，原本电路中使用75欧电阻，但测量中发现有两个电阻阻值不对，一个是偏小到50欧，另一个则无穷大。换掉电容电阻，上电接网线，成功秒杀</p>
</blockquote>
<h3 id="自定制并编译内核"><a href="#自定制并编译内核" class="headerlink" title="自定制并编译内核"></a>自定制并编译内核</h3><p><a href="https://github.com/openwrt/openwrt">openwrt</a>整个项目在github上可以找到</p>
<p>也可以通过<a href="https://git.openwrt.org/openwrt/openwrt.git">官方OpenWrt源码</a>下载</p>
<p>于是直接用git下载或下载压缩包到linux系统就可以使用了</p>
<p>一般来说可以使用虚拟机搭建环境，但是如果你习惯了使用桌面端linux，可以直接在你的双系统/纯linux环境中搭建openwrt的开发环境</p>
<h4 id="配环境"><a href="#配环境" class="headerlink" title="配环境"></a>配环境</h4><p>根据openwrt项目中的README文档就可以简单地配好整个环境，这里摘录一下在ubuntu20中所需要安装的一些关键软件包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install gcc g++ make gettext libncurses5-dev patch binutils flex bison subversion build-essential autoconf bzip2 libz-dev zlib1g-dev gawk git ccache gettext asciidoc libssl-dev sphinxsearch xsltproc sphinx-common libtool libssl-dev unzip</span><br></pre></td></tr></table></figure>

<p>安装完依赖以后还要下载一些openwrt主分支中没有加入的源代码，这些都是诸如kernel、package之类的大号源码，需要从官方<strong>对应的版本库</strong>中拉取到本地</p>
<p>这里需要注意：版本！</p>
<p>在拉取之前应该确定你想要编译的内核版本</p>
<p>常用的大版本有14、15、16、17、18、19，小版本从.1到.9不等，各个版本差异都比较大，大版本之间软件包基本是不可能通用的，小版本之间的软件包安装也存在各种问题，所以<strong>选版本的时候尽量考虑清楚</strong></p>
<p>使用指令<code>git checkout openwrt-xx.xx</code>来切换到某个指定的内核版本，可以通过<strong>git指令</strong>查看各个版本间的不同</p>
<p>选择版本后就要添加软件扩展包了：</p>
<p>首先</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp feeds.conf.default feeds.conf</span><br></pre></td></tr></table></figure>

<p>设置所需要使用的源，然后</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./scripts/feeds update -a</span><br><span class="line">./scripts/feeds install -a</span><br></pre></td></tr></table></figure>

<p>更新并安装扩展程序</p>
<p>完成后应该可以看到OpenWrt目录如下：</p>
<ul>
<li>config 编译选项配置文件目录: 包含全局编译设置，开发人员设置和内核编译设置</li>
<li>include 就是普通的头文件目录，但是也包含了各种脚本和Makefile</li>
<li>package 软件包目录</li>
<li>scripts 环境脚本、下载补丁脚本、Makefile等</li>
<li>target 嵌入式平台移植包</li>
<li>toolchain 编译器和C库工具链</li>
<li>tools 用于生成固件的辅助工具</li>
<li>dl 下载的软件包目录</li>
</ul>
<p>顺带一提，在编译完成时还能看到build_dir和staging_dir，二者分别是中间文件目录和编译安装目录</p>
<p>在完成配置后可以使用<code>make defconfig</code>来测试编译环境是否配置正确</p>
<blockquote>
<p>千万注意不要被老版本的配环境资料误导，包括本篇！不要看见一个差不多的资料就从里面复制粘贴指令！</p>
<p>一定要选择适合自己系统的配环境资料，最好查阅官方文档！虽然会麻烦一点但是可以很大程度上避免滚挂系统！</p>
<p>不要问我怎么知道的，我只能说linux双系统有风险，滚挂系统重装好麻烦的！</p>
</blockquote>
<h4 id="menuconfig"><a href="#menuconfig" class="headerlink" title="menuconfig"></a>menuconfig</h4><p>配完环境以后就可以进行半可视化配置内核、应用程序的menuconfig了</p>
<p>先使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>

<p><strong>打开menuconfig半图形化配置界面，在里面添加需要选用的组件</strong></p>
<p>操作：键盘上下移动光标，左右选择底部按键，回车是确认，空格是设置选择模式，选项最前面的选择模式有[*]表示编译进固件，[M]表示编译成安装包，[ ]表示不选择，esc是返回上级菜单，按?是帮助，按/是搜索</p>
<p>注意一般应用程序编译成安装包等进入系统后再安装，kmod内核驱动要编译进固件，带opkg字样的东西一定要编译进固件，不然没法安其他包</p>
<p><strong>配置选项定义</strong></p>
<table>
<thead>
<tr>
<th align="center">配置选项</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Target System</td>
<td align="left">目标平台，对应目录openwrt/target/linux 里的目录</td>
</tr>
<tr>
<td align="center">Subtarget</td>
<td align="left">目录 openwrt/target/linux/(目标) 里的子目录，定义特定目标</td>
</tr>
<tr>
<td align="center">Target Profile</td>
<td align="left">目标描述文件，在subtarget目录下面的profile目录中</td>
</tr>
<tr>
<td align="center">Target Images</td>
<td align="left">编译生成目标固件的控制选项</td>
</tr>
<tr>
<td align="center">Global build settings</td>
<td align="left">全局编译设置，按默认设置进行编译就可以</td>
</tr>
<tr>
<td align="center">Advanced configuration options</td>
<td align="left">高级配置选项，无需理会</td>
</tr>
<tr>
<td align="center">Build the OpenWrt Image Builder</td>
<td align="left">可以编译出一个编译系统供其它主机安装</td>
</tr>
<tr>
<td align="center">Build the OpenWrt SDK</td>
<td align="left">编译生成SDK开发包，提供给其它主机进行应用开发</td>
</tr>
<tr>
<td align="center">Package the OpenWrt-based Toolchain</td>
<td align="left">生成开发工具链包，提供给其它主机进行应用开发</td>
</tr>
<tr>
<td align="center">Image configuration</td>
<td align="left">控制是否打开feed.conf中的模块</td>
</tr>
<tr>
<td align="center">Base system</td>
<td align="left">基本软件包选择，主要是busybox组件</td>
</tr>
<tr>
<td align="center">Boot Loaders</td>
<td align="left">引导系统的系统，不用管它</td>
</tr>
<tr>
<td align="center">Development</td>
<td align="left">开发包、开发工具，如gcc、gdb之类</td>
</tr>
<tr>
<td align="center">Firmware</td>
<td align="left">特定硬件的固件</td>
</tr>
<tr>
<td align="center">Kernel modules</td>
<td align="left">内核模块、内核配置选项</td>
</tr>
<tr>
<td align="center">Languages</td>
<td align="left">软件开发语言选择</td>
</tr>
<tr>
<td align="center">Libraries</td>
<td align="left">动态链接库选择</td>
</tr>
<tr>
<td align="center">Network</td>
<td align="left">网络功能模块选择</td>
</tr>
<tr>
<td align="center">Utillities</td>
<td align="left">一些实用工具模块</td>
</tr>
</tbody></table>
<p>（上面内容摘录自<a href="https://www.jianshu.com/p/e2b5a292392e%EF%BC%89">https://www.jianshu.com/p/e2b5a292392e）</a></p>
<p>完成选择后就可以保存退出了，生成的文件会让你命名，一般直接保持默认<code>.config</code>即可</p>
<blockquote>
<p>在这个项目里，我遇到的最大问题就是在menuconfig的时候安装进模块的软件包无法使用，于是只能和OpenWrt内核版本、底层硬件驱动、网口配置斗智斗勇……在一般情况下面对嵌入式设备一定要首先考虑在menuconfig的时候安装软件包，否则后续的操作有可能反而比menuconfig复杂——尤其是在安装额外的kmod，也就是内核驱动时。自行编译的内核是具有独立的md5码的，并不能和官方的bin文件对应的md5码吻合，这就导致下载软件包的时候kmod无法匹配内核，所以要使用强制安装，而又因为你的内核是自行编译的，所以很有可能会出现因为内核版本不对而很多程序无法运行，甚至运行时崩溃的情况</p>
</blockquote>
<h4 id="漫长的编译"><a href="#漫长的编译" class="headerlink" title="漫长的编译"></a>漫长的编译</h4><p>make就完事了，make的时候可以换各种姿势</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make V=s #输出编译信息，第一次编译一般用这个，单核编译小水管不得不品尝</span><br><span class="line">make V=99 #上面这个的老版本用法</span><br><span class="line"></span><br><span class="line">make -j12 #j后面跟你的cpu核心数，对amd cpu很友好，但是不会输出编译信息，如果要反复编译还是比较适合的，省时间</span><br><span class="line">make clean #重新编译之前记得用一下，不然下次编译可能出现莫名其妙的错误</span><br></pre></td></tr></table></figure>

<p>特别地，现在GitHub有一个叫Actions的服务，有人利用这个服务制作了一套<a href="https://github.com/P3TERX/Actions-OpenWrt">在线编译OpenWrt的系统</a></p>
<p>主要有以下特色：</p>
<ul>
<li><strong>免费！快速！一次编译成功率高！</strong></li>
<li>一键快速自动多线程编译</li>
<li>无需搭建编译环境，上手就用，用完就扔</li>
</ul>
<p>根据<a href="https://p3terx.com/archives/build-openwrt-with-github-actions.html">项目的中文介绍页面</a>里面的介绍一步步来就可以实现在线编译了（记得提前准备一个GitHub账号）</p>
<p>其中比较友好的是可以支持SSH连接到GitHub Actions虚拟服务器环境，直接在服务器上menuconfig</p>
<blockquote>
<p>编译的时候出现了很多错误，不要嫌麻烦，挨个查看改正就行，第一次编译难免出错，正常情况下改一天肯定是能编译出来的</p>
<p>不过后续烧录能不能识别嘛……祈祷自己的设备比较常见吧；特种设备采用特殊器件装特殊系统……自求多福，运气好总能成功的</p>
</blockquote>
<h3 id="上位机连接到OpenWrt"><a href="#上位机连接到OpenWrt" class="headerlink" title="上位机连接到OpenWrt"></a>上位机连接到OpenWrt</h3><p>终于完成了整个系统的编译，接下来就能尝试烧录并连接到设备了。烧录过程和设备具体硬件配置有关</p>
<h3 id="烧录"><a href="#烧录" class="headerlink" title="烧录"></a>烧录</h3><p>如果你使用的是普通路由器，一般来说连上LAN口，登录网关地址，里面的选项里会有一个更新固件，直接把bin文件上传，点击烧录就可以了；如果使用的是一般的嵌入式设备，一般可以选择使用openocd配合jtag进行烧录，只要900+rmb氪入一套jlink基本可以完美烧录（笑）上面两个方法都太简单（没钱买设备是个人问题，有钱人烧录都很简单的）。下面介绍一下常用的三种烧录方法：</p>
<ol>
<li><p><strong>uBoot烧录</strong></p>
<p>一般来说设备出厂以后都会烧录<strong>uBoot</strong>，这个东西和grub有点像，但是它工作在嵌入式领域，可以支持Linux、安卓、FreeBSD等系统的引导，支持MIPS、x86、ARM、RISC-V等等各种架构的CPU，而OpenWrt对应使用的uBoot往往会着重增强网络能力，因此一般OpenWrt设备的uBoot都会自带TFTP协议的功能，并且会打开一个操作界面，因此可以直接参考厂商给出的说明，按以下步骤启动设备</p>
<ul>
<li>连接LAN口到上位机</li>
<li>修改上位机IP为厂商指定的静态IP地址，并按照地址设定子网掩码</li>
<li>下位机设备断电，按住Boot按键（或者叫WPS按键）（当然如果没有这个按键应该从Boot引脚到地焊接一根跳线）</li>
<li>将设备上电</li>
<li>保持按键一段时间，等待设备从uBoot启动（类似于按住进入键盘上某个键进入BIOS设置界面）</li>
<li>松开按键并在上位机打开厂商指定的IP地址（浏览器打开，别想着用什么奇奇怪怪的软件）</li>
<li>选择固件、上传、等待</li>
<li>等到足够长时间以后（具体多长要参考厂商说明）修改LAN口为dhcp或默认设置的静态IP</li>
<li>尝试正常连接路由器</li>
</ul>
<p>如果中间没有操作界面，可以尝试反复ping要连接的uBoot地址，如果能ping通那就是连上了，之后使用类似下面的uboot命令（由厂商决定）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tftp 固件保存地址 要上传的固件</span><br><span class="line">erase 固件启动地址 + $固件大小</span><br><span class="line">cp 固件保存地址 固件启动地址 $固件大小</span><br><span class="line">set bootcmd 固件启动地址</span><br><span class="line">save</span><br><span class="line">boot</span><br></pre></td></tr></table></figure>

<p>总体过程就是：上传-擦除原本固件-复制上传的固件到启动位置-设置固件启动位置-保存-重启设备</p>
<p>uBoot功能很强大，在某种程度上说它就像桌面版linux的livecd一样，只要uboot不刷坏，设备就可以说是不死的，一直可以通过重新进入uboot的方式刷新系统</p>
<blockquote>
<p>顺便提一下，对于14.07版本的内核，应用在MT7621上时，安装kmod-usb-ehci与kmod-usb-hid可能会导致冲突让系统崩溃，就是因为同时安装了他俩让我不得不重新刷机好几次</p>
</blockquote>
</li>
<li><p><strong>luci界面升级</strong></p>
<p>就是上面说过的登入网关以后从配置界面上传固件升级的过程，但是一般来说会保留原来系统的配置，所以最好刷更新的固件，而不是刷老版本固件，否则会有可能变砖，还需要用第一种方法再刷一次</p>
</li>
<li><p><strong>烧录器烧录</strong></p>
<p>如果uBoot损坏、网口有问题甚至Flash挂了，那就必须使用这种方法了。</p>
<p>一般来说需要使用专门的Flash烧录器配合上位机软件对准Flash的引脚进行烧录，Flash烧录器有1.8V、3.3V、5V三种，一般来说现在的SPI Flash（最典型的W25Q128）使用3.3V烧录器就可以，但是很多设备都用上了低功耗Flash，这就需要一个电平转换板或者直接使用1.8V烧录器进行烧录。如果是最为极端的情况，Flash挂了，那就必须把Flash拆下来，换一个新Flash上去再烧录</p>
</li>
</ol>
<blockquote>
<p>在艰难的配环境过程中，某个不愿透露姓名的学长就把Flash整废了，好巧不巧那块Flash还是特殊封装的贴片元件，极其难焊接，于是只能购入巨贵的专用烧录板，烧录新的Flash以后再装上去。由于没碰见过这种情况+快递速度缓慢，流程整整走了一周。</p>
<p>笔者接手项目以后，还遇到了uBoot死活不启动的情况，检查电路以后发现是板上的Boot线路被莫名划坏一道，于是补好了铜线才得以启动uBoot</p>
<p><strong>新手注意：遇到uBoot不启动不要慌，较大可能是你按的时间不够久或者操作有疏忽导致uBoot启动被跳过了，只要认真多试几遍总能成功，在期间善用百度很关键</strong></p>
</blockquote>
<h4 id="Luci"><a href="#Luci" class="headerlink" title="Luci"></a>Luci</h4><p>完成系统烧录以后，上电，上位机连上LAN口，等待几分钟，浏览器打开网关地址（一般是<code>192.168.1.1</code>），一般来说就能进入一个登陆界面，这就是OpenWrt的<strong>Luci界面</strong></p>
<p>通过这个界面可以对设备的大多数设置进行调整，这里不多作介绍，都是很直接了当的东西</p>
<p>在某些角落会留着language的设置栏，在这里可以选择语言，省去啃生肉的烦恼</p>
<h4 id="串口终端"><a href="#串口终端" class="headerlink" title="串口终端"></a>串口终端</h4><p>最传统登录Linux的方法当然是串口终端——不论嵌入式linux还是服务器linux</p>
<blockquote>
<p>TTL串口是人类的好朋友</p>
</blockquote>
<p>这种方法不必多说，折腾过树莓派的人都懂，串口调试器连接UART Tx、Rx、GND，重启设备，开启Putty或者XShell，之后开机信息就会从界面喷涌而出</p>
<h4 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h4><p>这种方法很适合具有WiFi功能的OpenWrt设备，能够省掉一根网线。不过有网线连接的时候也很实用，对于linux来说命令行总是比可视化可靠。</p>
<p>连上网线ping通后，直接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh 用户名(一般是root)@目标设备IP</span><br></pre></td></tr></table></figure>

<p>就可以登录到OpenWrt了</p>
<h4 id="任何其他Linux发行版允许的登录方式"><a href="#任何其他Linux发行版允许的登录方式" class="headerlink" title="任何其他Linux发行版允许的登录方式"></a>任何其他Linux发行版允许的登录方式</h4><p>只要在内核里面使能了某个可行的登陆方式，并且硬件允许它运行，那么用户就能用这种方式进行登录OpenWrt</p>
<p>毕竟这可是Linux啊！</p>
<h3 id="联网"><a href="#联网" class="headerlink" title="联网"></a>联网</h3><p>强调一下：<strong>如果是必须的kmod还是应该先想好然后在编译内核阶段完成安装</strong></p>
<p>一般来说正常安装了网络设备驱动和普通luci界面的设备直接插上网线或者通过luci界面配置好wifi以后就可以联网了，但是如果无法联网可能有以下几个原因：</p>
<ol>
<li>编译内核时没有把网络设备驱动编译进去（一般来说是默认添加且不能修改的，但是谁知道用户会做出什么逆天操作）</li>
<li>外部设备不支持联网（一般是硬件坏了，弄个交换机上OpenWrt还不如多花点钱买个带千/万兆网口的）</li>
<li>配置问题</li>
</ol>
<p>1、2点需要重新编译或者检查硬件甚至重新选型，非常难以解决，所以一定要避免这两种问题出现；第三种相对容易解决一些，根据百度到的教程一步步来即可，一般来说都是因为路由器接口/netif/wpa/交换机接口配置出错，依次排除不要着急</p>
<blockquote>
<p>在我调试这个板子的时候发生了一件很绝望的事情：板子无法联网，但是能够在内网登录luci界面并ssh。刚开始我以为是软件问题，先去查找了一遍OpenWrt的官方文档，通过luci界面配置了一遍接口，但是无济于事；然后又ssh进去通过vi查找配置文件，无果；因为项目进度逼的比较紧，于是只能换用离线装软件包的方法。等到折腾了一大通硬装软件包以后才想起来检查硬件问题，最后发现是开头说的网络变压器电路问题导致无法联网</p>
<p>所以嵌入式编程<strong>一定要先排除硬件问题</strong>！</p>
</blockquote>
<h3 id="包管理器"><a href="#包管理器" class="headerlink" title="包管理器"></a>包管理器</h3><p>OpenWrt最与众不同的一点就是它配备了<strong>opkg</strong>包管理器，它和apt、yum、pacman等指令使用方式类似，能够<em>不是很智能地智能解决</em>软件包依赖问题：<em>只能解决一点点</em>。一般来说自动解决需要一层依赖的软件包安装还是可以的，但是为了安全起见还是一步一步的安装软件包吧。opkg常用指令如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">opkg install </span><br><span class="line">opkg remove</span><br><span class="line">opkg update</span><br><span class="line">opkg upgrade</span><br></pre></td></tr></table></figure>

<p>软件包管理器的设置位于<code>/etc/opkg</code>中</p>
<p>这个包管理器也是支持<strong>换源</strong>的，如果某个软件源不好连接，完全可以更换当前使用的软件源，使用luci界面就可以轻松换源，如果非要使用命令行也可以像ubuntu那样直接编辑设置文件来换源</p>
<p>具体操作网上有很多，不再赘述，特别指出善用下面的指令可以快速更换软件源的域名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i</span><br></pre></td></tr></table></figure>

<p>特别地，安装软件包时如果碰到了kmod字样的软件包，就说明这是一个内核驱动包，在安装它的时候很可能会遇到内核版本不正确的情况——因为自行编译的OpenWrt生成时会自动携带一个经过修改的md5码，它往往和已有的内核驱动应该对应的验证码不一致，因此会出现报错，这种情况下在安装指令后面加上如下参数就可以解决问题了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--force-depends</span><br></pre></td></tr></table></figure>

<p>如果还是不行，甚至出现系统崩溃、变砖的情况，就要考虑是否是自己的软件源选错抑或是自己编译的内核版本不对了</p>
<p>这就是为什么在上面反复强调要注意内核版本与内核驱动</p>
<p><strong>snapshot版本和release版本区别</strong></p>
<p>我们经常会看到软件源中的某些项目版本以release或snapshots结尾，一般来说snapshots版本代表正在开发中的版本（快照版本,一般处于开发阶段），release代表比较稳定的发布版本（这次迭代的所有功能都已经完成）</p>
<blockquote>
<p>换源的操作对于嵌入式Linux，或者说OpenWrt来说不是很重要，但是在面对很难处理的软件bug时可以考虑换源来解决，我在处理项目时通过多次换源解决了一些软件包的依赖问题，使用到的源如下：</p>
<p>清华源 src/gz barrier_breaker_base <a href="http://mirrors.tuna.tsinghua.edu.cn/openwrt/barrier_breaker/14.07/ramips/mt7621/packages/base">http://mirrors.tuna.tsinghua.edu.cn/openwrt/barrier_breaker/14.07/ramips/mt7621/packages/base</a></p>
<p>稳定版官方源 src/gz barrier_breaker_base <a href="http://downloads.openwrt.org/snapshots/trunk/ramips/mt7621/packages/base">http://downloads.openwrt.org/snapshots/trunk/ramips/mt7621/packages/base</a></p>
<p>快照版官方源 src/gz barrier_breaker_base <a href="http://downloads.openwrt.org/snapshots/trunk/ramips/mt7621/packages/base">http://downloads.openwrt.org/snapshots/trunk/ramips/mt7621/packages/base</a></p>
<p>存档版官方源src/gz barrier_breaker_base <a href="https://archive.openwrt.org/snapshots/trunk/ramips/mt7621/packages/base">https://archive.openwrt.org/snapshots/trunk/ramips/mt7621/packages/base</a></p>
<p><strong>主要的思路就是查看自己要安装的软件包都需要什么依赖，然后对照依赖版本寻找对应的md5码，再根据md5码选择支持的官方源</strong></p>
<p>在换源的时候可能会遇到下面的报错：Package xxx version xxx has no valid architecture, ignoring.</p>
<p>这是因为源指定的系统和设备上刷入的系统md5码不符合，可以直接在/etc/opkg.conf文件中加入对系统支持的architecture的设置，也就是在文件中添加下面的内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arch all 100</span><br><span class="line">arch &lt;arch类型1&gt; 200</span><br><span class="line">arch &lt;arch类型2&gt; 300</span><br></pre></td></tr></table></figure>

<p>arch类型可以在源下面的package目录内配置文件中查找到，我使用的配置如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arch all 100</span><br><span class="line">arch mips 200</span><br><span class="line">arch ramips 300</span><br><span class="line">arch unkown 400</span><br></pre></td></tr></table></figure>

<p>换用<a href="https://archive.openwrt.org/">官方archive源</a>也可以帮助解决一些老版本不兼容的问题</p>
</blockquote>
<h3 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h3><p>只要登陆进luci界面，再让设备联网就可以轻松地进行可视化安装，并且luci界面还会将软件包依赖关系列出来，非常简便；命令行下的安装过程也不算复杂，和ubuntu、centos等发行版的软件安装方法类似</p>
<p>一般我们用opkg安装软件有两种方式：</p>
<ul>
<li><p>是连上网络后从官方网站安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">opkg update</span><br><span class="line">opkg install xxx</span><br></pre></td></tr></table></figure></li>
<li><p>把软件下载到上位机（直接进入软件源网页，通过ftp下载即可），通过winscp或者linux下使用scp指令传到路由器tmp目录，再使用指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">opkg install xxx.ipk</span><br></pre></td></tr></table></figure>

<p>安装</p>
</li>
</ul>
<p>如果路由暂时上不了网，就无法使用前一种方法，后一种方法又有些麻烦，其实除此之外还可以通过上位机开启ftp/http服务，让设备接入来实现“在内网”安装：</p>
<ol>
<li><p>在本机上开ftp/http/其他网络服务</p>
</li>
<li><p>修改/etc/opkgconfig，将第一行的网址（也就是软件源地址）改成上位机服务器放安装包的服务目录</p>
</li>
<li><p>从软件源下载需要的安装包到服务目录</p>
</li>
<li><p>把软件源的packages文件下载到服务目录</p>
</li>
<li><p>使用指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">opkg update</span><br><span class="line">opkg install xxx</span><br></pre></td></tr></table></figure>

<p>安装软件</p>
</li>
</ol>
<blockquote>
<p>上面提到了本地安装软件包的方法，所以在这里特别提一下，<strong>实际上安装非常麻烦</strong>，所以尽量不要使用这种方法</p>
</blockquote>
]]></content>
      <tags>
        <tag>嵌入式Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32外设配置速查【摄像头】</title>
    <url>/2021/11/19/STM32%E5%A4%96%E8%AE%BE%E9%85%8D%E7%BD%AE%E9%80%9F%E6%9F%A5%E3%80%90%E6%91%84%E5%83%8F%E5%A4%B4%E3%80%91/</url>
    <content><![CDATA[<h1 id="OV2640"><a href="#OV2640" class="headerlink" title="OV2640"></a>OV2640</h1><p>OV2640是OmniVision公司生产的1/4英寸CMOS UXGA(1632_1232分辨率)图像传感器</p>
<p>特点：</p>
<ul>
<li>体积小、工作电压低、灵敏度高</li>
<li>具有单片UXGA摄像头和影像处理器的所有功能</li>
<li>通过SCCB总线控制</li>
<li>可输出整帧、子采样、缩放、取窗口等方式各种分辨率的8/10位影像数据</li>
<li>最高帧数15帧/秒（SVGA可达30帧，CIF可达60帧）</li>
<li>用户定义图像质量、数据格式、传输方式等</li>
<li>所有图像处理功能都可以通过==SCCB接口==（行摄像机控制总线协议，相当于一个简易的I2C协议）编程</li>
<li>==兼容I2C接口==</li>
<li>支持RawRGB、RGB、GRB422、YUV和YCbCr输出格式</li>
<li>内置DSP，<strong>支持UXGA、SXGA、SVGA以及按比例缩小到从SXGA到40*30的任何尺寸</strong>，支持图像缩放</li>
<li>支持自动曝光控制、自动增益控制、自动白平衡、自动消除灯光条纹、自动黑电平校准等自动控制功能和色饱和度、色相、伽马、锐度等设置，支持闪光灯</li>
<li>支持图像压缩，可输出JPEG图像数据</li>
</ul>
<h2 id="SCCB时序"><a href="#SCCB时序" class="headerlink" title="SCCB时序"></a>SCCB时序</h2><p>SCCB（Serial Camera Control Bus串行摄像头控制总线）总线是由OV（OmniVision）公司定义和发展的三线式串行总线。现在SCCB总线大多采用两线式接口总线，接口总线包括SIOC串行时钟输入线和SIOD串行双向数据线，分别相当于IIC协议的SCL信号线和SDA信号线。<strong>SCCB就是个简化版的IIC</strong>，可以直接使用IIC的软件驱动代码改编成SCCB的驱动</p>
<span id="more"></span>

<h3 id="基本概念简介"><a href="#基本概念简介" class="headerlink" title="基本概念简介"></a>基本概念简介</h3><table>
<thead>
<tr>
<th>UXGA</th>
<th>1600*1200</th>
</tr>
</thead>
<tbody><tr>
<td>SXGA</td>
<td>1280*1024</td>
</tr>
<tr>
<td>XVGA</td>
<td>1280*960</td>
</tr>
<tr>
<td>WXGA</td>
<td>1280*800</td>
</tr>
<tr>
<td>XGA</td>
<td>1024*768</td>
</tr>
<tr>
<td>SVGA</td>
<td>800*600</td>
</tr>
<tr>
<td>VGA</td>
<td>640*480</td>
</tr>
<tr>
<td>QQVGA</td>
<td>160*120</td>
</tr>
<tr>
<td>CIF</td>
<td>352*288</td>
</tr>
<tr>
<td>PCLK</td>
<td>像素时钟：一个PCLK时钟，输出一个(Raw格式)或半个(RGB565格式)像素</td>
</tr>
<tr>
<td>VSYNC</td>
<td>帧同步信号</td>
</tr>
<tr>
<td>HREF/HSYNC</td>
<td>行同步信号</td>
</tr>
</tbody></table>
<p>ov2640的图像数据输出通过Y[9:0]寄存器输出，这里只使用一**字节(8位)**数据，再PCLK、VSYNC、HREF/HSYNC控制下进行</p>
<p>==对于Raw格式数据，$1<em>t_p=1</em>T_{PCLK}$==</p>
<p>==对于YUV/RGB格式数据，$1<em>t_p=2</em>T_{PCLK}$==</p>
<h3 id="行输出时序"><a href="#行输出时序" class="headerlink" title="行输出时序"></a>行输出时序</h3><p><strong>HREF高电平</strong>期间的<strong>PCLK上升沿</strong>进行输出，每个PCLK上升沿从Y[9:0]输出一个**字节(8位)**数据</p>
<p>PCLK最大可达36MHz</p>
<p>例：以<strong>UXGA(1600*1200)<strong>时序，采用</strong>RGB565</strong>格式输出，每2字节组成一个像素的颜色，且低字节在前高字节在后。这样<strong>每行</strong>输出总共有<strong>1600*2个PCLK周期</strong>，<strong>输出1600*2个字节</strong></p>
<h3 id="帧输出时序"><a href="#帧输出时序" class="headerlink" title="帧输出时序"></a>帧输出时序</h3><p><strong>输出开始时，VSYNC输出$4*t_{LINE}$有效电平</strong>（可自行设置为高/低）脉冲</p>
<p><strong>$27193*t_p$后，HREF拉高，开始输出行数据</strong>，每行数据输出之间以$322*t_p$为间隔，直到完成所有行输出</p>
<p>最后会有$57697*t_p$间隔才能进行下一帧输出</p>
<h3 id="JPEG时序"><a href="#JPEG时序" class="headerlink" title="JPEG时序"></a>JPEG时序</h3><p>JPEG输出时，PCLK大大减少，HREF不连续，数据流以0xFF、0xD8开头，以0xFF、0xD9结束，将此间数据保存为.jpg文件即可在电脑打开查看</p>
<h2 id="相关硬件配置"><a href="#相关硬件配置" class="headerlink" title="相关硬件配置"></a>相关硬件配置</h2><h3 id="OV2640传感器窗口设置"><a href="#OV2640传感器窗口设置" class="headerlink" title="OV2640传感器窗口设置"></a>OV2640传感器窗口设置</h3><p>传感器窗口设置允许用户设置整个传感器区域（1632*1220）的感兴趣部分，即<strong>在传感器里面开窗</strong>，开窗范围从2*2到1632*1220都可以设置，但<strong>要求这个窗口必须大于等于随后设置的图像尺寸</strong></p>
<p>详细内容可查看数据手册</p>
<h3 id="图像尺寸设置"><a href="#图像尺寸设置" class="headerlink" title="图像尺寸设置"></a>图像尺寸设置</h3><p>即<strong>DSP输出到LCD的图像最大尺寸</strong>，该尺寸要小于等于传感器窗口设置所设定的窗口尺寸</p>
<h3 id="图像窗口设置"><a href="#图像窗口设置" class="headerlink" title="图像窗口设置"></a>图像窗口设置</h3><p>在设置的图像尺寸里面再次设置窗口大小，该窗口必须小于等于前面设置的图像尺寸，<strong>该窗口设置后的图像范围将用于输出到外部</strong></p>
<h3 id="图像输出大小设置（缩放设置）"><a href="#图像输出大小设置（缩放设置）" class="headerlink" title="图像输出大小设置（缩放设置）"></a>图像输出大小设置（缩放设置）</h3><p><strong>控制最终输出到外部的图像尺寸</strong></p>
<p>该设置仅会对图像进行缩放处理，如果设置的图像输出大小不等于图像窗口设置图像大小，那么图像就会被缩放处理，<strong>只有两者大小一样（图像输出大小=图像窗口设置大小）时，输出比例才是1：1</strong></p>
<h3 id="OV2640模块参数"><a href="#OV2640模块参数" class="headerlink" title="OV2640模块参数"></a>OV2640模块参数</h3><ol>
<li>支持RGB565/JPEG数据输出</li>
<li>支持最大UXGA分辨率输出</li>
<li>支持图像任意缩放</li>
<li>自带24M有源晶振、3.3V稳压电路、带滤光片的感光红外镜头</li>
<li>支持手动对焦（旋下盖上螺丝调节镜头即可）</li>
</ol>
<p>引脚参数：</p>
<table>
<thead>
<tr>
<th>脚位</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>GND</td>
<td>接地</td>
</tr>
<tr>
<td>2</td>
<td>VCC3.3</td>
<td>接3.3V电源</td>
</tr>
<tr>
<td>3</td>
<td>OV_SCL</td>
<td>SCCB时钟线（I）</td>
</tr>
<tr>
<td>4</td>
<td>OV_VSYNC</td>
<td>帧同步信号（O）</td>
</tr>
<tr>
<td>5</td>
<td>OV_SDA</td>
<td>SCCB数据线（I/O）</td>
</tr>
<tr>
<td>6</td>
<td>OV_HREF</td>
<td>行同步信号（O）</td>
</tr>
<tr>
<td>8</td>
<td>OV_RESET</td>
<td>复位信号，低电平有效（I）</td>
</tr>
<tr>
<td>15</td>
<td>OV_PCLK</td>
<td>像素时钟（O）</td>
</tr>
<tr>
<td>17</td>
<td>OV_PWDN</td>
<td>掉电模式使能，高电平有效（I）</td>
</tr>
<tr>
<td>18</td>
<td>NC</td>
<td>空脚</td>
</tr>
<tr>
<td>7、9、10、11、12、13、14、16</td>
<td>OV_D0~D7</td>
<td>数据线（O）</td>
</tr>
</tbody></table>
<h2 id="OV2640模块使用过程"><a href="#OV2640模块使用过程" class="headerlink" title="OV2640模块使用过程"></a>OV2640模块使用过程</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ol>
<li>初始化IO口</li>
<li>上电、复位</li>
<li>读取传感器ID</li>
<li>执行初始化序列</li>
</ol>
<p>全部内容由OV2640公司提供源码</p>
<h3 id="MCU读取模块图像数据"><a href="#MCU读取模块图像数据" class="headerlink" title="MCU读取模块图像数据"></a>MCU读取模块图像数据</h3><ol>
<li>等待帧同步（等待VSYNC信号）</li>
<li>等待HRED为高电平</li>
<li>等待第一个PCLK上升沿</li>
<li>读取第一个像素的低字节</li>
<li>等待第二个PCLK上升沿</li>
<li>读取第一个像素的高字节</li>
<li>等待下一个PCLK上升沿</li>
<li>重复4-7步骤直到读完剩余像素</li>
<li>结束读取</li>
</ol>
<h1 id="DCMI接口"><a href="#DCMI接口" class="headerlink" title="DCMI接口"></a>DCMI接口</h1><p>DCMI(Digital Camera Interface)是STM32F4xx自带的数字摄像头接口，属于同步并行接口</p>
<p>特性：</p>
<ul>
<li><p>能够接受外部8、10、12、14位并行接口最高54MB/s的高速数据流</p>
</li>
<li><p>支持内嵌码/外部行同步/帧同步</p>
</li>
<li><p>支持连续模式或快照模式</p>
</li>
<li><p>支持裁剪功能</p>
</li>
<li><p>可支持不同数据格式：单色或原始拜尔（Bayer）格式、YCbCr 4:2:2逐行视频、RGB565逐行视频、压缩数据(JPEG)格式</p>
</li>
<li><p>接口通过FIFO和数据格式化器直接与AHB总线相连</p>
</li>
</ul>
<p>该接口包含14条数据线（D13-D0）和1条像素时钟线（PIXCLK），且像素时钟的有效电平可由用户程序决定，能在像素时钟的上升沿或下降沿捕获数据</p>
<p>DCMI接口包含以下信号：</p>
<table>
<thead>
<tr>
<th>DCMI接口</th>
<th>引脚</th>
<th>别名</th>
<th>对应OV2640接口</th>
<th>引脚</th>
</tr>
</thead>
<tbody><tr>
<td>数据流输入</td>
<td>D[0:13]</td>
<td></td>
<td>数据流输出</td>
<td>D[0:7]</td>
</tr>
<tr>
<td>水平同步</td>
<td>输入HREF/HSYNC</td>
<td>行同步</td>
<td>行同步信号</td>
<td>HREF/HSYNC</td>
</tr>
<tr>
<td>垂直同步</td>
<td>输入VSYNC</td>
<td>帧同步/场同步</td>
<td>帧同步信号</td>
<td>VSYNC</td>
</tr>
<tr>
<td>像素时钟输入</td>
<td>PIXCLK</td>
<td>像素时钟</td>
<td>像素时钟</td>
<td>PCLK</td>
</tr>
</tbody></table>
<h3 id="时序"><a href="#时序" class="headerlink" title="时序"></a>时序</h3><p>数据与PIXCLK同步，并根据像素时钟的极性在像素时钟上升沿/下降沿发生变化</p>
<p>HREF/HSYNC指示行的开始或结束，VSYNC指示帧的开始或结束</p>
<p>DCMI时序与上述OV2640时序基本一致，但DCMI的PIXCLK有效沿可自定义，且<strong>HSYNC、VSYNC有效状态对应指示数据在并行接口上无效时，HSYNC/VSYNC引脚上的引脚电平</strong>（人话：==和OV2640的有效状态相反==）</p>
<h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><p>DCMI接收到的数据存储在DCMI_DR 32位寄存器内，接入OV2640模块时采用8位数据宽度，所以<strong>每4个像素时钟才捕获完32位数据</strong>，第一个字节存放在LSB位置，第四个字节存放在MSB位置遵守<strong>低字节在前，高字节在后</strong></p>
<p>==<strong>DCMI支持DMA传输</strong>==，DCMI可被配置为每在其数据寄存器中收到一个完整的32位数据块时，发送一个DMA请求，由DMA将寄存器内的值搬运到目的地址（如LCD/SRAM）</p>
<p>注意：DCMI的DMA请求映射在<strong>DMA2 Channel1 Stream1</strong>上；如果使用DCMI-&gt;DMA-&gt;LCD的传输路径，因为LCD是16位宽（RGB565），但DCMI_DR是32位宽，所以一次<strong>DCMI引起的DMA请求将引发往LCD写2次数据</strong></p>
<h2 id="相关设置"><a href="#相关设置" class="headerlink" title="相关设置"></a>相关设置</h2><p>DCMI支持连续模式和快照模式，连续模式=录像；快照模式=照相</p>
<p>DCMI支持内嵌码同步和硬件同步，一般采用硬件同步 </p>
<p>硬件同步下使用HSYNC和VSYNC两个信号，系统会忽略两个信号有效电平期间接收的所有数据，即<strong>硬件同步模式下的HSYNC、VSYNC信号相当于消隐信号</strong></p>
<h2 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h2><ol>
<li>配置相关引脚复用为DCMI</li>
<li>使能DCMI时钟</li>
<li>设置DCMI工作模式和PCLK、HSYNC、VSYNC等参数</li>
<li>设置DMA搬运DCMI数据</li>
<li>使能DCMI传输</li>
</ol>
<h1 id="实际配置方法与代码"><a href="#实际配置方法与代码" class="headerlink" title="实际配置方法与代码"></a>实际配置方法与代码</h1><h2 id="硬件配置"><a href="#硬件配置" class="headerlink" title="硬件配置"></a>硬件配置</h2><p>OV2640模块-转接-DCMI接口 对应好即可</p>
<h2 id="软件配置"><a href="#软件配置" class="headerlink" title="软件配置"></a>软件配置</h2><ol>
<li>sccb协议驱动（与I2C协议类似）</li>
</ol>
<p>sccb.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SCCB_H</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> __SCCB_H</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line">	<span class="comment">//IO方向设置</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> SCCB_SDA_IN() &#123;GPIOD-&gt;MODER&amp;=~(3<span class="meta-string">&lt;&lt;(7*2));GPIOD-&gt;</span>MODER|=0&lt;&lt;7*2;&#125; <span class="comment">//PD7输入</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> SCCB_SDA_OUT() &#123;GPIOD-&gt;MODER&amp;=~(3<span class="meta-string">&lt;&lt;(7*2));GPIOD-&gt;</span>MODER|=1&lt;&lt;7*2;&#125; <span class="comment">//PD7输出</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//IO操作函数</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> SCCB_SCL PDout(6) <span class="comment">//PD6配置为SCL(仅输出)</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> SCCB_SDA PDout(7) <span class="comment">//SDA输出</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> SCCB_READ_SDA PDin(7) <span class="comment">//SDA输出</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> SCCB_ID 0X60 <span class="comment">//OV2640的ID</span></span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SCCB_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//SCCB接口初始化</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SCCB_Start</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//起始信号</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SCCB_Stop</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//停止信号</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SCCB_No_Ack</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//NA信号</span></span><br><span class="line">	<span class="function">u8 <span class="title">SCCB_WR_Byte</span><span class="params">(u8 dat)</span></span>;<span class="comment">//写数据</span></span><br><span class="line">	<span class="function">u8 <span class="title">SCCB_RD_Byte</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//读数据</span></span><br><span class="line">	<span class="function">u8 <span class="title">SCCB_WR_Reg</span><span class="params">(u8 reg,u8 data)</span></span>;<span class="comment">//写寄存器</span></span><br><span class="line">	<span class="function">u8 <span class="title">SCCB_RD_Reg</span><span class="params">(u8 reg)</span></span>;<span class="comment">//读寄存器</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>sccb.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sccb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化SCCB接口 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SCCB_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GPIO_InitTypeDef  GPIO_InitStructure;</span><br><span class="line"></span><br><span class="line">	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);<span class="comment">//使能GPIOD时钟</span></span><br><span class="line">    </span><br><span class="line">	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_6|GPIO_Pin_7;<span class="comment">//PD6、PD7</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_OUT;<span class="comment">//输出模式</span></span><br><span class="line">  	GPIO_InitStructure.GPIO_OType=GPIO_OType_PP;<span class="comment">//推挽输出</span></span><br><span class="line">  	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;<span class="comment">//100MHz</span></span><br><span class="line">  	GPIO_InitStructure.GPIO_PuPd=GPIO_PuPd_UP;<span class="comment">//内部上拉</span></span><br><span class="line">    <span class="comment">//应用设置</span></span><br><span class="line">  	GPIO_Init(GPIOD,&amp;GPIO_InitStructure);</span><br><span class="line"> </span><br><span class="line">	GPIO_SetBits(GPIOD,GPIO_Pin_6|GPIO_Pin_7);<span class="comment">//初始为高电平</span></span><br><span class="line">	SCCB_SDA_OUT();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SCCB起始信号</span></span><br><span class="line"><span class="comment">//时钟为高时,数据线下降沿,为SCCB起始信号</span></span><br><span class="line"><span class="comment">//在激活状态下,SDA和SCL均为低电平</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SCCB_Start</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SCCB_SDA=<span class="number">1</span>;<span class="comment">//数据线高电平	   </span></span><br><span class="line">    SCCB_SCL=<span class="number">1</span>;<span class="comment">//时钟线高时数据线下降沿</span></span><br><span class="line">    delay_us(<span class="number">50</span>);</span><br><span class="line">    SCCB_SDA=<span class="number">0</span>;</span><br><span class="line">    delay_us(<span class="number">50</span>);</span><br><span class="line">    SCCB_SCL=<span class="number">0</span>;<span class="comment">//数据线恢复低电平，单操作函数必要	  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SCCB停止信号</span></span><br><span class="line"><span class="comment">//时钟为高时,数据线上升沿,为SCCB停止信号</span></span><br><span class="line"><span class="comment">//空闲状况下,SDA,SCL均为高电平</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SCCB_Stop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SCCB_SDA=<span class="number">0</span>;</span><br><span class="line">    delay_us(<span class="number">50</span>);	 </span><br><span class="line">    SCCB_SCL=<span class="number">1</span>;<span class="comment">//数据线高电平</span></span><br><span class="line">    delay_us(<span class="number">50</span>);</span><br><span class="line">    SCCB_SDA=<span class="number">1</span>;<span class="comment">//时钟线高时数据线上升沿</span></span><br><span class="line">    delay_us(<span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NA信号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SCCB_No_Ack</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	delay_us(<span class="number">50</span>);</span><br><span class="line">	SCCB_SDA=<span class="number">1</span>;<span class="comment">//SDA、SCL都为高电平</span></span><br><span class="line">	SCCB_SCL=<span class="number">1</span>;</span><br><span class="line">	delay_us(<span class="number">50</span>);</span><br><span class="line">	SCCB_SCL=<span class="number">0</span>;</span><br><span class="line">	delay_us(<span class="number">50</span>);</span><br><span class="line">	SCCB_SDA=<span class="number">0</span>;</span><br><span class="line">	delay_us(<span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SCCB写入一个字节</span></span><br><span class="line"><span class="comment">//返回值:0,成功;1,失败</span></span><br><span class="line"><span class="function">u8 <span class="title">SCCB_WR_Byte</span><span class="params">(u8 dat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 j,res;	 </span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">8</span>;j++)<span class="comment">//循环8次发送数据</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(dat&amp;<span class="number">0x80</span>)</span><br><span class="line">            SCCB_SDA=<span class="number">1</span>;	</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">            SCCB_SDA=<span class="number">0</span>;</span><br><span class="line">		dat&lt;&lt;=<span class="number">1</span>;<span class="comment">//发送数据</span></span><br><span class="line">		delay_us(<span class="number">50</span>);</span><br><span class="line">		SCCB_SCL=<span class="number">1</span>;</span><br><span class="line">		delay_us(<span class="number">50</span>);</span><br><span class="line">		SCCB_SCL=<span class="number">0</span>;		   </span><br><span class="line">	&#125;</span><br><span class="line">	SCCB_SDA_IN();<span class="comment">//设置SDA为输入 </span></span><br><span class="line">	delay_us(<span class="number">50</span>);</span><br><span class="line">	SCCB_SCL=<span class="number">1</span>;<span class="comment">//接收第九位,判断是否发送成功</span></span><br><span class="line">	delay_us(<span class="number">50</span>);</span><br><span class="line">	<span class="keyword">if</span>(SCCB_READ_SDA)<span class="comment">//读取到NA数据</span></span><br><span class="line">        res=<span class="number">1</span>;<span class="comment">//SDA=1发送失败，返回1</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        res=<span class="number">0</span>;<span class="comment">//SDA=0发送成功，返回0</span></span><br><span class="line">	SCCB_SCL=<span class="number">0</span>;		 </span><br><span class="line">	SCCB_SDA_OUT();<span class="comment">//设置SDA为输出 </span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SCCB读取一个字节</span></span><br><span class="line"><span class="comment">//SCL上升沿,数据锁存</span></span><br><span class="line"><span class="comment">//返回值:读到的数据</span></span><br><span class="line"><span class="function">u8 <span class="title">SCCB_RD_Byte</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 temp=<span class="number">0</span>,j;</span><br><span class="line">	SCCB_SDA_IN();<span class="comment">//设置SDA为输入  </span></span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">8</span>;j&gt;<span class="number">0</span>;j--)<span class="comment">//循环8次接收数据</span></span><br><span class="line">	&#123;</span><br><span class="line">		delay_us(<span class="number">50</span>);</span><br><span class="line">		SCCB_SCL=<span class="number">1</span>;</span><br><span class="line">		temp=temp&lt;&lt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(SCCB_READ_SDA)</span><br><span class="line">            temp++;   </span><br><span class="line">		delay_us(<span class="number">50</span>);</span><br><span class="line">		SCCB_SCL=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	SCCB_SDA_OUT();<span class="comment">//设置SDA为输出    </span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写寄存器</span></span><br><span class="line"><span class="comment">//返回值:0,成功;1,失败.</span></span><br><span class="line"><span class="function">u8 <span class="title">SCCB_WR_Reg</span><span class="params">(u8 reg,u8 data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 res=<span class="number">0</span>;</span><br><span class="line">	SCCB_Start();<span class="comment">//启动SCCB传输</span></span><br><span class="line">	<span class="keyword">if</span>(SCCB_WR_Byte(SCCB_ID))</span><br><span class="line">        res=<span class="number">1</span>;<span class="comment">//写器件ID	  </span></span><br><span class="line">	delay_us(<span class="number">100</span>);</span><br><span class="line">  	<span class="keyword">if</span>(SCCB_WR_Byte(reg))</span><br><span class="line">        res=<span class="number">1</span>;<span class="comment">//写寄存器地址	  </span></span><br><span class="line">	delay_us(<span class="number">100</span>);</span><br><span class="line">  	<span class="keyword">if</span>(SCCB_WR_Byte(data))</span><br><span class="line">       res=<span class="number">1</span>;<span class="comment">//写数据	 </span></span><br><span class="line">  	SCCB_Stop();</span><br><span class="line">  	<span class="keyword">return</span></span><br><span class="line">        res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读寄存器</span></span><br><span class="line"><span class="comment">//返回值:读到的寄存器值</span></span><br><span class="line"><span class="function">u8 <span class="title">SCCB_RD_Reg</span><span class="params">(u8 reg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 val=<span class="number">0</span>;</span><br><span class="line">	SCCB_Start();<span class="comment">//启动SCCB传输</span></span><br><span class="line">	SCCB_WR_Byte(SCCB_ID);<span class="comment">//写器件ID</span></span><br><span class="line">	delay_us(<span class="number">100</span>);	 </span><br><span class="line">  	SCCB_WR_Byte(reg);<span class="comment">//写寄存器地址	  </span></span><br><span class="line">	delay_us(<span class="number">100</span>);	  </span><br><span class="line">	SCCB_Stop();   </span><br><span class="line">	delay_us(<span class="number">100</span>);	   </span><br><span class="line">	</span><br><span class="line">    <span class="comment">//设置寄存器地址后进行读操作</span></span><br><span class="line">	SCCB_Start();</span><br><span class="line">	SCCB_WR_Byte(SCCB_ID|<span class="number">0X01</span>);<span class="comment">//发送读命令	  </span></span><br><span class="line">	delay_us(<span class="number">100</span>);</span><br><span class="line">  	val=SCCB_RD_Byte();<span class="comment">//读取数据</span></span><br><span class="line">  	SCCB_No_Ack();</span><br><span class="line">  	SCCB_Stop();</span><br><span class="line">  	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>ov2640驱动</li>
</ol>
<p>ov2640.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _OV2640_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _OV2640_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sccb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_PWDN PGout(9) <span class="comment">//POWER_DOWN控制信号 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_RST PGout(15) <span class="comment">//复位控制信号 </span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*片内信息核对*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_MID 0X7FA2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_PID 0X2642</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//当选择DSP地址(0XFF=0X00)时,OV2640的DSP寄存器地址映射表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_R_BYPASS     0x05</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_Qs           0x44</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_CTRL         0x50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_HSIZE1       0x51</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_VSIZE1       0x52</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_XOFFL        0x53</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_YOFFL        0x54</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_VHYX         0x55</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_DPRP         0x56</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_TEST         0x57</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_ZMOW         0x5A</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_ZMOH         0x5B</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_ZMHH         0x5C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_BPADDR       0x7C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_BPDATA       0x7D</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_CTRL2        0x86</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_CTRL3        0x87</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_SIZEL        0x8C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_HSIZE2       0xC0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_VSIZE2       0xC1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_CTRL0        0xC2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_CTRL1        0xC3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_R_DVP_SP     0xD3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_IMAGE_MODE   0xDA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_RESET        0xE0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_MS_SP        0xF0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_SS_ID        0x7F</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_SS_CTRL      0xF8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_MC_BIST      0xF9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_MC_AL        0xFA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_MC_AH        0xFB</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_MC_D         0xFC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_P_STATUS     0xFE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_DSP_RA_DLMT      0xFF </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当选择传感器地址(0XFF=0X01)时,OV2640的DSP寄存器地址映射表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_GAIN       0x00</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_COM1       0x03</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_REG04      0x04</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_REG08      0x08</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_COM2       0x09</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_PIDH       0x0A</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_PIDL       0x0B</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_COM3       0x0C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_COM4       0x0D</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_AEC        0x10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_CLKRC      0x11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_COM7       0x12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_COM8       0x13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_COM9       0x14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_COM10      0x15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_HREFST     0x17</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_HREFEND    0x18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_VSTART     0x19</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_VEND       0x1A</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_MIDH       0x1C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_MIDL       0x1D</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_AEW        0x24</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_AEB        0x25</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_W          0x26</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_REG2A      0x2A</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_FRARL      0x2B</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_ADDVSL     0x2D</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_ADDVHS     0x2E</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_YAVG       0x2F</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_REG32      0x32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_ARCOM2     0x34</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_REG45      0x45</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_FLL        0x46</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_FLH        0x47</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_COM19      0x48</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_ZOOMS      0x49</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_COM22      0x4B</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_COM25      0x4E</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_BD50       0x4F</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_BD60       0x50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_REG5D      0x5D</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_REG5E      0x5E</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_REG5F      0x5F</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_REG60      0x60</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_HISTO_LOW  0x61</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OV2640_SENSOR_HISTO_HIGH 0x62</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*OV2640初始化函数*/</span></span><br><span class="line"><span class="function">u8 <span class="title">OV2640_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">/*OV2640选项调节函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OV2640_JPEG_Mode</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OV2640_RGB565_Mode</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OV2640_Auto_Exposure</span><span class="params">(u8 level)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OV2640_Light_Mode</span><span class="params">(u8 mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OV2640_Color_Saturation</span><span class="params">(u8 sat)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OV2640_Brightness</span><span class="params">(u8 bright)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OV2640_Contrast</span><span class="params">(u8 contrast)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OV2640_Special_Effects</span><span class="params">(u8 eft)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OV2640_Color_Bar</span><span class="params">(u8 sw)</span></span>;</span><br><span class="line"><span class="comment">/*OV2640硬件软件&quot;开窗&quot;函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OV2640_Window_Set</span><span class="params">(u16 sx,u16 sy,u16 width,u16 height)</span></span>;</span><br><span class="line"><span class="function">u8 <span class="title">OV2640_OutSize_Set</span><span class="params">(u16 width,u16 height)</span></span>;</span><br><span class="line"><span class="function">u8 <span class="title">OV2640_ImageWin_Set</span><span class="params">(u16 offx,u16 offy,u16 width,u16 height)</span></span>;</span><br><span class="line"><span class="function">u8 <span class="title">OV2640_ImageSize_Set</span><span class="params">(u16 width,u16 height)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>ov2640.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ov2640.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ov2640cfg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;timer.h“</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">#include &quot;</span>sccb.h<span class="meta-string">&quot;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">#include &quot;</span>delay.h<span class="meta-string">&quot;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">#include &quot;</span>usart.h<span class="meta-string">&quot;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//初始化OV2640 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//默认输出1600*1200尺寸的图片</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//返回值:0,成功</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//    其他,错误代码</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">u8 OV2640_Init(void)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u16 i=0;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u16 reg;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    /*设置IO连接OV2640*/</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	GPIO_InitTypeDef GPIO_InitStructure;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOG, ENABLE);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	//GPIOG9,15初始化设置</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_9|GPIO_Pin_15;//PG9,15</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_OUT; //普通输出模式</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	GPIO_InitStructure.GPIO_OType=GPIO_OType_PP;//推挽输出</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;//100MHz</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	GPIO_InitStructure.GPIO_PuPd=GPIO_PuPd_UP;//内部上拉</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    //应用设置</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	GPIO_Init(GPIOG,&amp;GPIO_InitStructure);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	OV2640_PWDN=0;//开始硬复位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	delay_ms(10);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	OV2640_RST=0;//复位OV2640</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	delay_ms(10);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	OV2640_RST=1;//结束复位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_Init();//初始化SCCB 的IO口	 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(OV2640_DSP_RA_DLMT,0x01);//操作sensor寄存器</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(OV2640_SENSOR_COM7,0x80);//开始软复位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	delay_ms(50);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	reg=SCCB_RD_Reg(OV2640_SENSOR_MIDH);//读取厂家ID 高八位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	reg&lt;&lt;=8;//存入寄存器</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	reg|=SCCB_RD_Reg(OV2640_SENSOR_MIDL);//读取厂家ID 低八位 并 存入寄存器</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	if(reg!=OV2640_MID)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		printf(&quot;</span>MID:%d\r\n<span class="meta-string">&quot;,reg);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		return 1;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	reg=SCCB_RD_Reg(OV2640_SENSOR_PIDH);//读取厂家ID 高八位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	reg&lt;&lt;=8;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	reg|=SCCB_RD_Reg(OV2640_SENSOR_PIDL);//读取厂家ID 低八位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	if(reg!=OV2640_PID)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		printf(&quot;</span>HID:%d\r\n<span class="meta-string">&quot;,reg);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		return 2;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	/*采用SXGA分辨率(1600*1200)初始化*/  </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	for(i=0;i&lt;sizeof(ov2640_sxga_init_reg_tbl)/2;i++)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		SCCB_WR_Reg(ov2640_sxga_init_reg_tbl[i][0],ov2640_sxga_init_reg_tbl[i][1]);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	return 0x00;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">/*参数选项函数*/</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//OV2640切换为JPEG模式</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">void OV2640_JPEG_Mode(void) </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u16 i=0;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	//设置:YUV422格式</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	for(i=0;i&lt;(sizeof(ov2640_yuv422_reg_tbl)/2);i++)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		SCCB_WR_Reg(ov2640_yuv422_reg_tbl[i][0],ov2640_yuv422_reg_tbl[i][1]); </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#125; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	//设置:输出JPEG数据</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	for(i=0;i&lt;(sizeof(ov2640_jpeg_reg_tbl)/2);i++)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		SCCB_WR_Reg(ov2640_jpeg_reg_tbl[i][0],ov2640_jpeg_reg_tbl[i][1]);  </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#125;  </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//OV2640切换为RGB565模式</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">void OV2640_RGB565_Mode(void) </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u16 i=0;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	//设置:RGB565输出</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	for(i=0;i&lt;(sizeof(ov2640_rgb565_reg_tbl)/2);i++)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		SCCB_WR_Reg(ov2640_rgb565_reg_tbl[i][0],ov2640_rgb565_reg_tbl[i][1]); </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#125; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//自动曝光设置参数表,支持5个等级</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">const static u8 OV2640_AUTOEXPOSURE_LEVEL[5][8]=</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0xFF,0x01,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0x24,0x20,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0x25,0x18,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0x26,0x60,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#125;,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0xFF,0x01,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0x24,0x34,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0x25,0x1c,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0x26,0x00,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#125;,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0xFF,0x01,	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0x24,0x3e,	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0x25,0x38,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0x26,0x81,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#125;,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0xFF,0x01,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0x24,0x48,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0x25,0x40,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0x26,0x81,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#125;,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0xFF,0x01,	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0x24,0x58,	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0x25,0x50,	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		0x26,0x92,	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#125;,</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//OV2640自动曝光等级设置</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//level:0~4</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">void OV2640_Auto_Exposure(u8 level)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;  </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u8 i;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u8* p=(u8*)OV2640_AUTOEXPOSURE_LEVEL[level];</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	for(i=0;i&lt;4;i++)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#123; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		SCCB_WR_Reg(p[i*2],p[i*2+1]); </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#125; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//白平衡设置</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//0:自动</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//1:太阳sunny</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//2,阴天cloudy</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//3,办公室office</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//4,家里home</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">void OV2640_Light_Mode(u8 mode)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u8 regccval=0X5E;//Sunny </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u8 regcdval=0X41;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u8 regceval=0X54;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	switch(mode)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#123; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		case 0://auto </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			SCCB_WR_Reg(0XFF,0X00);	 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			SCCB_WR_Reg(0XC7,0X10);//AWB ON </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			return;  	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		case 2://cloudy</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			regccval=0X65;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			regcdval=0X41;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			regceval=0X4F;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			break;	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		case 3://office</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			regccval=0X52;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			regcdval=0X41;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			regceval=0X66;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			break;	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		case 4://home</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			regccval=0X42;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			regcdval=0X3F;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			regceval=0X71;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			break;	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XFF,0X00);	 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XC7,0X40);	//AWB OFF </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XCC,regccval); </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XCD,regcdval); </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XCE,regceval);  </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//色度设置</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//0:-2</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//1:-1</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//2,0</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//3,+1</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//4,+2</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">void OV2640_Color_Saturation(u8 sat)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u8 reg7dval=((sat+2)&lt;&lt;4)|0X08;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XFF,0X00);		</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X7C,0X00);		</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X7D,0X02);				</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X7C,0X03);			</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X7D,reg7dval);			</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X7D,reg7dval); 		</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//亮度设置</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//0:(0X00)-2</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//1:(0X10)-1</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//2,(0X20) 0</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//3,(0X30)+1</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//4,(0X40)+2</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">void OV2640_Brightness(u8 bright)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  SCCB_WR_Reg(0xff, 0x00);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  SCCB_WR_Reg(0x7c, 0x00);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  SCCB_WR_Reg(0x7d, 0x04);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  SCCB_WR_Reg(0x7c, 0x09);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  SCCB_WR_Reg(0x7d, bright&lt;&lt;4); </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  SCCB_WR_Reg(0x7d, 0x00); </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//对比度设置</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//0:-2</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//1:-1</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//2,0</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//3,+1</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//4,+2</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">void OV2640_Contrast(u8 contrast)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u8 reg7d0val=0X20;//默认为普通模式</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u8 reg7d1val=0X20;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	switch(contrast)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		case 0://-2</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d0val=0X18;	 	 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d1val=0X34;	 	 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			break;	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		case 1://-1</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d0val=0X1C;	 	 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d1val=0X2A;	 	 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			break;	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		case 3://1</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d0val=0X24;	 	 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d1val=0X16;	 	 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			break;	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		case 4://2</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d0val=0X28;	 	 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d1val=0X0C;	 	 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			break;	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0xff,0x00);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0x7c,0x00);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0x7d,0x04);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0x7c,0x07);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0x7d,0x20);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0x7d,reg7d0val);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0x7d,reg7d1val);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0x7d,0x06);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//特效设置</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//0:普通模式    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//1,负片</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//2,黑白   </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//3,偏红色</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//4,偏绿色</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//5,偏蓝色</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//6,复古	    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">void OV2640_Special_Effects(u8 eft)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u8 reg7d0val=0X00;//默认为普通模式</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u8 reg7d1val=0X80;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u8 reg7d2val=0X80; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	switch(eft)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		case 1://负片</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d0val=0X40; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			break;	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		case 2://黑白</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d0val=0X18; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			break;	 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		case 3://偏红色</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d0val=0X18; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d1val=0X40;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d2val=0XC0; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			break;	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		case 4://偏绿色</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d0val=0X18; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d1val=0X40;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d2val=0X40; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			break;	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		case 5://偏蓝色</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d0val=0X18; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d1val=0XA0;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d2val=0X40; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			break;	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		case 6://复古</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d0val=0X18; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d1val=0X40;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			reg7d2val=0XA6; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			break;	 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0xff,0x00);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0x7c,0x00);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0x7d,reg7d0val);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0x7c,0x05);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0x7d,reg7d1val);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0x7d,reg7d2val); </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//彩条测试</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//sw:0,关闭彩条</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//   1,开启彩条(注意OV2640的彩条是叠加在图像上面的)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">void OV2640_Color_Bar(u8 sw)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u8 reg;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XFF,0X01);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	reg=SCCB_RD_Reg(0X12);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	reg&amp;=~(1&lt;&lt;1);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	if(sw)reg|=1&lt;&lt;1; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X12,reg);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">/*硬件软件窗口配置*/</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//设置图像输出窗口 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//sx,sy,起始地址</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//width,height:宽度(对应:horizontal)和高度(对应:vertical)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">void OV2640_Window_Set(u16 sx,u16 sy,u16 width,u16 height)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u16 endx;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u16 endy;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u8 temp; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	endx=sx+width/2;//V*2</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"> 	endy=sy+height/2;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XFF,0X01);			</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	temp=SCCB_RD_Reg(0X03);//读取Vref之前的值</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	temp&amp;=0XF0;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	temp|=((endy&amp;0X03)&lt;&lt;2)|(sy&amp;0X03);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X03,temp);//设置Vref的start和end的最低2位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X19,sy&gt;&gt;2);//设置Vref的start高8位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X1A,endy&gt;&gt;2);//设置Vref的end的高8位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	temp=SCCB_RD_Reg(0X32);//读取Href之前的值</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	temp&amp;=0XC0;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	temp|=((endx&amp;0X07)&lt;&lt;3)|(sx&amp;0X07);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X32,temp);//设置Href的start和end的最低3位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X17,sx&gt;&gt;3);//设置Href的start高8位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X18,endx&gt;&gt;3);//设置Href的end的高8位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//设置图像输出大小</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//OV2640输出图像的大小(分辨率),完全由改函数确定</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//width,height:宽度(对应:horizontal)和高度(对应:vertical),width和height必须是4的倍数</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//返回值:0,设置成功</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//    其他,设置失败</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">u8 OV2640_OutSize_Set(u16 width,u16 height)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u16 outh;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u16 outw;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u8 temp;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	if(width%4)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        return 1;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	if(height%4)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        return 2;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	outw=width/4;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	outh=height/4;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XFF,0X00);	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XE0,0X04);			</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X5A,outw&amp;0XFF);//设置OUTW的低八位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X5B,outh&amp;0XFF);//设置OUTH的低八位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	temp=(outw&gt;&gt;8)&amp;0X03;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	temp|=(outh&gt;&gt;6)&amp;0X04;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X5C,temp);//设置OUTH/OUTW的高位 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XE0,0X00);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	return 0;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//设置图像开窗大小</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//由:OV2640_ImageSize_Set确定传感器输出分辨率从大小.</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//该函数则在这个范围上面进行开窗,用于OV2640_OutSize_Set的输出</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//注意:本函数的宽度和高度,必须大于等于OV2640_OutSize_Set函数的宽度和高度</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//     OV2640_OutSize_Set设置的宽度和高度,根据本函数设置的宽度和高度,由DSP</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//     自动计算缩放比例,输出给外部设备.</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//width,height:宽度(对应:horizontal)和高度(对应:vertical),width和height必须是4的倍数</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//返回值:0,设置成功</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//    其他,设置失败</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">u8 OV2640_ImageWin_Set(u16 offx,u16 offy,u16 width,u16 height)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u16 hsize;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u16 vsize;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u8 temp;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	if(width%4)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        return 1;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	if(height%4)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        return 2;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	hsize=width/4;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	vsize=height/4;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XFF,0X00);	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XE0,0X04);					</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X51,hsize&amp;0XFF);//设置H_SIZE的低八位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X52,vsize&amp;0XFF);//设置V_SIZE的低八位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X53,offx&amp;0XFF);//设置offx的低八位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X54,offy&amp;0XFF);//设置offy的低八位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	temp=(vsize&gt;&gt;1)&amp;0X80;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	temp|=(offy&gt;&gt;4)&amp;0X70;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	temp|=(hsize&gt;&gt;5)&amp;0X08;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	temp|=(offx&gt;&gt;8)&amp;0X07; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X55,temp);//设置H_SIZE/V_SIZE/OFFX,OFFY的高位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X57,(hsize&gt;&gt;2)&amp;0X80);//设置H_SIZE/V_SIZE/OFFX,OFFY的高位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XE0,0X00);	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	return 0;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//该函数设置图像尺寸大小,也就是所选格式的输出分辨率</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//UXGA:1600*1200,SVGA:800*600,CIF:352*288</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//width,height:图像宽度和图像高度</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//返回值:0,设置成功</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//    其他,设置失败</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">u8 OV2640_ImageSize_Set(u16 width,u16 height)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	u8 temp;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XFF,0X00);			</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XE0,0X04);			</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XC0,(width)&gt;&gt;3&amp;0XFF);//设置HSIZE的10:3位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XC1,(height)&gt;&gt;3&amp;0XFF);//设置VSIZE的10:3位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	temp=(width&amp;0X07)&lt;&lt;3;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	temp|=height&amp;0X07;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	temp|=(width&gt;&gt;4)&amp;0X80;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0X8C,temp);	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	SCCB_WR_Reg(0XE0,0X00);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	return 0;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>ov2640cfg.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//OV2640 SXGA初始化寄存器序列表</span></span><br><span class="line"><span class="comment">//模式选择</span></span><br><span class="line"><span class="comment">//内容过长，略去，详见正点原子教程</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>dcmi接口配置</li>
</ol>
<p>dcmi.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _DCMI_H</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> _DCMI_H</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">My_DCMI_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DCMI_DMA_Init</span><span class="params">(u32 DMA_Memory0BaseAddr,u16 DMA_BufferSize,u32 DMA_MemoryDataSize,u32 DMA_MemoryInc)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DCMI_Start</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DCMI_Stop</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DCMI_Set_Window</span><span class="params">(u16 sx,u16 sy,u16 width,u16 height)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DCMI_CR_Set</span><span class="params">(u8 pclk,u8 hsync,u8 vsync)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>dcmi.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;dcmi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;lcd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ov2640.h”</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">u8 ov_frame=0;//帧率</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">extern void jpeg_data_process(void);//JPEG数据处理函数</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">DCMI_InitTypeDef DCMI_InitStructure;//全局变量注意</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//DCMI中断服务函数</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">void DCMI_IRQHandler(void)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	if(DCMI_GetITStatus(DCMI_IT_FRAME)==SET)//捕获到一帧图像</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		jpeg_data_process();//jpeg数据处理	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		DCMI_ClearITPendingBit(DCMI_IT_FRAME);//清除帧中断</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		LED1=!LED1;//LED指示捕获到图像</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		ov_frame++;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		LCD_SetCursor(0,0);//重置LCD</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		LCD_WriteRAM_Prepare();//开始写入GRAM</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//DCMI DMA配置</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//DMA_Memory0BaseAddr:存储器地址——将要存储摄像头数据的内存地址(也可以是外设地址)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//DMA_BufferSize:存储器长度——0~65535</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//DMA_MemoryDataSize:存储器位宽</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//DMA_MemoryInc:存储器增长方式</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">void DCMI_DMA_Init(u32 DMA_Memory0BaseAddr,u16 DMA_BufferSize,u32 DMA_MemoryDataSize,u32 DMA_MemoryInc)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	DMA_InitTypeDef  DMA_InitStructure;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2,ENABLE);//使能DMA2时钟</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	DMA_DeInit(DMA2_Stream1);//清空流</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	while (DMA_GetCmdStatus(DMA2_Stream1)!=DISABLE);//等待DMA2Stream1可配置 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	/*配置DMA2 Stream1 Channel1*/</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	DMA_InitStructure.DMA_Channel=DMA_Channel_1;//DMA2Stream1Channel1</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	DMA_InitStructure.DMA_PeripheralBaseAddr=(u32)&amp;DCMI-&gt;DR;//外设地址:DCMI-&gt;DR</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	DMA_InitStructure.DMA_Memory0BaseAddr=DMA_Memory0BaseAddr;//DMA存储器0地址</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	DMA_InitStructure.DMA_DIR=DMA_DIR_PeripheralToMemory;//外设到存储器模式</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	DMA_InitStructure.DMA_BufferSize=DMA_BufferSize;//数据传输量 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	DMA_InitStructure.DMA_PeripheralInc=DMA_PeripheralInc_Disable;//外设非增量模式</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	DMA_InitStructure.DMA_MemoryInc=DMA_MemoryInc;//存储器增量模式</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	DMA_InitStructure.DMA_PeripheralDataSize=DMA_PeripheralDataSize_Word;//外设数据长度:32位</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	DMA_InitStructure.DMA_MemoryDataSize=DMA_MemoryDataSize;//存储器数据长度</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	DMA_InitStructure.DMA_Mode=DMA_Mode_Circular;//使用循环模式 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	DMA_InitStructure.DMA_Priority=DMA_Priority_High;//高优先级</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	DMA_InitStructure.DMA_FIFOMode=DMA_FIFOMode_Enable;//使能FIFO        </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	DMA_InitStructure.DMA_FIFOThreshold=DMA_FIFOThreshold_Full;//使用全FIFO </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    DMA_InitStructure.DMA_MemoryBurst=DMA_MemoryBurst_Single;//外设突发单次传输</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	DMA_InitStructure.DMA_PeripheralBurst=DMA_PeripheralBurst_Single;//存储器突发单次传输</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    //应用设置</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	DMA_Init(DMA2_Stream1,&amp;DMA_InitStructure);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//DCMI初始化</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">void My_DCMI_Init(void)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	GPIO_InitTypeDef  GPIO_InitStructure;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	NVIC_InitTypeDef NVIC_InitStructure;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA|</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">                           RCC_AHB1Periph_GPIOB|</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">                       	   RCC_AHB1Periph_GPIOC|</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">                           RCC_AHB1Periph_GPIOE,ENABLE);//使能GPIOA B C E时钟</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_DCMI,ENABLE);//使能DCMI时钟</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    /*PA4、PA6、PB6、PB7、PC6、PC7、PC8、PC9、PC11、PE5、PE6设置为复用输出*/</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF; //复用功能</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	GPIO_InitStructure.GPIO_OType=GPIO_OType_PP;//推挽输出</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_100MHz;//100MHz</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	GPIO_InitStructure.GPIO_PuPd=GPIO_PuPd_UP;//内部上拉</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    GPIO_InitStructure.GPIO_Pin=GPIO_Pin_4|GPIO_Pin_6;//PA4、6复用输出</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    //应用设置</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_7|GPIO_Pin_6;//PB6、7复用输出</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    //应用设置</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_6|GPIO_Pin_7|GPIO_Pin_8|GPIO_Pin_9|GPIO_Pin_11;//PC6、7、8、9、11 复用输出</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    //应用设置</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	GPIO_Init(GPIOC, &amp;GPIO_InitStructure);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5|GPIO_Pin_6;//PE5、6复用输出</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    //应用设置</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	GPIO_Init(GPIOE, &amp;GPIO_InitStructure);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	GPIO_PinAFConfig(GPIOA,GPIO_PinSource4,GPIO_AF_DCMI);//PA4,AF13  DCMI_HSYNC</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	GPIO_PinAFConfig(GPIOA,GPIO_PinSource6,GPIO_AF_DCMI);//PA6,AF13  DCMI_PCLK  </span></span></span><br><span class="line"><span class="meta-string"><span class="meta"> 	GPIO_PinAFConfig(GPIOB,GPIO_PinSource7,GPIO_AF_DCMI);//PB7,AF13  DCMI_VSYNC </span></span></span><br><span class="line"><span class="meta-string"><span class="meta"> 	GPIO_PinAFConfig(GPIOC,GPIO_PinSource6,GPIO_AF_DCMI);//PC6,AF13  DCMI_D0  </span></span></span><br><span class="line"><span class="meta-string"><span class="meta"> 	GPIO_PinAFConfig(GPIOC,GPIO_PinSource7,GPIO_AF_DCMI);//PC7,AF13  DCMI_D1 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	GPIO_PinAFConfig(GPIOC,GPIO_PinSource8,GPIO_AF_DCMI);//PC8,AF13  DCMI_D2</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	GPIO_PinAFConfig(GPIOC,GPIO_PinSource9,GPIO_AF_DCMI);//PC9,AF13  DCMI_D3</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	GPIO_PinAFConfig(GPIOC,GPIO_PinSource11,GPIO_AF_DCMI);//PC11,AF13 DCMI_D4 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	GPIO_PinAFConfig(GPIOB,GPIO_PinSource6,GPIO_AF_DCMI);//PB6,AF13  DCMI_D5 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	GPIO_PinAFConfig(GPIOE,GPIO_PinSource5,GPIO_AF_DCMI);//PE5,AF13  DCMI_D6</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	GPIO_PinAFConfig(GPIOE,GPIO_PinSource6,GPIO_AF_DCMI);//PE6,AF13  DCMI_D7</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	DCMI_DeInit();//清除原来的设置</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	DCMI_InitStructure.DCMI_CaptureMode=DCMI_CaptureMode_Continuous;//连续模式</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	DCMI_InitStructure.DCMI_CaptureRate=DCMI_CaptureRate_All_Frame;//全帧捕获</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	DCMI_InitStructure.DCMI_ExtendedDataMode= DCMI_ExtendedDataMode_8b;//8位数据格式  </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	DCMI_InitStructure.DCMI_HSPolarity= DCMI_HSPolarity_Low;//HSYNC低电平有效</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    DCMI_InitStructure.DCMI_VSPolarity=DCMI_VSPolarity_Low;//VSYNC低电平有效</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	DCMI_InitStructure.DCMI_PCKPolarity= DCMI_PCKPolarity_Rising;//PCLK上升沿有效</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	DCMI_InitStructure.DCMI_SynchroMode= DCMI_SynchroMode_Hardware;//硬件同步HSYNC,VSYNC</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    //应用设置</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	DCMI_Init(&amp;DCMI_InitStructure);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	DCMI_ITConfig(DCMI_IT_FRAME,ENABLE);//使能帧中断 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	DCMI_Cmd(ENABLE);//使能DCMI</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	//此时不能捕获，还要启动传输</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    NVIC_InitStructure.NVIC_IRQChannel=DCMI_IRQn;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=0;//抢占优先级0</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	NVIC_InitStructure.NVIC_IRQChannelSubPriority=0;//子优先级0</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;//IRQ通道使能</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    //应用设置</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	NVIC_Init(&amp;NVIC_InitStructure);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//DCMI,启动传输</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">void DCMI_Start(void)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;  </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	LCD_SetCursor(0,0);//重置LCD</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	LCD_WriteRAM_Prepare();//开始写入GRAM</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	DMA_Cmd(DMA2_Stream1, ENABLE);//开启DMA2Stream1 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	DCMI_CaptureCmd(ENABLE);//使能DCMI捕获</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">//DCMI,关闭传输</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">void DCMI_Stop(void)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  	DCMI_CaptureCmd(DISABLE);//关闭DCMI捕获	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	while(DCMI-&gt;CR&amp;0X01);//等待传输结束</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	DMA_Cmd(DMA2_Stream1,DISABLE);//关闭DMA2Stream1</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;</span></span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>main()配置</li>
</ol>
<p>main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;lcd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;usmart.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;usart2.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;timer.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ov2640.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;dcmi.h&quot;</span> </span></span><br><span class="line"></span><br><span class="line">u8 ov2640_mode=<span class="number">0</span>;<span class="comment">//工作模式:0,RGB565模式;1,JPEG模式</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> jpeg_buf_size 31*1024<span class="comment">//定义JPEG数据缓存jpeg_buf的大小(*4字节)</span></span></span><br><span class="line">__align(<span class="number">4</span>) u32 jpeg_buf[jpeg_buf_size];<span class="comment">//JPEG数据缓存buf</span></span><br><span class="line"><span class="keyword">volatile</span> u32 jpeg_data_len=<span class="number">0</span>;<span class="comment">//buf中的JPEG有效数据长度 </span></span><br><span class="line"><span class="keyword">volatile</span> u8 jpeg_data_ok=<span class="number">0</span>;<span class="comment">//JPEG数据采集完成标志 </span></span><br><span class="line">						   <span class="comment">//0,数据没有采集完;</span></span><br><span class="line">						   <span class="comment">//1,数据采集完了,但是还没处理;</span></span><br><span class="line">						   <span class="comment">//2,数据已经处理完成了,可以开始下一帧接收</span></span><br><span class="line"><span class="comment">//JPEG尺寸支持列表</span></span><br><span class="line"><span class="keyword">const</span> u16 jpeg_img_size_tbl[][<span class="number">2</span>]=</span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">176</span>,<span class="number">144</span>,	<span class="comment">//QCIF</span></span><br><span class="line">	<span class="number">160</span>,<span class="number">120</span>,	<span class="comment">//QQVGA</span></span><br><span class="line">	<span class="number">352</span>,<span class="number">288</span>,	<span class="comment">//CIF</span></span><br><span class="line">	<span class="number">320</span>,<span class="number">240</span>,	<span class="comment">//QVGA</span></span><br><span class="line">	<span class="number">640</span>,<span class="number">480</span>,	<span class="comment">//VGA</span></span><br><span class="line">	<span class="number">800</span>,<span class="number">600</span>,	<span class="comment">//SVGA</span></span><br><span class="line">	<span class="number">1024</span>,<span class="number">768</span>,	<span class="comment">//XGA</span></span><br><span class="line">	<span class="number">1280</span>,<span class="number">1024</span>,	<span class="comment">//SXGA</span></span><br><span class="line">	<span class="number">1600</span>,<span class="number">1200</span>,	<span class="comment">//UXGA</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">const</span> u8*EFFECTS_TBL[<span class="number">7</span>]=&#123;<span class="string">&quot;Normal&quot;</span>,<span class="string">&quot;Negative&quot;</span>,<span class="string">&quot;B&amp;W&quot;</span>,<span class="string">&quot;Redish&quot;</span>,<span class="string">&quot;Greenish&quot;</span>,<span class="string">&quot;Bluish&quot;</span>,<span class="string">&quot;Antique&quot;</span>&#125;;<span class="comment">//7种特效 </span></span><br><span class="line"><span class="keyword">const</span> u8*JPEG_SIZE_TBL[<span class="number">9</span>]=&#123;<span class="string">&quot;QCIF&quot;</span>,<span class="string">&quot;QQVGA&quot;</span>,<span class="string">&quot;CIF&quot;</span>,<span class="string">&quot;QVGA&quot;</span>,<span class="string">&quot;VGA&quot;</span>,<span class="string">&quot;SVGA&quot;</span>,<span class="string">&quot;XGA&quot;</span>,<span class="string">&quot;SXGA&quot;</span>,<span class="string">&quot;UXGA&quot;</span>&#125;;<span class="comment">//JPEG 9种尺寸 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//处理JPEG数据</span></span><br><span class="line"><span class="comment">//当采集完一帧JPEG数据后,调用此函数,切换JPEG BUF.开始下一帧采集.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jpeg_data_process</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ov2640_mode)<span class="comment">//只有在JPEG格式下,才需要做处理</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(jpeg_data_ok==<span class="number">0</span>)<span class="comment">//如果还未采集完数据</span></span><br><span class="line">		&#123;	</span><br><span class="line">			DMA_Cmd(DMA2_Stream1, DISABLE);<span class="comment">//停止当前传输 </span></span><br><span class="line">			<span class="keyword">while</span>(DMA_GetCmdStatus(DMA2_Stream1)!=DISABLE);<span class="comment">//等待DMA2_Stream1可配置  </span></span><br><span class="line">			jpeg_data_len=jpeg_buf_size-DMA_GetCurrDataCounter(DMA2_Stream1);<span class="comment">//得到此次数据传输的长度</span></span><br><span class="line">			jpeg_data_ok=<span class="number">1</span>;<span class="comment">//标记JPEG数据采集完成,等待其他函数处理</span></span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">if</span>(jpeg_data_ok==<span class="number">2</span>)<span class="comment">//如果jpeg数据已经被处理了</span></span><br><span class="line">		&#123;</span><br><span class="line">			DMA2_Stream1-&gt;NDTR=jpeg_buf_size;	</span><br><span class="line">			DMA_SetCurrDataCounter(DMA2_Stream1,jpeg_buf_size);<span class="comment">//传输长度为jpeg_buf_size*4字节</span></span><br><span class="line">			DMA_Cmd(DMA2_Stream1,ENABLE);<span class="comment">//重新传输</span></span><br><span class="line">			jpeg_data_ok=<span class="number">0</span>;<span class="comment">//标记数据未采集</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//JPEG测试</span></span><br><span class="line"><span class="comment">//JPEG数据,通过串口1发送给电脑.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jpeg_test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u32 i; </span><br><span class="line">	u8* p;</span><br><span class="line">	u8 key;</span><br><span class="line">	u8 effect=<span class="number">0</span>,saturation=<span class="number">2</span>,contrast=<span class="number">2</span>;</span><br><span class="line">	u8 size=<span class="number">3</span>;<span class="comment">//默认QVGA 320*240尺寸</span></span><br><span class="line">	u8 msgbuf[<span class="number">15</span>];<span class="comment">//消息缓存区 </span></span><br><span class="line">	LCD_Clear(WHITE);</span><br><span class="line">	POINT_COLOR=RED; </span><br><span class="line">	LCD_ShowString(<span class="number">30</span>,<span class="number">70</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;OV2640 JPEG Mode&quot;</span>);</span><br><span class="line">	LCD_ShowString(<span class="number">30</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;KEY0:Contrast&quot;</span>);<span class="comment">//对比度</span></span><br><span class="line">	<span class="comment">//LCD_ShowString(30,120,200,16,16,&quot;KEY1:Saturation&quot;);//色彩饱和度</span></span><br><span class="line">	<span class="comment">//LCD_ShowString(30,140,200,16,16,&quot;KEY2:Effects&quot;);//特效 </span></span><br><span class="line">	LCD_ShowString(<span class="number">30</span>,<span class="number">160</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;KEY_UP:Size&quot;</span>);<span class="comment">//分辨率设置 </span></span><br><span class="line">	<span class="built_in">sprintf</span>((<span class="keyword">char</span>*)msgbuf,<span class="string">&quot;JPEG Size:%s&quot;</span>,JPEG_SIZE_TBL[size]);</span><br><span class="line">	LCD_ShowString(<span class="number">30</span>,<span class="number">180</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,msgbuf);<span class="comment">//显示当前JPEG分辨率</span></span><br><span class="line">	</span><br><span class="line"> 	OV2640_JPEG_Mode();<span class="comment">//JPEG模式</span></span><br><span class="line">	My_DCMI_Init();<span class="comment">//初始化DCMI</span></span><br><span class="line">	DCMI_DMA_Init((u32)&amp;jpeg_buf,jpeg_buf_size,DMA_MemoryDataSize_Word,DMA_MemoryInc_Enable);<span class="comment">//初始化DMA</span></span><br><span class="line">	OV2640_OutSize_Set(jpeg_img_size_tbl[size][<span class="number">0</span>],jpeg_img_size_tbl[size][<span class="number">1</span>]);<span class="comment">//设置输出尺寸</span></span><br><span class="line">	DCMI_Start();<span class="comment">//启动传输</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(jpeg_data_ok==<span class="number">1</span>)<span class="comment">//若已经采集完一帧图像</span></span><br><span class="line">		&#123;  </span><br><span class="line">			p=(u8*)jpeg_buf;</span><br><span class="line">			LCD_ShowString(<span class="number">30</span>,<span class="number">210</span>,<span class="number">210</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;Sending JPEG data...&quot;</span>);<span class="comment">//提示正在传输数据</span></span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;jpeg_data_len*<span class="number">4</span>;i++)<span class="comment">//dma传输1次等于4字节,要乘4</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">while</span>((USART1-&gt;SR&amp;<span class="number">0X40</span>)==RESET);<span class="comment">//循环发送直到发送完毕  		</span></span><br><span class="line">				USART1-&gt;DR=p[i];</span><br><span class="line">				key=KEY_Scan(<span class="number">0</span>);</span><br><span class="line">				<span class="keyword">if</span>(key)</span><br><span class="line">                    <span class="keyword">break</span>;<span class="comment">//若按键按下则需要处理，跳至下部分</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(key)<span class="comment">//有按键按下,需要处理</span></span><br><span class="line">			&#123;  </span><br><span class="line">				LCD_ShowString(<span class="number">30</span>,<span class="number">210</span>,<span class="number">210</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;Quit Sending data&quot;</span>);<span class="comment">//提示退出数据传输</span></span><br><span class="line">                </span><br><span class="line">				<span class="keyword">switch</span>(key)</span><br><span class="line">				&#123;				    </span><br><span class="line">					<span class="keyword">case</span> KEY0_PRES:<span class="comment">//对比度设置</span></span><br><span class="line">						contrast++;</span><br><span class="line">						<span class="keyword">if</span>(contrast&gt;<span class="number">4</span>)contrast=<span class="number">0</span>;</span><br><span class="line">						OV2640_Contrast(contrast);</span><br><span class="line">						<span class="built_in">sprintf</span>((<span class="keyword">char</span>*)msgbuf,<span class="string">&quot;Contrast:%d&quot;</span>,(<span class="keyword">signed</span> <span class="keyword">char</span>)contrast<span class="number">-2</span>);</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> KEY1_PRES:<span class="comment">//饱和度Saturation</span></span><br><span class="line">						<span class="comment">//saturation++;</span></span><br><span class="line">						<span class="comment">//if(saturation&gt;4)saturation=0;</span></span><br><span class="line">						<span class="comment">//OV2640_Color_Saturation(saturation);</span></span><br><span class="line">						<span class="comment">//sprintf((char*)msgbuf,&quot;Saturation:%d&quot;,(signed char)saturation-2);</span></span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> KEY2_PRES:<span class="comment">//特效设置				 </span></span><br><span class="line">						<span class="comment">//effect++;</span></span><br><span class="line">						<span class="comment">//if(effect&gt;6)effect=0;</span></span><br><span class="line">						<span class="comment">//OV2640_Special_Effects(effect);//设置特效</span></span><br><span class="line">						<span class="comment">//sprintf((char*)msgbuf,&quot;%s&quot;,EFFECTS_TBL[effect]);</span></span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> WKUP_PRES:<span class="comment">//JPEG输出尺寸设置   </span></span><br><span class="line">						size++;  </span><br><span class="line">						<span class="keyword">if</span>(size&gt;<span class="number">8</span>)size=<span class="number">0</span>;   </span><br><span class="line">						OV2640_OutSize_Set(jpeg_img_size_tbl[size][<span class="number">0</span>],jpeg_img_size_tbl[size][<span class="number">1</span>]);<span class="comment">//设置输出尺寸  </span></span><br><span class="line">						<span class="built_in">sprintf</span>((<span class="keyword">char</span>*)msgbuf,<span class="string">&quot;JPEG Size:%s&quot;</span>,JPEG_SIZE_TBL[size]);</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">                </span><br><span class="line">				LCD_Fill(<span class="number">30</span>,<span class="number">180</span>,<span class="number">239</span>,<span class="number">190</span>+<span class="number">16</span>,WHITE);</span><br><span class="line">				LCD_ShowString(<span class="number">30</span>,<span class="number">180</span>,<span class="number">210</span>,<span class="number">16</span>,<span class="number">16</span>,msgbuf);<span class="comment">//显示提示内容</span></span><br><span class="line">				delay_ms(<span class="number">800</span>); 				  </span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                LCD_ShowString(<span class="number">30</span>,<span class="number">210</span>,<span class="number">210</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;Send data complete!!&quot;</span>);<span class="comment">//提示传输结束设置 </span></span><br><span class="line">			jpeg_data_ok=<span class="number">2</span>;	<span class="comment">//标记jpeg数据处理完毕,可以让DMA采集下一帧</span></span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;    </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//RGB565测试</span></span><br><span class="line"><span class="comment">//RGB数据直接显示在LCD上面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rgb565_test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	u8 key;</span><br><span class="line">	u8 effect=<span class="number">0</span>,saturation=<span class="number">2</span>,contrast=<span class="number">2</span>;</span><br><span class="line">	u8 scale=<span class="number">1</span>;<span class="comment">//默认是全尺寸缩放</span></span><br><span class="line">	u8 msgbuf[<span class="number">15</span>];<span class="comment">//消息缓存区</span></span><br><span class="line">    </span><br><span class="line">	LCD_Clear(WHITE);</span><br><span class="line">    POINT_COLOR=RED; </span><br><span class="line">	LCD_ShowString(<span class="number">30</span>,<span class="number">70</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;OV2640 RGB565 Mode&quot;</span>);</span><br><span class="line">	LCD_ShowString(<span class="number">30</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;KEY0:Contrast&quot;</span>);<span class="comment">//对比度</span></span><br><span class="line">	<span class="comment">//LCD_ShowString(30,130,200,16,16,&quot;KEY1:Saturation&quot;);//色彩饱和度</span></span><br><span class="line">	<span class="comment">//LCD_ShowString(30,150,200,16,16,&quot;KEY2:Effects&quot;);//特效 </span></span><br><span class="line">	LCD_ShowString(<span class="number">30</span>,<span class="number">170</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;KEY_UP:FullSize/Scale&quot;</span>);<span class="comment">//1:1尺寸(显示真实尺寸)/全尺寸缩放</span></span><br><span class="line">	</span><br><span class="line">	OV2640_RGB565_Mode();<span class="comment">//RGB565模式</span></span><br><span class="line">	My_DCMI_Init();<span class="comment">//DCMI配置</span></span><br><span class="line">	DCMI_DMA_Init((u32)&amp;LCD-&gt;LCD_RAM,<span class="number">1</span>,DMA_MemoryDataSize_HalfWord,DMA_MemoryInc_Disable);<span class="comment">//DCMI DMA配置  </span></span><br><span class="line"> 	OV2640_OutSize_Set(lcddev.width,lcddev.height); </span><br><span class="line">	DCMI_Start();<span class="comment">//启动传输</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		key=KEY_Scan(<span class="number">0</span>); </span><br><span class="line">		<span class="keyword">if</span>(key)</span><br><span class="line">		&#123; </span><br><span class="line">			DCMI_Stop();<span class="comment">//停止显示</span></span><br><span class="line">			<span class="keyword">switch</span>(key)</span><br><span class="line">			&#123;				    </span><br><span class="line">				<span class="keyword">case</span> KEY0_PRES:<span class="comment">//对比度设置</span></span><br><span class="line">					contrast++;</span><br><span class="line">					<span class="keyword">if</span>(contrast&gt;<span class="number">4</span>)contrast=<span class="number">0</span>;</span><br><span class="line">					OV2640_Contrast(contrast);</span><br><span class="line">					<span class="built_in">sprintf</span>((<span class="keyword">char</span>*)msgbuf,<span class="string">&quot;Contrast:%d&quot;</span>,(<span class="keyword">signed</span> <span class="keyword">char</span>)contrast<span class="number">-2</span>);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> KEY1_PRES:	<span class="comment">//饱和度Saturation</span></span><br><span class="line">					<span class="comment">//saturation++;</span></span><br><span class="line">					<span class="comment">//if(saturation&gt;4)saturation=0;</span></span><br><span class="line">					<span class="comment">//OV2640_Color_Saturation(saturation);</span></span><br><span class="line">					<span class="comment">//sprintf((char*)msgbuf,&quot;Saturation:%d&quot;,(signed char)saturation-2);</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> KEY2_PRES:<span class="comment">//特效设置				 </span></span><br><span class="line">					<span class="comment">//effect++;</span></span><br><span class="line">					<span class="comment">//if(effect&gt;6)effect=0;</span></span><br><span class="line">					<span class="comment">//OV2640_Special_Effects(effect);//设置特效</span></span><br><span class="line">					<span class="comment">//sprintf((char*)msgbuf,&quot;%s&quot;,EFFECTS_TBL[effect]);</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> WKUP_PRES:<span class="comment">//1:1尺寸(显示真实尺寸)/缩放	    </span></span><br><span class="line">					scale=!scale;  </span><br><span class="line">					</span><br><span class="line">                    <span class="keyword">if</span>(scale==<span class="number">0</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						OV2640_ImageWin_Set((<span class="number">1600</span>-lcddev.width)/<span class="number">2</span>,(<span class="number">1200</span>-lcddev.height)/<span class="number">2</span>,lcddev.width,lcddev.height);<span class="comment">//1:1真实尺寸</span></span><br><span class="line">						OV2640_OutSize_Set(lcddev.width,lcddev.height); </span><br><span class="line">						<span class="built_in">sprintf</span>((<span class="keyword">char</span>*)msgbuf,<span class="string">&quot;Full Size 1:1&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						OV2640_ImageWin_Set(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1600</span>,<span class="number">1200</span>);				<span class="comment">//全尺寸缩放</span></span><br><span class="line">						OV2640_OutSize_Set(lcddev.width,lcddev.height); </span><br><span class="line">						<span class="built_in">sprintf</span>((<span class="keyword">char</span>*)msgbuf,<span class="string">&quot;Scale&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			LCD_ShowString(<span class="number">30</span>,<span class="number">50</span>,<span class="number">210</span>,<span class="number">16</span>,<span class="number">16</span>,msgbuf);<span class="comment">//显示提示内容</span></span><br><span class="line">			delay_ms(<span class="number">800</span>);</span><br><span class="line">			DCMI_Start();<span class="comment">//重新开始传输</span></span><br><span class="line">		&#125; </span><br><span class="line">		delay_ms(<span class="number">10</span>);		</span><br><span class="line">	&#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	u8 key;</span><br><span class="line">	u8 t;</span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//设置系统中断优先级分组2</span></span><br><span class="line">	delay_init(<span class="number">168</span>);<span class="comment">//初始化延时函数</span></span><br><span class="line">	uart_init(<span class="number">115200</span>);<span class="comment">//初始化串口波特率为115200</span></span><br><span class="line">	usart2_init(<span class="number">42</span>,<span class="number">115200</span>);<span class="comment">//初始化串口2波特率为115200</span></span><br><span class="line">	LED_Init();<span class="comment">//初始化LED </span></span><br><span class="line"> 	LCD_Init();<span class="comment">//LCD初始化  </span></span><br><span class="line"> 	KEY_Init();<span class="comment">//按键初始化 </span></span><br><span class="line">	TIM3_Int_Init(<span class="number">10000</span><span class="number">-1</span>,<span class="number">8400</span><span class="number">-1</span>);<span class="comment">//10Khz计数,1秒钟中断一次</span></span><br><span class="line">	</span><br><span class="line"> 	usmart_dev.init(<span class="number">84</span>);<span class="comment">//初始化USMART</span></span><br><span class="line"> 	POINT_COLOR=RED;<span class="comment">//设置字体为红色 </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(OV2640_Init())<span class="comment">//初始化OV2640</span></span><br><span class="line">	&#123;</span><br><span class="line">		LCD_ShowString(<span class="number">30</span>,<span class="number">130</span>,<span class="number">240</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;OV2640 ERR&quot;</span>);</span><br><span class="line">		delay_ms(<span class="number">200</span>);</span><br><span class="line">	    LCD_Fill(<span class="number">30</span>,<span class="number">130</span>,<span class="number">239</span>,<span class="number">170</span>,WHITE);</span><br><span class="line">		delay_ms(<span class="number">200</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	LCD_ShowString(<span class="number">30</span>,<span class="number">130</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;OV2640 OK&quot;</span>);</span><br><span class="line">    </span><br><span class="line"> 	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;	</span><br><span class="line">		key=KEY_Scan(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(key==KEY0_PRES)<span class="comment">//RGB565模式</span></span><br><span class="line">		&#123;</span><br><span class="line">			ov2640_mode=<span class="number">0</span>;   </span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key==WKUP_PRES)<span class="comment">//JPEG模式</span></span><br><span class="line">		&#123;</span><br><span class="line">			ov2640_mode=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		t++; 									  </span><br><span class="line">		<span class="keyword">if</span>(t==<span class="number">100</span>)</span><br><span class="line">            LCD_ShowString(<span class="number">30</span>,<span class="number">150</span>,<span class="number">230</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;KEY0:RGB565  KEY_UP:JPEG&quot;</span>);<span class="comment">//闪烁显示提示信息</span></span><br><span class="line"> 		<span class="keyword">if</span>(t==<span class="number">200</span>)</span><br><span class="line">		&#123;	</span><br><span class="line">			LCD_Fill(<span class="number">30</span>,<span class="number">150</span>,<span class="number">230</span>,<span class="number">150</span>+<span class="number">16</span>,WHITE);</span><br><span class="line">			t=<span class="number">0</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		delay_ms(<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ov2640_mode)</span><br><span class="line">        jpeg_test();</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">        rgb565_test(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32外设配置速查【板级总线协议】</title>
    <url>/2021/11/19/STM32%E5%A4%96%E8%AE%BE%E9%85%8D%E7%BD%AE%E9%80%9F%E6%9F%A5%E3%80%90%E6%9D%BF%E7%BA%A7%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE%E3%80%91/</url>
    <content><![CDATA[<h1 id="总线协议"><a href="#总线协议" class="headerlink" title="总线协议"></a>总线协议</h1><h2 id="I2C-（又称I-2-C、IIC等）"><a href="#I2C-（又称I-2-C、IIC等）" class="headerlink" title="I2C （又称I^2^C、IIC等）"></a>I2C （又称I^2^C、IIC等）</h2><p>I2C（Integrated Circuit）是<strong>两线</strong>式<strong>半双工串行</strong>总线</p>
<p>由数据线<strong>SDA</strong>和时钟<strong>SCL</strong>构成</p>
<p>一般可达400kbps以上</p>
<h3 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h3><h4 id="底层硬件"><a href="#底层硬件" class="headerlink" title="底层硬件"></a>底层硬件</h4><p>SDA和SCL分别上拉到VCC，同时接入设备</p>
<p>主设备操纵SCL，可以接收/发送SDA</p>
<p>从设备可以发送/接收SDA</p>
<h3 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h3><h5 id="空闲（释放总线）"><a href="#空闲（释放总线）" class="headerlink" title="空闲（释放总线）"></a>空闲（释放总线）</h5><p>SDA=1    SCL=1</p>
<h5 id="起止信号"><a href="#起止信号" class="headerlink" title="起止信号"></a>起止信号</h5><p>起始信号：SCL=1    SDA下降沿</p>
<p>停止信号：SCL=1    SDA上升沿</p>
<h5 id="应答信号ACK"><a href="#应答信号ACK" class="headerlink" title="应答信号ACK"></a>应答信号ACK</h5><p>发送器<strong>每发送一个字节</strong>，就在时钟9器件释放SDA，由接收器反馈一个应答信号</p>
<p><strong>0为有效应答</strong>，ACK称为应答位，表示接收器已接收</p>
<p><strong>1为非应答</strong>，NACK称为非应答位，表示接收器接收该字节没有成功</p>
<p>从设备要求：</p>
<p>在==第9个==时钟脉冲之前的低电平期间==将SDA拉低==，并确保在该时钟高电平期间位稳定的低电平</p>
<p>主设备要求：</p>
<p>在==收到最后一个字节后发送一个NACK信号==以通知被控发送器结束数据发送，并SDA=1（释放SDA），以便从设备发送停止信号P</p>
<h5 id="数据有效性确认"><a href="#数据有效性确认" class="headerlink" title="数据有效性确认"></a>数据有效性确认</h5><p>SCL=1期间，SDA上的数据必须保持稳定，只有在SCL=0时，SDA才允许变化</p>
<span id="more"></span>

<p>即<em><strong>数据在SCL上升沿到来前就要准备好，并在下降沿到来前必须稳定</strong></em></p>
<h5 id="stm32实现"><a href="#stm32实现" class="headerlink" title="stm32实现"></a>stm32实现</h5><p>stm32自带I2C不稳定，通常使用GPIO模拟I2C</p>
<p>iic.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __IIC_H</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> __IIC_H</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//定义模拟线</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> IIC_SCL GPIO_Pin_8<span class="comment">//以PB8、PB9作为I2C模拟线</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> IIC_SDA GPIO_Pin_9</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//设置端口操作</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> IIC_SCL_WRITE PBout(8)<span class="comment">//PB8模拟SCL输出</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> IIC_SDA_WRITE PBout(9)<span class="comment">//PB9模拟SDA输出</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> IIC_SDA_READ PBin(9)<span class="comment">//PB9模拟SDA输入</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//设置端口输入输出模式</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> IIC_SDA_IN() &#123;GPIOB-&gt;MODER&amp;=~(3<span class="meta-string">&lt;&lt;(9*2));GPIOB-&gt;</span>MODER|=0&lt;&lt;9*2;&#125; <span class="comment">//PB9输入模式</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> IIC_SDA_OUT() &#123;GPIOB-&gt;MODER&amp;=~(3<span class="meta-string">&lt;&lt;(9*2));GPIOB-&gt;</span>MODER|=1&lt;&lt;9*2;&#125; <span class="comment">//PB9输出模式</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">IIC_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//产生IIC起始信号</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">IIC_stop</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//产生IIC停止信号</span></span><br><span class="line">	<span class="function">u8 <span class="title">IIC_wait_ACK</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//等待应答信号</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">IIC_ACK</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//产生ACK应答</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">IIC_NACK</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//不产生ACK应答</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">IIC_send_byte</span><span class="params">(u8 txd)</span></span>;<span class="comment">//IIC发送一个字节</span></span><br><span class="line">	<span class="function">u8 <span class="title">IIC_read_byte</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> ACK)</span></span>;<span class="comment">//IIC读取一个字节</span></span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>iic.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;iic.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化IIC</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	</span><br><span class="line">	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB,ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_OUT;<span class="comment">//普通输出模式</span></span><br><span class="line">	GPIO_InitStructure.GPIO_OType=GPIO_OType_PP;<span class="comment">//推挽输出</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin=IIC_SCL|IIC_SDA;<span class="comment">//模拟IIC</span></span><br><span class="line">	GPIO_InitStructure.GPIO_PuPd=GPIO_PuPd_UP;<span class="comment">//内部上拉</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_100MHz;<span class="comment">//100MHz</span></span><br><span class="line">	<span class="comment">//应用设置</span></span><br><span class="line">	GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">	IIC_SCL_WRITE=<span class="number">1</span>;</span><br><span class="line">	IIC_SDA_WRITE=<span class="number">1</span>;<span class="comment">//默认拉高总线</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产生IIC起始信号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_start</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	IIC_SDA_OUT();<span class="comment">//SDA输出</span></span><br><span class="line">	</span><br><span class="line">	IIC_SDA_WRITE=<span class="number">1</span>;</span><br><span class="line">	IIC_SCL_WRITE=<span class="number">1</span>;</span><br><span class="line">	delay_us(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	IIC_SDA_WRITE=<span class="number">0</span>;<span class="comment">//开始信号为SDA上升沿</span></span><br><span class="line">	delay_us(<span class="number">4</span>);</span><br><span class="line">	</span><br><span class="line">	IIC_SCL_WRITE=<span class="number">0</span>;<span class="comment">//拉低SCL，准备接收或发送数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产生IIC停止信号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_stop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	IIC_SDA_OUT();<span class="comment">//SDA输出</span></span><br><span class="line">	</span><br><span class="line">	IIC_SCL_WRITE=<span class="number">0</span>;</span><br><span class="line">	IIC_SDA_WRITE=<span class="number">0</span>;</span><br><span class="line">	delay_us(<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">	IIC_SCL_WRITE=<span class="number">1</span>;</span><br><span class="line">	IIC_SDA_WRITE=<span class="number">1</span>;<span class="comment">//停止信号为SDA下降沿</span></span><br><span class="line">	delay_us(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待应答信号</span></span><br><span class="line"><span class="comment">//返回1：接收应答失败</span></span><br><span class="line"><span class="comment">//返回0：接收应答成功</span></span><br><span class="line"><span class="function">u8 <span class="title">IIC_wait_ACK</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 Err_time=<span class="number">0</span>;</span><br><span class="line">	IIC_SDA_IN();<span class="comment">//SDA输入</span></span><br><span class="line">	</span><br><span class="line">	IIC_SDA_WRITE=<span class="number">1</span>;<span class="comment">//等待接收应答</span></span><br><span class="line">	delay_us(<span class="number">1</span>);</span><br><span class="line">	IIC_SCL_WRITE=<span class="number">1</span>;</span><br><span class="line">	delay_us(<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(IIC_SDA_READ)<span class="comment">//获取SDA的信号</span></span><br><span class="line">	&#123;</span><br><span class="line">		Err_time++;<span class="comment">//每读取一次高电平则+1</span></span><br><span class="line">		<span class="keyword">if</span>(Err_time&gt;<span class="number">250</span>)<span class="comment">//若一直读到高电平则接收应答失败</span></span><br><span class="line">		&#123;</span><br><span class="line">			IIC_stop();</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	IIC_SCL_WRITE=<span class="number">0</span>;<span class="comment">//一直读到低电平则为有效应答</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产生ACK应答</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_ACK</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	IIC_SDA_OUT();<span class="comment">//SDA输出</span></span><br><span class="line">	</span><br><span class="line">	IIC_SCL_WRITE=<span class="number">0</span>;<span class="comment">//SCL上升沿时SDA=0</span></span><br><span class="line">	IIC_SDA_WRITE=<span class="number">0</span>;</span><br><span class="line">	delay_us(<span class="number">2</span>);</span><br><span class="line">	IIC_SCL_WRITE=<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">	delay_us(<span class="number">2</span>);</span><br><span class="line">	IIC_SDA_WRITE=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不产生ACK应答</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_NACK</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	IIC_SDA_OUT();<span class="comment">//SDA输出</span></span><br><span class="line">	</span><br><span class="line">	IIC_SCL_WRITE=<span class="number">0</span>;<span class="comment">//SCL上升沿时SDA=1</span></span><br><span class="line">	IIC_SDA_WRITE=<span class="number">1</span>;</span><br><span class="line">	delay_us(<span class="number">2</span>);</span><br><span class="line">	IIC_SCL_WRITE=<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">	delay_us(<span class="number">2</span>);</span><br><span class="line">	IIC_SCL_WRITE=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IIC发送一个字节</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_send_byte</span><span class="params">(u8 txd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 t;</span><br><span class="line"></span><br><span class="line">	IIC_SDA_OUT();<span class="comment">//SDA输出</span></span><br><span class="line">	IIC_SCL_WRITE=<span class="number">0</span>;<span class="comment">//拉低SCL准备输出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送数据以SDA电平为准</span></span><br><span class="line">	<span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;<span class="number">8</span>;t++)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//SDA早来晚走</span></span><br><span class="line">		IIC_SDA_WRITE=(txd &amp; <span class="number">0x80</span>)&gt;&gt;<span class="number">7</span>;<span class="comment">//取最高位发送</span></span><br><span class="line">		txd&lt;&lt;=<span class="number">1</span>;<span class="comment">//待发送数据向左移位，次高位变成最高位，获取下一个待发送的位</span></span><br><span class="line">		delay_us(<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//SCL晚来早走</span></span><br><span class="line">		IIC_SCL_WRITE=<span class="number">1</span>;</span><br><span class="line">		delay_us(<span class="number">2</span>);</span><br><span class="line">		IIC_SCL_WRITE=<span class="number">0</span>;</span><br><span class="line">		delay_us(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IIC读取一个字节</span></span><br><span class="line"><span class="comment">//ack_flag=1时发送ACK</span></span><br><span class="line"><span class="comment">//ack_flag=0时发送NACK</span></span><br><span class="line"><span class="function">u8 <span class="title">IIC_read_byte</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> ACK)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> i,receive=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	IIC_SDA_IN();<span class="comment">//SDA输入</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		IIC_SCL_WRITE=<span class="number">0</span>;<span class="comment">//SCL上升沿</span></span><br><span class="line">		delay_us(<span class="number">2</span>);</span><br><span class="line">		IIC_SCL_WRITE=<span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		receive&lt;&lt;=<span class="number">1</span>;<span class="comment">//读取1位</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(IIC_SDA_READ)</span><br><span class="line">			receive++;</span><br><span class="line">		delay_us(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!ACK)</span><br><span class="line">		IIC_NACK();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		IIC_ACK();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> receive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>示例程序：I2C驱动24C01（EEPROM）</p>
<p>24C02规格：总容量2K=256B*8</p>
<p>引脚定义如下：【1-A0 2-A1 3-A2】（地址线） 4-GND 【5-SDA 6-SCL】（I2C控制线） 7-WP（写保护） 8-VCC</p>
<p>在此A0=A1=A2=0</p>
<p>SCL==PB8    SDA==PB9</p>
<p><strong>详细内容参考芯片手册即可</strong></p>
<h6 id="写时序"><a href="#写时序" class="headerlink" title="写时序"></a>写时序</h6><p>start-&gt;片选-&gt;选择地址-&gt;wait-&gt;传输数据-&gt;stop</p>
<h6 id="读时序"><a href="#读时序" class="headerlink" title="读时序"></a>读时序</h6><p> start-&gt;片选-&gt;选择地址线-&gt;start-&gt;选择地址线-&gt;wait-&gt;读取数据-&gt;stop</p>
<p><strong>程序读者自写</strong></p>
<h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><p>SPI（Serial Peripheral interface）串行外围设备接口，是一种<strong>四线</strong>、<strong>高速</strong>、<strong>全双工</strong>、<strong>同步</strong>通信总线</p>
<p>==应用广泛==</p>
<p>四条通信线：</p>
<p><strong>MISO</strong>：（Master input &amp; Slave output）主设备数据输入、从设备数据输出 即 <strong>从设备-&gt;主设备</strong></p>
<p><strong>MOSI</strong>：（Master output &amp; Slave input）主设备数据输出、从设备数据输入 即 <strong>主设备-&gt;从设备</strong></p>
<p><strong>SCLK</strong>：时钟信号，由主设备产生</p>
<p><strong>CS</strong>：片选信号，由主设备控制</p>
<h3 id="协议栈-1"><a href="#协议栈-1" class="headerlink" title="协议栈"></a>协议栈</h3><h4 id="底层硬件-1"><a href="#底层硬件-1" class="headerlink" title="底层硬件"></a>底层硬件</h4><p>stm32f4自带SPI接口，相关内容参考芯片手册即可</p>
<p>基本原理</p>
<ol>
<li>4线总线</li>
<li>主机从机各有一个串行移位寄存器（以下简称SPI寄存器），主机通过向它的SPI寄存器写入一个字节来发起一次传输</li>
<li>SPI寄存器通过MOSI线将字节传输给从机，从机也将自己SPI寄存器中的内容通过MISO线返回主机，最终<strong>两个移位寄存器中的内容被交换</strong></li>
<li><strong>外设读写操作同步完成</strong>，如果<strong>只进行写操作，主机忽略收到数据</strong>即可；若<strong>只进行读操作，需要发送一个空字节来引发从机的传输</strong></li>
</ol>
<p>外设SPI的MISO、MOSI、SCLK可直接挂载到总线上，但CS线需要单独连接到stm32的GPIO模拟CS引脚，当对应GPIOxPinx&lt;-&gt;CS拉低时表示选中该外设，才可进行通信</p>
<h4 id="驱动-1"><a href="#驱动-1" class="headerlink" title="驱动"></a>驱动</h4><p>驱动由stm32f4 STL提供，只需调用库函数即可</p>
<h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><p>SPI应用过程</p>
<ol>
<li>使能SPIx和GPIO时钟</li>
<li>初始化GPIO为复用功能</li>
<li>设置引脚复用为映射</li>
<li>初始化SPIx，设置SPIx工作模式</li>
<li>使能SPIx</li>
<li>SPI传输数据</li>
<li>查看SPI传输状态</li>
</ol>
<p>示例程序：SPI驱动W25Q128</p>
<p>W25Q128规格：<strong>总容量16M</strong>    分成256块64K    每个块分成16扇区，每个扇区4K</p>
<p>擦写周期多达10W次，具有20年的数据保存期限</p>
<p>==支持电压2.7-3.6V==</p>
<p>最小擦除单位为一个扇区，也就是<strong>每次必须擦除4K个字节</strong></p>
<p>需要给W25Q128开辟一个至少4K的缓存区</p>
<p>支持标准SPI协议，还支持双输出/四输出的SPI，最大SPI时钟可以到80MHz（双输出时相当于160MHz，四输出时相当于320MHz）</p>
<p>引脚定义如下：</p>
<p>1 片选信号CS    2 MISO线SO    3 使能引脚WP#    4 接地GND    5 MOSI线SI    6 SCK线CLK    7 保持位HOLD    8 接电源VCC</p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>spi.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;spi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//SPI1初始化，配置为主机</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPI1_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	SPI_InitTypeDef SPI_InitStructure;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1. 使能GPIOA/GPIOB时钟与SPI1时钟</span></span><br><span class="line">	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,ENABLE);<span class="comment">//w25qxx</span></span><br><span class="line">	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB,ENABLE);<span class="comment">//SPI通信</span></span><br><span class="line">	RCC_AHB1PeriphClockCmd(RCC_APB2Periph_SPI1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2. 初始化GPIOF</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF;<span class="comment">//引脚复用</span></span><br><span class="line">	GPIO_InitStructure.GPIO_OType=GPIO_OType_PP;<span class="comment">//推挽输出</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_3|GPIO_Pin_4|GPIO_Pin_5;<span class="comment">//GPIO3、4、5复用输出</span></span><br><span class="line">	GPIO_InitStructure.GPIO_PuPd=GPIO_PuPd_UP;<span class="comment">//内部上拉</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_100MHz;<span class="comment">//100MHz</span></span><br><span class="line">	<span class="comment">//应用设置</span></span><br><span class="line">	GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3. GPIOB引脚复用为SPI1输出端</span></span><br><span class="line">	GPIO_PinAFConfig(GPIOB,GPIO_PinSource3,GPIO_AF_SPI1);</span><br><span class="line">	GPIO_PinAFConfig(GPIOB,GPIO_PinSource4,GPIO_AF_SPI1);</span><br><span class="line">	GPIO_PinAFConfig(GPIOB,GPIO_PinSource5,GPIO_AF_SPI1);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//4. 初始化SPI口</span></span><br><span class="line">	RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1,DISABLE);<span class="comment">//复位SPI1</span></span><br><span class="line">	RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1,DISABLE);<span class="comment">//停止复位</span></span><br><span class="line">	</span><br><span class="line">	SPI_InitStructure.SPI_Direction=SPI_Direction_2Lines_FullDuplex;<span class="comment">//双线全双工</span></span><br><span class="line">	SPI_InitStructure.SPI_Mode=SPI_Mode_Master;<span class="comment">//主机模式</span></span><br><span class="line">	SPI_InitStructure.SPI_DataSize=SPI_DataSize_8b;<span class="comment">//SPI发送接收8位帧结构</span></span><br><span class="line">	SPI_InitStructure.SPI_CPOL=SPI_CPOL_High;<span class="comment">//SCLK空闲状态为高电平</span></span><br><span class="line">	SPI_InitStructure.SPI_CPHA=SPI_CPHA_2Edge;<span class="comment">//SCLK第二个跳变沿数据被采样</span></span><br><span class="line">	SPI_InitStructure.SPI_NSS=SPI_NSS_Soft;<span class="comment">//NSS信号由硬件（NSS管脚）还是软件（使用SSI位管理）：硬件管理</span></span><br><span class="line">	SPI_InitStructure.SPI_BaudRatePrescaler=SPI_BaudRatePrescaler_256;<span class="comment">//预分频256</span></span><br><span class="line">	SPI_InitStructure.SPI_FirstBit=SPI_FirstBit_MSB;<span class="comment">//指定数据传输从MSB位还是LSB位开始：数据传输从MSB位开始</span></span><br><span class="line">	SPI_InitStructure.SPI_CRCPolynomial=<span class="number">7</span>;<span class="comment">//CRC计算的多项式</span></span><br><span class="line">	<span class="comment">//应用设置</span></span><br><span class="line">	SPI_Init(SPI1,&amp;SPI_InitStructure);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//5. 使能SPI</span></span><br><span class="line">	SPI_Cmd(SPI1,ENABLE);</span><br><span class="line">	<span class="comment">//6. 主机发送0xff，维持MOSI为高电平，启动SPI传输</span></span><br><span class="line">	SPI1_RW_byte(<span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置SPI1波特率</span></span><br><span class="line"><span class="comment">//SPI速率=f_&#123;APB2&#125;/分频系数</span></span><br><span class="line"><span class="comment">//f_&#123;APB2&#125;一般为84MHz</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPI1_set_speed</span><span class="params">(u8 SPI_BaudRatePrescaler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_BaudRatePrescaler));<span class="comment">//判断有效性</span></span><br><span class="line">	SPI1-&gt;CR1 &amp;= <span class="number">0xFFC7</span>;<span class="comment">//位3-5清零，设置波特率</span></span><br><span class="line">	SPI1-&gt;CR1 |= SPI_BaudRatePrescaler;<span class="comment">//设置波特率</span></span><br><span class="line">	SPI_Cmd(SPI1,ENABLE);<span class="comment">//使能SPI1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过SPI1总线读写一个字节</span></span><br><span class="line"><span class="comment">//tx_data：发送字节</span></span><br><span class="line"><span class="comment">//返回接收字节</span></span><br><span class="line"><span class="function">u8 <span class="title">SPI1_RW_byte</span><span class="params">(u8 tx_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_TXE)==RESET);<span class="comment">//等待发送区清空</span></span><br><span class="line">	SPI_I2S_SendData(SPI1,tx_data);<span class="comment">//发送数据</span></span><br><span class="line">	<span class="keyword">while</span>(SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_RXNE)==RESET)<span class="comment">//等待接收完一个字节</span></span><br><span class="line">	<span class="keyword">return</span> SPI_I2S_ReceiveData(SPI1);<span class="comment">//返回最近接收的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>spi.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SPI_H</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> __SPI_H</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SPI1_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//初始化SPI1</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SPI1_set_speed</span><span class="params">(u8 SPI_BaudRatePrescaler)</span></span>;<span class="comment">//设置SPI1波特率</span></span><br><span class="line">	<span class="function">u8 <span class="title">SPI1_RW_byte</span><span class="params">(u8 tx_data)</span></span>;<span class="comment">//通过SPI1总线读写一个字节（读写同时进行）</span></span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>W25Q128.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u16 W25QXX_TYPE;<span class="comment">//FLASH型号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//FLASH初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">W25QXX_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1. 使能GPIOB与GPIOG时钟</span></span><br><span class="line">	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB,ENABLE);<span class="comment">//GPIOB</span></span><br><span class="line">	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOG,ENABLE);<span class="comment">//GPIOG</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2. 初始化GPIOF</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_OUT;<span class="comment">//普通输出</span></span><br><span class="line">	GPIO_InitStructure.GPIO_OType=GPIO_OType_PP;<span class="comment">//推挽输出</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_14;<span class="comment">//PB14输出</span></span><br><span class="line">	GPIO_InitStructure.GPIO_PuPd=GPIO_PuPd_UP;<span class="comment">//内部上拉</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_100MHz;<span class="comment">//100MHz</span></span><br><span class="line">	<span class="comment">//应用设置</span></span><br><span class="line">	GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_7;<span class="comment">//PG7</span></span><br><span class="line">	<span class="comment">//应用设置</span></span><br><span class="line">	GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	GPIO_SetBits(GPIOG,GPIO_Pin_7);<span class="comment">//PG7连接到NRF，会同时连接到SPI，令PG7输出1，防止NRF干扰SPI FLASH通信</span></span><br><span class="line">	W25QXX_CS=<span class="number">1</span>;<span class="comment">//不选中FLASH</span></span><br><span class="line">	SPI1_init();<span class="comment">//初始化SPI</span></span><br><span class="line">	SPI1_set_speed(SPI_BaudRatePrescaler_2);<span class="comment">//1/2分频，时钟频率为42MHz，高速模式</span></span><br><span class="line">	W25QXX_TYPE=W25QXX_ReadID();<span class="comment">//读取FLASH ID</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取FLASH ID</span></span><br><span class="line"><span class="function">u16  <span class="title">W25QXX_ReadID</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u16 ID_Temp=<span class="number">0</span>;</span><br><span class="line">	W25QXX_CS=<span class="number">0</span>;<span class="comment">//片选</span></span><br><span class="line">	SPI1_RW_byte(<span class="number">0x90</span>);<span class="comment">//发送读取ID命令</span></span><br><span class="line">	SPI1_RW_byte(<span class="number">0x00</span>);</span><br><span class="line">	SPI1_RW_byte(<span class="number">0x00</span>);</span><br><span class="line">	SPI1_RW_byte(<span class="number">0x00</span>);</span><br><span class="line">	</span><br><span class="line">	ID_Temp |= SPI1_RW_byte(<span class="number">0xFF</span>)&lt;&lt;<span class="number">8</span>;</span><br><span class="line">	ID_Temp |= SPI1_RW_byte(<span class="number">0xFF</span>);</span><br><span class="line">	W25QXX_CS=<span class="number">0</span>;<span class="comment">//取消片选</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> ID_Temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取状态寄存器</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	BIT 6 	5 	4 	3 	2 	1 	0</span></span><br><span class="line"><span class="comment">	SPR RV TB BP2 BP1 BP0 WEL BUSY</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	SPR默认0，状态寄存器保护位，配合WP使用</span></span><br><span class="line"><span class="comment">	TB、BP2、BP1、BP0：FLASH区域写保护设置</span></span><br><span class="line"><span class="comment">	WEL写使能锁定		BUSY忙标记位，1为忙，0为空闲</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	默认0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">u8 <span class="title">W25QXX_ReadSR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 byte=<span class="number">0</span>;</span><br><span class="line">	W25QXX_CS=<span class="number">0</span>;<span class="comment">//片选</span></span><br><span class="line">	SPI1_RW_byte(W25X_ReadStatusReg);<span class="comment">//发送读取寄存器命令</span></span><br><span class="line">	byte=SPI1_RW_byte(<span class="number">0xff</span>);<span class="comment">//读取一个字节</span></span><br><span class="line">	W25QXX_CS=<span class="number">1</span>;<span class="comment">//取消片选</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> byte;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写状态寄存器</span></span><br><span class="line"><span class="comment">//只能写入SPR、TB、BP2、BP1、BP0(bit 7,5,4,3,2)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Write_SR</span><span class="params">(u8 sr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	W25QXX_CS=<span class="number">0</span>;<span class="comment">//片选</span></span><br><span class="line">	SPI1_RW_byte(W25X_WriteStatusReg);<span class="comment">//发送写寄存器命令</span></span><br><span class="line">	SPI1_RW_byte(sr);<span class="comment">//读取一个字节</span></span><br><span class="line">	W25QXX_CS=<span class="number">1</span>;<span class="comment">//取消片选</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写使能	将WEL置位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Write_Enable</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	W25QXX_CS=<span class="number">0</span>;<span class="comment">//片选</span></span><br><span class="line">	SPI1_RW_byte(W25X_WriteEnable);<span class="comment">//发送写使能命令</span></span><br><span class="line">	W25QXX_CS=<span class="number">1</span>;<span class="comment">//取消片选</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写保护	将WEL清零</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Write_Disable</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	W25QXX_CS=<span class="number">0</span>;<span class="comment">//片选</span></span><br><span class="line">	SPI1_RW_byte(W25X_WriteDisable);<span class="comment">//发送写禁止命令</span></span><br><span class="line">	W25QXX_CS=<span class="number">1</span>;<span class="comment">//取消片选</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待空闲</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Wait_Busy</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>((W25QXX_ReadSR()&amp;<span class="number">0x01</span>)==<span class="number">0x01</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进入掉电模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">W25QXX_PowerDown</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	W25QXX_CS=<span class="number">0</span>;<span class="comment">//片选</span></span><br><span class="line">	SPI1_RW_byte(W25X_PowerDown);<span class="comment">//发送掉电命令</span></span><br><span class="line">	W25QXX_CS=<span class="number">1</span>;<span class="comment">//取消片选</span></span><br><span class="line">	delay_us(<span class="number">3</span>);<span class="comment">//等待TPD</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">W25QXX_WAKEUP</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	W25QXX_CS=<span class="number">0</span>;<span class="comment">//片选</span></span><br><span class="line">	SPI1_RW_byte(W25X_ReleasePowerDown);<span class="comment">//发送唤醒命令</span></span><br><span class="line">	W25QXX_CS=<span class="number">1</span>;<span class="comment">//取消片选</span></span><br><span class="line">	delay_us(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//按页写入FLASH</span></span><br><span class="line"><span class="comment">//在指定地址开始写入最大256字节的数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Write_Page</span><span class="params">(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u16 i;</span><br><span class="line">	</span><br><span class="line">	W25QXX_Write_Enable();<span class="comment">//WEL置位</span></span><br><span class="line">	W25QXX_CS=<span class="number">0</span>;<span class="comment">//片选</span></span><br><span class="line">	SPI1_RW_byte(W25X_PageProgram);<span class="comment">//发送写页命令</span></span><br><span class="line">	SPI1_RW_byte((u8)((WriteAddr)&gt;&gt;<span class="number">16</span>));<span class="comment">//发送24位地址</span></span><br><span class="line">	SPI1_RW_byte((u8)((WriteAddr)&gt;&gt;<span class="number">8</span>));</span><br><span class="line">	SPI1_RW_byte((u8)WriteAddr);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;NumByteToWrite;i++)<span class="comment">//循环写入</span></span><br><span class="line">		SPI1_RW_byte(pBuffer[i]);</span><br><span class="line">	W25QXX_CS=<span class="number">1</span>;<span class="comment">//取消片选</span></span><br><span class="line">	W25QXX_Wait_Busy();<span class="comment">//等待写入结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//无保护写入FLASH</span></span><br><span class="line"><span class="comment">//必须确保所写地址内数据为0xFF</span></span><br><span class="line"><span class="comment">//可自动换页</span></span><br><span class="line"><span class="comment">//在指定地址开始写入指定长度的数据，但要确保地址不越界</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Write_NoCheck</span><span class="params">(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u16 page_remain;</span><br><span class="line">	page_remain=<span class="number">256</span>-WriteAddr%<span class="number">256</span>;<span class="comment">//单页剩余的字节数</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(NumByteToWrite&lt;=page_remain)<span class="comment">//待写入字节不大于单页剩余字节</span></span><br><span class="line">		page_remain=NumByteToWrite;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		W25QXX_Write_Page(pBuffer,WriteAddr,page_remain);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(NumByteToWrite==page_remain)</span><br><span class="line">			<span class="keyword">break</span>;<span class="comment">//写入结束</span></span><br><span class="line">		<span class="keyword">else</span><span class="comment">//若待写入字节数比单页剩余字节数大</span></span><br><span class="line">		&#123;</span><br><span class="line">			pBuffer+=page_remain;</span><br><span class="line">			WriteAddr+=page_remain;</span><br><span class="line">			</span><br><span class="line">			NumByteToWrite-=page_remain;<span class="comment">//减去已经写入的字节数</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(NumByteToWrite&gt;<span class="number">256</span>)<span class="comment">//若剩余字节数大于一页字节数</span></span><br><span class="line">				page_remain=<span class="number">256</span>;<span class="comment">//下页能写满</span></span><br><span class="line">			<span class="keyword">else</span><span class="comment">//若不够256个字节</span></span><br><span class="line">				page_remain=NumByteToWrite;<span class="comment">//下页不能写满</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取SPI FLASH</span></span><br><span class="line"><span class="comment">//在指定地址读取指定长度的数据</span></span><br><span class="line"><span class="comment">//pBuffer：数据储存区</span></span><br><span class="line"><span class="comment">//ReadAddr：开始读取的地址（24位）</span></span><br><span class="line"><span class="comment">//NumByteToRead：要读取的最大字节数（&lt;=65535）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Read</span><span class="params">(u8* pBuffer,u32 ReadAddr,u16 NumByteToRead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u16 i;</span><br><span class="line">	W25QXX_CS=<span class="number">0</span>;<span class="comment">//片选</span></span><br><span class="line">	SPI1_RW_byte(W25X_ReadData);<span class="comment">//发送读取命令</span></span><br><span class="line">	SPI1_RW_byte((u8)((ReadAddr)&gt;&gt;<span class="number">16</span>));<span class="comment">//发送24位地址</span></span><br><span class="line">	SPI1_RW_byte((u8)((ReadAddr)&gt;&gt;<span class="number">8</span>));</span><br><span class="line">	SPI1_RW_byte((u8)ReadAddr);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;NumByteToRead;i++)</span><br><span class="line">		pBuffer[i]=SPI1_RW_byte(<span class="number">0xFF</span>);<span class="comment">//循环从FLASH中读数</span></span><br><span class="line">	</span><br><span class="line">	W25QXX_CS=<span class="number">1</span>;<span class="comment">//取消片选</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//写入FLASH</span></span><br><span class="line"><span class="comment">//在指定地址带擦除地开始写入指定长度的数据</span></span><br><span class="line"><span class="comment">//pBuffer：数据存储区</span></span><br><span class="line"><span class="comment">//ReadAddr：开始写入的地址（24位）</span></span><br><span class="line"><span class="comment">//NumByteToRead：要写入的最大字节数（&lt;=65535）</span></span><br><span class="line">u8 W25QXX_BUFFER[<span class="number">4096</span>];<span class="comment">//缓存：保存芯片内不为空的数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Write</span><span class="params">(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u32 sec_pos;</span><br><span class="line">	u16 sec_off;</span><br><span class="line">	u16 sec_remain;</span><br><span class="line">	u16 i;</span><br><span class="line">	u8* W25QXX_BUF;</span><br><span class="line">	</span><br><span class="line">	W25QXX_BUF=W25QXX_BUFFER;</span><br><span class="line">	</span><br><span class="line">	sec_pos=WriteAddr/<span class="number">4096</span>;<span class="comment">//扇区基地址</span></span><br><span class="line">	sec_off=WriteAddr%<span class="number">4096</span>;<span class="comment">//偏移地址</span></span><br><span class="line">	sec_remain=<span class="number">4096</span>-sec_off;<span class="comment">//扇区剩余空间</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(NumByteToWrite&lt;sec_remain)</span><br><span class="line">		sec_remain=NumByteToWrite;<span class="comment">//剩余地址不大于4096个字节</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//反复执行直到完成擦除</span></span><br><span class="line">	&#123;</span><br><span class="line">		W25QXX_Read(W25QXX_BUF,sec_pos*<span class="number">4096</span>,<span class="number">4096</span>);<span class="comment">//读出全扇区内容</span></span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;sec_remain;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(W25QXX_BUF[sec_off+i]!=<span class="number">0xFF</span>)<span class="comment">//若存在非空地址</span></span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">//需要擦除</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;sec_remain)<span class="comment">//如果需要擦除</span></span><br><span class="line">		&#123;</span><br><span class="line">			W25QXX_Erase_Sector(sec_pos);<span class="comment">//那么擦除这个扇区</span></span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;sec_remain;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				W25QXX_BUF[sec_off+i]=pBuffer[i];<span class="comment">//指针指向地址为扇区基地址+偏移地址</span></span><br><span class="line">			&#125;</span><br><span class="line">			W25QXX_Write_NoCheck(W25QXX_BUF,sec_pos*<span class="number">4096</span>,<span class="number">4096</span>);<span class="comment">//写入需要的部分</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//如果不需要擦除（检查到的部分都为空）</span></span><br><span class="line">			W25QXX_Write_NoCheck(W25QXX_BUF,sec_pos*<span class="number">4096</span>,<span class="number">4096</span>);<span class="comment">//直接写入扇区区间</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(NumByteToWrite==sec_remain)<span class="comment">//若待写字节数等于扇区剩余字节数（写完惹）</span></span><br><span class="line">			<span class="keyword">break</span>;<span class="comment">//结束写入</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			sec_pos++;<span class="comment">//扇区地址+1</span></span><br><span class="line">			sec_off=<span class="number">0</span>;<span class="comment">//偏移地址为0，定位到扇区头部</span></span><br><span class="line">			</span><br><span class="line">			pBuffer+=sec_remain;<span class="comment">//指针偏移</span></span><br><span class="line">			WriteAddr+=sec_remain;<span class="comment">//写入地址偏移</span></span><br><span class="line">			NumByteToWrite-=sec_remain;<span class="comment">//待写字节数递减</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(NumByteToWrite&gt;<span class="number">4096</span>)<span class="comment">//若待写字节数比一个扇区空间大</span></span><br><span class="line">				sec_remain=<span class="number">4096</span>;<span class="comment">//下个扇区还是写不完</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				sec_remain=NumByteToWrite;<span class="comment">//下个扇区就可以写完</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整片擦除</span></span><br><span class="line"><span class="comment">//注意：等待时间较长</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Erase_Chip</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ERASE ALL CHIP!&quot;</span>);<span class="comment">//显示警告</span></span><br><span class="line">	</span><br><span class="line">	W25QXX_Write_Enable();<span class="comment">//WEL置位并等待</span></span><br><span class="line">	W25QXX_Wait_Busy();</span><br><span class="line">	</span><br><span class="line">	W25QXX_CS=<span class="number">0</span>;<span class="comment">//片选</span></span><br><span class="line">	SPI1_RW_byte(W25X_ChipErase);</span><br><span class="line">	W25QXX_CS=<span class="number">1</span>;<span class="comment">//取消片选</span></span><br><span class="line">	W25QXX_Wait_Busy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//擦除一个扇区</span></span><br><span class="line"><span class="comment">//Dst_Addr为目标扇区地址</span></span><br><span class="line"><span class="comment">//擦除一个扇区最少用时150ms</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Erase_Sector</span><span class="params">(u32 Dst_Addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x will be erase!\r\n&quot;</span>,Dst_Addr);<span class="comment">//显示警告</span></span><br><span class="line">	</span><br><span class="line">	Dst_Addr*=<span class="number">4096</span>;</span><br><span class="line">	W25QXX_Write_Enable();<span class="comment">//WEL置位并等待</span></span><br><span class="line">	W25QXX_Wait_Busy();</span><br><span class="line">	</span><br><span class="line">	W25QXX_CS=<span class="number">0</span>;<span class="comment">//片选</span></span><br><span class="line">	SPI1_RW_byte(W25X_SectorErase);</span><br><span class="line">	SPI1_RW_byte((u8)((Dst_Addr)&gt;&gt;<span class="number">16</span>));</span><br><span class="line">	SPI1_RW_byte((u8)((Dst_Addr)&gt;&gt;<span class="number">8</span>));</span><br><span class="line">	SPI1_RW_byte((u8)Dst_Addr);</span><br><span class="line">	W25QXX_CS=<span class="number">1</span>;<span class="comment">//取消片选</span></span><br><span class="line">	W25QXX_Wait_Busy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>W25Q128.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前部分略	</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25Q80 	0XEF13</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25Q16 	0XEF14</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25Q32	0XEF15</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25Q64 	0XEF16</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25Q128 0XEF17</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*W35X系列/Q系列芯片列表</span></span><br><span class="line"><span class="comment">	W25Q80 0XEF13</span></span><br><span class="line"><span class="comment">	W25Q16 0XEF14</span></span><br><span class="line"><span class="comment">	W25Q32 0XEF15</span></span><br><span class="line"><span class="comment">	W25Q64 0XEF16</span></span><br><span class="line"><span class="comment">	W25Q128 0XEF17</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">extern</span> u16 W25QXX_TYPE;<span class="comment">//定义W25QXX芯片型号</span></span><br><span class="line">	</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25QXX_CS PBout(14)<span class="comment">//PB14输出W25QXX片选信号(软件片选)</span></span></span><br><span class="line">	</span><br><span class="line"><span class="comment">/***************************指令表***************************/</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25X_WriteEnable 			0x06</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25X_WriteDisable 			0x04</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25X_ReadStatusReg 			0x05</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25X_WriteStatusReg 		0x01</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25X_ReadData 				0x03</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25X_FastReadData 			0x0B</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25X_FastReadDual 			0x3B</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25X_PageProgram 			0x02</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25X_BlockErase 			0xD8</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25X_SectorErase 			0x20</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25X_ChipErase 				0xC7</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25X_PowerDown 				0xB9</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25X_ReleasePowerDown 		0xAB</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25X_DeviceID 				0xAB</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25X_ManufactDeviceID 		0x90</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> W25X_JedecDeviceID 			0x9F</span></span><br><span class="line"><span class="comment">/***************************指令表***************************/</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">W25QXX_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//FLASH初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="function">u16  <span class="title">W25QXX_ReadID</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//读取FLASH ID</span></span><br><span class="line">	<span class="function">u8 	 <span class="title">W25QXX_ReadSR</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//读取状态寄存器</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Write_SR</span><span class="params">(u8 sr)</span></span>;<span class="comment">//写状态寄存器</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Write_Enable</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//写使能</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Write_Disable</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//写保护</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Write_NoCheck</span><span class="params">(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Read</span><span class="params">(u8* pBuffer,u32 ReadAddr,u16 NumByteToRead)</span></span>;<span class="comment">//读取FLASH</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Write</span><span class="params">(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)</span></span>;<span class="comment">//写入FLASH</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Erase_Chip</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//整片擦除</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Erase_Sector</span><span class="params">(u32 Dst_Addr)</span></span>;<span class="comment">//扇区擦除</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">W25QXX_Wait_Busy</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//等待空闲</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">W25QXX_PowerDown</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//进入掉电模式</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">W25QXX_WAKEUP</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//唤醒</span></span><br></pre></td></tr></table></figure>

<h2 id="CAN"><a href="#CAN" class="headerlink" title="CAN"></a>CAN</h2><h3 id="协议栈-2"><a href="#协议栈-2" class="headerlink" title="协议栈"></a>协议栈</h3><p>CAN(Controller Area Network)是ISO国际标准化的串行通信协议，由德国电气商博世公司在1986年率先提出。此后CAN通过ISO11898及ISO11519进行了标准化，<strong>可靠性高</strong></p>
<p>具有两个标准：</p>
<ol>
<li><p>ISO11898高速通信标准（速率125Kbps~1Mbps）</p>
</li>
<li><p>ISO11519-2低速通信标准（速率125Kbps以下）</p>
</li>
</ol>
<p>特点：</p>
<ul>
<li>多主控制</li>
</ul>
<p>总线空闲时所有单元都可发送消息，两个以上单元同时发送消息时，根据<strong>标识符</strong>（ID，<strong>不是地址</strong>）决定优先级。对各个消息ID的各个位进行逐个仲裁比较，<strong>仲裁获胜单元可继续发送消息，失利的单元需立刻停止发送而进行接收工作</strong></p>
<ul>
<li>系统柔软性</li>
</ul>
<p>连接总线的单元没有类似地址的信息，可以很方便地<strong>添加新单元，不需要改动旧设备</strong></p>
<ul>
<li>速度快，距离远</li>
</ul>
<p>速率最高1Mbps（距离&lt;40m），最远可达10km（速率&lt;5kbps）</p>
<ul>
<li>具有错误检测、错误通知和错误恢复功能</li>
</ul>
<p><strong>所有单元都能检测错误，检测到错误会立即通知所有其他单元，正在发送消息的单元一旦检测到出错会强制结束发送，并不断反复重新发送此消息直到发送成功</strong></p>
<ul>
<li>故障封闭功能</li>
</ul>
<p>可以判断出错误的类型是总线上暂时的数据错误还是持续的数据错误。当总线上发生持续数据错误时，可将引起此故障的单元从总线上隔离出去</p>
<ul>
<li>连接节点多</li>
</ul>
<p>可同时连接多个单元，理论上没有总数限制，但实际上可连接单元越多，通信速率越慢；通信速率越快，可连接单元数越少</p>
<h4 id="底层硬件-2"><a href="#底层硬件-2" class="headerlink" title="底层硬件"></a>底层硬件</h4><p>==使用ISO11898标准==</p>
<p>CAN控制器根据CAN_L和CAN_H上的电位差来判断总线电平</p>
<p>发送方通过使总线电平发生变化将消息发送给接收方</p>
<ul>
<li><p>显性电平对应逻辑0：CAN_H与CAN_L之差在2V左右</p>
</li>
<li><p>隐性电平对应逻辑1：CAN_H与CAN_L之差为0V</p>
</li>
</ul>
<p>总线电平必为二者之一，<strong>显性电平具有优先权</strong>，只要一个单元输出显性电平，总线上即为显性电平；只有所有单元都输出隐性电平，总线上才为隐性电平</p>
<p>单元在总线上呈并联，<strong>总线起止端各有一个120Ω的终端电阻</strong>（作用：阻抗匹配，减少回波反射）</p>
<p>stm32f407自带<strong>2个</strong>基本可扩展CAN外设（bxCAN），支持CAN协议2.0A和2.0B主动模式，波特率最高1Mbps，通过GPIO复用2个引脚输出，但需要接入<strong>TJA1050</strong>电平转换ic才能正常接入CAN总线</p>
<p>每个CAN具有3个3级深度（<strong>可同时存储三条有效报文</strong>）发送邮箱，互相独立；2个接收FIFO，最多28个可变筛选器组</p>
<p><strong>两个CAN分别拥有独立的发送邮箱和接收FIFO，但他们会共用28个筛选器</strong></p>
<h5 id="CAN标识符筛选器"><a href="#CAN标识符筛选器" class="headerlink" title="CAN标识符筛选器"></a>CAN标识符筛选器</h5><p><strong>CAN的标识符</strong>不表示目标地址而是<strong>表示发送优先级</strong>，接收节点根据标识符的值决定是否接受对应信息</p>
<p>STM32 CAN控制器每个筛选器组由2个32位寄存器组成，根据位宽不同，每个筛选器组可提供</p>
<ul>
<li>1个32位筛选器，包括STDID[10:0] EXTID[17:0] IDE RTR</li>
<li>2个16位筛选器，包括STDID[10:0] IDE RTR EXTID[17:15]</li>
</ul>
<p>应用程序不用的筛选器组应当保持禁用</p>
<p>筛选器编号从0开始</p>
<p>筛选器可配置为屏蔽位模式和标识符列表模式：</p>
<ul>
<li><p>屏蔽位模式下，标识符寄存器指定报文标识符哪一位“必须匹配”；屏蔽寄存器指定报文标识符哪一位“不用关心”</p>
<p>屏蔽寄存器置0的标识寄存器对应位会被忽略</p>
<p>类似“掩码”操作，一次筛选出<strong>一组</strong>标识符</p>
</li>
<li><p>标识符列表模式下，屏蔽寄存器也被当做标识符寄存器用，接受报文标识符的每一位都必须和筛选器标识符相同</p>
<p>一次过滤出<strong>一个</strong>标识符号</p>
</li>
</ul>
<p>==举例：1个32位筛选器-标识符屏蔽模式，设置CAN_F0R1=0xFFFF0000，CAN_F0R2=0xFF00FF00，则期望收到的id形式为0xFFFF0000，同时必须关心id形式为0xFF00FF00，即标记为F的四个位必须和F0R1中的对应位一模一样，另外的六个位可以一样也可以不一样，即收到的映像必须是0xFF??00??才算是正确的，并不关心标?的位是多少==</p>
<h4 id="驱动-2"><a href="#驱动-2" class="headerlink" title="驱动"></a>驱动</h4><h5 id="CAN通信"><a href="#CAN通信" class="headerlink" title="CAN通信"></a>CAN通信</h5><ul>
<li><p>数据帧：<strong>发送单元</strong>向接收单元<strong>传送数据</strong></p>
</li>
<li><p>遥控帧：<strong>接收单元</strong>向具有相同ID的发送单元<strong>请求数据</strong></p>
</li>
<li><p>错误帧：检测出错时<strong>向其他单元通知错误</strong></p>
</li>
<li><p>过载帧：接收单元通知其<strong>尚未做好接收准备</strong>（标记忙碌状态）</p>
</li>
<li><p>间隔帧：将数据帧和遥控帧与前面的帧<strong>分隔</strong>开的帧</p>
</li>
</ul>
<p><strong>数据帧</strong>和<strong>遥控帧</strong>有<strong>11位ID的标准格式</strong>和<strong>29位ID的拓展格式</strong></p>
<h6 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h6><p>由7个段组成，下面是标准格式的实现</p>
<ol>
<li>帧起始：1位显性电平</li>
<li>仲裁段：11位ID+1位RTR（显性电平）</li>
</ol>
<p>表示数据优先级。<strong>ID高位在前，低位在后</strong>，<strong>禁止高7位都是隐性</strong>（不能ID=1111111XXXX）</p>
<p>RTR：<strong>远程请求</strong>位——0表示数据帧，1表示远程帧</p>
<p>SRR：<strong>替代远程请求</strong>位——设置为1</p>
<p>IDE：<strong>标识符选择</strong>位——0表示标准标识符，1表示扩展标识符</p>
<ol start="3">
<li>控制段：1位IDE（显性电平）+1位r0（显性电平）+4位DLC</li>
</ol>
<p>r0、r1：<strong>保留位</strong>——必须以显性电平发送，但接收可以是隐性电平</p>
<p>DLC：<strong>数据长度码</strong>——0-8表示发送/接收的数据长度（字节）</p>
<ol start="4">
<li>数据段：0-64位（0-8个字节）的数据</li>
</ol>
<p><strong>从最高位开始输出</strong></p>
<ol start="5">
<li>CRC段：15位+1位RCR界定符（隐性电平）</li>
</ol>
<p>用于检查帧传输错误</p>
<p>CRC的值计算范围包括：帧起始、仲裁段、控制段、数据段</p>
<p>接收方和发送方以同样的算法计算CRC并进行比较，不一致时会通报错误</p>
<ol start="6">
<li>ACK段：1位ACK槽（发送位为隐性电平，接收位随接收成功与否变化）+1位ACK界定符（隐性电平）</li>
</ol>
<p>用来确认是否正常接收</p>
<p><strong>发送单元ACK段发送2个隐性电平</strong></p>
<p>接收单元ACK段：<strong>接收到正确消息的单元在ACK槽发送显性位</strong>，称之为发送ACK/返回ACK</p>
<p>发送ACK的时既不处于总线关闭态也不处于休眠态的所有接受单元中，接收到正常消息（不含填充错误、格式错误、CRC错误）的单元，<strong>发送单元不会发送ACK</strong></p>
<ol start="7">
<li>帧结束：7位EOF（7位隐性电平）</li>
</ol>
<h6 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="总线仲裁"></a>总线仲裁</h6><ol>
<li>总线空闲时最先发送的单元优先，一旦发送无法被抢占</li>
<li>多个单元同时发送，连续输出显性电平多的单元优先</li>
<li>先比较ID，若ID相同，就比较RTR、SRR等位</li>
</ol>
<h6 id="位时序（波特率）"><a href="#位时序（波特率）" class="headerlink" title="位时序（波特率）"></a>位时序（波特率）</h6><p>位速率：发送单元在非同步情况下发送的每秒钟位数称为位速率</p>
<p>一个位一般可以分成四段</p>
<p>这些段又由最小时间单位Time Quantum(Tq)组成</p>
<p>1位分4段，1段分多个Tq，即<strong>位时序</strong></p>
<p>$$位时间=\frac{1}{波特率}$$</p>
<p>可以任意设定位时序，多个单元可同时采样，也可任意设定采样点</p>
<ul>
<li>同步段 SS</li>
</ul>
<p>多个单元实现时序同步，1Tq</p>
<p>电平边沿跳变最好出现在此段中</p>
<ul>
<li>传播时间段 PTS</li>
</ul>
<p>吸收网络物理延迟</p>
<p>该段时间=2*(发送单元输出延迟+总线信号传播延迟+接受单元输入延迟)=1~8Tq</p>
<ul>
<li>相位缓冲段1 PBS1</li>
</ul>
<p>1~8Tq</p>
<ul>
<li>相位缓冲段2 PBS2</li>
</ul>
<p>2~8Tq</p>
<p>两段负责补偿未被包含在SS段的信号边沿；通过对相位缓冲段加减SJW吸收细微时钟误差，但会导致通信速度下降</p>
<ul>
<li>再同步补偿宽度 SJW</li>
</ul>
<p>1~4Tq</p>
<p>补偿时钟频率偏差/传输延迟等导致误差的最大值</p>
<h5 id="STM32F407的CAN控制器设置"><a href="#STM32F407的CAN控制器设置" class="headerlink" title="STM32F407的CAN控制器设置"></a>STM32F407的CAN控制器设置</h5><p>可分为三种模式</p>
<ul>
<li><p>工作模式，通过CAN_MCR寄存器控制</p>
<p>INRQ=1,SLEEP=0 初始化工作模式</p>
<p>INRQ=0,SLEEP=0 ==正常工作==</p>
<p>SLEEP=1 开启睡眠，降低功耗</p>
</li>
<li><p>测试模式，通过CAN_BTR控制</p>
<p>LBKM=0,SLIM=1 静默，CANtx恒为1（只接收不发送），可以监控总线数据</p>
<p>LBKM=1,SLIM=0 ==环回==，CANrx被阻塞（只发送不接收）</p>
<p>LBKM=1,SLIM=1 环回静默，CANrx、CANtx都被阻塞（不接收不发送）</p>
</li>
<li><p>调试模式</p>
</li>
</ul>
<h5 id="CAN发收流程"><a href="#CAN发收流程" class="headerlink" title="CAN发收流程"></a>CAN发收流程</h5><h6 id="CAN发送流程"><a href="#CAN发送流程" class="headerlink" title="CAN发送流程"></a>CAN发送流程</h6><ol>
<li>选择空置邮箱（TME=1）</li>
<li>设置标识符（ID）、数据长度、待发送的数据内容</li>
<li>设置CAN_TIxR的TXRQ位为1，请求发送</li>
<li>邮箱挂号，等待成为最高优先级才能够发送</li>
<li>预定发送，等待总线空闲</li>
<li>发送数据</li>
<li>邮箱空置</li>
</ol>
<p>可随时置ABRQ为1退出发送进入等待，如果发送失败则可以重新等待发送或重启发动流程</p>
<h6 id="CAN接收流程"><a href="#CAN接收流程" class="headerlink" title="CAN接收流程"></a>CAN接收流程</h6><ol>
<li>FIFO为空</li>
<li>收到有效报文（被正确接收（直到EOF都未出现错误）且通过标识符过滤的报文）</li>
<li>挂号1，存入FIFO的一个邮箱（此步骤由硬件完成）</li>
<li>收到有效报文</li>
<li>挂号2</li>
<li>收到有效报文</li>
<li>挂号3</li>
<li>收到有效报文</li>
<li>溢出，可设置是否锁定，锁定后新数据将被丢弃，不锁定则新数据会替代老数据</li>
</ol>
<p>通过读取CAN_RFxR的FMP寄存器获取FIFO中当前存储的数据条数，只要不为0则可以读取报文</p>
<h6 id="STM32-CAN位时序"><a href="#STM32-CAN位时序" class="headerlink" title="STM32 CAN位时序"></a>STM32 CAN位时序</h6><p>$波特率=\frac{1}{正常的位时间}$</p>
<p>$正常的位时间=1*t_q+t_{BS1}+t_{BS2}$</p>
<p>$t_{BS1}=t_q*(TS1[3:0]+1)$</p>
<p>$t_{BS2}=t_q*(TS2[2:0]+1)$</p>
<p>$t_q=(BRP[9:0]+1)*t_{PCLK}$</p>
<p>$t_q$代表1个时间单元，$t_{PCLK}$表示APB时钟的时钟周期</p>
<p>对于stm32f407，设置TS1=6,TS2=5,BRP=5</p>
<p>$波特率=\frac{42000}{[(7+6+1)*6]}=500Kbps$</p>
<h4 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h4><p>初始化流程</p>
<ol>
<li>配置引脚复用</li>
<li>使能CAN控制器时钟</li>
<li>设置CAN工作模式和波特率</li>
<li>设置过滤器</li>
<li>CAN自动开始工作</li>
</ol>
<p>can.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;can.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//CAN1初始化</span></span><br><span class="line"><span class="comment">//使用PA11、PA12引脚输入输出</span></span><br><span class="line"><span class="comment">/***********************************************</span></span><br><span class="line"><span class="comment">	Tsjw：重新同步跳跃时间单元，范围1Tq-4Tq CAN_BS1_1tq-CAN_BS1_16tq</span></span><br><span class="line"><span class="comment">	Tbs2：时间段2的时间单元，范围1Tq-8Tq CAN_BS2_1tq-CAN_BS2_8tq</span></span><br><span class="line"><span class="comment">	Tbs1：时间段1的时间单元，范围1Tq-16Tq</span></span><br><span class="line"><span class="comment">	brp：波特率分频器，范围1-1024	</span></span><br><span class="line"><span class="comment">	计算公式：1个时间单元Tq=(brp)*Tpclk1</span></span><br><span class="line"><span class="comment">	波特率=Fpclk1/(brp*(tbs1+1+tbs2+1+1))</span></span><br><span class="line"><span class="comment">	mode：CAN_Mode_Normal为普通模式，CAN_Mode_LoopBack为回环模式</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	Fpclk1时钟在初始化时设置为36MHz，</span></span><br><span class="line"><span class="comment">	如果设置sjw=1,bs2=8,bs1=9,brp=4,回环模式，则波特率为36M/((8+9+1)*4)=500Kbps</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	返回0则正常初始化，返回其他则初始化失败</span></span><br><span class="line"><span class="comment">************************************************/</span></span><br><span class="line"><span class="function">u8 <span class="title">CAN1_Mode_init</span><span class="params">(u8 Tsjw,u8 Tbs2,u8 Tbs1,u16 brp,u8 mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	CAN_InitTypeDef CAN_InitStruct;</span><br><span class="line">	CAN_FilterInitTypeDef CAN_FilterInitStruct;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//如果使能FIFO消息挂号中断则开启</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> CAN1_RX0_INT_ENABLE</span></span><br><span class="line">		NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">	</span><br><span class="line">		CAN_ITConfig(CAN1,CAN_IT_FMP0,ENABLE);<span class="comment">//使能FIFO消息挂号中断</span></span><br><span class="line">		NVIC_InitStructure.NVIC_IRQChannel=CAN1_RX0_IRQn;</span><br><span class="line">		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span>;<span class="comment">//抢占优先级为1</span></span><br><span class="line">		NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">0</span>;<span class="comment">//子优先级为0</span></span><br><span class="line">		NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;<span class="comment">//使能FIFO消息挂号中断</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1. 使能GPIO和CAN控制器时钟</span></span><br><span class="line">	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,ENABLE);</span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2. 初始化PA11、PA12</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF;<span class="comment">//引脚复用</span></span><br><span class="line">	GPIO_InitStructure.GPIO_OType=GPIO_OType_PP;<span class="comment">//推挽输出</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_11|GPIO_Pin_12;<span class="comment">//PA11、PA12</span></span><br><span class="line">	GPIO_InitStructure.GPIO_PuPd=GPIO_PuPd_UP;<span class="comment">//内部上拉</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_100MHz;<span class="comment">//100Mhz</span></span><br><span class="line">	<span class="comment">//应用设置</span></span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2. 设置引脚复用映射</span></span><br><span class="line">	GPIO_PinAFConfig(GPIOA,GPIO_PinSource11,GPIO_AF_CAN1);<span class="comment">//PA11复用为CAN1</span></span><br><span class="line">	GPIO_PinAFConfig(GPIOA,GPIO_PinSource12,GPIO_AF_CAN1);<span class="comment">//PA12复用为CAN1</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3. 设置CAN控制器</span></span><br><span class="line">		<span class="comment">//软件管理设定</span></span><br><span class="line">	CAN_InitStruct.CAN_TTCM=DISABLE;<span class="comment">//非时间触发 通信模式</span></span><br><span class="line">	CAN_InitStruct.CAN_ABOM=DISABLE;<span class="comment">//软件自动离线管理</span></span><br><span class="line">	CAN_InitStruct.CAN_AWUM=DISABLE;<span class="comment">//睡眠模式通过软件唤醒</span></span><br><span class="line">		<span class="comment">//报文相关设定</span></span><br><span class="line">	CAN_InitStruct.CAN_NART=ENABLE;<span class="comment">//禁止报文自动传送</span></span><br><span class="line">	CAN_InitStruct.CAN_RFLM=DISABLE;<span class="comment">//报文不锁定，新报文将覆盖堆积旧报文</span></span><br><span class="line">	CAN_InitStruct.CAN_TXFP=DISABLE;<span class="comment">//优先级由报文标识符决定</span></span><br><span class="line">		<span class="comment">//参数设置</span></span><br><span class="line">	CAN_InitStruct.CAN_Mode=mode;<span class="comment">//模式设置</span></span><br><span class="line">	CAN_InitStruct.CAN_SJW=Tsjw;<span class="comment">//同步跳跃宽度设置</span></span><br><span class="line">	CAN_InitStruct.CAN_BS1=Tbs1;<span class="comment">//Tbs1 设置为CAN_BS1_1tq-CAN_BS1_16tq</span></span><br><span class="line">	CAN_InitStruct.CAN_BS2=Tbs2;<span class="comment">//Tbs2 设置为CAN_BS2_1tq-CAN_BS2_8tq</span></span><br><span class="line">	CAN_InitStruct.CAN_Prescaler=brp;<span class="comment">//分频系数=brp+1</span></span><br><span class="line">	<span class="comment">//应用设置</span></span><br><span class="line">	CAN_Init(CAN1,&amp;CAN_InitStruct);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//4. 设置标识符过滤器</span></span><br><span class="line">		<span class="comment">//基础设置</span></span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterNumber=<span class="number">0</span>;<span class="comment">//使用过滤器0</span></span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterMode=CAN_FilterMode_IdMask;<span class="comment">//使用标识符屏蔽模式</span></span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterScale=CAN_FilterScale_32bit;<span class="comment">//使用32位寄存器模式</span></span><br><span class="line">		<span class="comment">//32位ID设置</span></span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterIdHigh=<span class="number">0x0000</span>;</span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterIdLow=<span class="number">0x0000</span>;</span><br><span class="line">		<span class="comment">//32位掩码设置</span></span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterMaskIdHigh=<span class="number">0x0000</span>;</span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterMaskIdLow=<span class="number">0x0000</span>;</span><br><span class="line">		<span class="comment">//应用过滤器和FIFO设置</span></span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterFIFOAssignment=CAN_Filter_FIFO0;<span class="comment">//使用FIFO0</span></span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterActivation=ENABLE;<span class="comment">//激活标识符过滤器0</span></span><br><span class="line">	<span class="comment">//应用设置</span></span><br><span class="line">	CAN_FilterInit(&amp;CAN_FilterInitStruct);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//完成初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果使能FIFO消息挂号中断则开启，负责接收剩余信息</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CAN1_RX0_INT_ENABLE</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">CAN1_RX0_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		CanRxMsg CAN_rx_massage;</span><br><span class="line">		<span class="keyword">int</span> CAN_rx_counter=<span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		CAN_Receive(CAN1,<span class="number">0</span>,&amp;CAN_rx_massage);</span><br><span class="line">		<span class="keyword">for</span>(CAN_rx_counter=<span class="number">0</span>;CAN_rx_counter&lt;<span class="number">8</span>;CAN_rx_counter++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;rxbuf[%d]:%d\r\n&quot;</span>,CAN_rx_counter,CAN_rx_massage.Data[CAN_rx_counter]);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//CAN发送数据</span></span><br><span class="line"><span class="comment">//固定格式：ID=0x12，标准帧，数据帧</span></span><br><span class="line"><span class="comment">//msg为数据指针，最大8个字节</span></span><br><span class="line"><span class="comment">//len为数据长度	0-8</span></span><br><span class="line"><span class="comment">//返回0表示成功，返回1表示失败</span></span><br><span class="line"><span class="function">u8 <span class="title">CAN1_tx_msg</span><span class="params">(u8* msg,u8 len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 mbox;</span><br><span class="line">	u16 i=<span class="number">0</span>;</span><br><span class="line">	CanTxMsg CAN_tx_massage;</span><br><span class="line">	</span><br><span class="line">	CAN_tx_massage.StdId=<span class="number">0x12</span>;<span class="comment">//标准标识符为0</span></span><br><span class="line">	CAN_tx_massage.ExtId=<span class="number">0x12</span>;<span class="comment">//设置29位扩展标识符</span></span><br><span class="line">	CAN_tx_massage.IDE=<span class="number">0</span>;<span class="comment">//使用扩展标识符</span></span><br><span class="line">	CAN_tx_massage.RTR=<span class="number">0</span>;<span class="comment">//消息类型：数据帧，1帧8位</span></span><br><span class="line">	CAN_tx_massage.DLC=len;<span class="comment">//发送2帧消息</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">		CAN_tx_massage.Data[i]=msg[i];<span class="comment">//发送信息</span></span><br><span class="line">	</span><br><span class="line">	mbox=CAN_Transmit(CAN1,&amp;CAN_tx_massage);</span><br><span class="line">	</span><br><span class="line">	i=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>((CAN_TransmitStatus(CAN1,mbox)==CAN_TxStatus_Failed)&amp;&amp;(i&lt;<span class="number">0xFFF</span>))</span><br><span class="line">		i++;</span><br><span class="line">	<span class="keyword">if</span>(i&gt;=<span class="number">0xfff</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CAN接收数据</span></span><br><span class="line"><span class="comment">//buf为数据缓存区</span></span><br><span class="line"><span class="comment">//返回0表示无数据被接收到，若接收到数据则返回接收的数据长度</span></span><br><span class="line"><span class="function">u8 <span class="title">CAN1_rx_msg</span><span class="params">(u8* buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u32 i;</span><br><span class="line">	CanRxMsg CAN_rx_massage;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(CAN_MessagePending(CAN1,CAN_FIFO0)==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	CAN_Receive(CAN1,CAN_FIFO0,&amp;CAN_rx_massage);<span class="comment">//读取数据</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;CAN_rx_massage.DLC;i++)</span><br><span class="line">		buf[i]=CAN_rx_massage.Data[i];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> CAN_rx_massage.DLC;<span class="comment">//返回接收到的数据长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>can.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __CAN_H</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> __CAN_H</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">	<span class="function">u8 <span class="title">CAN1_mode_init</span><span class="params">(u8 Tsjw,u8 Tbs2,u8 Tbs1,u16 brp,u8 mode)</span></span>;<span class="comment">//CAN1初始化函数</span></span><br><span class="line">	<span class="function">u8 <span class="title">CAN1_tx_msg</span><span class="params">(u8* msg,u8 len)</span></span>;<span class="comment">//CAN发送数据</span></span><br><span class="line">	<span class="function">u8 <span class="title">CAN1_rx_msg</span><span class="params">(u8* buf)</span></span>;<span class="comment">//CAN接收数据</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;dac.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;dht11.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;dma.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stmflash.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;can.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 key,res,i=<span class="number">0</span>,t=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">	u8 CAN_buf[<span class="number">8</span>];</span><br><span class="line">	u8 mode=<span class="number">1</span>;<span class="comment">//CAN工作模式：1为环回模式，0为普通模式</span></span><br><span class="line">	</span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//中断优先级分组2</span></span><br><span class="line">	</span><br><span class="line">	delay_init(<span class="number">168</span>);</span><br><span class="line">	uart_init(<span class="number">115200</span>);<span class="comment">//串口波特率115200</span></span><br><span class="line">	LED_init();</span><br><span class="line">	LCD_init();</span><br><span class="line">	KEY_init();</span><br><span class="line">	CAN1_mode_init(CAN_SJW_1tq,CAN_BS2_6tq,CAN_BS1_7tq,<span class="number">6</span>,CAN_Mode_LoopBack);<span class="comment">//初始化为环回模式，波特率500kbps</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		key=KEY_scan(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(key==KEY0_PRES)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				CAN_buf[i]=cnt+<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(i&lt;<span class="number">4</span>)</span><br><span class="line">					LCD_ShowxNum(<span class="number">30</span>+i*<span class="number">32</span>,<span class="number">210</span>,CAN_buf[i],<span class="number">3</span>,<span class="number">16</span>,<span class="number">0x80</span>);<span class="comment">//显示数据</span></span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					LCD_ShowxNum(<span class="number">30</span>+(i<span class="number">-4</span>)*<span class="number">32</span>,<span class="number">230</span>,CAN_buf[i],<span class="number">3</span>,<span class="number">16</span>,<span class="number">0x80</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			res=CAN1_tx_msg(CAN_buf,<span class="number">8</span>);<span class="comment">//发送8个字节</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(res)</span><br><span class="line">				LCD_ShowString(<span class="number">30</span>+<span class="number">80</span>,<span class="number">190</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;Failed&quot;</span>);<span class="comment">//发送失败</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				LCD_ShowString(<span class="number">30</span>+<span class="number">80</span>,<span class="number">190</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;OK    &quot;</span>);<span class="comment">//发送成功</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(KEY_init==WKUP_PRES)</span><br><span class="line">		&#123;</span><br><span class="line">			mode=!mode;</span><br><span class="line">			CAN1_mode_init(CAN_SJW_1tq,CAN_BS2_6tq,CAN_BS1_7tq,<span class="number">6</span>,mode);<span class="comment">//初始化为普通模式，波特率500kbps</span></span><br><span class="line">			</span><br><span class="line">			POINT_COLOR=RED;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(mode==<span class="number">0</span>)<span class="comment">//普通模式，使用两套开发板通信</span></span><br><span class="line">			&#123;</span><br><span class="line">				LCD_ShowString(<span class="number">30</span>,<span class="number">130</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;Normal Mode&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span><span class="comment">//环回模式</span></span><br><span class="line">			&#123;</span><br><span class="line">				LCD_ShowString(<span class="number">30</span>,<span class="number">130</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;LoopBack Mode&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		key=CAN1_rx_msg();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(key)</span><br><span class="line">		&#123;</span><br><span class="line">			LCD_Fill(<span class="number">30</span>,<span class="number">270</span>,<span class="number">160</span>,<span class="number">310</span>,WHITE);</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;key;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(i&lt;<span class="number">4</span>)</span><br><span class="line">					LCD_ShowxNum(<span class="number">30</span>+i*<span class="number">32</span>,<span class="number">270</span>,CAN_buf[i],<span class="number">3</span>,<span class="number">16</span>,<span class="number">0x80</span>);<span class="comment">//显示数据</span></span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					LCD_ShowxNum(<span class="number">30</span>+(i<span class="number">-4</span>)*<span class="number">32</span>,<span class="number">290</span>,CAN_buf[i],<span class="number">3</span>,<span class="number">16</span>,<span class="number">0x80</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		t++;</span><br><span class="line">		delay_ms(<span class="number">10</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(t==<span class="number">20</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			LED0=!LED0;</span><br><span class="line">			t=<span class="number">0</span>;</span><br><span class="line">			cnt++;</span><br><span class="line">			LCD_ShowxNum(<span class="number">30</span>+<span class="number">48</span>,<span class="number">170</span>,cnt,<span class="number">3</span>,<span class="number">16</span>,<span class="number">0x80</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA学习笔记1【FPGA原理与结构】</title>
    <url>/2021/11/19/FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E3%80%90FPGA%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%93%E6%9E%84%E3%80%91/</url>
    <content><![CDATA[<p>注意：本篇内容根据《FPGA原理和结构》（[日]天野英晴 著 赵谦 译）一书整理，作者也是初学者，有错漏请见谅</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>FPGA即<strong>现场可编程门阵列</strong>（Field Programmable Gate Arry），与之对应的是FPAA<strong>现场可编程模拟阵列</strong>（Field Programmable Analog Array）。这是一种可以通过重新编程来实现用户所需<strong>逻辑电路</strong>的半导体器件</p>
<h2 id="布尔代数"><a href="#布尔代数" class="headerlink" title="布尔代数"></a>布尔代数</h2><p>布尔运算是一种二值运算，在布尔运算中，运算数只有0或1，基本运算有<strong>与 ·</strong>、**或 +<strong>、</strong>非 ~**三种，可以通过这三种基本运算构造出异或、与非等等运算</p>
<p>布尔运算遵循的定理如下：</p>
<span id="more"></span>

<ul>
<li>零元：x·0=0，x+1=1</li>
<li>单位元：x·1=x，x+0=x</li>
<li>幂等律：x·x=x，x+x=x</li>
<li>补余律：x·(~x)=0，x+(~x)=1</li>
<li>互反律：~(~x)=x</li>
<li>常见的交换律、结合律、分配律</li>
<li>吸收律：x+(x·y)=x，x·(x+y)=x</li>
<li>德摩根定律：~(x+y)=(~x)·(~y)，~(x·y)=(~x)+(~y)</li>
</ul>
<p>布尔代数中的函数用<strong>逻辑表达式</strong>来描述，描述同一逻辑函数的逻辑表达式可能有多个。逻辑表达式中，逻辑变量以原变量或反变量的形式出现，原变量和反变量统称<strong>字面量</strong>，字面量的逻辑与称为<strong>与项</strong>，与项的逻辑或运算叫做<strong>积之和</strong>，包含所有字面量的与项称为最小项，由最小项构成的积之和称为标准积之和（<strong>标准积</strong>），类似的存在或项（字面量的逻辑或）、和之积、最大项、标准和的概念</p>
<p>逻辑函数还能通过<strong>真值表</strong>描述，针对逻辑函数所有可能的输入组合一一列出输出值就可以得到真值表。==一个逻辑函数的真值表唯一==，实现真值表定义的功能的电路称为<strong>查找表</strong>（LUT，Look-up Table），这就是FPGA的基本单元</p>
<p>写FPGA逻辑就是写其中的查找表逻辑</p>
<h2 id="数字电路"><a href="#数字电路" class="headerlink" title="数字电路"></a>数字电路</h2><p>数字电路也可以叫做逻辑电路</p>
<p>本质是用电路描述数字布尔逻辑。</p>
<p><strong>所有逻辑电路都能用积之和表达式来描述</strong></p>
<h3 id="组合逻辑电路"><a href="#组合逻辑电路" class="headerlink" title="组合逻辑电路"></a>组合逻辑电路</h3><p>不包含记忆元件，某时刻输出（逻辑函数值）仅取决于该时刻输入的数字电路就是组合逻辑电路</p>
<p>使用与-或-非三种门电路组合成的组合逻辑电路可以实现任何逻辑函数。这种方式被称为与-或逻辑电路或者是<strong>与-或阵列</strong></p>
<p>PLA（可编程逻辑阵列Programmable Logic Array）就是使用与-或阵列</p>
<h3 id="时序逻辑电路"><a href="#时序逻辑电路" class="headerlink" title="时序逻辑电路"></a>时序逻辑电路</h3><p>含有记忆元件，某时刻输出取决于该时刻输入及系统过去的电路状态的逻辑电路就是时序逻辑电路</p>
<p>时序逻辑电路分为同步和异步两种</p>
<p>同步时序电路的输入状态和内部状态的变化由时钟信号控制同步进行，但异步时序电路不需要时钟信号</p>
<p>异步时序电路设计需要考虑临界资源、亚稳态等诸多因素，FPGA很少涉及异步时序电路。一般地，FPGA使用有限状态机模型来实现同步时序电路，同步状态机将会在之后的硬件算法部分介绍</p>
<p>同步状态机分为Moore和Mealy两类，Mealy模型的状态数一般比Moore模型的少，电路规模一般也更小，但输入会立刻反映到输出，容易造成信号竞争导致非预期的错误输出，这种情况称为竞争<strong>冒险</strong>。Moore电路速度快且不易发生冒险，但是电路规模较大</p>
<h2 id="同步电路设计"><a href="#同步电路设计" class="headerlink" title="同步电路设计"></a>同步电路设计</h2><p>同步电路让系统状态的变化和时钟信号同步，从而降低电路设计难度</p>
<p><strong>同步电路设计是FPGA设计的基础</strong></p>
<p>触发器（Flip Flop，FF）是一种只能存储一个二进制位的存储单元，一般用作时序电路的记忆元件。FPGA内一般使用D触发器（D-FF）在时钟跳变沿将输入信号的变化传送至输出</p>
<p>它的真值表如下所示</p>
<table>
<thead>
<tr>
<th>输入 D</th>
<th>时钟 CLK</th>
<th>输出 Q</th>
<th>反相输出 Q</th>
</tr>
</thead>
<tbody><tr>
<td>x</td>
<td>0</td>
<td>保持之前状态</td>
<td>保持之前状态</td>
</tr>
<tr>
<td>0</td>
<td>上升沿</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>上升沿</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>x</td>
<td>1</td>
<td>保持之前状态</td>
<td>保持之前状态</td>
</tr>
<tr>
<td>x</td>
<td>下降沿</td>
<td>保持之前状态</td>
<td>保持之前状态</td>
</tr>
<tr>
<td>无论输入如何</td>
<td>当且仅当上升沿时</td>
<td>Q&lt;=D</td>
<td>Q&lt;=(~D)</td>
</tr>
<tr>
<td></td>
<td>任何其他情况</td>
<td>保持之前状态</td>
<td>保持之前状态</td>
</tr>
</tbody></table>
<h3 id="D触发器的局限性"><a href="#D触发器的局限性" class="headerlink" title="D触发器的局限性"></a>D触发器的局限性</h3><p>CMOS工艺下，D-FF由传输门1、主锁存器、传输门2、从锁存器串联组成</p>
<p>传输们起开关作用，会随CLK的状态变化切换开关，外部信号先被锁存在主锁存器，一个时钟周期后，信号会被再次锁存在从锁存器。这里传输门1和传输门2的时钟相位相反。</p>
<p>然而由于寄生电容、寄生电阻的存在，在时钟信号变化过快时，如果读取到还没有稳定下来而是在0和1之间摇摆的中间电位就会导致读取错误，这被称为<strong>亚稳态</strong>。所以一般会通过<strong>建立时间</strong>（Setup Time）来约束在时钟上升沿到来前输入D保持稳定的时间</p>
<p>对于下降沿的情况下，若输入在传输门变为高阻态之前就发生变化也会出现反相器环路震荡的隐患，所以使用<strong>保持时间</strong>（Hold Time）约束</p>
<p>由于这两个约束的存在，时钟频率需要受到限制，FPGA设计中使用静态时序分析STA来评估性能，静态时序分析主要评估FPGA上设计电路的延迟是否满足时序约束。此外还需要使用DRC约束和DC约束来保证电路的结构无误</p>
<p>STA验证具有验证速度高的特点，但对电路结构有要求：</p>
<ul>
<li>延迟分析的起点和终点必须是基于同一时钟的FF，从而能够通过累加延迟来计算、验证每条路径的总延迟</li>
</ul>
<p>所以FPGA一般来说都会使用单相同步时钟来设计</p>
<p>由于时钟信号驱动的负载（扇出数）、布线延迟等导致的时间差称为<strong>时钟偏移</strong>（skew）</p>
<p>由于时钟振荡器或PLL器件的输出变形或信号变形导致时钟边沿偏离平均位置的情况称为<strong>时钟抖动</strong>（jitter）</p>
<p>在实际ASIC设计中，需要控制时钟偏移和抖动在一定范围之内；FPGA上已经提前实现好了多层时钟树结构，并通过驱动能力强的专用布线（global buffer）将时钟低偏移地连接到全芯片的FF上，所以在时钟设计上比ASIC简便很多</p>
<h2 id="CPLD"><a href="#CPLD" class="headerlink" title="CPLD"></a>CPLD</h2><p>所有可编程逻辑器件统称PLD，而其中有CPLD（Complex PLD）一个特殊的分支，与FPGA相反，它基于ROM技术制造，基本结构是乘积项。由与阵列和或阵列组成的与-或构造就称为乘积项形式，这一结构的特点就是成本低廉、掉电后不会丢失逻辑</p>
<h1 id="FPGA简介"><a href="#FPGA简介" class="headerlink" title="FPGA简介"></a>FPGA简介</h1><p>FPGA是PLD的一种。实际上它并不是单纯由”门“形成的结构。</p>
<h2 id="FPGA结构简介"><a href="#FPGA结构简介" class="headerlink" title="FPGA结构简介"></a>FPGA结构简介</h2><p>FPGA大致由三部分构成：</p>
<ul>
<li>实现逻辑电路的逻辑要素：<strong>逻辑块</strong></li>
</ul>
<p>一般由查找表LUT、乘积项PT、数据选择器MUX等组成，不管什么方式，都应该是由实现FF等器件的数据存储电路和数据选择器MUX组成的</p>
<ul>
<li>和外部进行信号输入/输出的要素：<strong>I/O块</strong></li>
</ul>
<p>连接IO引脚和内部布线要素的模块，其中通常包括控制上拉下拉、输入输出、极性、速率、开漏等模式的控制电路和触发器等数据存储电路。一般会支持TTL、PCI、PCIE、SSTL等等单端标准IO和LVDS等差分标准IO</p>
<ul>
<li>连接前两种元素的布线要素：包括<strong>布线通道、开关块SB、连接块CB</strong></li>
</ul>
<p>可以通过布线资源形成任意的布线通路，其中主要通过开关的编程配置决定选择哪个布线通道</p>
<p>实际电路中还可能加入硬核处理器、DSP模块、块存储器等等其他具有固定功能的硬核电路</p>
<p><strong>硬核</strong>：具有固定结构、无法使用硬件描述语言编程的电路</p>
<p><strong>软核</strong>：具有一定结构，可以使用硬件描述语言编程的电路</p>
<p>这三个部分一般呈==岛型==排布，每个“岛“占据一个格子，格子之间是布线要素</p>
<h2 id="FPGA可编程技术"><a href="#FPGA可编程技术" class="headerlink" title="FPGA可编程技术"></a>FPGA可编程技术</h2><p>FPGA通过闪存、反熔丝和静态存储器作为可编程的基础，目前市面上的FPGA多使用SRAM技术（静态存储器）制造，这三种技术各有特点</p>
<h3 id="闪存"><a href="#闪存" class="headerlink" title="闪存"></a>闪存</h3><p>闪存（FLASH）是EEPROM的一种，属于非易失存储器，采用MOSFET（Metal-Oxide-Semiconductor Field Effect Transistor金属-氧化物-半导体场效应管）技术制造</p>
<blockquote>
<p>MOSFET是一种以<strong>金属栅极</strong>隔着<strong>氧化层</strong>利用电场效应来控制<strong>半导体</strong>的场效应晶体管。而与之相对的还有JFET，即结型场效应管，在N型半导体（这里以N沟道为例）两端加入P型半导体，并在其中P型半导体较少的一端引出源极和漏极，另一边的P型半导体引出栅极，用栅极电压产生的静电效应来控制漏极电流。MOSFET则是以P型半导体为基底，两个小块N型半导体嵌入，通过引脚引出作为源极和漏极，在基底上有一个二氧化硅薄片，上面固定了金属铝制造的栅极，当栅极加适当电压时，在两个N型半导体之间会出现导电沟道，即源-漏极电流出现（这里以增强型NMOSFET为例，PMOS的导通电流方向相反，耗尽型为不加栅极电压时才会导通）</p>
<p>无论P类型还是N类型的MOSFET都分为增强型和耗尽型两种，增强型的特点是“常开”，耗尽型的特点是“常闭”，这里的增强和耗尽指的是栅极电压控制漏极电流的“增强”或“耗尽”</p>
</blockquote>
<p>闪存根据写入方式不同可以分成两种：NAND型和NOR型，NAND型在写入时需要高电压，而NOR型在写入时需要大电流</p>
<p>NAND FLASH的MOSFET表现为耗尽型，源极、漏极之间存在一个栅极G，这里就和普通的DRAM构造相同（MOSFET结构），但是在栅极下方的二氧化硅中埋藏了一个多晶硅构成的浮栅。初始状态下浮栅不带电，根据耗尽型MOSFET的特点，栅极零偏压时电流可以通过；但当将栅极加高电压后，浮栅会由于电场效应（实际是产生了隧道电流）带电（负电），此时在低电压范围内，无论栅极加不加电压，导电沟道都关闭，电流无法通过，也就是说浮栅上存有电荷时表现为无电流通过；而只有再次在源极S上加高电压时，电流才能通过。由于浮栅中的电荷没有逃脱路径，因此可以半永久保存数据；当在源极加高电压时，可以将浮栅中的电子以隧道电流的形式引出。对于NOR FLASH的情况，通过在源极和漏极之间通大电流后，一部分电子作为热电子注入浮栅来完成写入</p>
<p>NAND FLASH的结构特点导致了它能够以位（比特）为单位写入（控制单个栅极电压），但只能以块为单位擦除（源极并联在一起，难以单个控制）</p>
<h3 id="基于闪存的可编程开关"><a href="#基于闪存的可编程开关" class="headerlink" title="基于闪存的可编程开关"></a>基于闪存的可编程开关</h3><p>FPGA内的可编程开关由两个晶体管组成，一个负责编程信号的写入/擦除，另一个用于控制用户电路的开关，两个晶体管共用控制栅极G和浮栅，从编程用开关管注入电子就可以直接决定用户所使用开关的状态</p>
<p>使用步骤如下：</p>
<ol>
<li>在编程晶体管S-D之间加5V</li>
<li>在G加-11V电压，电子自动流入G（G-D电压为-16V），开关开启</li>
<li>正常工作时，栅极保持2.5V，浮栅电位会大致维持在4.5V</li>
<li>擦除时，编程晶体管S、D接地，G极加16V电压后浮栅电位会降到0V以下，开关关闭</li>
</ol>
<p>可编程开关的以上特性决定了它存在一些缺点：</p>
<ul>
<li>无法使用CMOS工艺（最大硬伤，不过这也导致其成本较低）</li>
<li>重写次数有限制</li>
<li>接通电阻和负载电容较大</li>
</ul>
<p>它的优点如下：</p>
<ul>
<li>非易失、可重编程</li>
<li>对软性错误容错强、上电后立即工作（Live At Power-Up，LAPU）</li>
<li>尺寸较小（至少比SRAM工艺小，但是对于先进的FinFET优势就不大了）</li>
</ul>
<p>目前的CPLD很多都是基于该工艺制造</p>
<h3 id="反熔丝"><a href="#反熔丝" class="headerlink" title="反熔丝"></a>反熔丝</h3><p>熔丝是在电流过大时对电路进行保护或防止事故的元件，当有大电流流过时会自行发热并熔断。反熔丝的特性和熔丝正好相反：初始状态为开路，当通电后会发生熔合</p>
<p>一种反熔丝使用多晶硅和n^+^扩散层作为导体，在他们中甲插入ONO氧化物-氮化物-氧化物的电介质作为绝缘体的构造，ONO电介质厚度在10nm以下，通常在10V-5mA情况下可以形成上下连接的通路。其直径大约和接触孔（为了连接硅基底上的门电路和金属层或上下两层金属层而设置的通孔）相当，其导通电阻大概在300~500Ω</p>
<p>还有Metal-to-Metal设计的反熔丝，用于连接布线层，在上下两层金属布线层间插入绝缘的非晶硅和钨插塞等导体，在为编程时处于高阻抗状态，而在编程处理后可以变为几乎和金属层连线同等程度的低阻抗状态，导通电阻大约50~80Ω。在编程中需要约15mA电流</p>
<p>因为Metal-to-Metal反熔丝面积较小、导通电阻低，构造上不可能将配置信息直接读取出来，难以实行逆向工程，安全性很高，所以成为现代反熔丝技术的主流</p>
<p>反熔丝优点如下：</p>
<ul>
<li>尺寸小、密度高、非易失</li>
<li>接通电阻和负载电容小</li>
<li>安全性高、对软性错误容错性强</li>
</ul>
<p>缺点：</p>
<ul>
<li>无法重写</li>
<li>每根线都需要额外的晶体管用于编程</li>
<li>需要使用专用编程器且编程时间长</li>
<li>难以debug、出错率较高</li>
</ul>
<h3 id="静态存储器"><a href="#静态存储器" class="headerlink" title="静态存储器"></a>静态存储器</h3><p>静态存储器由两个CMOS反相器构成的触发器和两个传输晶体管（Pass-Transistor，PT）组成。他利用触发器的双稳态0和1记录数据，通过NMOS型的PT执行写入</p>
<p>静态存储器通常使用地址信号来驱动字线（读取地址信号所控字线上的多位数据），数据的读取也通过PT进行。由于FPGA需要一直读取数据，所以在FPGA中数据直接从触发器读取而不通过PT。</p>
<p>基于静态存储器的FPGA大多使用LUT，并使用MUX等来切换布线连接，真值表本身由多位静态存储器构成，这种FPGA一般称为SRAM型FPGA。说人话就是使用SRAM技术存储真值表来实现编程信息的存储</p>
<p>优点如下：</p>
<ul>
<li>能够使用先进的CMOS工艺</li>
<li>可重配置</li>
<li>重写次数没有限制（一片spartan传祖孙三辈人没问题）</li>
</ul>
<p>缺点：</p>
<ul>
<li>存储器尺寸大（可以通过FinFET工艺缓解）</li>
<li>易失性存储器</li>
<li>难以保证电路信息安全</li>
<li>对软性错误敏感</li>
<li>导通电阻、负载电容较大</li>
</ul>
<p>目前SRAM型FPGA占据市场主流，因为CMOS和FinFET就是无敌的存在，制程碾压一切</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>反熔丝待机耗电低、连接开关的接通电阻小、速度快，并且保密性高、无法进行重写，比较适用于军工等不要求最先进工艺但对可靠性要求高的场合</p>
<p>静态存储器工艺制程先进、性能强大，但存在易失性且安全性不高、待机功耗大（这一点正在逐渐改善）、耐放射线能力弱，但是很适合民用与实验，符合FPGA的定位，所以成为市场的主流</p>
<p>闪存工艺是静态存储器和反熔丝之间的平衡点，成本低廉且可以重写、可靠性较高，但是性能较劣势，说的难听点就是鸡肋，所以市场上基于闪存的FPGA已经越来越少</p>
<h2 id="FPGA的逻辑实现"><a href="#FPGA的逻辑实现" class="headerlink" title="FPGA的逻辑实现"></a>FPGA的逻辑实现</h2><p>基于LUT的FPGA逻辑块可以实现任何<strong>输入数在查找表电路输入数量之内</strong>的逻辑函数；基于乘积项方式实现的CPLD则需要先将表达式转换为标准积之和的形式</p>
<p>一个小型的电路至少需要通过IO PAD（输入信号）、FPGA内部布线、可编程逻辑块、FPGA内部布线、输出缓冲器、IO PAD（输出信号）这几个硬件资源才能实现</p>
<p>可编程逻辑块内的主要资源就是LUT，<strong>LUT是1个字只有1位的内存表</strong>，字数取决于地址的位数，FPGA中的查找表存储单元大多使用SRAM实现。一般k输入的LUT由2^k^个SRAM单元和一个2^k^输入的数据选择器组成，<strong>查找表的输入就是内存表的地址信号，输出就是该地址所选字的1位数据</strong>。k输入的查找表可以实现$2^{2^k}$种逻辑函数。</p>
<p>使用查找表时，先根据查找表的输入值对真值表进行转换，然后将函数值直接写入配置内存，当所要实现的逻辑函数的输入数比查找表的输入数多时，可以并联使用多个查找表来实现</p>
<h3 id="查找表的实现"><a href="#查找表的实现" class="headerlink" title="查找表的实现"></a>查找表的实现</h3><p>早期FPGA使用过5晶体管结构（两个晶体管构成一个非门，两个非门和一个额外的晶体管构成一个SRAM单元）存储单元，因为LUT中的SRAM总是在输出数据，所以查找表只需要以5晶体管存储单元为基础配合选择信号就可以实现了；在此之后Xilinx的Freeman改良了LUT的配置存储器，让其可以作为FPGA上的分散存储器使用，此时SRAM具有了独立的写入端口，该结构可以复用为存储器和查找表，使用两个输入信号作为控制——需要注意：存储器的读取端口和查找表的输出是通用的</p>
<p>随后，查找表又被改良可以作为移位寄存器使用；当前的查找表已经能够支持簇结构（cluster）和自适应（可以将一个8输入查找表分割为2个7输入查找表或1个7输入查找表和2个6输入查找表等小型查找表簇的方式使用，更加灵活）</p>
<h1 id="FPGA的结构"><a href="#FPGA的结构" class="headerlink" title="FPGA的结构"></a>FPGA的结构</h1><p>岛型FPGA由逻辑块、IO块、布线要素等组成，<strong>相邻的逻辑块、开关块、连接块组成了一个可重复逻辑模块</strong>，模块呈阵列型排列最终形成岛型FPGA</p>
<p>FPGA中具有专门用途的电路称为“硬核”，可编程的部分称为“软核”。Xilinx将逻辑块称为CLB（Configurable Logic Block可编辑逻辑块），Altera则将其称为LAB（Logic Array Block逻辑阵列块），但他们的基本原理一样</p>
<p>除了主要部件之外，现代FPGA通常还包括很多其他部件</p>
<h2 id="逻辑块结构"><a href="#逻辑块结构" class="headerlink" title="逻辑块结构"></a>逻辑块结构</h2><p>对于逻辑块架构，最重要的设计问题就是权衡逻辑块的功能和自身面积</p>
<blockquote>
<p>集成电路领域著名的AT^2^定律指的是对于某个给定的半导体工艺流程，如果其相关的某数字设计的面积是A，而执行时间是T，则存在一个下限边界B，使得AT^2^=B，也就是说面积和效率不可兼得</p>
</blockquote>
<p>这一点同样适用于FPGA</p>
<p>其中对逻辑块功能影响最大的是查找表的大小，因为k输入查找表可以实现任意k输入的函数，采用较大的查找表有助于减少逻辑块的使用数量，但k-LUT需要使用2^k^个配置存储单元，因此逻辑块自身的面积会增大，而且增加的输入/输出引脚数量会导致布线面积增大。</p>
<p>此外，FPGA运行速度还受到以下影响：如果增加每个逻辑块的功能，所实现电路的逻辑深度就更小；但同时也会增加逻辑块自身的内部延迟</p>
<p>逻辑深度指通过关键路径的逻辑块数量，它由FPGA设计环节中的技术映射过程决定（参考后面FPGA设计与ASIC设计的区别与原理部分），降低逻辑深度可以减少布线、提高电路速度，同时也会增加内部延迟，导致降低逻辑深度的效果大打折扣</p>
<p>综上所述，查找表的输入大小和FPGA的面积、延迟有密切关系</p>
<p><strong>现代的商用FPGA都倾向于采用6-LUT</strong></p>
<h3 id="专用进位逻辑"><a href="#专用进位逻辑" class="headerlink" title="专用进位逻辑"></a>专用进位逻辑</h3><p>为了提高算术运算电路的性能，现代FPGA逻辑块中还含有专用的进位电路，可以使用这些专用进位逻辑来获得更高集成度和运行速度</p>
<p>Xilinx没有设计专用的全加器电路，而是使用查找表和进位生成电路的组合来实现加法。全加器的加法运算用两个2输入EXOR实现，进位输出电路由1个EXOR和1个MUX组成</p>
<p>可以通过这种单元的不断组合实现多位加法器甚至加法器矩阵</p>
<h3 id="逻辑簇"><a href="#逻辑簇" class="headerlink" title="逻辑簇"></a>逻辑簇</h3><p>逻辑簇是由多个BLE群组化形成的逻辑块结构，逻辑簇内部局部布线采用硬连线连接，比外部的通用布线速度更快；逻辑簇内部局部布线的负载电容比外部通用布线小很多，因此对FPGA的耗电（特别是动态功耗）的削减有效果；逻辑簇内部BLE可以共享输入信号，有助于减少局部连接块的开关数量</p>
<p><strong>含有多BLE的逻辑块最大的优势就是在增加逻辑块功能性的同时又不会大幅影响FPGA的整体面积</strong></p>
<p>逻辑块面积随输入k的增大呈指数级增大；而增加逻辑簇中BLE的数量N会导致逻辑块的面积只按二次函数增长</p>
<p>计算逻辑块输入数量$I=\frac{k(N+1)}{2}$</p>
<p>根据上面的经验公式，逻辑块面积的增长得到了抑制</p>
<p>一般来说，面积延迟乘积性能最优的结构参数为：N=3~10,k=4~6</p>
<p>也就是说一个逻辑簇中设置3到10个输入、4到6个BLE比较好</p>
<h3 id="自适应查找表"><a href="#自适应查找表" class="headerlink" title="自适应查找表"></a>自适应查找表</h3><p>Xilinx在XC40000系列的逻辑块中推出了早期的不同输入数查找表结构</p>
<p>而现代的FPGA多支持将较多输入的查找表分解使用的机制，也就是<strong>自适应查找表</strong></p>
<h2 id="全局布线架构"><a href="#全局布线架构" class="headerlink" title="全局布线架构"></a>全局布线架构</h2><p>布线架构分为全局布线和详细布线，全局布线主要解决逻辑块的连接、布线通道的宽度等高层次问题；而详细布线则决定具体的连接方式</p>
<p>层次型FPGA使用UCB的HSRA布线构造，将FPGA内部布线分成多个层次，布线的交叉点上包含各层的开关，一般层次越高通道里连线的数量就越多。目前层次型FPGA已经不再适用</p>
<p>岛型FPGA就是一直在介绍的FPGA类型，下面的详细布线架构也将围绕岛型FPGA说明</p>
<h2 id="详细布线架构"><a href="#详细布线架构" class="headerlink" title="详细布线架构"></a>详细布线架构</h2><p>详细布线架构中需要确定逻辑块和布线通道之间的开关布置和布线的线段长度，以此来确定电路延迟</p>
<p>由连接块和开关块组成的布线要素对FPGA面积和电路延迟的影响很大，在决定详细布线架构时要注意：</p>
<ol>
<li>逻辑块和晶体管参数</li>
<li>布线线段长度的种类和比例</li>
<li>布线开关的晶体管参数</li>
</ol>
<p>还应该考虑传输晶体管和三态缓冲器使用上的平衡</p>
<p>现代FPGA为了更好的性能，通常使用较多单向连线和辅助的双向连线，并正在加大单向连线的比重；同时还提供了各种不同长度的连线，从短线到长距离布线，以此增强设备的时序表现</p>
<h2 id="开关块"><a href="#开关块" class="headerlink" title="开关块"></a>开关块</h2><p><strong>所有开关块均由可编程开关管构成，以下简称开关管，注意不要和晶体管意义上的开关管弄混</strong></p>
<h3 id="开关块的拓扑"><a href="#开关块的拓扑" class="headerlink" title="开关块的拓扑"></a>开关块的拓扑</h3><p>开关块位于横向和纵向布线通道的交叉处，通过可编程开关来控制布线路径，一般开关块的拓扑分为三种</p>
<p>对于一个开关块中的一个控制晶体管，负责三条交叉路经的通断，因此开关快都是从三个输入中选择一个输出，自由度F<del>s</del>=3</p>
<h4 id="不相交型"><a href="#不相交型" class="headerlink" title="不相交型"></a>不相交型</h4><p>Xilinx的特色拓扑，因此也被称为赛灵思型开关块</p>
<p>由6个开关管构成</p>
<p>将四个方向上序号相同的进行连接，相邻两个方向呈斜45度或15度连接</p>
<p>自由度较低</p>
<h4 id="通用型"><a href="#通用型" class="headerlink" title="通用型"></a>通用型</h4><p>同样由6个开关管构成，但两个成对的连线可以在开关块内互联</p>
<p>总体上可实现斜对角45度全连接</p>
<p>但是这种技术只能对应单倍线，无法应用在其他长度的布线上</p>
<h4 id="威尔顿型"><a href="#威尔顿型" class="headerlink" title="威尔顿型"></a>威尔顿型</h4><p>采用6*n个开关管连接序号不同的连线</p>
<p>自由度更高，可以实现顺时针、逆时针的闭环路径，可以提高FPGA的测试效率</p>
<h3 id="数据选择器结构"><a href="#数据选择器结构" class="headerlink" title="数据选择器结构"></a>数据选择器结构</h3><p>一般使用4输入的数据选择器延迟最优，8输入的数据选择器面积延迟乘积最优</p>
<h2 id="连接块与IO块"><a href="#连接块与IO块" class="headerlink" title="连接块与IO块"></a>连接块与IO块</h2><p>连接块也由可编程开关构成</p>
<p>连接块负责连接布线通道和逻辑块的输入/输出</p>
<p>由于需要考虑到连接块的面积，所以很少使用全交叉开关矩阵实现，而是使用节省掉一些开关的<strong>稀疏开关矩阵</strong></p>
<p>IO块则负责器件的IO引脚和逻辑块之间的接口部分</p>
<p>一般FPGA的IO除了固定用途的电源、时钟等专用引脚，还有用户可以配置的用户IO，用户IO具有输入/输出缓冲、输出驱动、信号方向控制、高阻抗控制等功能，和现代MCU的GPIO结构相似</p>
<p>一般具有以下特点：</p>
<ul>
<li>可配置的上拉、下拉电阻</li>
<li>输出使能信号可以控制输出缓冲器</li>
<li>输入/输出出啊其，可用于调整信号延迟</li>
<li>可编程的输出缓存器转换速率</li>
<li>可以调整使用TTL、CMOS、PCIE等多种输出电压标准或输入缓冲器阈值</li>
<li>专用延时电路，用于保证输入的保持时间</li>
<li>可适用于高速通信的差分信号LVDS</li>
<li>配置有钳位二极管</li>
</ul>
<p>总体而言连接块与IO块类似MCU中的总线桥和GPIO</p>
<h2 id="嵌入式硬核"><a href="#嵌入式硬核" class="headerlink" title="嵌入式硬核"></a>嵌入式硬核</h2><h3 id="DSP块"><a href="#DSP块" class="headerlink" title="DSP块"></a>DSP块</h3><p>现代FPGA被普遍用于数字信号处理DSP、人工智能加速AIA、硬件算法实现等场景，因此出现了搭载大量乘法器、浮点运算电路的FPGA</p>
<p>这些内嵌DSP块的结构大致如下：</p>
<p>输入</p>
<p>前置加法器</p>
<p>乘法器</p>
<p>累加运算单元</p>
<p>模式检测器与控制电路</p>
<p>输出</p>
<p>很多DSP块支持粒度调节和浮点运算支持</p>
<p>在FPGA厂商提供的IP生成工具中设置好相关IP就可以选择是否在DSP块上实现，同时使用FPGA厂商推荐的硬件描述语言使用方式，综合工具就可以自动识别并使用DSP块，也可以在代码中直接实例化并使用DSP块的模块，但这种方法缺乏可移植性</p>
<h3 id="硬宏"><a href="#硬宏" class="headerlink" title="硬宏"></a>硬宏</h3><p><strong>硬宏</strong>：商用FPGA中嵌入的专用硬件电路</p>
<p>硬件乘法器和DSP块都属于硬宏，但都比较常见，当前已经被视为商用FPGA的“标配”</p>
<p>除此之外，很多中高端产品都会搭载PCIE接口、USB接口、SPI接口、外部DRAM接口、专用DAC、ADC等硬宏</p>
<p>一般来说硬宏化的接口电路不多，需要考虑硬宏的位置再进行布局布线</p>
<h3 id="硬核处理器"><a href="#硬核处理器" class="headerlink" title="硬核处理器"></a>硬核处理器</h3><p>FPGA厂商已经越来越多地在高端品牌上搭载硬核处理器，也就是作为硬宏的嵌入式处理器</p>
<p>比较著名的就是Xilinx的Zynq系列，搭载ARM Cortex A系列处理器，可以运行Linux等通用OS或RT-Thread等大型RTOS，同时可以按照标准设计电路接口，让FPGA部分的用户电路与硬核处理器通过AMBA交换模块连接，以定制硬件的方式实现加速</p>
<h3 id="嵌入式存储器"><a href="#嵌入式存储器" class="headerlink" title="嵌入式存储器"></a>嵌入式存储器</h3><p>部分商用FPGA为了解决存储器总线带宽问题，直接将存储器嵌入到FPGA内部</p>
<p>这样的嵌入式存储器分为两种类型</p>
<ol>
<li><p>存储器块硬宏</p>
<p> 以硬宏的形式在架构中嵌入存储器块，在Xilinx的架构中，这种存储器被称为块存储器（Block RAM，BRAM），支持一分多、多合一</p>
<p> BRAM既可以作为单端口存储器也可以作为双端口存储器使用，可以方便的使用它作为FIFO存储器</p>
<p> 需要注意：BRAM不支持异步访问，想要同步两个时钟域还是应该使用传统的异步时钟FIFO</p>
</li>
<li><p>查找表存储器</p>
<p> 也可以使用逻辑块内部的查找表实现存储器</p>
<p> Xilinx的架构中，这种由查找表构成的存储器称为分布式RAM（distributed RAM），但只有被称为SLICEM的逻辑块中的查找表才能够作为分布式RAM使用。此外，为了不挤占查找表的存储资源，一般在需要小规模存储器时再使用这种方法</p>
</li>
</ol>
<p>嵌入式存储器一般和DSP块一样，只要按照FPGA厂商的说明编写HDL程序，综合后就能够调用</p>
<p>它的优点在于大，能有效节省外部总线资源和时序损耗</p>
<h3 id="配置链"><a href="#配置链" class="headerlink" title="配置链"></a>配置链</h3><p>把电路编程到FPGA上的过程叫做配置，向FPGA写入的电路信息叫做配置数据。配置数据包含在FPGA上实现电路的所有信息，包括但不仅限于查找表中的真值表数据和开关块中各个开关的状态等</p>
<p>一般地，FPGA可以分为三种类型</p>
<ul>
<li>SRAM型：掉电信息即丢失，所以一般在上电时使用内部或外部的自动配置器件将配置信息写入</li>
<li>闪存型：非易失，一般闪存写入次数的限制都比较大，虽然没有SRAM那样的永久寿命，但用十几年也没有问题，只是写入速度较慢</li>
<li>反熔丝型：写入一次后就不能再修改</li>
</ul>
<p>一般在调试过程中使用JTAG接口，可以实时观测FPGA内部信号的变化：先将观测信号的变化写入嵌入式存储器，再通过JTAG读取到上位机，这样就能直观地看到信号波形，称为<strong>虚拟逻辑分析仪</strong></p>
<p>这样对于配置流程就能有更好的把控</p>
<h3 id="PLL与MMCM"><a href="#PLL与MMCM" class="headerlink" title="PLL与MMCM"></a>PLL与MMCM</h3><p>过去的FPGA一般使用外部晶振，在内部的时钟信号频率受到限制</p>
<p>现代FPGA大多配置有PLL电路，可以将外部输入的基准时钟进行进一步处理</p>
<p>PLL即Phase Locked Loop锁相环，外部基准时钟输入<strong>鉴相器</strong>，鉴相器就是一个精密的时钟相位比较器，将PLL内部<strong>压控振荡器</strong>（Votage-Controlled Oscillator，VCO，可以根据所加的电压调整输出频率）生成的时钟与外部输入的基准时钟进行比较，如果两个时钟一致则维持VCO电压，否则调整控制电路对VCO电压进行调整（VCO主频过高则降低电压；反之升高电压），经过鉴相器得到的电压还存在一定的高频谐波，通过一个低通滤波器后输入VCO即可实现效果。整个电路呈现为</p>
<p>基准时钟输入-鉴相器-低通滤波器-VCO-反馈输入-标准输出</p>
<p>的状态。整个电路使用模拟电路实现，高频谐波由于反馈电路和后级电路耦合而产生</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">A[输入]--&gt;B(鉴相器)</span><br><span class="line">C[反馈]--&gt;B</span><br><span class="line">B--&gt;D[低通滤波器]</span><br><span class="line">D--&gt;E[VCO]</span><br><span class="line">E--&gt;C</span><br><span class="line">E--&gt;F[输出]</span><br></pre></td></tr></table></figure>

<p>除了基本结构之外，PLL通常还会在输入输出阶段添加额外的分频器用于削减输出频率；同时在反馈阶段加入分频器用于增加输出频率</p>
<p>流程框图如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">INPUT(输入)--&gt;A[基准时钟预分频器N]</span><br><span class="line">A--&gt;B(鉴相器)</span><br><span class="line">C[反馈时钟分频器M]--&gt;B</span><br><span class="line">D--&gt;E[VCO]</span><br><span class="line">E--&gt;C</span><br><span class="line">B--&gt;D[低通滤波器]</span><br><span class="line">E--&gt;F[输出时钟分频器1]</span><br><span class="line">F--&gt;OUTPUTA(输出时钟1)</span><br><span class="line">E--&gt;G[输出时钟分频器2]</span><br><span class="line">G--&gt;OUTPUTB(输出时钟2)</span><br><span class="line">E--&gt;H[输出时钟分频器i]</span><br><span class="line">H--&gt;OUTPUTC(输出时钟i)</span><br></pre></td></tr></table></figure>

<p>可以得到输出频率控制公式<br>$$<br>F_{vco}=\frac{M}{N \cdot K_i} F_{ref}<br>$$<br>式中M为反馈时钟分频器分频系数，N为基准时钟预分频器分频系数，K<del>i</del>为输出时钟分频器分频系数，最后对应输出时钟F<del>i</del></p>
<p>虽然可以通过有限个预分频器调节时钟，但事实上各个分频器的分频比是有限制的，设定值不能超出规定</p>
<p><strong>PLL实质上是一个以外部输入基准信号为目标，使用VCO为控制对象的线性反馈控制系统</strong>，在启动、复位或基准时钟大幅度变动时，无法做到立即响应，所以在PLL的输出时钟稳定前，由该时钟同步的用户电路可能会发生无法预测的动作。为了避免这种情况，常常使用PLL锁定机制，PLL通常会设置1位输出信号来表示PLL是否为锁定状态，外部电路可以利用该寄存器位来判断是否能使用时钟</p>
<p>使用数字方式也可以实现PLL类似的功能，称为DLL，具有响应速度快的优势。但是因为PLL的自由度更高、稳定性更好、成本更低，所以大多使用PLL或其升级版本MMCM</p>
<h1 id="FPGA设计流程与原理"><a href="#FPGA设计流程与原理" class="headerlink" title="FPGA设计流程与原理"></a>FPGA设计流程与原理</h1><h2 id="基于HDL"><a href="#基于HDL" class="headerlink" title="基于HDL"></a>基于HDL</h2><ol>
<li><p>使用FPGA厂商提供IDE创建工程</p>
</li>
<li><p>约束设定</p>
<p> 设置物理约束、引脚约束</p>
</li>
<li><p>创建源文件</p>
<p> 依次编写RTL级描述，可以按照自顶向下/自底向上设计方法，先编写顶层文件（系统级）或底层模块；通过模块例化进行层次连接</p>
</li>
<li><p>创建仿真源文件</p>
<p> 可以使用SystemVerilog等语言创建仿真用的源文件testbench</p>
</li>
<li><p>逻辑综合和技术映射</p>
<p> 对于Xilinx系FPGA来说需要先进行RTL文件的<strong>逻辑综合</strong>，如果使用了Verilog HDL则会先生成门级Verilog文件，随后生成网表文件，这些网表文件描述了逻辑门、触发器等逻辑元素的集合以及它们的连接关系。综合后在进行<strong>技术映射</strong>，将逻辑映射到FPGA实际的逻辑元素。</p>
<p> 一般在执行这两步时，厂商IDE会提供DRC、网表、逻辑分析报告，可以借此初步判断bug</p>
</li>
<li><p>RTL仿真</p>
<p> 使用testbench对电路进行仿真，这一步可以使用厂商提供的仿真软件或仿真器，也可以使用集成电路设计中常用的modelsim等仿真软件。通过对输入输出波形的仿真判断电路是否存在问题</p>
</li>
<li><p>布局布线</p>
<p> 利用片上逻辑和布线等资源实现网表。先进行逻辑元素再进行网络布线。布局过程中可以对信号拥挤度和传输延迟进行初步预测，不过并不一定准确，目前业界多使用STA静态时序分析进行仿真。需要特别注意的是，布局布线需要耗费很长时间，规模越大、逻辑资源使用率越高的电路耗时越长，且布线失败的可能性越大。当前的IDE中虽然有自动布局布线功能，但是也可能发生问题，这就需要换用硬件或重新设计架构、算法等</p>
</li>
<li><p>配置FPGA</p>
<p> 可以通过以下方法将编程数据烧录到FPGA：</p>
<ul>
<li><p>JTAG烧录比特流文件</p>
<p>  JTAG是面向器件编程和板卡调试的一种通用标准，FPGA厂商都提供了对应FPGA的JTAG烧录器/调试器</p>
<p>  但是JTAG烧录后如果FPGA断电或重置，配置信息就会丢失</p>
<p>  一般使用bit格式</p>
</li>
<li><p>自动从片外ROM中读取文件</p>
<p>  在上电或重置时可以让特殊配置过的FPGA从片外ROM中读取配置数据或使用其他控制器将片外文件数据加载到FPGA上</p>
<p>  一般使用mcs或pof格式</p>
</li>
<li><p>通过储存卡等写入</p>
</li>
<li><p>使用专用IC或总线协议配置FPGA</p>
</li>
</ul>
<p> 特别地，一些FPGA配备了处理器硬核，可以使用SD卡或专用总线，可以用这种方式自动加载FPGA</p>
</li>
<li><p>实机功能验证</p>
</li>
<li><p>优化</p>
<p>在实现功能后，可以考虑更改设计来让器件达到更高的工作频率或获得更高的效率</p>
</li>
</ol>
<h2 id="基于HLS"><a href="#基于HLS" class="headerlink" title="基于HLS"></a>基于HLS</h2><p>使用FPGA厂商专用的HLS工具可以将高级语言代码转换为HDL代码，进而实现方便的电路设计</p>
<p>详细内容可以查看其它关于HLS的介绍</p>
<h2 id="基于已有IP"><a href="#基于已有IP" class="headerlink" title="基于已有IP"></a>基于已有IP</h2><p>往往可以从厂商或开源社区获取到某些器件的RTL代码并加以修改融入当前设计</p>
<p>使用这种开发方式可以</p>
<ul>
<li>使用开源的处理器RTL代码实现软核处理器</li>
<li>构建SoC</li>
<li>整合软硬件开发</li>
</ul>
<h2 id="FPGA设计与ASIC设计的区别与原理"><a href="#FPGA设计与ASIC设计的区别与原理" class="headerlink" title="FPGA设计与ASIC设计的区别与原理"></a>FPGA设计与ASIC设计的区别与原理</h2><p>FPGA设计自由度较低，无法实现对硬件的定制，且无法在器件内集成模拟集成电路元件，但成本较低；而ASIC可以有更高的自由度，但成本高昂；FPGA也常常被用于ASIC设计中的原型验证</p>
<p>除此之外，FPGA与ASIC设计的不同点还体现在如下方面</p>
<h3 id="工艺映射"><a href="#工艺映射" class="headerlink" title="工艺映射"></a>工艺映射</h3><p><strong>工艺映射</strong>：将不依赖于任何工艺的门级网表转换为由特定FPGA逻辑单元所表示的网表的过程</p>
<p>人话：把网表翻译成用FPGA内部逻辑单元组成的电路</p>
<p>ASIC设计中并不需要这一步，而是直接将综合后的RTL文件映射为器件，之后就是版图设计师的任务了</p>
<p>工艺映射的步骤有两个：</p>
<h4 id="分解"><a href="#分解" class="headerlink" title="分解"></a>分解</h4><p><strong>门级网络实际上是用布尔网络</strong>（基于<em>有向图DAG</em>的门级网表的表现方式，各个节点表示逻辑门或逻辑门的组合逻辑，有向边则表示输入/输出信号）<strong>的形式来表示的，在这一步里要将布尔网络的各个节点分解直到输入数小于查找表的输入数k</strong></p>
<h4 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h4><p>使用某种基准对分解得到的布尔网络进行切分，使用k-LUT覆盖多个节点</p>
<p>实际上这个过程是一种可以在多项式时间内找到逻辑层数最优解的方法^[1]^</p>
<p>一种执行覆盖的方法<strong>FlowMap</strong>如下：</p>
<ol>
<li>获取分解得到的最小电路</li>
<li>获取输出信号对应的最后一个器件，该器件被抽象为有2个输入、1个输出的节点</li>
<li>将所有输入节点标号为0</li>
<li>从输出节点开始，以遍历树的方式寻找对应的上一层节点，将其输入切分出来</li>
<li>在上一层中标注标签最大的数字，再加上当前节点的层数（以最后一层的遍历为例，上一层标签为0+1=1）</li>
<li>顺序计算已经标注节点的相邻节点，如果遇到还未标注的节点，先对其进行计算标注</li>
<li>在当前层（切分点以下）所有相关标签都计算完毕后，再计算第二层节点的标签</li>
<li>反复计算所有结点的标签</li>
<li>每一层的逻辑都可以让单个查找表实现</li>
<li>执行逻辑打包</li>
</ol>
<p>术语介绍：</p>
<ul>
<li><p>节点（node）：使用布尔网络表示DAG时基于2输入逻辑门模型表示的基本构成要素——电路网络中的逻辑门全部用2输入1输出的节点来建模表示</p>
</li>
<li><p>标签：标签的数值用于表示网络的深度，即从各个节点到主输入按照最小深度映射时的逻辑层数</p>
</li>
<li><p>切分集：按照k输入进行工艺映射时可能实现的切分集合</p>
<p>  切分：将节点划分为总输入在k之内、可以使用查找表实现的节点集合</p>
</li>
</ul>
<h3 id="逻辑打包"><a href="#逻辑打包" class="headerlink" title="逻辑打包"></a>逻辑打包</h3><p><strong>逻辑打包</strong>：将多个查找表和触发器集合到同一个逻辑块的过程</p>
<p>目前主流的FPGA逻辑块都有多个查找表，所以需要高效地将查找表打包到逻辑块</p>
<p>逻辑打包的要点如下：</p>
<ol>
<li>逻辑块内部布线（局部布线）和逻辑块外部布线（布线通道）的延迟相差较大，所以需要平衡并缩短延迟</li>
<li>如果逻辑块中有查找表空闲，资源使用率就会降低，所以需要增加逻辑块使用量</li>
</ol>
<p>一种早期的执行逻辑打包的方法^[2]^如下：</p>
<ol>
<li>选择输入占用最多的LUT作为逻辑块的种子</li>
<li>将具有最多共同输入信号的LUT装填到当前逻辑块</li>
</ol>
<p>这种方法无法考虑逻辑布线的延时差，所以有以下改进版本^[3]^：</p>
<p>采用Timing-driven（延时驱动）的装箱算法<strong>T-VPack</strong></p>
<ol>
<li><p>选择关键路径上输入最多的LUT作为逻辑块的种子</p>
</li>
<li><p>考虑连接重要度和影响路径数</p>
<p> 连接重要度使用slack（延迟余裕）值计算而来，用于判断当前路径对时序影响的大小和是否是关键路径</p>
<p> slack值越小，该路径就越接近关键路径</p>
<p> 影响路径数指的是当前LUT所影响的关键路径的数目，即输入和当前LUT之间关键路径的总和，该指标表明了当前查找表的延迟一旦改善，总共会有多少路径可以随之得到改善</p>
</li>
<li><p>考虑共同信号数量</p>
</li>
<li><p>连接重要度大、延迟余裕小、共同信号数量多的逻辑打包到同一个查找表</p>
</li>
</ol>
<p>这种算法很好的考虑到布线延迟和逻辑块使用量的均衡</p>
<p>近年来的自适应查找表也对装箱算法有很大影响</p>
<p>较为现代化的算法有AAPack等</p>
<h3 id="布局布线"><a href="#布局布线" class="headerlink" title="布局布线"></a>布局布线</h3><p><strong>布局</strong>：决定逻辑块的物理位置</p>
<p><strong>布线</strong>：决定逻辑块的信号连接路径</p>
<p>多数FPGA的逻辑块都成二维阵列状排列，因此<strong>逻辑块布局问题可以被视为二次分配问题</strong>，这类问题也被公认为NP问题（具有和计算复杂度理论中的NP（Non-deterministic Polynomial Time，非确定性多项式时间）类问题同等或同等以上难度的问题，二次分配问题是具有NP难度的组合优化问题中非常难解的一种问题），通常只能使用SA（Simulated Annealing）等算法获取近似解</p>
<p>布线过程中主要使用两种布线方法：全局布线和详细布线</p>
<p>全局布线主要决定线网的布线路径；详细布线则基于全局布线所得信息确定路径具体使用了哪些布线资源、通过了哪些开关等</p>
<p>这一步FPGA开发和ASIC设计采用的思路都差不多：==瞎蒙==</p>
<p>具体来说使用VPR工具步骤如下：</p>
<ol>
<li>随机放置逻辑块、IO块</li>
<li>计算当前布局的布线拥挤度</li>
<li>随机选择两个逻辑块并对调位置</li>
<li>比较对调后的布线拥挤度</li>
<li>比较对调前后拥挤度的数指，决定是否接受新的布局</li>
</ol>
<h1 id="硬件算法简介"><a href="#硬件算法简介" class="headerlink" title="硬件算法简介"></a>硬件算法简介</h1><p>对于FPGA，或者说ASIC而言，对比CPU最大的优势就是可以实现并行计算，同时能够针对特定问题、特定算法进行优化</p>
<h2 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h2><p>将一个连续的硬件电路拆分为n个均等的阶段，每个阶段的输出作为下一个阶段的输入，下一个阶段执行必须等待前一个阶段完成，每个阶段称为流水线的“级”。对于一个非流水线结构中的运算，完成时间为L，则加入n级流水线后，每L/n个单位时间就可以完成1个运算，这样就将同时在电路运算中的数据量增大了n倍，即<strong>吞吐量</strong>增大了n倍。</p>
<p>实际运算中，n级流水线并不一定能够得到n倍的速度提升</p>
<p>对于n级流水线结构，完成N个运算所需时间为<br>$$<br>T_{pipe}(N)=L+\frac{(N-1)L}{n}=\frac{n+N-1}{n}<br>$$<br>其中完成一个运算所需时间为L</p>
<p>速度提升率为<br>$$<br>S_{pipe}(N)=\frac{T(N)}{T_{pipe}(N)}=\frac{nN}{n+N-1}=\frac{n}{1+\frac{n-1}{N}}<br>$$<br>当$n\ll N$时，有$S_{pipe}(N)\cong n$</p>
<p>流水线结构和非流水线结构相比所得的速度提升和级数成正比，系数为n</p>
<p>这里要注意的是：全部N个运算的时间被缩短，但每个运算从刚开始到结束的时间没有变化，且在刚开始计算时，也就是流水线没有完全开始工作时的<strong>载入过程</strong>，还有结束计算时的<strong>清空过程</strong>无法省略且难以获得吞吐量增益。</p>
<p>流水线结构设计中，还要注意时钟周期限制，在寄存器与寄存器之间存在传输延迟、关键电路延迟。当将非流水线硬件改为流水线结构设计时，需要考虑各个部分的延迟。考虑不周很可能发生前一级完成传输时后一级的传输还在进行，就会产生电路错误</p>
<p>对于两个寄存器之间的延迟，$时钟周期&gt;传输延迟+组合逻辑电路的关键电路延迟+建立时间$，这一时钟周期对应频率的极限就是电路时钟频率的最大值</p>
<p>当级数增多时，流水线寄存器延迟、建立时间、寄存器输入时钟信号偏移、各级之间处理延迟的不同导致的问题越发显著，虽然引入流水线可以在一定程度上增加总体处理速率，增大吞吐量，但是会引入更多需要考虑的因素</p>
<h2 id="并行计算与Flynn"><a href="#并行计算与Flynn" class="headerlink" title="并行计算与Flynn"></a>并行计算与Flynn</h2><p>Michel.J.Flynn在1965年提出了称为<strong>Flynn分类</strong>的并行计算架构分类方法</p>
<p>在通用计算机架构中存在用于控制的<em>指令流</em>和作为运算对象的<em>数据流</em>，Flynn根据基于指令流和数据流的并行度对架构进行分类，分成SISD、SIMD、MISD、MIMD四类，将计算机模型抽象为运算单元PU、控制单元CU、数据存储器、指令存储器四个部分</p>
<ul>
<li><p>SISD架构</p>
<p>  单一CU从指令存储器读取指令流来控制单一的PU，PU受CU控制，从数据存储器读取单一数据流进行计算处理</p>
<p>  这一架构代表基本的顺序计算，不具备并行计算能力</p>
</li>
<li><p>SIMD架构</p>
<p>  单一CU读取指令流的同时控制多个PU，<strong>各个PU接受相同的控制，各自对不同的数据流进行相同的计算处理</strong>，各个PU可以有自己的本地存储器，也可以所有PU访问同一个共享存储器</p>
<p>  该架构中的PU常常被用于图像处理等ASIC中</p>
<p>  通常处理器还会提供SIMD指令来实现数据并行计算，经典的浮点数SIMD指令就是其中之一</p>
</li>
<li><p>MISD架构</p>
<p>  多个CU各自读取不同的指令流并控制多个PU，各个PU根据不同的控制指令对单一数据流进行操作，操作完成后前一阶段的PU将计算结果交付给下一阶段的PU，这样就形成了类似流水线的结构。通过每个CU各自控制一个不同功能的PU来实现并行计算，一般和SIMD架构同时使用来提高效率</p>
</li>
<li><p>MIMD架构</p>
<p>  多个CU各自读取不同的指令流并控制多个PU，各个独立受控的PU对不同的数据流并行处理</p>
<p>  该架构通常应用于具有SMP等多个核心紧密结合的处理器，可以实现共享数据存储器或独立存储器的计算</p>
</li>
</ul>
<h2 id="脉动算法"><a href="#脉动算法" class="headerlink" title="脉动算法"></a>脉动算法</h2><p><strong>脉动算法</strong>：基于H.T.Kung所提倡的脉动阵列所实现并行处理算法的简称</p>
<p><strong>脉动阵列</strong>：由大量单一或多种构造的运算元件（PE）按规律排列的硬件架构，其中只有相邻的运算元件互相连接，运算元件只重复进行简单的数据处理和必要的数据收发，且由统一的时钟同步工作，数据每次只能在相邻运算原件之间移动；使用了总线等连接方式的架构称为半脉动阵列</p>
<p>脉动阵列中的运算元件也可以称为单元</p>
<p><strong>这种架构的系统性能可以随阵列规模扩大而成比例增加，非常适合在集成电路上实现</strong></p>
<h3 id="基于一维脉动阵列的部分排序"><a href="#基于一维脉动阵列的部分排序" class="headerlink" title="基于一维脉动阵列的部分排序"></a>基于一维脉动阵列的部分排序</h3><p>排序：将数据按照某种顺序重新排列的过程</p>
<p>一维排列上设计N个具有寄存器的PE，用于对N个数据进行排序</p>
<p>PE的寄存器用于保存临时最大值X<del>MAX</del>，当输入比临时最大值大时将临时最大值更新为输入值（使用两路数据选择器，输出较大的数据），在PE之间不断重复这个过程直到所有N个数据进入PE，数值最大的N个数据就会依次存储在各个PE的寄存器中，最后一起输出就完成了比较步骤</p>
<p>一般的硬件排序电路一般还具有_rst复位输入、mode模式选择输入、shiftRead从大到小逐次读出等输入端</p>
<p>这样的电路一般也可以当作移位寄存器</p>
<h3 id="基于一维和二维脉动阵列的矩阵向量相乘"><a href="#基于一维和二维脉动阵列的矩阵向量相乘" class="headerlink" title="基于一维和二维脉动阵列的矩阵向量相乘"></a>基于一维和二维脉动阵列的矩阵向量相乘</h3><p>矩阵向量相乘<strong>Y=AX</strong>的计算也可以采用一维脉动阵列实现，呈网格状排列的二位脉动阵列可以更直观地体现计算思路</p>
<ul>
<li><p>一维</p>
<p>  需要N个PE来实现N x N的矩阵运算，每个PE都是独立的加法器，矩阵X和A分别从左和从上输入阵列，PE会将两矩阵的对应行、列元素相加，并将结果暂存在各自的寄存器中。每个时钟周期都会进行运算并输出当前寄存器内的值</p>
<p>  需要注意在运算开始前应将寄存器初始化为0，即实现如下算法（C语言形式）</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">y=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>  每一步都会执行如下算法（C语言形式）</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">y=y+a*x;</span><br></pre></td></tr></table></figure>

<p>  最后完成运算所需总步数为2N-1</p>
</li>
<li><p>二维</p>
<p>  二维矩阵只需要将两个输入矩阵错位，每个时钟周期输入一次即可</p>
<p>  运算所需总步数为3N-2</p>
</li>
</ul>
<h3 id="实现任意模板计算的可编程脉动阵列"><a href="#实现任意模板计算的可编程脉动阵列" class="headerlink" title="实现任意模板计算的可编程脉动阵列"></a>实现任意模板计算的可编程脉动阵列</h3><p>由</p>
<ul>
<li><p>运算器</p>
<p>  用于进行浮点数乘法和加法</p>
</li>
<li><p>本地存储器</p>
<p>  用于在脉动阵列电路内存储一部分运算数据</p>
</li>
<li><p>交换电路</p>
<p>  将当前位置的运算器和本地存储器中的数据运输到其他地方</p>
</li>
<li><p>可编程序列发生器</p>
<p>  控制整个脉动阵列，使用微程序进行操纵</p>
</li>
</ul>
<p>组成</p>
<p>通常一个脉动计算存储器阵列分为多个控制组，各控制组内的PE由统一序列发生器控制，按照SIMD架构并行处理</p>
<p>结合微程序控制交换电路对数据进行搬运，就可以实现任意模板计算</p>
<h2 id="数据流机"><a href="#数据流机" class="headerlink" title="数据流机"></a>数据流机</h2><p><strong>数据流机</strong>是一种只要输入数据就能进行计算的非冯诺依曼架构的计算机。这种运行方式被称为数据驱动方式</p>
<p>他将对象程序转化为数据流图后执行处理。一个典型的数据流机有以下节点：</p>
<ul>
<li>Fork复制数据到另一支路</li>
<li>Primitive Operation按描述进行两个数据的算术运算并输出结果</li>
<li>Branch控制数据流向多个分支中的哪一个分支</li>
<li>Merge根据条件信号的值选择输入数据并输出</li>
<li>令牌：被操作的数据</li>
</ul>
<p>数据流机可以简单地实现条件分支和循环</p>
<p>其中条件分支可以使用Branch和Merge的组合来实现，而循环则有两类实现方式</p>
<h3 id="静态数据流机"><a href="#静态数据流机" class="headerlink" title="静态数据流机"></a>静态数据流机</h3><p>将循环完全展开，全部以数据流的形式实现</p>
<p>优点：并行性很高</p>
<p>缺点：数据流图的规模庞大，对应的电路结构也无法避免地变大</p>
<p>常用于节点运算功能和运算数混合存在的场合，电路中一个命令单元对应一个运算器，运算器会通过控制网络向命令单元传输当前状态。处理完毕的数据进入分发网络送至命令单元，命令通过仲裁网络以操作包的形式发送到运算器，这样就实现了循环的控制</p>
<h3 id="动态数据流机"><a href="#动态数据流机" class="headerlink" title="动态数据流机"></a>动态数据流机</h3><p>只实现循环体的数据流，在之后的循环中复用同一组硬件搭配条件分支来实现</p>
<p>优点：</p>
<p>缺点：需要设置额外的控制电路，如果发生循环间令牌混乱的情况就难以保证计算的正确性</p>
<p>常用于节点运算功能和运算数分离的场合，可以使用<em>带标号的令牌</em>来实现循环处理</p>
<p>典型的电路结构如下：</p>
<p><img src="/2021/11/19/FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E3%80%90FPGA%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%93%E6%9E%84%E3%80%91/image-20210404102541269.png" alt="image-20210404102541269"></p>
<p>其中每个PE的结构如下：</p>
<p><img src="/2021/11/19/FPGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E3%80%90FPGA%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%93%E6%9E%84%E3%80%91/image-20210404103243188.png" alt="image-20210404103243188"></p>
<p>运算数据由标号令牌表示，程序和数据完全分离，每个PE都可以视作一个小型的冯诺依曼架构计算机，数据令牌则由存储位置指令的状态编号、自己的标号、存储位置指令的入口编号、存储位置指令的运算数组成，控制不同标号的运算数据进入不同的PE即可实现循环</p>
<p>PE中的I结构是一个为数组等简单数据结构提供等待功能的模块，在按数据驱动方式处理数组访问时，需要保证数据在写入之后再次被读取。一般的解决方法是对每一个元素设置一个存在标志位，指示数据是否已经被写入，I结构一般要内置该功能以加速简单数据结构的运算。</p>
<h3 id="Petri网"><a href="#Petri网" class="headerlink" title="Petri网"></a>Petri网</h3><p>表示信号输入/输出的图被称为Petri网，<strong>信号转换图</strong>是它的一个子类。可以用于描述并行系统和异步系统</p>
<p>Petri网是由<em>库所</em>（place）和<em>变迁</em>（transition）两类节点和有向弧组成的二分图</p>
<p>系统的状态或条件由库所表示，系统状态迁移的发生和完成等事件用变迁表示，库所-&gt;变迁的有向弧表示现象的发生及其前提条件，变迁-&gt;库所表示事件发生后的状态和成立条件的关系。</p>
<p>Petri网可以表示以下基本状态行为：</p>
<ul>
<li>并发</li>
<li>冲突</li>
<li>困惑</li>
<li>同步</li>
<li>资源共享</li>
<li>读取</li>
<li>有限容量</li>
</ul>
<p>常使用Petri网和数据流机共同描述一个算法，以便在HDL中进行有效的算法优化</p>
<h2 id="流处理思想及其实现"><a href="#流处理思想及其实现" class="headerlink" title="流处理思想及其实现"></a>流处理思想及其实现</h2><p><strong>流处理</strong>：针对逐个输入的数据序列，持续依次处理其中各个元素的方式</p>
<p>数据元素可以是单一标量数据，也可以是包含多个字的向量数据，但流处理每次只能处理一个元素，这就导致元素增多（数据流增长）时的处理时间会成比例增加，不过这也相当于<strong>只要付出时间就可以处理巨大的数据集</strong></p>
<p>流处理数据元素的处理单元称为处理核（kernal），流处理中可以只包含一个处理核也可以包含多个处理核</p>
<h3 id="硬件实现"><a href="#硬件实现" class="headerlink" title="硬件实现"></a>硬件实现</h3><p>如果有充足的硬件资源，可以实现多个处理核，每个处理核作为一级流水线相互连接，最终形成一个大型流水线设计，这样的系统能够达到吞吐量为1的流处理，每个时钟周期都可以进行数据的输入/输出；当硬件资源不充足时，可以将原数据流图折叠变小后映射到硬件，这种方法称为<strong>折叠法</strong>，该设计会导致处理周期增加，吞吐量降低，但可以节省硬件资源或在硬件资源有限的情况下实现流处理</p>
<p>对于某些硬件使用率不到100%的电路，也可以考虑使用折叠法来提高硬件使用率：在运算器输入处插入数据选择器，在需要提高硬件使用率的情况下将正常的流处理程序改变为折叠过后的流处理程序；如果连续处理的多个数据之间存在依赖关系，可以在流处理过程中插入延迟缓冲存储器，将上一步运算的结果暂存，在下一个时钟周期进行处理来实现流处理效果</p>
<h2 id="元胞自动机"><a href="#元胞自动机" class="headerlink" title="元胞自动机"></a>元胞自动机</h2><p><strong>元胞自动机</strong>是基于网格状单元核简单规则的离散计算模型，于冯诺依曼等人在20世纪40年代提出。</p>
<p>元胞自动机由具有有限个状态的元胞组成，经过离散时间后每个细胞的状态都会发生变化，某时刻t元胞的状态会受到上一个时刻元胞状态和其邻居元胞状态的影响。按照考虑邻居元胞的个数，分为冯诺依曼型（只考虑上下左右四个元胞的状态）和摩尔型（考虑全部八个周边元胞状态）</p>
<p>最著名的元胞自动机就是<em>生命游戏</em>，它的一种简单C语言实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单的状态机练习</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;LifeGame.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开始菜单</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CtrlGame</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> input=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Welcome to play LifeGame!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter p to start\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        input=getch();</span><br><span class="line">        <span class="keyword">if</span>(input==<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//游戏数据初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitGame</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>)); <span class="comment">//生成种子</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;HIGH;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;WIDTH;j++)</span><br><span class="line">            cell_map[i][j]=rand()%<span class="number">2</span>;<span class="comment">//细胞初始状态随机</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行游戏</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunGame</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cell_num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        system(<span class="string">&quot;cls&quot;</span>);<span class="comment">//清屏</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;HIGH;i++) <span class="comment">//打印本迭代细胞地图</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;WIDTH;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(cell_map[i][j]==<span class="number">1</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot; # &quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(cell_map[i][j]==<span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot; * &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算1个细胞周围8个格子内的活细胞总量并进行下一步判断</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;HIGH;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;WIDTH;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>) <span class="comment">//最上一行</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(j==<span class="number">0</span>) <span class="comment">//左上角</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        cell_num=</span><br><span class="line">                                                         cell_map[i][j+<span class="number">1</span>]+</span><br><span class="line">                                      cell_map[i+<span class="number">1</span>][j]+ cell_map[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(j==WIDTH<span class="number">-1</span>) <span class="comment">//右上角</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        cell_num=</span><br><span class="line">                                     cell_map[i][j<span class="number">-1</span>]+                     </span><br><span class="line">                                     cell_map[i+<span class="number">1</span>][j<span class="number">-1</span>]+ cell_map[i+<span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="comment">//其他</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        cell_num=</span><br><span class="line">                                     cell_map[i][j<span class="number">-1</span>]+                     cell_map[i][j+<span class="number">1</span>]+</span><br><span class="line">                                     cell_map[i+<span class="number">1</span>][j<span class="number">-1</span>]+ cell_map[i+<span class="number">1</span>][j]+ cell_map[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i==HIGH<span class="number">-1</span>) <span class="comment">//最下一行</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(j==<span class="number">0</span>) <span class="comment">//左下角</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        cell_num= cell_map[i<span class="number">-1</span>][j]+ cell_map[i<span class="number">-1</span>][j+<span class="number">1</span>]+</span><br><span class="line">                                                    cell_map[i][j+<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(j==WIDTH<span class="number">-1</span>) <span class="comment">//右下角</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        cell_num=cell_map[i<span class="number">-1</span>][j<span class="number">-1</span>]+ cell_map[i<span class="number">-1</span>][j]+ </span><br><span class="line">                                 cell_map[i][j<span class="number">-1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="comment">//其他</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        cell_num=cell_map[i<span class="number">-1</span>][j<span class="number">-1</span>]+ cell_map[i<span class="number">-1</span>][j]+ cell_map[i<span class="number">-1</span>][j+<span class="number">1</span>]+</span><br><span class="line">                                 cell_map[i][j<span class="number">-1</span>]+                     cell_map[i][j+<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>) <span class="comment">//除左上角和左下角的最左一列</span></span><br><span class="line">                &#123;</span><br><span class="line">                    cell_num=cell_map[i<span class="number">-1</span>][j]+ cell_map[i<span class="number">-1</span>][j+<span class="number">1</span>]+</span><br><span class="line">                                               cell_map[i][j+<span class="number">1</span>]+</span><br><span class="line">                             cell_map[i+<span class="number">1</span>][j]+ cell_map[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==WIDTH<span class="number">-1</span>) <span class="comment">//除右上角和右下角的最右一列</span></span><br><span class="line">                &#123;</span><br><span class="line">                    cell_num=cell_map[i<span class="number">-1</span>][j<span class="number">-1</span>]+ cell_map[i<span class="number">-1</span>][j]+</span><br><span class="line">                             cell_map[i][j<span class="number">-1</span>]+</span><br><span class="line">                             cell_map[i+<span class="number">1</span>][j<span class="number">-1</span>]+ cell_map[i+<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">//其他位置</span></span><br><span class="line">                &#123;</span><br><span class="line">                    cell_num=cell_map[i<span class="number">-1</span>][j<span class="number">-1</span>]+ cell_map[i<span class="number">-1</span>][j]+ cell_map[i<span class="number">-1</span>][j+<span class="number">1</span>]+</span><br><span class="line">                             cell_map[i][j<span class="number">-1</span>]+                     cell_map[i][j+<span class="number">1</span>]+</span><br><span class="line">                             cell_map[i+<span class="number">1</span>][j<span class="number">-1</span>]+ cell_map[i+<span class="number">1</span>][j]+ cell_map[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(cell_num==<span class="number">3</span>) <span class="comment">//当周围有3个活细胞时,该细胞下一代为活细胞</span></span><br><span class="line">                    new_cell_map[i][j]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(cell_num==<span class="number">2</span>) <span class="comment">//周围有2个活细胞时，该细胞下一代状态不变</span></span><br><span class="line">                    new_cell_map[i][j]=cell_map[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">//其它情况时，该细胞下一代转为死细胞</span></span><br><span class="line">                    new_cell_map[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;HIGH;i++) <span class="comment">//创建下一迭代</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;WIDTH;j++)</span><br><span class="line">                cell_map[i][j]=new_cell_map[i][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(CtrlGame()==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        InitGame();</span><br><span class="line">        RunGame();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LifeGame.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;windows.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//游戏尺寸</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HIGH 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDTH 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cell_map[HIGH][WIDTH]; <span class="comment">//初始状态细胞地图</span></span><br><span class="line"><span class="keyword">int</span> new_cell_map[HIGH][WIDTH]; <span class="comment">//下一代细胞地图</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CtrlGame</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//开始菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitGame</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//游戏数据初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunLifeGame</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//进行游戏</span></span><br></pre></td></tr></table></figure>

<h2 id="硬件排序算法"><a href="#硬件排序算法" class="headerlink" title="硬件排序算法"></a>硬件排序算法</h2><p><strong>排序</strong>：将由n个元素组成的乱序数列按升序或降序重新排列的过程</p>
<p>硬件上常常使用<strong>排序网络</strong>和<strong>归并排序树</strong></p>
<h3 id="基于冒泡排序的排序网络"><a href="#基于冒泡排序的排序网络" class="headerlink" title="基于冒泡排序的排序网络"></a>基于冒泡排序的排序网络</h3><p>特点：可以并行地对相邻两个元素进行排序</p>
<p>排序网络由连线和用于排序相邻元素的交换单元EU组成</p>
<p>连线的数量和元素的数量一致，每个元素最多通过n-1级EU，使用流水线可以提升吞吐量</p>
<p>缺点：面积大，占用硬件资源</p>
<p>在此基础上换用Batcher奇偶排序网络可实现高效排序</p>
<h3 id="归并排序树"><a href="#归并排序树" class="headerlink" title="归并排序树"></a>归并排序树</h3><p>使用二叉树结构连接各个EU，使用FIFO进行输入/输出实现电路内部和外部去耦</p>
<p>全部EU的排序处理可以并行执行，待排列的数列并行输入归并排序树，每层EU选出两个元素中较大（较小）的那个，每层EU将排序后的数列送到下一层的输入FIFO，依次执行最后可以串行输出排序后的数列</p>
<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p><strong>模式匹配</strong>：在数据中按照给定的模式进行搜索</p>
<h3 id="精确匹配"><a href="#精确匹配" class="headerlink" title="精确匹配"></a>精确匹配</h3><p>精确匹配中的模式长度固定，分成0、1、’dont care‘三种状态</p>
<p>可以使用CAM（Content Addressable Memory）存储器实现。在FPGA上常常实现CAM的索引生成单元（Index Generation Unit，IGU）</p>
<p>总体思路是将输入数据p存储到<em>主存储器</em>，主存储器输出索引生成函数f，使用辅助存储器存储f，将其和匹配输入X进行比较，输出q，使用q在辅助存储器查询得到X’，将X和X‘进行逻辑与运算，如果两者相同就输出q，否则输出0</p>
<p>IGU可以将2^n^个元素的集合映射到k+1个集合，内存占用量从O(2^n^)缩减到O(2^p^)，其中p是输入数据p的位数</p>
<h3 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h3><p>正则表达式由字符和描述字符集合的元字符组成。正则表达式匹配等价于使用同等功能的有穷自动机对字符串进行处理</p>
<p>对于确定的输入无法确定迁移状态的自动机称为<strong>非确定性有穷自动机（NFA）</strong>；对确定的输入能够确定迁移状态的自动机称为<strong>确定性有穷自动机（DFA）</strong>。采用DFA的硬件加速实现一般基于Aho-Corasick算法；采用NFA的硬件加速一般使用Prasanna方法</p>
<p>下面仅介绍NFA实现：</p>
<ul>
<li>电路使用存储器对单个字符进行检索，并将结果送入匹配单元ME</li>
<li>ME会模拟状态迁移过程并输出匹配信号</li>
</ul>
<p>总体上是利用一个解析元字符的ME来控制对整个字符串的检索</p>
<p>NFA和DFA两种并行硬件的比较如下</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>按位分割DFA</th>
<th>Prasanna-NFA</th>
</tr>
</thead>
<tbody><tr>
<td>空间复杂度</td>
<td>查找表数</td>
<td>O(1)</td>
<td>O(ms)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>存储器使用量</td>
<td>$O(\sum ^{ms})$</td>
<td>O(ms)</td>
</tr>
<tr>
<td>时间复杂度</td>
<td>处理周期</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>对于FPGA来说更适合NFA实现，因为DFA方法的存储器使用量呈指数型增加，而NFA方法的空间复杂度恒定</p>
<h3 id="近似匹配"><a href="#近似匹配" class="headerlink" title="近似匹配"></a>近似匹配</h3><p>近似字符串匹配：在文本中查找和模式相似的字符串的问题</p>
<p>近似匹配过程中往往伴随着对模式进行删除、置换、插入等处理</p>
<p>一个典型的近似匹配硬件加速架构如下：</p>
<ul>
<li>宿主PC将文本和模式发送到硬件部分</li>
<li>文本被发送到缓冲存储器，模式被发送到编辑距离运算电路</li>
<li>编辑距离运算电路从缓冲存储器读取一部分文本，并计算文本和模式的编辑距离。当且仅当编辑距离最小时，控制电路会将最小编辑距离和表示文本位置的地址输出到FIFO保存</li>
<li>文本每次移动一个字符并重复上一步</li>
<li>所有文本匹配完成时，会将结果发回宿主PC</li>
</ul>
<p>所有步骤中最复杂的就是计算编辑距离，在这里常常需要实现特殊的<strong>动态规划</strong>硬件算法</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1]Jason Cong,Yuzheng Ding. FlowMap: an optimal technology mapping  algorithm for delay optimization in lookup-table based FPGA designs.[J]. IEEE Trans. on CAD of Integrated Circuits and Systems,1994,13(1).</p>
<p>[2]VPack-Jonathan Rose.UToronto</p>
<p>[3]Alexander (Sandy) Marquardt,Vaughn Betz,Jonathan Rose. Using  cluster-based logic blocks and timing-driven packing to improve FPGA  speed and density[P]. Field programmable gate arrays,1999.</p>
]]></content>
      <tags>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32外设配置速查【QSPI】</title>
    <url>/2021/11/19/STM32%E5%A4%96%E8%AE%BE%E9%85%8D%E7%BD%AE%E9%80%9F%E6%9F%A5%E3%80%90QSPI%E3%80%91/</url>
    <content><![CDATA[<h1 id="QSPI协议"><a href="#QSPI协议" class="headerlink" title="QSPI协议"></a>QSPI协议</h1><p>QSPI是Queued SPI（队列串行外围接口）的缩写，是由摩托罗拉公司推出的SPI协议的一个扩展，比SPI应用更加广泛，现在的FLASH、SRAM等存储器大多支持QSPI协议——QSPI是一种==专用==的通信接口，可连接单、双或四线SPI存储器</p>
<p>QSPI在SPI协议的基础上增加了<strong>队列传输机制</strong>。</p>
<p>STM32将Queued SPI协议接口实现为QUADSPI接口。QSPI的实现和SPI基本相似，有部分不同点，在下面列出。</p>
<h2 id="物理连接"><a href="#物理连接" class="headerlink" title="物理连接"></a>物理连接</h2><p>QSPI是标准的四信号线SPI，MCU与外设之间由六根线连接：NSS、IO0、IO1、IO2、IO3、SCLK，其中IO0-3是数据线；NSS又称CS，是片选信号线；SCLK又称SCK，是SPI/QSPI的同步时钟线</p>
<span id="more"></span>

<h2 id="通信规则"><a href="#通信规则" class="headerlink" title="通信规则"></a>通信规则</h2><h3 id="读写命令"><a href="#读写命令" class="headerlink" title="读写命令"></a>读写命令</h3><p><strong>有且仅有一条数据线工作</strong></p>
<h3 id="读写数据"><a href="#读写数据" class="headerlink" title="读写数据"></a>读写数据</h3><p><strong>四条数据线同时工作</strong></p>
<p>读写地址位时四条数据线发送不同的地址，从机自行分辨，引导向各自的地址；读写具体数据时根据对应的地址读写</p>
<h1 id="STM32F1中的SPI特性"><a href="#STM32F1中的SPI特性" class="headerlink" title="STM32F1中的SPI特性"></a>STM32F1中的SPI特性</h1><ul>
<li>三线全双工同步传输</li>
<li>双线/三线单工同步传输</li>
<li>8位/16位传输帧格式选择</li>
<li>主从操作、支持多主模式</li>
<li>8个主模式波特率分频系数（最高可达$f_{PCLK}/2$）</li>
<li>硬件/软件可调的SS（CS片选信号）管理</li>
<li>相关底层配置可编程</li>
<li>可触发中断的发送/接收标志</li>
<li>SPI总线忙碌标志位</li>
<li>支持硬件CRC校验</li>
<li>支持DMA</li>
</ul>
<h1 id="STM32F4中的SPI实现"><a href="#STM32F4中的SPI实现" class="headerlink" title="STM32F4中的SPI实现"></a>STM32F4中的SPI实现</h1><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li><p>支持SPI的TI模式（主要是片选信号差异，用于TI系的IC）</p>
</li>
<li><p>支持F1的全部功能</p>
</li>
</ul>
<p>与F1的功能基本一致，满足SPI接口的使用需要</p>
<h2 id="硬件实现"><a href="#硬件实现" class="headerlink" title="硬件实现"></a>硬件实现</h2><ol>
<li>寄存器配置SPI设置</li>
<li>波特率发生器配置SCLK</li>
<li>MOSI、MISO通过移位寄存器进行收发数据，接收数据即将数据从移位寄存器中复制到RxFIFO；发送数据即将数据放入TxFIFO后送入移位寄存器</li>
<li>主控制逻辑电路和通信控制电路调配相关收发过程</li>
</ol>
<h2 id="HAL库实现"><a href="#HAL库实现" class="headerlink" title="HAL库实现"></a>HAL库实现</h2><p>直接<strong>将收发数据封装为库函数</strong></p>
<h1 id="STM32F7中的SPI特点"><a href="#STM32F7中的SPI特点" class="headerlink" title="STM32F7中的SPI特点"></a>STM32F7中的SPI特点</h1><ul>
<li><p>支持F4的所有功能</p>
</li>
<li><p>可调传输帧格式4位到16位（对应原来的8位/16位传输帧格式选择）</p>
</li>
<li><p>具有DMA功能的两个32位内置Rx、Tx FIFO缓存</p>
</li>
</ul>
<h1 id="STM32H7中的SPI实现"><a href="#STM32H7中的SPI实现" class="headerlink" title="STM32H7中的SPI实现"></a>STM32H7中的SPI实现</h1><h2 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h2><ul>
<li>支持F7的所有功能</li>
<li>数据帧格式大小可从4位到32位</li>
<li><strong>双时钟域</strong>，外设内核时钟可以独立于PCLK</li>
<li>更高的主频，8个主模式波特率预分频器（没有改动），主从模式频率均最高可达内核频率的1/2（$f_{FCLK}/2$）</li>
<li>保护配置和设置</li>
<li>数据之间的最小延时、SS与数据流之间的最小延时均可调</li>
<li>底层配置可编程，支持SS信号极性、时序可编程和MISOxMOSI交互功能</li>
<li>可调节的主器件接收器采样时间</li>
<li>配备停止模式（不向外设IP提供时钟）</li>
<li>具有停止模式下从器件发送/接收功能和低功耗唤醒功能</li>
<li>可编程的FIFO阈值（数据打包）</li>
<li>可编程的传输数据量</li>
<li>具有DMA功能的Rx、Tx FIFO容量扩大到16x8位或8x8位且可选</li>
<li>从模式下，下溢条件可配置，支持级联循环缓冲区</li>
</ul>
<p>H7的SPI控制器比之前版本的控制器自由度更高（但大部分情况下用不上）</p>
<h2 id="硬件实现-1"><a href="#硬件实现-1" class="headerlink" title="硬件实现"></a>硬件实现</h2><p>与之前的SPI控制器基本相同，但多了双时钟域的功能块：时钟寄存器控制时钟发生器工作，可以由SPI_PCLK或SPI_KER_CK提供时钟，SPI_KER_CK时钟直接提供给时钟发生器，进而用于SCK或MCK</p>
<h2 id="软件配置"><a href="#软件配置" class="headerlink" title="软件配置"></a>软件配置</h2><ol>
<li>在CubeMX中根据外设IC配置GPIO复用和SPI相关设定</li>
<li>CubeMX会使能外设时钟、配置SPI模式、地址、速率等参数并使能SPI外设；模式设定与f4设定基本类似，可参考【STM32F4外设配置速查总线协议部分】</li>
<li>编写对应外设IC的驱动程序</li>
<li>设置检验程序，上电后检验驱动程序及外设连接情况</li>
<li>编写应用程序</li>
</ol>
<h1 id="STM32F7-H7中的QSPI实现"><a href="#STM32F7-H7中的QSPI实现" class="headerlink" title="STM32F7/H7中的QSPI实现"></a>STM32F7/H7中的QSPI实现</h1><p>QUADSPI主要用于控制SPI FLASH器件（只要满足QSPI时序就可以控制其他器件），工作在以下三种模式：</p>
<ol>
<li>间接模式：使用QUADSPI寄存器执行全部操作</li>
<li><strong>状态轮询模式</strong>：周期性轮询外部FLASH状态寄存器，如果为1（擦除/烧写完毕）则引发中断</li>
<li><strong>内存映射模式</strong>：外部FLASH映射到MCU片上SRAM地址空间，系统将其视作<strong>内部FLASH</strong>存储器进行操作（==内部FLASH只读==）</li>
</ol>
<p>特别地，采用双闪存模式时，将<strong>同时访问两个QSPI FLASH，吞吐量和容量*2</strong></p>
<h2 id="特性-2"><a href="#特性-2" class="headerlink" title="特性"></a>特性</h2><ul>
<li>双闪存模式：并行访问两块FLASH，同时收发8位数据</li>
<li>支持SDR和DDR模式</li>
<li>集成接收/发送FIFO</li>
<li>允许8、16、32位数据访问</li>
<li>间接模式下可使用DMA</li>
<li>可使能的FIFO溢出、超时、操作完成、访问错误中断（异常）</li>
</ul>
<h2 id="硬件实现-2"><a href="#硬件实现-2" class="headerlink" title="硬件实现"></a>硬件实现</h2><p>可以实现单线、双线、四线SPI功能</p>
<p>与SPI控制器的不同点主要在于：FIFO和外设寄存器直接接入AHB总线</p>
<p>双闪存模式下，外设引脚复用可选择一个CS信号线或两个CS信号线</p>
<p>其他内容可参考MCU数据手册</p>
<h2 id="软件配置-1"><a href="#软件配置-1" class="headerlink" title="软件配置"></a>软件配置</h2><ol>
<li>基本配置同上</li>
</ol>
<p>外部SPI FLASH驱动代码如下，与上面的代码差别不大</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* W25Q256.h文件的函数声明 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;													<span class="comment">//初始化W25QXX</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Qspi_Enable</span><span class="params">(<span class="keyword">void</span>)</span></span>;											<span class="comment">//使能QSPI模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Qspi_Disable</span><span class="params">(<span class="keyword">void</span>)</span></span>;											<span class="comment">//关闭QSPI模式</span></span><br><span class="line"><span class="function">u16  <span class="title">NORFLASH_ReadID</span><span class="params">(<span class="keyword">void</span>)</span></span>;													<span class="comment">//读取FLASH ID</span></span><br><span class="line"><span class="function">u8 	 <span class="title">NORFLASH_ReadSR</span><span class="params">(u8 regno)</span></span>;												<span class="comment">//读取状态寄存器 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_4ByteAddr_Enable</span><span class="params">(<span class="keyword">void</span>)</span></span>;										<span class="comment">//使能4字节地址模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Write_SR</span><span class="params">(u8 regno,u8 sr)</span></span>;										<span class="comment">//写状态寄存器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Write_Enable</span><span class="params">(<span class="keyword">void</span>)</span></span>;  											<span class="comment">//写使能 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Write_Disable</span><span class="params">(<span class="keyword">void</span>)</span></span>;											<span class="comment">//写保护</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Write_NoCheck</span><span class="params">(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)</span></span>;	<span class="comment">//写flash,不校验</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Read</span><span class="params">(u8* pBuffer,u32 ReadAddr,u16 NumByteToRead)</span></span>;   			<span class="comment">//读取flash</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Write</span><span class="params">(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)</span></span>;			<span class="comment">//写入flash</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Erase_Chip</span><span class="params">(<span class="keyword">void</span>)</span></span>;    	  										<span class="comment">//整片擦除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Erase_Sector</span><span class="params">(u32 Dst_Addr)</span></span>;									<span class="comment">//扇区擦除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Wait_Busy</span><span class="params">(<span class="keyword">void</span>)</span></span>;           									<span class="comment">//等待空闲</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* W25Q256.c文件全部内容 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;norflash.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;qspi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;usart.h&quot;</span> </span></span><br><span class="line"></span><br><span class="line">u16 NORFLASH_TYPE=W25Q256;	<span class="comment">//使用W25Q256</span></span><br><span class="line">u8 NORFLASH_QPI_MODE=<span class="number">0</span>;		<span class="comment">//QSPI模式标志:0,SPI模式;1,QSPI模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 4Kbytes为一个Sector（扇区）</span></span><br><span class="line"><span class="comment"> * 16个扇区为1个Block（块）</span></span><br><span class="line"><span class="comment"> * W25Q64容量为8M字节,共有128个Block,2048个Sector，W25Q256刚好是它的4倍</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化SPI FLASH的IO口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	u8 temp;</span><br><span class="line">	QSPI_Init();						<span class="comment">//初始化QSPI</span></span><br><span class="line"> 	NORFLASH_Qspi_Enable();				<span class="comment">//使能QSPI模式</span></span><br><span class="line">	NORFLASH_TYPE=NORFLASH_ReadID();	<span class="comment">//读取FLASH ID</span></span><br><span class="line">	<span class="keyword">if</span>(NORFLASH_TYPE==W25Q64)</span><br><span class="line">	&#123;</span><br><span class="line">		NORFLASH_Write_Enable();		<span class="comment">//写使能</span></span><br><span class="line">		QSPI_Send_CMD(W25X_SetReadParam,<span class="number">0</span>,(<span class="number">3</span>&lt;&lt;<span class="number">6</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//QSPI设置读参数指令,地址为0,4线传数据_8位地址_无地址_4线传输指令,无空周期,1个字节数据</span></span><br><span class="line">		temp=<span class="number">3</span>&lt;&lt;<span class="number">4</span>;						<span class="comment">//设置P4&amp;P5=11,8个dummy clocks,104M</span></span><br><span class="line">		QSPI_Transmit(&amp;temp,<span class="number">1</span>);			<span class="comment">//发送1个字节</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ID:%x\r\n&quot;</span>,NORFLASH_TYPE);	<span class="comment">//打印FLASH参数</span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//W25QXX进入QSPI模式 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Qspi_Enable</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 stareg2=<span class="number">0</span>;</span><br><span class="line">	stareg2=NORFLASH_ReadSR(<span class="number">2</span>);			<span class="comment">//先读出状态寄存器2的原始值 </span></span><br><span class="line">	<span class="comment">//printf(&quot;stareg2:%x\r\n&quot;,stareg2);	//打印参数</span></span><br><span class="line">	<span class="keyword">if</span>((stareg2&amp;<span class="number">0X02</span>)==<span class="number">0</span>)				<span class="comment">//QE位未使能</span></span><br><span class="line">	&#123; </span><br><span class="line">		NORFLASH_Write_Enable();		<span class="comment">//写使能 </span></span><br><span class="line">		stareg2|=<span class="number">1</span>&lt;&lt;<span class="number">1</span>;					<span class="comment">//使能QE位		</span></span><br><span class="line">		NORFLASH_Write_SR(<span class="number">2</span>,stareg2);	<span class="comment">//写状态寄存器2</span></span><br><span class="line">	&#125;</span><br><span class="line">	QSPI_Send_CMD(W25X_EnterQPIMode,<span class="number">0</span>,(<span class="number">0</span>&lt;&lt;<span class="number">6</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//写command指令,地址为0,无数据_8位地址_无地址_单线传输指令,无空周期,0个字节数据</span></span><br><span class="line">	NORFLASH_QPI_MODE=<span class="number">1</span>;				<span class="comment">//标记QSPI模式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//W25QXX退出QSPI模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Qspi_Disable</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	QSPI_Send_CMD(W25X_ExitQPIMode,<span class="number">0</span>,(<span class="number">0</span>&lt;&lt;<span class="number">6</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//写command指令,地址为0,无数据_8位地址_无地址_4线传输指令,无空周期,0个字节数据</span></span><br><span class="line">	NORFLASH_QPI_MODE=<span class="number">0</span>;<span class="comment">//标记SPI模式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取W25QXX的状态寄存器 */</span></span><br><span class="line"><span class="comment">//W25QXX一共有3个状态寄存器</span></span><br><span class="line"><span class="comment">//状态寄存器1：</span></span><br><span class="line"><span class="comment">//BIT7  6   5   4   3   2   1   0</span></span><br><span class="line"><span class="comment">//SPR   RV  TB BP2 BP1 BP0 WEL BUSY</span></span><br><span class="line"><span class="comment">//SPR:默认0,状态寄存器保护位,配合WP使用</span></span><br><span class="line"><span class="comment">//TB,BP2,BP1,BP0:FLASH区域写保护设置</span></span><br><span class="line"><span class="comment">//WEL:写使能锁定</span></span><br><span class="line"><span class="comment">//BUSY:忙标记位(1,忙;0,空闲)</span></span><br><span class="line"><span class="comment">//默认:0x00</span></span><br><span class="line"><span class="comment">//状态寄存器2：</span></span><br><span class="line"><span class="comment">//BIT7  6   5   4   3   2   1   0</span></span><br><span class="line"><span class="comment">//SUS   CMP LB3 LB2 LB1 (R) QE  SRP1</span></span><br><span class="line"><span class="comment">//状态寄存器3：</span></span><br><span class="line"><span class="comment">//BIT7      6    5    4   3   2   1   0</span></span><br><span class="line"><span class="comment">//HOLD/RST  DRV1 DRV0 (R) (R) WPS ADP ADS</span></span><br><span class="line"><span class="comment">//regno:状态寄存器号，范:1~3</span></span><br><span class="line"><span class="comment">//返回值:状态寄存器值</span></span><br><span class="line"><span class="function">u8 <span class="title">NORFLASH_ReadSR</span><span class="params">(u8 regno)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	u8 byte=<span class="number">0</span>,command=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">switch</span>(regno)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            command=W25X_ReadStatusReg1;    <span class="comment">//读状态寄存器1指令</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            command=W25X_ReadStatusReg2;    <span class="comment">//读状态寄存器2指令</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            command=W25X_ReadStatusReg3;    <span class="comment">//读状态寄存器3指令</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            command=W25X_ReadStatusReg1;    </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">	<span class="keyword">if</span>(NORFLASH_QPI_MODE)</span><br><span class="line">        QSPI_Send_CMD(command,<span class="number">0</span>,(<span class="number">3</span>&lt;&lt;<span class="number">6</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">    	<span class="comment">//QSPI模式,写command指令,地址为0,4线传数据_8位地址_无地址_4线传输指令,无空周期,1个字节数据</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        QSPI_Send_CMD(command,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;<span class="number">6</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">    	<span class="comment">//SPI模式,写command指令,地址为0,单线传数据_8位地址_无地址_单线传输指令,无空周期,1个字节数据</span></span><br><span class="line">	QSPI_Receive(&amp;byte,<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> byte;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment">//写W25QXX状态寄存器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Write_SR</span><span class="params">(u8 regno,u8 sr)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    u8 command=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span>(regno)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            command=W25X_WriteStatusReg1;    <span class="comment">//写状态寄存器1指令</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            command=W25X_WriteStatusReg2;    <span class="comment">//写状态寄存器2指令</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            command=W25X_WriteStatusReg3;    <span class="comment">//写状态寄存器3指令</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            command=W25X_WriteStatusReg1;    </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">	<span class="keyword">if</span>(NORFLASH_QPI_MODE)</span><br><span class="line">        QSPI_Send_CMD(command,<span class="number">0</span>,(<span class="number">3</span>&lt;&lt;<span class="number">6</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">    	<span class="comment">//QPI,写command指令,地址为0,4线传数据_8位地址_无地址_4线传输指令,无空周期,1个字节数据</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        QSPI_Send_CMD(command,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;<span class="number">6</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//SPI,写command指令,地址为0,单线传数据_8位地址_无地址_单线传输指令,无空周期,1个字节数据</span></span><br><span class="line">	QSPI_Transmit(&amp;sr,<span class="number">1</span>);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//W25QXX写使能</span></span><br><span class="line"><span class="comment">//将S1寄存器的WEL置位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Write_Enable</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(NORFLASH_QPI_MODE)</span><br><span class="line">        QSPI_Send_CMD(W25X_WriteEnable,<span class="number">0</span>,(<span class="number">0</span>&lt;&lt;<span class="number">6</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">    	<span class="comment">//QPI,写使能指令,地址为0,无数据_8位地址_无地址_4线传输指令,无空周期,0个字节数据</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        QSPI_Send_CMD(W25X_WriteEnable,<span class="number">0</span>,(<span class="number">0</span>&lt;&lt;<span class="number">6</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">    	<span class="comment">//SPI,写使能指令,地址为0,无数据_8位地址_无地址_单线传输指令,无空周期,0个字节数据</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//W25QXX写禁止	</span></span><br><span class="line"><span class="comment">//将WEL清零  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Write_Disable</span><span class="params">(<span class="keyword">void</span>)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	<span class="keyword">if</span>(NORFLASH_QPI_MODE)</span><br><span class="line">        QSPI_Send_CMD(W25X_WriteDisable,<span class="number">0</span>,(<span class="number">0</span>&lt;&lt;<span class="number">6</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">    	<span class="comment">//QPI,写禁止指令,地址为0,无数据_8位地址_无地址_4线传输指令,无空周期,0个字节数据</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        QSPI_Send_CMD(W25X_WriteDisable,<span class="number">0</span>,(<span class="number">0</span>&lt;&lt;<span class="number">6</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">    	<span class="comment">//SPI,写禁止指令,地址为0,无数据_8位地址_无地址_单线传输指令,无空周期,0个字节数据 </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值如下:				   </span></span><br><span class="line"><span class="comment">//0XEF13,表示芯片型号为W25Q80  </span></span><br><span class="line"><span class="comment">//0XEF14,表示芯片型号为W25Q16    </span></span><br><span class="line"><span class="comment">//0XEF15,表示芯片型号为W25Q32  </span></span><br><span class="line"><span class="comment">//0XEF16,表示芯片型号为W25Q64 </span></span><br><span class="line"><span class="comment">//0XEF17,表示芯片型号为W25Q128 	  </span></span><br><span class="line"><span class="comment">//0XEF18,表示芯片型号为W25Q256</span></span><br><span class="line"><span class="function">u16 <span class="title">NORFLASH_ReadID</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 temp[<span class="number">2</span>];</span><br><span class="line">	u16 deviceid;</span><br><span class="line">	<span class="keyword">if</span>(NORFLASH_QPI_MODE)</span><br><span class="line">        QSPI_Send_CMD(W25X_ManufactDeviceID,<span class="number">0</span>,(<span class="number">3</span>&lt;&lt;<span class="number">6</span>)|(<span class="number">2</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">    	<span class="comment">//QPI,读id,地址为0,4线传输数据_24位地址_4线传输地址_4线传输指令,无空周期,2个字节数据</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        QSPI_Send_CMD(W25X_ManufactDeviceID,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;<span class="number">6</span>)|(<span class="number">2</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">    	<span class="comment">//SPI,读id,地址为0,单线传输数据_24位地址_单线传输地址_单线传输指令,无空周期,2个字节数据</span></span><br><span class="line">	QSPI_Receive(temp,<span class="number">2</span>);</span><br><span class="line">	deviceid=(temp[<span class="number">0</span>]&lt;&lt;<span class="number">8</span>)|temp[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> deviceid;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">//读取SPI FLASH,仅支持QSPI模式</span></span><br><span class="line"><span class="comment">//在指定地址开始读取指定长度的数据</span></span><br><span class="line"><span class="comment">//pBuffer:数据存储区</span></span><br><span class="line"><span class="comment">//ReadAddr:开始读取的地址(最大32bit)</span></span><br><span class="line"><span class="comment">//NumByteToRead:要读取的字节数(最大65535)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Read</span><span class="params">(u8* pBuffer,u32 ReadAddr,u16 NumByteToRead)</span>   </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	QSPI_Send_CMD(W25X_FastReadData,ReadAddr,(<span class="number">3</span>&lt;&lt;<span class="number">6</span>)|(<span class="number">2</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">0</span>),<span class="number">8</span>);</span><br><span class="line">    <span class="comment">//QPI,快速读数据,地址为ReadAddr,4线传输数据_24位地址_4线传输地址_4线传输指令,8空周期,NumByteToRead个数据</span></span><br><span class="line">	QSPI_Receive(pBuffer,NumByteToRead); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SPI在一页(0~65535)内写入少于256个字节的数据</span></span><br><span class="line"><span class="comment">//在指定地址开始写入最大256字节的数据</span></span><br><span class="line"><span class="comment">//pBuffer:数据存储区</span></span><br><span class="line"><span class="comment">//WriteAddr:开始写入的地址(最大32bit)</span></span><br><span class="line"><span class="comment">//NumByteToWrite:要写入的字节数(最大256),该数不应该超过该页的剩余字节数!!!	 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Write_Page</span><span class="params">(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	NORFLASH_Write_Enable();<span class="comment">//写使能</span></span><br><span class="line">	QSPI_Send_CMD(W25X_PageProgram,WriteAddr,(<span class="number">3</span>&lt;&lt;<span class="number">6</span>)|(<span class="number">2</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//QPI,页写指令,地址为WriteAddr,4线传输数据_24位地址_4线传输地址_4线传输指令,无空周期,NumByteToWrite个数据</span></span><br><span class="line">	QSPI_Transmit(pBuffer,NumByteToWrite);</span><br><span class="line">	NORFLASH_Wait_Busy();<span class="comment">//等待写入结束</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//无检验写SPI FLASH</span></span><br><span class="line"><span class="comment">//必须确保所写的地址范围内的数据全部为0XFF,否则在非0XFF处写入的数据将失败!</span></span><br><span class="line"><span class="comment">//具有自动换页功能</span></span><br><span class="line"><span class="comment">//在指定地址开始写入指定长度的数据,但是要确保地址不越界!</span></span><br><span class="line"><span class="comment">//pBuffer:数据存储区</span></span><br><span class="line"><span class="comment">//WriteAddr:开始写入的地址(最大32bit)</span></span><br><span class="line"><span class="comment">//NumByteToWrite:要写入的字节数(最大65535)</span></span><br><span class="line"><span class="comment">//CHECK OK</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Write_NoCheck</span><span class="params">(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)</span>   </span></span><br><span class="line"><span class="function"></span>&#123; 			 		 </span><br><span class="line">	u16 pageremain;	   </span><br><span class="line">	pageremain=<span class="number">256</span>-WriteAddr%<span class="number">256</span>;<span class="comment">//单页剩余的字节数		 	    </span></span><br><span class="line">	<span class="keyword">if</span>(NumByteToWrite&lt;=pageremain)pageremain=NumByteToWrite;<span class="comment">//不大于256个字节</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;	   </span><br><span class="line">		NORFLASH_Write_Page(pBuffer,WriteAddr,pageremain);</span><br><span class="line">		<span class="keyword">if</span>(NumByteToWrite==pageremain)</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//写入结束</span></span><br><span class="line">	 	<span class="keyword">else</span><span class="comment">//NumByteToWrite&gt;pageremain</span></span><br><span class="line">		&#123;</span><br><span class="line">			pBuffer+=pageremain;</span><br><span class="line">			WriteAddr+=pageremain;	</span><br><span class="line"></span><br><span class="line">			NumByteToWrite-=pageremain;<span class="comment">//减去已经写入了的字节数</span></span><br><span class="line">			<span class="keyword">if</span>(NumByteToWrite&gt;<span class="number">256</span>)</span><br><span class="line">                pageremain=<span class="number">256</span>;<span class="comment">//一次可以写入256个字节</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">                pageremain=NumByteToWrite;<span class="comment">//不够256个字节了</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;   </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//写SPI FLASH</span></span><br><span class="line"><span class="comment">//在指定地址开始写入指定长度的数据</span></span><br><span class="line"><span class="comment">//该函数带擦除操作!</span></span><br><span class="line"><span class="comment">//pBuffer:数据存储区</span></span><br><span class="line"><span class="comment">//WriteAddr:开始写入的地址(最大32bit)</span></span><br><span class="line"><span class="comment">//NumByteToWrite:要写入的字节数(最大65535)</span></span><br><span class="line">u8 NORFLASH_BUFFER[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Write</span><span class="params">(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)</span>   </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	u32 secpos;</span><br><span class="line">	u16 secoff;</span><br><span class="line">	u16 secremain;</span><br><span class="line"> 	u16 i;</span><br><span class="line">	u8 * NORFLASH_BUF;</span><br><span class="line"></span><br><span class="line">	NORFLASH_BUF=NORFLASH_BUFFER;</span><br><span class="line"> 	secpos=WriteAddr/<span class="number">4096</span>;<span class="comment">//扇区基地址</span></span><br><span class="line">	secoff=WriteAddr%<span class="number">4096</span>;<span class="comment">//偏移地址</span></span><br><span class="line">	secremain=<span class="number">4096</span>-secoff;<span class="comment">//扇区剩余空间大小</span></span><br><span class="line">    </span><br><span class="line"> 	<span class="comment">//printf(&quot;ad:%X,nb:%X\r\n&quot;,WriteAddr,NumByteToWrite);//测试用</span></span><br><span class="line"> 	<span class="keyword">if</span>(NumByteToWrite&lt;=secremain)</span><br><span class="line">        secremain=NumByteToWrite;<span class="comment">//如果待写入字节不大于4096个字节，将待写入大小限制为一个块大小</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		NORFLASH_Read(NORFLASH_BUF,secpos*<span class="number">4096</span>,<span class="number">4096</span>);<span class="comment">//读出整个扇区的内容</span></span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;secremain;i++)<span class="comment">//校验数据</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(NORFLASH_BUF[secoff+i]!=<span class="number">0XFF</span>)<span class="comment">//如果存在非空区域</span></span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//需要擦除</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;secremain)<span class="comment">//如果待写入字节小于剩余空间，需要擦除</span></span><br><span class="line">		&#123;</span><br><span class="line">			NORFLASH_Erase_Sector(secpos);<span class="comment">//擦除这个扇区</span></span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;secremain;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				NORFLASH_BUF[i+secoff]=pBuffer[i];<span class="comment">//将写入内容复制到FLASH	  </span></span><br><span class="line">			&#125;</span><br><span class="line">			NORFLASH_Write_NoCheck(NORFLASH_BUF,secpos*<span class="number">4096</span>,<span class="number">4096</span>);<span class="comment">//写入整个扇区   </span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//如果不需要擦除</span></span><br><span class="line">            NORFLASH_Write_NoCheck(pBuffer,WriteAddr,secremain);<span class="comment">//直接写入扇区剩余空区间</span></span><br><span class="line">        </span><br><span class="line">		<span class="keyword">if</span>(NumByteToWrite==secremain)</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//写入结束</span></span><br><span class="line">		<span class="keyword">else</span><span class="comment">//写入未结束，接着写下一个扇区</span></span><br><span class="line">		&#123;</span><br><span class="line">			secpos++;<span class="comment">//扇区地址增1</span></span><br><span class="line">			secoff=<span class="number">0</span>;<span class="comment">//偏移位置为0 	 </span></span><br><span class="line"></span><br><span class="line">			pBuffer+=secremain;<span class="comment">//指针偏移</span></span><br><span class="line">			WriteAddr+=secremain;<span class="comment">//写地址偏移</span></span><br><span class="line">			NumByteToWrite-=secremain;<span class="comment">//字节数递减</span></span><br><span class="line">			<span class="keyword">if</span>(NumByteToWrite&gt;<span class="number">4096</span>)</span><br><span class="line">                secremain=<span class="number">4096</span>;<span class="comment">//下一个扇区还是写不完</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">                secremain=NumByteToWrite;<span class="comment">//下一个扇区可以写完了</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全片擦除</span></span><br><span class="line"><span class="comment">//等待时间会很长</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Erase_Chip</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	NORFLASH_Write_Enable();<span class="comment">//WEL置位</span></span><br><span class="line">	NORFLASH_Wait_Busy();</span><br><span class="line">	QSPI_Send_CMD(W25X_ChipErase,<span class="number">0</span>,(<span class="number">0</span>&lt;&lt;<span class="number">6</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">0</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//QPI,写全片擦除指令,地址为0,无数据_8位地址_无地址_4线传输指令,无空周期,0个字节数据</span></span><br><span class="line">	NORFLASH_Wait_Busy();<span class="comment">//等待芯片擦除结束</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//擦除一个扇区</span></span><br><span class="line"><span class="comment">//Dst_Addr:扇区地址 根据实际容量设置</span></span><br><span class="line"><span class="comment">//擦除一个扇区的最少时间:150ms</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Erase_Sector</span><span class="params">(u32 Dst_Addr)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//printf(&quot;fe:%x\r\n&quot;,Dst_Addr);//监视falsh擦除情况,测试用  	  </span></span><br><span class="line">	Dst_Addr*=<span class="number">4096</span>;</span><br><span class="line">	NORFLASH_Write_Enable();<span class="comment">//WEL置位</span></span><br><span class="line">	NORFLASH_Wait_Busy();</span><br><span class="line">	QSPI_Send_CMD(W25X_SectorErase,Dst_Addr,(<span class="number">0</span>&lt;&lt;<span class="number">6</span>)|(<span class="number">2</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">3</span>&lt;&lt;<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//QPI,写扇区擦除指令,地址为0,无数据_24位地址_4线传输地址_4线传输指令,无空周期,0个字节数据</span></span><br><span class="line">	NORFLASH_Wait_Busy();<span class="comment">//等待擦除完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待空闲</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NORFLASH_Wait_Busy</span><span class="params">(<span class="keyword">void</span>)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>((NORFLASH_ReadSR(<span class="number">1</span>)&amp;<span class="number">0x01</span>)==<span class="number">0x01</span>);	<span class="comment">// 等待BUSY位清空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置QSPI</li>
</ol>
<p>这里写的驱动代码是纯HAL库函数实现，外设IC是W25Q64 8MB大小</p>
<p>w25q64.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> w25q64_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> w25q64_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stm32h7xx_hal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------------------------------------------- 命名参数宏 -------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QSPI_W25Qxx_OK           		0			<span class="comment">// W25Qxx通信正常</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_ERROR_INIT         		-1			<span class="comment">// 初始化错误</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_ERROR_WriteEnable       -2			<span class="comment">// 写使能错误</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_ERROR_AUTOPOLLING       -3			<span class="comment">// 轮询等待错误，无响应</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_ERROR_Erase         		-4			<span class="comment">// 擦除错误</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_ERROR_TRANSMIT         	-5			<span class="comment">// 传输错误</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_ERROR_MemoryMapped		-6    		<span class="comment">// 内存映射模式错误</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_CMD_EnableReset  		0x66		<span class="comment">// 使能复位</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_CMD_ResetDevice   		0x99		<span class="comment">// 复位器件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_CMD_JedecID 				0x9F		<span class="comment">// JEDEC ID  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_CMD_WriteEnable			0X06		<span class="comment">// 写使能</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_CMD_SectorErase 			0x20		<span class="comment">// 扇区擦除，4K字节， 参考擦除时间 45ms</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_CMD_BlockErase_32K 		0x52		<span class="comment">// 块擦除，  32K字节，参考擦除时间 120ms</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_CMD_BlockErase_64K 		0xD8		<span class="comment">// 块擦除，  64K字节，参考擦除时间 150ms</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_CMD_ChipErase 			0xC7		<span class="comment">// 整片擦除，参考擦除时间 20S</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_CMD_QuadInputPageProgram  	0x32  	<span class="comment">// 1-1-4模式下(1线指令1线地址4线数据)，页编程指令，参考写入时间 0.4ms </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_CMD_FastReadQuad_IO       	0xEB  	<span class="comment">// 1-4-4模式下(1线指令4线地址4线数据)，快速读取指令</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_CMD_ReadStatus_REG1			0X05	<span class="comment">// 读状态寄存器1</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_Status_REG1_BUSY  			0x01	<span class="comment">// 读状态寄存器1的第0位（只读），Busy标志位，当正在擦除/写入数据/写命令时会被置1</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_Status_REG1_WEL  			0x02	<span class="comment">// 读状态寄存器1的第1位（只读），WEL写使能标志位，该标志位为1时，代表可以进行写操作</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_PageSize       				256			<span class="comment">// 页大小，256字节</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_FlashSize       				0x800000	<span class="comment">// W25Q64大小，8M字节</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_FLASH_ID           			0Xef4017    <span class="comment">// W25Q64 JEDEC ID</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_ChipErase_TIMEOUT_MAX		100000U		<span class="comment">// 超时等待时间，W25Q64整片擦除所需最大时间是100S</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25Qxx_Mem_Addr						0x90000000 	<span class="comment">// 内存映射模式的地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------------------------------------------- 引脚配置宏 ------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUADSPI_CLK_PIN				GPIO_PIN_2						<span class="comment">// QUADSPI_CLK 引脚</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	QUADSPI_CLK_PORT			GPIOB							<span class="comment">// QUADSPI_CLK 引脚端口</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	QUADSPI_CLK_AF				GPIO_AF9_QUADSPI				<span class="comment">// QUADSPI_CLK IO口复用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_QUADSPI_CLK_ENABLE     __HAL_RCC_GPIOB_CLK_ENABLE()	<span class="comment">// QUADSPI_CLK 引脚时钟使能</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUADSPI_BK1_NCS_PIN			GPIO_PIN_6						<span class="comment">// QUADSPI_BK1_NCS 引脚</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	QUADSPI_BK1_NCS_PORT		GPIOB							<span class="comment">// QUADSPI_BK1_NCS 引脚端口</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	QUADSPI_BK1_NCS_AF			GPIO_AF10_QUADSPI				<span class="comment">// QUADSPI_BK1_NCS IO口复用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_QUADSPI_BK1_NCS_ENABLE __HAL_RCC_GPIOB_CLK_ENABLE()	<span class="comment">// QUADSPI_BK1_NCS 引脚时钟使能</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUADSPI_BK1_IO0_PIN			GPIO_PIN_11						<span class="comment">// QUADSPI_BK1_IO0 引脚</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	QUADSPI_BK1_IO0_PORT		GPIOD							<span class="comment">// QUADSPI_BK1_IO0 引脚端口</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	QUADSPI_BK1_IO0_AF			GPIO_AF9_QUADSPI				<span class="comment">// QUADSPI_BK1_IO0 IO口复用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_QUADSPI_BK1_IO0_ENABLE __HAL_RCC_GPIOD_CLK_ENABLE()	<span class="comment">// QUADSPI_BK1_IO0 引脚时钟使能</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUADSPI_BK1_IO1_PIN			GPIO_PIN_2						<span class="comment">// QUADSPI_BK1_IO1 引脚</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	QUADSPI_BK1_IO1_PORT		GPIOE							<span class="comment">// QUADSPI_BK1_IO1 引脚端口</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	QUADSPI_BK1_IO1_AF			GPIO_AF9_QUADSPI				<span class="comment">// QUADSPI_BK1_IO1 IO口复用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_QUADSPI_BK1_IO1_ENABLE __HAL_RCC_GPIOE_CLK_ENABLE()	<span class="comment">// QUADSPI_BK1_IO1 引脚时钟使能</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUADSPI_BK1_IO2_PIN			GPIO_PIN_12						<span class="comment">// QUADSPI_BK1_IO2 引脚</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	QUADSPI_BK1_IO2_PORT		GPIOD							<span class="comment">// QUADSPI_BK1_IO2 引脚端口</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	QUADSPI_BK1_IO2_AF			GPIO_AF9_QUADSPI				<span class="comment">// QUADSPI_BK1_IO2 IO口复用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_QUADSPI_BK1_IO2_ENABLE __HAL_RCC_GPIOD_CLK_ENABLE()	<span class="comment">// QUADSPI_BK1_IO2 引脚时钟使能</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUADSPI_BK1_IO3_PIN			GPIO_PIN_13						<span class="comment">// QUADSPI_BK1_IO3 引脚</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	QUADSPI_BK1_IO3_PORT		GPIOD							<span class="comment">// QUADSPI_BK1_IO3 引脚端口</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	QUADSPI_BK1_IO3_AF			GPIO_AF9_QUADSPI				<span class="comment">// QUADSPI_BK1_IO3 IO口复用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_QUADSPI_BK1_IO3_ENABLE __HAL_RCC_GPIOD_CLK_ENABLE()	<span class="comment">// QUADSPI_BK1_IO3 引脚时钟使能</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------------------------------------------- 函数声明 --------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span>	<span class="title">QSPI_W25Qxx_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;						<span class="comment">// W25Qxx初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> 	<span class="title">QSPI_W25Qxx_Reset</span><span class="params">(<span class="keyword">void</span>)</span></span>;					<span class="comment">// 复位器件</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">QSPI_W25Qxx_ReadID</span><span class="params">(<span class="keyword">void</span>)</span></span>;					<span class="comment">// 读取器件ID</span></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> 	<span class="title">QSPI_W25Qxx_MemoryMappedMode</span><span class="params">(<span class="keyword">void</span>)</span></span>;			<span class="comment">// 进入内存映射模式</span></span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> 	<span class="title">QSPI_W25Qxx_SectorErase</span><span class="params">(<span class="keyword">uint32_t</span> SectorAddress)</span></span>;		<span class="comment">// 扇区擦除，4K字节，参考擦除时间 45ms</span></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> 	<span class="title">QSPI_W25Qxx_BlockErase_32K</span> <span class="params">(<span class="keyword">uint32_t</span> SectorAddress)</span></span>;	<span class="comment">// 块擦除，32K字节，参考擦除时间 120ms</span></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> 	<span class="title">QSPI_W25Qxx_BlockErase_64K</span> <span class="params">(<span class="keyword">uint32_t</span> SectorAddress)</span></span>;	<span class="comment">// 块擦除，64K字节，参考擦除时间 150ms，实际使用建议使用64K擦除，擦除的时间最快</span></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> 	<span class="title">QSPI_W25Qxx_ChipErase</span> <span class="params">(<span class="keyword">void</span>)</span></span>;                         	<span class="comment">// 整片擦除，参考擦除时间 20S</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按页写入，最大256字节</span></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span>	<span class="title">QSPI_W25Qxx_WritePage</span><span class="params">(<span class="keyword">uint8_t</span>* pBuffer, <span class="keyword">uint32_t</span> WriteAddr, <span class="keyword">uint16_t</span> NumByteToWrite)</span></span>;</span><br><span class="line"><span class="comment">// 写入数据，最大不能超过flash芯片的大小</span></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span>	<span class="title">QSPI_W25Qxx_WriteBuffer</span><span class="params">(<span class="keyword">uint8_t</span>* pData, <span class="keyword">uint32_t</span> WriteAddr, <span class="keyword">uint32_t</span> Size)</span></span>;</span><br><span class="line"><span class="comment">// 读取数据，最大不能超过flash芯片的大小</span></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> 	<span class="title">QSPI_W25Qxx_ReadBuffer</span><span class="params">(<span class="keyword">uint8_t</span>* pBuffer, <span class="keyword">uint32_t</span> ReadAddr, <span class="keyword">uint32_t</span> NumByteToRead)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>w25q64.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;w25q64.h&quot;</span></span></span><br><span class="line">QSPI_HandleTypeDef hqspi;<span class="comment">//定义QSPI句柄，这里保留使用cubeMX生成的变量命名，方便用户参考和移植</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* QSPI初始化 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_QSPI_MspInit</span><span class="params">(QSPI_HandleTypeDef* hqspi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">if</span>(hqspi-&gt;Instance==QUADSPI)</span><br><span class="line">	&#123;</span><br><span class="line">		__HAL_RCC_QSPI_CLK_ENABLE();	<span class="comment">// 使能QSPI时钟</span></span><br><span class="line"></span><br><span class="line">		GPIO_QUADSPI_CLK_ENABLE;		<span class="comment">// 使能 QUADSPI_CLK IO口时钟</span></span><br><span class="line">		GPIO_QUADSPI_BK1_NCS_ENABLE;	<span class="comment">// 使能 QUADSPI_BK1_NCS IO口时钟</span></span><br><span class="line">		GPIO_QUADSPI_BK1_IO0_ENABLE;	<span class="comment">// 使能 QUADSPI_BK1_IO0 IO口时钟</span></span><br><span class="line">		GPIO_QUADSPI_BK1_IO1_ENABLE;	<span class="comment">// 使能 QUADSPI_BK1_IO1 IO口时钟</span></span><br><span class="line">		GPIO_QUADSPI_BK1_IO2_ENABLE;	<span class="comment">// 使能 QUADSPI_BK1_IO2 IO口时钟</span></span><br><span class="line">		GPIO_QUADSPI_BK1_IO3_ENABLE;	<span class="comment">// 使能 QUADSPI_BK1_IO3 IO口时钟</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">/******************************************************  </span></span><br><span class="line"><span class="comment">		PB2     ------&gt; QUADSPI_CLK	</span></span><br><span class="line"><span class="comment">		PB6     ------&gt; QUADSPI_BK1_NCS 		</span></span><br><span class="line"><span class="comment">		PD11    ------&gt; QUADSPI_BK1_IO0</span></span><br><span class="line"><span class="comment">		PD12    ------&gt; QUADSPI_BK1_IO1		</span></span><br><span class="line"><span class="comment">		PE2     ------&gt; QUADSPI_BK1_IO2	</span></span><br><span class="line"><span class="comment">		PD13    ------&gt; QUADSPI_BK1_IO3</span></span><br><span class="line"><span class="comment">		*******************************************************/</span></span><br><span class="line">		</span><br><span class="line">		GPIO_InitStruct.Mode 		= GPIO_MODE_AF_PP;				<span class="comment">// 复用推挽输出模式</span></span><br><span class="line">		GPIO_InitStruct.Pull 		= GPIO_NOPULL;					<span class="comment">// 无上下拉</span></span><br><span class="line">		GPIO_InitStruct.Speed 		= GPIO_SPEED_FREQ_VERY_HIGH;	<span class="comment">// 超高速IO口速度</span></span><br><span class="line">		</span><br><span class="line">		GPIO_InitStruct.Pin 			= QUADSPI_CLK_PIN;			<span class="comment">// QUADSPI_CLK 引脚</span></span><br><span class="line">		GPIO_InitStruct.Alternate 	= QUADSPI_CLK_AF;				<span class="comment">// QUADSPI_CLK 复用</span></span><br><span class="line">		HAL_GPIO_Init(QUADSPI_CLK_PORT, &amp;GPIO_InitStruct);			<span class="comment">// 初始化 QUADSPI_CLK 引脚</span></span><br><span class="line"></span><br><span class="line">		GPIO_InitStruct.Pin 			= QUADSPI_BK1_NCS_PIN;		<span class="comment">// QUADSPI_BK1_NCS 引脚</span></span><br><span class="line">		GPIO_InitStruct.Alternate 	= QUADSPI_BK1_NCS_AF;			<span class="comment">// QUADSPI_BK1_NCS 复用</span></span><br><span class="line">		HAL_GPIO_Init(QUADSPI_BK1_NCS_PORT, &amp;GPIO_InitStruct);   	<span class="comment">// 初始化 QUADSPI_BK1_NCS 引脚</span></span><br><span class="line">		</span><br><span class="line">		GPIO_InitStruct.Pin 			= QUADSPI_BK1_IO0_PIN;		<span class="comment">// QUADSPI_BK1_IO0 引脚</span></span><br><span class="line">		GPIO_InitStruct.Alternate 	= QUADSPI_BK1_IO0_AF;			<span class="comment">// QUADSPI_BK1_IO0 复用</span></span><br><span class="line">		HAL_GPIO_Init(QUADSPI_BK1_IO0_PORT, &amp;GPIO_InitStruct);		<span class="comment">// 初始化 QUADSPI_BK1_IO0 引脚	</span></span><br><span class="line">		</span><br><span class="line">		GPIO_InitStruct.Pin 			= QUADSPI_BK1_IO1_PIN;		<span class="comment">// QUADSPI_BK1_IO1 引脚</span></span><br><span class="line">		GPIO_InitStruct.Alternate 	= QUADSPI_BK1_IO1_AF;			<span class="comment">// QUADSPI_BK1_IO1 复用</span></span><br><span class="line">		HAL_GPIO_Init(QUADSPI_BK1_IO1_PORT, &amp;GPIO_InitStruct);   	<span class="comment">// 初始化 QUADSPI_BK1_IO1 引脚</span></span><br><span class="line">		</span><br><span class="line">		GPIO_InitStruct.Pin 			= QUADSPI_BK1_IO2_PIN;		<span class="comment">// QUADSPI_BK1_IO2 引脚</span></span><br><span class="line">		GPIO_InitStruct.Alternate 	= QUADSPI_BK1_IO2_AF;			<span class="comment">// QUADSPI_BK1_IO2 复用</span></span><br><span class="line">		HAL_GPIO_Init(QUADSPI_BK1_IO2_PORT, &amp;GPIO_InitStruct);		<span class="comment">// 初始化 QUADSPI_BK1_IO2 引脚</span></span><br><span class="line">		</span><br><span class="line">		GPIO_InitStruct.Pin 			= QUADSPI_BK1_IO3_PIN;		<span class="comment">// QUADSPI_BK1_IO3 引脚</span></span><br><span class="line">		GPIO_InitStruct.Alternate 	= QUADSPI_BK1_IO3_AF;			<span class="comment">// QUADSPI_BK1_IO3 复用</span></span><br><span class="line">		HAL_GPIO_Init(QUADSPI_BK1_IO3_PORT, &amp;GPIO_InitStruct);		<span class="comment">// 初始化 QUADSPI_BK1_IO3 引脚</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MX_QUADSPI_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	hqspi.Instance 					= QUADSPI;									<span class="comment">// QSPI外设</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* QSPI的内核时钟设置为PLL2CLK，速度250M，经过2分频得到125M驱动时钟 */</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 当使用内存映射模式时,这里的分频系数不能设置为0,否则会读取错误</span></span><br><span class="line">	hqspi.Init.ClockPrescaler= <span class="number">1</span>;<span class="comment">// 时钟分频值，将QSPI内核时钟进行 1+1 分频得到QSPI通信驱动时钟</span></span><br><span class="line">	hqspi.Init.FifoThreshold= <span class="number">32</span>;<span class="comment">// FIFO阈值</span></span><br><span class="line">	hqspi.Init.SampleShifting= QSPI_SAMPLE_SHIFTING_HALFCYCLE;<span class="comment">// 半个CLK周期之后进行采样</span></span><br><span class="line">	hqspi.Init.FlashSize= <span class="number">22</span>;<span class="comment">// flash大小，FLASH 中的字节数=2^[FSIZE+1]，对于8MB的W25Q64设置为22</span></span><br><span class="line">	hqspi.Init.ChipSelectHighTime=QSPI_CS_HIGH_TIME_1_CYCLE;<span class="comment">// 片选保持高电平的时间</span></span><br><span class="line">	hqspi.Init.ClockMode=QSPI_CLOCK_MODE_3;<span class="comment">// 模式3</span></span><br><span class="line">	hqspi.Init.FlashID=QSPI_FLASH_ID_1;<span class="comment">// 使用QSPI1</span></span><br><span class="line">	hqspi.Init.DualFlash=QSPI_DUALFLASH_DISABLE;<span class="comment">// 关闭双闪存模式</span></span><br><span class="line">	<span class="comment">// 应用配置</span></span><br><span class="line">	HAL_QSPI_Init(&amp;hqspi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检查W25Q64 */</span></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> <span class="title">QSPI_W25Qxx_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> Device_ID;</span><br><span class="line">	</span><br><span class="line">	MX_QUADSPI_Init();<span class="comment">//初始化QSPI</span></span><br><span class="line">	QSPI_W25Qxx_Reset();<span class="comment">//复位</span></span><br><span class="line">	Device_ID = QSPI_W25Qxx_ReadID();<span class="comment">//读取ID</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(Device_ID == W25Qxx_FLASH_ID )<span class="comment">//检查外设器件</span></span><br><span class="line">	&#123;</span><br><span class="line">		STM_printf (<span class="string">&quot;W25Q64 OK,flash ID:%X\r\n&quot;</span>,Device_ID);<span class="comment">//初始化成功，打印debug信息</span></span><br><span class="line">		<span class="keyword">return</span> QSPI_W25Qxx_OK;<span class="comment">//返回成功标志		</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		STM_printf (<span class="string">&quot;W25Q64 ERROR!!!!!  ID:%X\r\n&quot;</span>,Device_ID);<span class="comment">//初始化失败	</span></span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_INIT;<span class="comment">//返回错误标志</span></span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//轮询确认FLASH是否空闲（用于等待通讯结束等）</span></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> <span class="title">QSPI_W25Qxx_AutoPollingMemReady</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QSPI_CommandTypeDef     s_command;	   						<span class="comment">// 	QSPI传输配置</span></span><br><span class="line">	QSPI_AutoPollingTypeDef s_config;							<span class="comment">// 	轮询比较相关配置参数</span></span><br><span class="line"></span><br><span class="line">	s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;		<span class="comment">// 	1线指令模式</span></span><br><span class="line">	s_command.AddressMode       = QSPI_ADDRESS_NONE;			<span class="comment">// 	无地址模式</span></span><br><span class="line">	s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;	<span class="comment">//	无交替字节 </span></span><br><span class="line">	s_command.DdrMode           = QSPI_DDR_MODE_DISABLE;	    <span class="comment">// 	禁止DDR模式</span></span><br><span class="line">	s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;	<span class="comment">// 	DDR模式中数据延迟，这里用不到</span></span><br><span class="line">	s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;	   	<span class="comment">//	每次传输数据都发送指令	</span></span><br><span class="line">	s_command.DataMode          = QSPI_DATA_1_LINE;				<span class="comment">// 	1线数据模式</span></span><br><span class="line">	s_command.DummyCycles       = <span class="number">0</span>;							<span class="comment">//	空周期个数</span></span><br><span class="line">	s_command.Instruction       = W25Qxx_CMD_ReadStatus_REG1;	<span class="comment">// 	读状态信息寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不停查询 W25Qxx_CMD_ReadStatus_REG1 寄存器，将读取到的状态字节中的 W25Qxx_Status_REG1_BUSY 与0作比较</span></span><br><span class="line"><span class="comment">// 读状态寄存器1的第0位（只读），Busy标志位，当正在擦除/写入数据/写命令时会被置1，空闲或通信结束为0</span></span><br><span class="line">    s_config.Match           = <span class="number">0</span>;   							<span class="comment">//	匹配值</span></span><br><span class="line">	s_config.MatchMode       = QSPI_MATCH_MODE_AND;	      		<span class="comment">//	与运算</span></span><br><span class="line">	s_config.Interval        = <span class="number">0x10</span>;	                     	<span class="comment">//	轮询间隔</span></span><br><span class="line">	s_config.AutomaticStop   = QSPI_AUTOMATIC_STOP_ENABLE;		<span class="comment">// 自动停止模式</span></span><br><span class="line">	s_config.StatusBytesSize = <span class="number">1</span>;	                        	<span class="comment">//	状态字节数</span></span><br><span class="line">	s_config.Mask=W25Qxx_Status_REG1_BUSY;<span class="comment">//对在轮询模式下接收的状态字节进行屏蔽，只比较需要用到的位</span></span><br><span class="line">		</span><br><span class="line">	<span class="comment">// 发送轮询等待命令</span></span><br><span class="line">	<span class="keyword">if</span> (HAL_QSPI_AutoPolling(&amp;hqspi, &amp;s_command, &amp;s_config, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_AUTOPOLLING; <span class="comment">// 轮询等待无响应</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> QSPI_W25Qxx_OK; <span class="comment">// 通信正常结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FLASH软件复位</span></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> <span class="title">QSPI_W25Qxx_Reset</span><span class="params">(<span class="keyword">void</span>)</span>	</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QSPI_CommandTypeDef s_command;<span class="comment">// QSPI传输配置</span></span><br><span class="line"></span><br><span class="line">	s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;   	<span class="comment">// 1线指令模式</span></span><br><span class="line">	s_command.AddressMode 		= QSPI_ADDRESS_NONE;   			<span class="comment">// 无地址模式</span></span><br><span class="line">	s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE; 	<span class="comment">// 无交替字节 </span></span><br><span class="line">	s_command.DdrMode           = QSPI_DDR_MODE_DISABLE;     	<span class="comment">// 禁止DDR模式</span></span><br><span class="line">	s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY; 	<span class="comment">// DDR模式中数据延迟，这里用不到</span></span><br><span class="line">	s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;	 	<span class="comment">// 每次传输数据都发送指令</span></span><br><span class="line">	s_command.DataMode 			= QSPI_DATA_NONE;       		<span class="comment">// 无数据模式	</span></span><br><span class="line">	s_command.DummyCycles 		= <span class="number">0</span>;                     		<span class="comment">// 空周期个数</span></span><br><span class="line">	s_command.Instruction 		= W25Qxx_CMD_EnableReset;       <span class="comment">// 执行复位使能命令</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发送复位使能命令</span></span><br><span class="line">	<span class="keyword">if</span> (HAL_QSPI_Command(&amp;hqspi, &amp;s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) </span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_INIT;<span class="comment">//如果发送失败，返回错误信息</span></span><br><span class="line">	<span class="comment">// 使用自动轮询标志位，等待通信结束</span></span><br><span class="line">	<span class="keyword">if</span> (QSPI_W25Qxx_AutoPollingMemReady() != QSPI_W25Qxx_OK)</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_AUTOPOLLING;<span class="comment">// 轮询等待无响应</span></span><br><span class="line"></span><br><span class="line">	s_command.Instruction  = W25Qxx_CMD_ResetDevice;<span class="comment">//复位器件命令    </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//发送复位器件命令</span></span><br><span class="line">	<span class="keyword">if</span> (HAL_QSPI_Command(&amp;hqspi, &amp;s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) </span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_INIT;<span class="comment">// 如果发送失败，返回错误信息</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 使用自动轮询标志位，等待通信结束</span></span><br><span class="line">	<span class="keyword">if</span> (QSPI_W25Qxx_AutoPollingMemReady() != QSPI_W25Qxx_OK)</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_AUTOPOLLING;<span class="comment">// 轮询等待无响应</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> QSPI_W25Qxx_OK;<span class="comment">// 复位成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">QSPI_W25Qxx_ReadID</span><span class="params">(<span class="keyword">void</span>)</span>	</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QSPI_CommandTypeDef s_command;<span class="comment">// QSPI传输配置</span></span><br><span class="line">	<span class="keyword">uint8_t</span>	QSPI_ReceiveBuff[<span class="number">3</span>];<span class="comment">// 存储QSPI读到的数据</span></span><br><span class="line">	<span class="keyword">uint32_t</span> W25Qxx_ID;<span class="comment">// 器件的ID</span></span><br><span class="line"></span><br><span class="line">	s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;    	<span class="comment">// 1线指令模式</span></span><br><span class="line">	s_command.AddressSize       = QSPI_ADDRESS_24_BITS;     	<span class="comment">// 24位地址</span></span><br><span class="line">	s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;  	<span class="comment">// 无交替字节 </span></span><br><span class="line">	s_command.DdrMode           = QSPI_DDR_MODE_DISABLE;      	<span class="comment">// 禁止DDR模式</span></span><br><span class="line">	s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;  	<span class="comment">// DDR模式中数据延迟，这里用不到</span></span><br><span class="line">	s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;	 	<span class="comment">// 每次传输数据都发送指令</span></span><br><span class="line">	s_command.AddressMode		= QSPI_ADDRESS_NONE;   			<span class="comment">// 无地址模式</span></span><br><span class="line">	s_command.DataMode			= QSPI_DATA_1_LINE;       	 	<span class="comment">// 1线数据模式</span></span><br><span class="line">	s_command.DummyCycles 		= <span class="number">0</span>;                   			<span class="comment">// 空周期个数</span></span><br><span class="line">	s_command.NbData 			= <span class="number">3</span>;                       		<span class="comment">// 传输数据的长度</span></span><br><span class="line">	s_command.Instruction 		= W25Qxx_CMD_JedecID;         	<span class="comment">// 执行读器件ID命令</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发送指令</span></span><br><span class="line">	<span class="keyword">if</span> (HAL_QSPI_Command(&amp;hqspi, &amp;s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) </span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_INIT;<span class="comment">// 如果发送失败，返回错误信息</span></span><br><span class="line">	<span class="comment">// 接收数据</span></span><br><span class="line">	<span class="keyword">if</span> (HAL_QSPI_Receive(&amp;hqspi, QSPI_ReceiveBuff, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) </span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_TRANSMIT;<span class="comment">// 如果接收失败，返回错误信息</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 将得到的数据组合成ID</span></span><br><span class="line">	W25Qxx_ID = (QSPI_ReceiveBuff[<span class="number">0</span>] &lt;&lt; <span class="number">16</span>) | (QSPI_ReceiveBuff[<span class="number">1</span>] &lt;&lt; <span class="number">8</span> ) | QSPI_ReceiveBuff[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">return</span> W25Qxx_ID;<span class="comment">// 返回ID</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置QSPI为内存映射模式</span></span><br><span class="line"><span class="comment">//此模式为只读状态，无法写入</span></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> <span class="title">QSPI_W25Qxx_MemoryMappedMode</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QSPI_CommandTypeDef s_command;<span class="comment">// QSPI传输配置</span></span><br><span class="line">	QSPI_MemoryMappedTypeDef s_mem_mapped_cfg;<span class="comment">// 内存映射访问参数</span></span><br><span class="line"></span><br><span class="line">	s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;    		<span class="comment">// 1线指令模式</span></span><br><span class="line">	s_command.AddressSize       = QSPI_ADDRESS_24_BITS;            	<span class="comment">// 24位地址</span></span><br><span class="line">	s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;  		<span class="comment">// 无交替字节 </span></span><br><span class="line">	s_command.DdrMode           = QSPI_DDR_MODE_DISABLE;     		<span class="comment">// 禁止DDR模式</span></span><br><span class="line">	s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY; 		<span class="comment">// DDR模式中数据延迟，这里用不到</span></span><br><span class="line">	s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;			<span class="comment">// 每次传输数据都发送指令	</span></span><br><span class="line">	s_command.AddressMode 		= QSPI_ADDRESS_4_LINES; 			<span class="comment">// 4线地址模式</span></span><br><span class="line">	s_command.DataMode    		= QSPI_DATA_4_LINES;    			<span class="comment">// 4线数据模式</span></span><br><span class="line">	s_command.DummyCycles 		= <span class="number">6</span>;                    			<span class="comment">// 空周期个数</span></span><br><span class="line">	s_command.Instruction 		= W25Qxx_CMD_FastReadQuad_IO; 		<span class="comment">// 1-4-4模式下(1线指令4线地址4线数据)，快速读取指令</span></span><br><span class="line">	</span><br><span class="line">	s_mem_mapped_cfg.TimeOutActivation = QSPI_TIMEOUT_COUNTER_DISABLE; <span class="comment">// 禁用超时计数器, nCS 保持激活状态</span></span><br><span class="line">	s_mem_mapped_cfg.TimeOutPeriod     = <span class="number">0</span>;							   <span class="comment">// 超时判断周期</span></span><br><span class="line"></span><br><span class="line">	QSPI_W25Qxx_Reset();<span class="comment">// 复位W25Qxx</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (HAL_QSPI_MemoryMapped(&amp;hqspi, &amp;s_command, &amp;s_mem_mapped_cfg) != HAL_OK)<span class="comment">// 进行配置</span></span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_MemoryMapped;<span class="comment">// 设置内存映射模式错误</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> QSPI_W25Qxx_OK; <span class="comment">// 配置成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写使能</span></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> <span class="title">QSPI_W25Qxx_WriteEnable</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QSPI_CommandTypeDef     s_command;	   	<span class="comment">// QSPI传输配置</span></span><br><span class="line">	QSPI_AutoPollingTypeDef s_config;		<span class="comment">// 轮询比较相关配置参数</span></span><br><span class="line"></span><br><span class="line">	s_command.InstructionMode   	= QSPI_INSTRUCTION_1_LINE;    	<span class="comment">// 1线指令模式</span></span><br><span class="line">	s_command.AddressMode 			= QSPI_ADDRESS_NONE;   		    <span class="comment">// 无地址模式</span></span><br><span class="line">	s_command.AlternateByteMode 	= QSPI_ALTERNATE_BYTES_NONE;  	<span class="comment">// 无交替字节 </span></span><br><span class="line">	s_command.DdrMode           	= QSPI_DDR_MODE_DISABLE;      	<span class="comment">// 禁止DDR模式</span></span><br><span class="line">	s_command.DdrHoldHalfCycle  	= QSPI_DDR_HHC_ANALOG_DELAY;  	<span class="comment">// DDR模式中数据延迟，这里用不到</span></span><br><span class="line">	s_command.SIOOMode          	= QSPI_SIOO_INST_EVERY_CMD;		<span class="comment">// 每次传输数据都发送指令	</span></span><br><span class="line">	s_command.DataMode 				= QSPI_DATA_NONE;       	    <span class="comment">// 无数据模式</span></span><br><span class="line">	s_command.DummyCycles 			= <span class="number">0</span>;                   	        <span class="comment">// 空周期个数</span></span><br><span class="line">	s_command.Instruction	 		= W25Qxx_CMD_WriteEnable;      	<span class="comment">// 发送写使能命令</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发送写使能命令</span></span><br><span class="line">	<span class="keyword">if</span> (HAL_QSPI_Command(&amp;hqspi, &amp;s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) </span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_WriteEnable;</span><br><span class="line"><span class="comment">// 不停的查询W25Qxx_CMD_ReadStatus_REG1寄存器，将读取到的状态字节中的W25Qxx_Status_REG1_WEL与0x02作比较</span></span><br><span class="line"><span class="comment">// 读状态寄存器1的第1位（只读），WEL写使能标志位，该标志位为1时，代表可以进行写操作</span></span><br><span class="line">	</span><br><span class="line">	s_config.Match           = <span class="number">0x02</span>;  								<span class="comment">// 匹配值</span></span><br><span class="line">	s_config.Mask			 = W25Qxx_Status_REG1_WEL;				<span class="comment">// 读状态寄存器1的第1位（只读），WEL写使能标志位，该标志位为1时，代表可以进行写操作</span></span><br><span class="line">	s_config.MatchMode       = QSPI_MATCH_MODE_AND;			 		<span class="comment">// 与运算</span></span><br><span class="line">	s_config.StatusBytesSize = <span class="number">1</span>;									<span class="comment">// 状态字节数</span></span><br><span class="line">	s_config.Interval        = <span class="number">0x10</span>;							 	<span class="comment">// 轮询间隔</span></span><br><span class="line">	s_config.AutomaticStop   = QSPI_AUTOMATIC_STOP_ENABLE;			<span class="comment">// 自动停止模式</span></span><br><span class="line"></span><br><span class="line">	s_command.Instruction    = W25Qxx_CMD_ReadStatus_REG1;			<span class="comment">// 读状态信息寄存器</span></span><br><span class="line">	s_command.DataMode       = QSPI_DATA_1_LINE;					<span class="comment">// 1线数据模式</span></span><br><span class="line">	s_command.NbData         = <span class="number">1</span>;									<span class="comment">// 数据长度</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发送轮询等待命令	</span></span><br><span class="line">	<span class="keyword">if</span> (HAL_QSPI_AutoPolling(&amp;hqspi, &amp;s_command, &amp;s_config, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_AUTOPOLLING;<span class="comment">// 轮询等待无响应，返回错误</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> QSPI_W25Qxx_OK;<span class="comment">// 通信正常结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 擦除 */</span></span><br><span class="line"><span class="comment">//这里照搬原文档，指令都是重复的，不作注释</span></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> <span class="title">QSPI_W25Qxx_SectorErase</span><span class="params">(<span class="keyword">uint32_t</span> SectorAddress)</span>	</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QSPI_CommandTypeDef s_command;	<span class="comment">// QSPI传输配置</span></span><br><span class="line">	</span><br><span class="line">	s_command.InstructionMode   	= QSPI_INSTRUCTION_1_LINE;    <span class="comment">// 1线指令模式</span></span><br><span class="line">	s_command.AddressSize       	= QSPI_ADDRESS_24_BITS;       <span class="comment">// 24位地址模式</span></span><br><span class="line">	s_command.AlternateByteMode 	= QSPI_ALTERNATE_BYTES_NONE;  <span class="comment">//	无交替字节 </span></span><br><span class="line">	s_command.DdrMode           	= QSPI_DDR_MODE_DISABLE;      <span class="comment">// 禁止DDR模式</span></span><br><span class="line">	s_command.DdrHoldHalfCycle  	= QSPI_DDR_HHC_ANALOG_DELAY;  <span class="comment">// DDR模式中数据延迟，这里用不到</span></span><br><span class="line">	s_command.SIOOMode          	= QSPI_SIOO_INST_EVERY_CMD;	<span class="comment">// 每次传输数据都发送指令</span></span><br><span class="line">	s_command.AddressMode 			= QSPI_ADDRESS_1_LINE;        <span class="comment">// 1线地址模式</span></span><br><span class="line">	s_command.DataMode 				= QSPI_DATA_NONE;             <span class="comment">// 无数据</span></span><br><span class="line">	s_command.DummyCycles 			= <span class="number">0</span>;                          <span class="comment">// 空周期个数</span></span><br><span class="line">	s_command.Address           	= SectorAddress;              <span class="comment">// 要擦除的地址</span></span><br><span class="line">	s_command.Instruction	 		= W25Qxx_CMD_SectorErase;     <span class="comment">// 扇区擦除命令</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发送写使能</span></span><br><span class="line">	<span class="keyword">if</span> (QSPI_W25Qxx_WriteEnable() != QSPI_W25Qxx_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_WriteEnable;		<span class="comment">// 写使能失败</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 发出擦除命令</span></span><br><span class="line">	<span class="keyword">if</span> (HAL_QSPI_Command(&amp;hqspi, &amp;s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_Erase;				<span class="comment">// 擦除失败</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 使用自动轮询标志位，等待擦除的结束 </span></span><br><span class="line">	<span class="keyword">if</span> (QSPI_W25Qxx_AutoPollingMemReady() != QSPI_W25Qxx_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_AUTOPOLLING;		<span class="comment">// 轮询等待无响应</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> QSPI_W25Qxx_OK; <span class="comment">// 擦除成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> <span class="title">QSPI_W25Qxx_BlockErase_32K</span> <span class="params">(<span class="keyword">uint32_t</span> SectorAddress)</span>	</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QSPI_CommandTypeDef s_command;	<span class="comment">// QSPI传输配置</span></span><br><span class="line">	</span><br><span class="line">	s_command.InstructionMode   	= QSPI_INSTRUCTION_1_LINE;    <span class="comment">// 1线指令模式</span></span><br><span class="line">	s_command.AddressSize       	= QSPI_ADDRESS_24_BITS;       <span class="comment">// 24位地址模式</span></span><br><span class="line">	s_command.AlternateByteMode 	= QSPI_ALTERNATE_BYTES_NONE;  <span class="comment">//	无交替字节 </span></span><br><span class="line">	s_command.DdrMode           	= QSPI_DDR_MODE_DISABLE;      <span class="comment">// 禁止DDR模式</span></span><br><span class="line">	s_command.DdrHoldHalfCycle  	= QSPI_DDR_HHC_ANALOG_DELAY;  <span class="comment">// DDR模式中数据延迟，这里用不到</span></span><br><span class="line">	s_command.SIOOMode          	= QSPI_SIOO_INST_EVERY_CMD;	<span class="comment">// 每次传输数据都发送指令</span></span><br><span class="line">	s_command.AddressMode 			= QSPI_ADDRESS_1_LINE;        <span class="comment">// 1线地址模式</span></span><br><span class="line">	s_command.DataMode 				= QSPI_DATA_NONE;             <span class="comment">// 无数据</span></span><br><span class="line">	s_command.DummyCycles 			= <span class="number">0</span>;                          <span class="comment">// 空周期个数</span></span><br><span class="line">	s_command.Address           	= SectorAddress;              <span class="comment">// 要擦除的地址</span></span><br><span class="line">	s_command.Instruction	 		= W25Qxx_CMD_BlockErase_32K;  <span class="comment">// 块擦除命令，每次擦除32K字节</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发送写使能	</span></span><br><span class="line">	<span class="keyword">if</span> (QSPI_W25Qxx_WriteEnable() != QSPI_W25Qxx_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_WriteEnable;		<span class="comment">// 写使能失败</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 发出擦除命令</span></span><br><span class="line">	<span class="keyword">if</span> (HAL_QSPI_Command(&amp;hqspi, &amp;s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_Erase;				<span class="comment">// 擦除失败</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 使用自动轮询标志位，等待擦除的结束 </span></span><br><span class="line">	<span class="keyword">if</span> (QSPI_W25Qxx_AutoPollingMemReady() != QSPI_W25Qxx_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_AUTOPOLLING;		<span class="comment">// 轮询等待无响应</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> QSPI_W25Qxx_OK;	<span class="comment">// 擦除成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> <span class="title">QSPI_W25Qxx_BlockErase_64K</span> <span class="params">(<span class="keyword">uint32_t</span> SectorAddress)</span>	</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QSPI_CommandTypeDef s_command;	<span class="comment">// QSPI传输配置</span></span><br><span class="line">	</span><br><span class="line">	s_command.InstructionMode   	= QSPI_INSTRUCTION_1_LINE;    <span class="comment">// 1线指令模式</span></span><br><span class="line">	s_command.AddressSize       	= QSPI_ADDRESS_24_BITS;       <span class="comment">// 24位地址模式</span></span><br><span class="line">	s_command.AlternateByteMode 	= QSPI_ALTERNATE_BYTES_NONE;  <span class="comment">//	无交替字节 </span></span><br><span class="line">	s_command.DdrMode           	= QSPI_DDR_MODE_DISABLE;      <span class="comment">// 禁止DDR模式</span></span><br><span class="line">	s_command.DdrHoldHalfCycle  	= QSPI_DDR_HHC_ANALOG_DELAY;  <span class="comment">// DDR模式中数据延迟，这里用不到</span></span><br><span class="line">	s_command.SIOOMode          	= QSPI_SIOO_INST_EVERY_CMD;	<span class="comment">// 每次传输数据都发送指令</span></span><br><span class="line">	s_command.AddressMode 			= QSPI_ADDRESS_1_LINE;        <span class="comment">// 1线地址模式</span></span><br><span class="line">	s_command.DataMode 				= QSPI_DATA_NONE;             <span class="comment">// 无数据</span></span><br><span class="line">	s_command.DummyCycles 			= <span class="number">0</span>;                          <span class="comment">// 空周期个数</span></span><br><span class="line">	s_command.Address           	= SectorAddress;              <span class="comment">// 要擦除的地址</span></span><br><span class="line">	s_command.Instruction	 		= W25Qxx_CMD_BlockErase_64K;  <span class="comment">// 块擦除命令，每次擦除64K字节	</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发送写使能</span></span><br><span class="line">	<span class="keyword">if</span> (QSPI_W25Qxx_WriteEnable() != QSPI_W25Qxx_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_WriteEnable;	<span class="comment">// 写使能失败</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 发出擦除命令</span></span><br><span class="line">	<span class="keyword">if</span> (HAL_QSPI_Command(&amp;hqspi, &amp;s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_Erase;			<span class="comment">// 擦除失败</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 使用自动轮询标志位，等待擦除的结束 </span></span><br><span class="line">	<span class="keyword">if</span> (QSPI_W25Qxx_AutoPollingMemReady() != QSPI_W25Qxx_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_AUTOPOLLING;	<span class="comment">// 轮询等待无响应</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> QSPI_W25Qxx_OK;		<span class="comment">// 擦除成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> <span class="title">QSPI_W25Qxx_ChipErase</span> <span class="params">(<span class="keyword">void</span>)</span>	</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QSPI_CommandTypeDef s_command;		<span class="comment">// QSPI传输配置</span></span><br><span class="line">	QSPI_AutoPollingTypeDef s_config;	<span class="comment">// 轮询等待配置参数</span></span><br><span class="line"></span><br><span class="line">	s_command.InstructionMode   	= QSPI_INSTRUCTION_1_LINE;    <span class="comment">// 1线指令模式</span></span><br><span class="line">	s_command.AddressSize       	= QSPI_ADDRESS_24_BITS;       <span class="comment">// 24位地址模式</span></span><br><span class="line">	s_command.AlternateByteMode 	= QSPI_ALTERNATE_BYTES_NONE;  <span class="comment">//	无交替字节 </span></span><br><span class="line">	s_command.DdrMode           	= QSPI_DDR_MODE_DISABLE;      <span class="comment">// 禁止DDR模式</span></span><br><span class="line">	s_command.DdrHoldHalfCycle  	= QSPI_DDR_HHC_ANALOG_DELAY;  <span class="comment">// DDR模式中数据延迟，这里用不到</span></span><br><span class="line">	s_command.SIOOMode          	= QSPI_SIOO_INST_EVERY_CMD;	<span class="comment">// 每次传输数据都发送指令</span></span><br><span class="line">	s_command.AddressMode 			= QSPI_ADDRESS_NONE;       	<span class="comment">// 无地址</span></span><br><span class="line">	s_command.DataMode 				= QSPI_DATA_NONE;             <span class="comment">// 无数据</span></span><br><span class="line">	s_command.DummyCycles 			= <span class="number">0</span>;                          <span class="comment">// 空周期个数</span></span><br><span class="line">	s_command.Instruction	 		= W25Qxx_CMD_ChipErase;       <span class="comment">// 擦除命令，进行整片擦除</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发送写使能	</span></span><br><span class="line">	<span class="keyword">if</span> (QSPI_W25Qxx_WriteEnable() != QSPI_W25Qxx_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_WriteEnable;	<span class="comment">// 写使能失败</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 发出擦除命令</span></span><br><span class="line">	<span class="keyword">if</span> (HAL_QSPI_Command(&amp;hqspi, &amp;s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_Erase;		 <span class="comment">// 擦除失败</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不停的查询 W25Qxx_CMD_ReadStatus_REG1 寄存器，将读取到的状态字节中的 W25Qxx_Status_REG1_BUSY 不停的与0作比较</span></span><br><span class="line"><span class="comment">// 读状态寄存器1的第0位（只读），Busy标志位，当正在擦除/写入数据/写命令时会被置1，空闲或通信结束为0</span></span><br><span class="line">	</span><br><span class="line">	s_config.Match           = <span class="number">0</span>;   									<span class="comment">//	匹配值</span></span><br><span class="line">	s_config.MatchMode       = QSPI_MATCH_MODE_AND;	      	<span class="comment">//	与运算</span></span><br><span class="line">	s_config.Interval        = <span class="number">0x10</span>;	                     	<span class="comment">//	轮询间隔</span></span><br><span class="line">	s_config.AutomaticStop   = QSPI_AUTOMATIC_STOP_ENABLE;	<span class="comment">// 自动停止模式</span></span><br><span class="line">	s_config.StatusBytesSize = <span class="number">1</span>;	                        	<span class="comment">//	状态字节数</span></span><br><span class="line">	s_config.Mask            = W25Qxx_Status_REG1_BUSY;	   <span class="comment">// 对在轮询模式下接收的状态字节进行屏蔽，只比较需要用到的位</span></span><br><span class="line">	</span><br><span class="line">	s_command.Instruction    = W25Qxx_CMD_ReadStatus_REG1;	<span class="comment">// 读状态信息寄存器</span></span><br><span class="line">	s_command.DataMode       = QSPI_DATA_1_LINE;					<span class="comment">// 1线数据模式</span></span><br><span class="line">	s_command.NbData         = <span class="number">1</span>;										<span class="comment">// 数据长度</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// W25Q64整片擦除的典型参考时间为20s，最大时间为100s，这里的超时等待值 W25Qxx_ChipErase_TIMEOUT_MAX 为 100S</span></span><br><span class="line">	<span class="keyword">if</span> (HAL_QSPI_AutoPolling(&amp;hqspi, &amp;s_command, &amp;s_config, W25Qxx_ChipErase_TIMEOUT_MAX) != HAL_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_AUTOPOLLING;	 <span class="comment">// 轮询等待无响应</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> QSPI_W25Qxx_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写入 */</span></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> <span class="title">QSPI_W25Qxx_WritePage</span><span class="params">(<span class="keyword">uint8_t</span>* pBuffer, <span class="keyword">uint32_t</span> WriteAddr, <span class="keyword">uint16_t</span> NumByteToWrite)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QSPI_CommandTypeDef s_command;	<span class="comment">// QSPI传输配置	</span></span><br><span class="line">	</span><br><span class="line">	s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;    		<span class="comment">// 1线指令模式</span></span><br><span class="line">	s_command.AddressSize       = QSPI_ADDRESS_24_BITS;            <span class="comment">// 24位地址</span></span><br><span class="line">	s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;  		<span class="comment">// 无交替字节 </span></span><br><span class="line">	s_command.DdrMode           = QSPI_DDR_MODE_DISABLE;     		<span class="comment">// 禁止DDR模式</span></span><br><span class="line">	s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY; 		<span class="comment">// DDR模式中数据延迟，这里用不到</span></span><br><span class="line">	s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;			<span class="comment">// 每次传输数据都发送指令	</span></span><br><span class="line">	s_command.AddressMode 		 = QSPI_ADDRESS_1_LINE; 				<span class="comment">// 1线地址模式</span></span><br><span class="line">	s_command.DataMode    		 = QSPI_DATA_4_LINES;    				<span class="comment">// 4线数据模式</span></span><br><span class="line">	s_command.DummyCycles 		 = <span class="number">0</span>;                    				<span class="comment">// 空周期个数</span></span><br><span class="line">	s_command.NbData      		 = NumByteToWrite;      			   <span class="comment">// 数据长度，最大只能256字节</span></span><br><span class="line">	s_command.Address     		 = WriteAddr;         					<span class="comment">// 要写入 W25Qxx 的地址</span></span><br><span class="line">	s_command.Instruction 		 = W25Qxx_CMD_QuadInputPageProgram; <span class="comment">// 1-1-4模式下(1线指令1线地址4线数据)，页编程指令</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 写使能</span></span><br><span class="line">	<span class="keyword">if</span> (QSPI_W25Qxx_WriteEnable() != QSPI_W25Qxx_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_WriteEnable;	<span class="comment">// 写使能失败</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 写命令</span></span><br><span class="line">	<span class="keyword">if</span> (HAL_QSPI_Command(&amp;hqspi, &amp;s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_TRANSMIT;		<span class="comment">// 传输数据错误</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 开始传输数据</span></span><br><span class="line">	<span class="keyword">if</span> (HAL_QSPI_Transmit(&amp;hqspi, pBuffer, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_TRANSMIT;		<span class="comment">// 传输数据错误</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 使用自动轮询标志位，等待写入的结束 </span></span><br><span class="line">	<span class="keyword">if</span> (QSPI_W25Qxx_AutoPollingMemReady() != QSPI_W25Qxx_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_AUTOPOLLING; <span class="comment">// 轮询等待无响应</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> QSPI_W25Qxx_OK;	<span class="comment">// 写数据成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> <span class="title">QSPI_W25Qxx_WriteBuffer</span><span class="params">(<span class="keyword">uint8_t</span>* pBuffer, <span class="keyword">uint32_t</span> WriteAddr, <span class="keyword">uint32_t</span> Size)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="keyword">uint32_t</span> end_addr, current_size, current_addr;</span><br><span class="line">	<span class="keyword">uint8_t</span> *write_data;  <span class="comment">// 要写入的数据</span></span><br><span class="line"></span><br><span class="line">	current_size = W25Qxx_PageSize - (WriteAddr % W25Qxx_PageSize); <span class="comment">// 计算当前页还剩余的空间</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (current_size &gt; Size)	<span class="comment">// 判断当前页剩余的空间是否足够写入所有数据</span></span><br><span class="line">	&#123;</span><br><span class="line">		current_size = Size;		<span class="comment">// 如果足够，则直接获取当前长度</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	current_addr = WriteAddr;		<span class="comment">// 获取要写入的地址</span></span><br><span class="line">	end_addr = WriteAddr + Size;	<span class="comment">// 计算结束地址</span></span><br><span class="line">	write_data = pBuffer;			<span class="comment">// 获取要写入的数据</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 发送写使能</span></span><br><span class="line">		<span class="keyword">if</span> (QSPI_W25Qxx_WriteEnable() != QSPI_W25Qxx_OK)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> W25Qxx_ERROR_WriteEnable;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 按页写入数据</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(QSPI_W25Qxx_WritePage(write_data, current_addr, current_size) != QSPI_W25Qxx_OK)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> W25Qxx_ERROR_TRANSMIT;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 使用自动轮询标志位，等待写入的结束 </span></span><br><span class="line">		<span class="keyword">else</span> 	<span class="keyword">if</span> (QSPI_W25Qxx_AutoPollingMemReady() != QSPI_W25Qxx_OK)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> W25Qxx_ERROR_AUTOPOLLING;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span> <span class="comment">// 按页写入数据成功，进行下一次写数据的准备工作</span></span><br><span class="line">		&#123;</span><br><span class="line">			current_addr += current_size;	<span class="comment">// 计算下一次要写入的地址</span></span><br><span class="line">			write_data += current_size;	<span class="comment">// 获取下一次要写入的数据存储区地址</span></span><br><span class="line">			<span class="comment">// 计算下一次写数据的长度</span></span><br><span class="line">			current_size = ((current_addr + W25Qxx_PageSize) &gt; end_addr) ? (end_addr - current_addr) : W25Qxx_PageSize;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (current_addr &lt; end_addr) ; <span class="comment">// 判断数据是否全部写入完毕</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> QSPI_W25Qxx_OK;	<span class="comment">// 写入数据成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取 */</span></span><br><span class="line"><span class="function"><span class="keyword">int8_t</span> <span class="title">QSPI_W25Qxx_ReadBuffer</span><span class="params">(<span class="keyword">uint8_t</span>* pBuffer, <span class="keyword">uint32_t</span> ReadAddr, <span class="keyword">uint32_t</span> NumByteToRead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QSPI_CommandTypeDef s_command;	<span class="comment">// QSPI传输配置</span></span><br><span class="line">	</span><br><span class="line">	s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;    		<span class="comment">// 1线指令模式</span></span><br><span class="line">	s_command.AddressSize       = QSPI_ADDRESS_24_BITS;            <span class="comment">// 24位地址</span></span><br><span class="line">	s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;  		<span class="comment">// 无交替字节 </span></span><br><span class="line">	s_command.DdrMode           = QSPI_DDR_MODE_DISABLE;     		<span class="comment">// 禁止DDR模式</span></span><br><span class="line">	s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY; 		<span class="comment">// DDR模式中数据延迟，这里用不到</span></span><br><span class="line">	s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;			<span class="comment">// 每次传输数据都发送指令	</span></span><br><span class="line">	s_command.AddressMode 		 = QSPI_ADDRESS_4_LINES; 				<span class="comment">// 4线地址模式</span></span><br><span class="line">	s_command.DataMode    		 = QSPI_DATA_4_LINES;    				<span class="comment">// 4线数据模式</span></span><br><span class="line">	s_command.DummyCycles 		 = <span class="number">6</span>;                    				<span class="comment">// 空周期个数</span></span><br><span class="line">	s_command.NbData      		 = NumByteToRead;      			   	<span class="comment">// 数据长度，最大不能超过flash芯片的大小</span></span><br><span class="line">	s_command.Address     		 = ReadAddr;         					<span class="comment">// 要读取 W25Qxx 的地址</span></span><br><span class="line">	s_command.Instruction 		 = W25Qxx_CMD_FastReadQuad_IO; 		<span class="comment">// 1-4-4模式下(1线指令4线地址4线数据)，快速读取指令</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 发送读取命令</span></span><br><span class="line">	<span class="keyword">if</span> (HAL_QSPI_Command(&amp;hqspi, &amp;s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_TRANSMIT;		<span class="comment">// 传输数据错误</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//	接收数据</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (HAL_QSPI_Receive(&amp;hqspi, pBuffer, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_TRANSMIT;		<span class="comment">// 传输数据错误</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用自动轮询标志位，等待接收的结束 </span></span><br><span class="line">	<span class="keyword">if</span> (QSPI_W25Qxx_AutoPollingMemReady() != QSPI_W25Qxx_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> W25Qxx_ERROR_AUTOPOLLING; <span class="comment">// 轮询等待无响应</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> QSPI_W25Qxx_OK;	<span class="comment">// 读取数据成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，使用HAL库函数调用QSPI执行简单读写的基本方式是**==【QSPI传输配置】——【发送相关命令】——【读取回复】——【执行操作】——【等待接收完毕】==**</p>
<p>简单读写一般采用下面的方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">QSPI_Status=QSPI_W25Qxx_ReadBuffer(W25Qxx_ReadBuffer,W25Qxx_TestAddr,W25Qxx_NumByteToTest);<span class="comment">//读取数据</span></span><br><span class="line">QSPI_Status=QSPI_W25Qxx_BlockErase_32K(W25Qxx_TestAddr);<span class="comment">//擦除32K字节,也可以调用上面.c文件里的其他擦除函数</span></span><br><span class="line">QSPI_Status=QSPI_W25Qxx_WriteBuffer(W25Qxx_WriteBuffer,W25Qxx_TestAddr,W25Qxx_NumByteToTest);<span class="comment">//写入数据</span></span><br></pre></td></tr></table></figure>

<p>在软件中加入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">QSPI_Status = QSPI_W25Qxx_MemoryMappedMode();</span><br></pre></td></tr></table></figure>

<p>即可在各模式之间切换，应当注意：<strong>内存映射模式下，SPI FLASH只读</strong>，使用以下指令进行读取</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(W25Qxx_ReadBuffer,(<span class="keyword">uint8_t</span> *)W25Qxx_Mem_Addr+W25Qxx_TestAddr,W25Qxx_NumByteToTest);</span><br><span class="line"><span class="comment">//从 QSPI_Mem_Addr +W25Qxx_TestAddr 地址处复制数据到 W25Qxx_ReadBuffer</span></span><br></pre></td></tr></table></figure>

<p>如果需要开启DMA，在.c文件中加入MDMA相关配置即可，如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MDMA_HandleTypeDef QSPI_MDMA_Handle;<span class="comment">//定义MDMA句柄</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MX_MDMA_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__HAL_RCC_MDMA_CLK_ENABLE(); <span class="comment">// 开启MDMA化时钟</span></span><br><span class="line"></span><br><span class="line">	QSPI_MDMA_Handle.Instance = MDMA_Channel1; <span class="comment">// 使用通道1</span></span><br><span class="line">	QSPI_MDMA_Handle.Init.TransferTriggerMode = MDMA_BUFFER_TRANSFER; <span class="comment">// 使用缓冲区传输	</span></span><br><span class="line">	QSPI_MDMA_Handle.Init.BufferTransferLength 	= <span class="number">128</span>; <span class="comment">// 缓冲区单次传输数据长度，最大128字节</span></span><br><span class="line">	QSPI_MDMA_Handle.Init.Priority = MDMA_PRIORITY_VERY_HIGH; <span class="comment">// 优先级最高</span></span><br><span class="line">	QSPI_MDMA_Handle.Init.Request = MDMA_REQUEST_QUADSPI_FIFO_TH; <span class="comment">// FIFO阈值触发中断请求</span></span><br><span class="line">	QSPI_MDMA_Handle.Init.Endianness = MDMA_LITTLE_ENDIANNESS_PRESERVE; <span class="comment">// 小端字节格式，不使用交换</span></span><br><span class="line">	QSPI_MDMA_Handle.Init.DataAlignment = MDMA_DATAALIGN_PACKENABLE; <span class="comment">// 所有字节右对齐，使用小端格式	</span></span><br><span class="line">	QSPI_MDMA_Handle.Init.SourceInc = MDMA_SRC_INC_BYTE; <span class="comment">// 源地址按照字节递增(8 bits)</span></span><br><span class="line">	QSPI_MDMA_Handle.Init.SourceDataSize = MDMA_SRC_DATASIZE_BYTE; <span class="comment">// 源地址数据宽度为1字节(8 bits)</span></span><br><span class="line">	QSPI_MDMA_Handle.Init.SourceBurst = MDMA_SOURCE_BURST_SINGLE; <span class="comment">// 源数据单次突发传输</span></span><br><span class="line">	QSPI_MDMA_Handle.Init.DestinationInc = MDMA_DEST_INC_DISABLE; <span class="comment">// 禁止目标地址自增 </span></span><br><span class="line">	QSPI_MDMA_Handle.Init.DestDataSize = MDMA_DEST_DATASIZE_BYTE; <span class="comment">// 目标地址数据宽度为1字节(8 bits)</span></span><br><span class="line">	QSPI_MDMA_Handle.Init.DestBurst = MDMA_DEST_BURST_SINGLE; <span class="comment">// 目标数据单次突发传输</span></span><br><span class="line"></span><br><span class="line">	__HAL_LINKDMA(&amp;hqspi, hmdma, QSPI_MDMA_Handle); <span class="comment">// 关联MDMA句柄</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 应用配置</span></span><br><span class="line">	HAL_MDMA_Init(&amp;QSPI_MDMA_Handle);</span><br><span class="line"></span><br><span class="line">	HAL_NVIC_SetPriority(MDMA_IRQn, <span class="number">0x0E</span>, <span class="number">0</span>); <span class="comment">// 设置MDMA中断优先级</span></span><br><span class="line">	HAL_NVIC_EnableIRQ(MDMA_IRQn); <span class="comment">// 使能MDMA中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在QSPI_W25Qxx_Init()中加入MDMA初始化</span></span><br><span class="line">MX_MDMA_Init();<span class="comment">// MDMA初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//加入MDMA中断回调函数用于标识QSPI接收结束</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_QSPI_RxCpltCallback</span><span class="params">(QSPI_HandleTypeDef *hqspi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QSPI_RX_Status = <span class="number">1</span>;  <span class="comment">// 当进入此中断函数时，说明QSPI接收完成，将标志变量置1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将接收函数的if (HAL_QSPI_Receive(&amp;hqspi, pBuffer, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)都改成if (HAL_QSPI_Receive_DMA(&amp;hqspi, pBuffer) != HAL_OK)或类似形式，相当于把基本读取方式改变为等待DMA中断，DMA一旦中断就表明数据收取完毕，CPU再接管数据</span></span><br></pre></td></tr></table></figure>

<p>MDMA中断下，收发数据的应用层接口不变</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">QSPI_Status=QSPI_W25Qxx_WriteBuffer(W25Qxx_WriteBuffer,W25Qxx_TestAddr,W25Qxx_NumByteToTest);<span class="comment">//写入数据</span></span><br><span class="line">QSPI_Status=QSPI_W25Qxx_BlockErase_32K(W25Qxx_TestAddr);<span class="comment">//擦除32K字节</span></span><br><span class="line">QSPI_Status=QSPI_W25Qxx_ReadBuffer(W25Qxx_ReadBuffer,W25Qxx_TestAddr,W25Qxx_NumByteToTest);<span class="comment">//读取数据</span></span><br></pre></td></tr></table></figure>

<h2 id="HAL库的QSPI使用总结"><a href="#HAL库的QSPI使用总结" class="headerlink" title="HAL库的QSPI使用总结"></a>HAL库的QSPI使用总结</h2><ol>
<li>间接模式下，使用QSPI<strong>与使用其他外设一样</strong>，通过寄存器配置，与SPI的使用方法大同小异</li>
<li>自动轮询模式下，通过查询SPI FLASH的状态寄存器来使用，当读取/写入完成后轮询得到器件空闲，即可进行新一轮写入，可以配合MDMA使用，让其自动写入，CPU在中间还能做其他任务，轮询得到可以继续写入后再向buffer中填充写入数据或读取buffer中数据。可以使用<strong>掩码</strong>功能来<strong>匹配状态位</strong></li>
<li>内存映射模式下，将SPI FLASH视为STM32的片上FLASH，可以利用这个功能在片外SPI FLASH中存储程序。读取时使用指针即可，但SPI FLASH==<strong>只读</strong>==</li>
</ol>
<h1 id="W25Qxx系列SPI-FLASH特性"><a href="#W25Qxx系列SPI-FLASH特性" class="headerlink" title="W25Qxx系列SPI FLASH特性"></a>W25Qxx系列SPI FLASH特性</h1><p>详见芯片手册</p>
<p><img src="/2021/11/19/STM32%E5%A4%96%E8%AE%BE%E9%85%8D%E7%BD%AE%E9%80%9F%E6%9F%A5%E3%80%90QSPI%E3%80%91/W25Q64(3).jpg" alt="W25Q64(3)"></p>
<p><img src="/2021/11/19/STM32%E5%A4%96%E8%AE%BE%E9%85%8D%E7%BD%AE%E9%80%9F%E6%9F%A5%E3%80%90QSPI%E3%80%91/W25Q64(1).jpg" alt="W25Q64(1)"></p>
<p><img src="/2021/11/19/STM32%E5%A4%96%E8%AE%BE%E9%85%8D%E7%BD%AE%E9%80%9F%E6%9F%A5%E3%80%90QSPI%E3%80%91/W25Q64(2).jpg" alt="W25Q64(2)"></p>
<ul>
<li>支持标准摩托罗拉SPI协议</li>
<li>支持双线/四线SPI，通过写入IC内部的控制寄存器相关控制位，可将WP和Hold引脚作为IO2、IO3使用</li>
</ul>
<p>相关指令如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写保护</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_WriteEnable		0x06 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_WriteDisable		0x04 </span></span><br><span class="line"><span class="comment">//读写W25Qxx状态寄存器</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_ReadStatusReg1		0x05 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_ReadStatusReg2		0x35 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_ReadStatusReg3		0x15 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_WriteStatusReg1    0x01 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_WriteStatusReg2    0x31 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_WriteStatusReg3    0x11 </span></span><br><span class="line"><span class="comment">//读数据</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_ReadData			0x03 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_FastReadData		0x0B </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_FastReadDual		0x3B </span></span><br><span class="line"><span class="comment">//按页写入</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_PageProgram		0x02 </span></span><br><span class="line"><span class="comment">//擦除</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_BlockErase			0xD8 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_SectorErase		0x20 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_ChipErase			0xC7 </span></span><br><span class="line"><span class="comment">//关闭/低功耗</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_PowerDown			0xB9 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_ReleasePowerDown	0xAB </span></span><br><span class="line"><span class="comment">//ID相关</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_DeviceID			0xAB </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_ManufactDeviceID	0x90 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_JedecDeviceID		0x9F </span></span><br><span class="line"><span class="comment">//4字节地址模式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_Enable4ByteAddr    0xB7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_Exit4ByteAddr      0xE9</span></span><br><span class="line"><span class="comment">//设置读取参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_SetReadParam		0xC0 </span></span><br><span class="line"><span class="comment">//是否使用QSPI模式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_EnterQPIMode       0x38</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W25X_ExitQPIMode        0xFF</span></span><br></pre></td></tr></table></figure>

<p>四字节地址模式：<strong>使用该模式可以访问到W25Q256的所有空间</strong>，对于容量小于等于16MB的SPI FLASH并不需要开启此模式（仅W25Q256可用此模式）</p>
]]></content>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32深入学习【定时器】</title>
    <url>/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="定时器时钟"><a href="#定时器时钟" class="headerlink" title="定时器时钟"></a>定时器时钟</h1><blockquote>
<p>单片机就是定时器！定时器就是单片机！——某个不愿透露姓名的学长</p>
</blockquote>
<p>定时器是单片机的灵魂，学一个单片机，最先掌握的是GPIO，最容易掉坑的是中断控制器，最复杂的是那些总线协议，而最难掌握的就是定时器</p>
<p>这里笔者通过阅读STM32F4xx官方参考手册，配合英文版和中文版整理了与STM32标准外设库有关的定时器知识点（其实大部分是摘抄/翻译原文），经过自己浅薄的经验（半年多的STM32学习经历）梳理得到以下内容，权当抛砖引玉</p>
<p>将外设库源码摘抄附录在结尾，顺序与正文基本一致，可供参考</p>
<span id="more"></span>

<h2 id="内核定时器SYSTICK"><a href="#内核定时器SYSTICK" class="headerlink" title="内核定时器SYSTICK"></a>内核定时器SYSTICK</h2><blockquote>
<p>我心永恒——SysTick</p>
</blockquote>
<p>参考《Cortex M3与M4权威指南》内核定时器部分以获取更多信息</p>
<p>内核定时器SysTick是由ARM规定的包括在Cortex-M内核中的一个定时器，只能像基本定时器一样进行一般的定时功能，偶尔可以配合NVIC实现定时器中断</p>
<p>这个定时器主要用于作为操作系统（RTOS）系统时钟，使用CMSIS规定的库函数或寄存器就可以进行操作，大大增强操作系统的可移植性。下直自己码的简陋RTOS，上到嵌入式Linux都可以使用这个定时器</p>
<h2 id="通用定时器组1"><a href="#通用定时器组1" class="headerlink" title="通用定时器组1"></a>通用定时器组1</h2><blockquote>
<p>通用的就是最好的</p>
</blockquote>
<p>通用定时器由TIM2、TIM3、TIM4、TIM5组成，其中TIM2、5拥有32位自动重载计数器，精度更高；TIM3、4拥有16位自动重载计数器，该计数器由可编程预分频器驱动，<strong>预分频器为16位，分频系数在1到65536之间</strong></p>
<p>支持以下功能</p>
<ul>
<li>通过输入捕获测量输入信号脉冲宽度</li>
<li>可使用外部信号控制定时器</li>
<li>可实现多个定时器互连的同步电路</li>
<li>四个独立的输入捕获、输出比较和PWM输出、单脉冲输出通道</li>
<li>产生DMA请求（触发源包括定时器溢出、初始化、输入捕获、输出比较、触发事件等）</li>
<li>支持驱动编码器和霍尔传感器</li>
<li>外部时钟触发输入或逐周期电流管理</li>
</ul>
<p>所有这些定时器互相完全独立，不共享任何资源，可以让任意两个通用定时器同步工作</p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/image-20210516170041918.png" alt="image-20210516170041918"></p>
<h3 id="时基单元"><a href="#时基单元" class="headerlink" title="时基单元"></a>时基单元</h3><p><strong>定时器的时基单元实际上就是一套用于稳定输出时钟的计数器</strong>，定时器的其他高级功能都是在计数器的基础上实现的</p>
<p>这就是为什么定时器中断、输出PWM、检测输入信号等操作都需要预先设定时基单元</p>
<p>时基单元本身的时钟来自于RCC的TIMxCLK，由APB总线提供；不过也可以设定成由片外电路独立输入，也就是所谓的TIMxETR；甚至也可以用其他定时器触发，这就是“从模式-定时器级联”</p>
<p>时基单元包括：</p>
<ul>
<li><strong>计数器</strong>寄存器 (TIMx_CNT)</li>
<li><strong>预分频器</strong>寄存器 (TIMx_PSC)</li>
<li><strong>自动重载</strong>寄存器 (TIMx_ARR)</li>
</ul>
<p>计数器、自动重载寄存器和预分频器寄存器可通过软件进行读写。即使在计数器运行时也可执行读写操作。</p>
<h4 id="关于计数器重载"><a href="#关于计数器重载" class="headerlink" title="关于计数器重载"></a>关于计数器重载</h4><blockquote>
<p><strong>自动重载寄存器是预装载的</strong>。对自动重载寄存器执行写入或读取操作时会访问<strong>预装载寄存器</strong>。预装载寄存器的内容既可以<strong>直接传送</strong>到<strong>影子寄存器</strong>，也可以在每次<strong>发生更新事件</strong> (UEV) 时传送到影子寄存器——这取决于 TIMx_CR1 寄存器中的自动重载预装载使能位 (ARPE)。当 计数器达到上溢值（或者在递减计数时达到下溢值）并且 TIMx_CR1 寄存器中的 UDIS 位为 0 时，将发送更新事件。<strong>该更新事件也可由软件产生</strong>（称为软件更新事件）</p>
</blockquote>
<p>以上段落就是指时基单元中的计数器值会通过自动重载寄存器对应的影子寄存器进行更新，CPU能操作的是顶层的自动重载寄存器：写入值后，根据自动重载预装载使能位（ARPE）的选项，在发生更新事件后或下一个时钟信号到来时，表层寄存器的值会被复制到影子寄存器，同时计数器寄存器会自动根据影子寄存器的值更新</p>
<h4 id="关于计数器配置"><a href="#关于计数器配置" class="headerlink" title="关于计数器配置"></a>关于计数器配置</h4><blockquote>
<p>计数器由预分频器输出 CK_CNT 提供时钟，仅当 TIMx_CR1 寄存器中的计数器启动位 (CEN) 置 1 时，才会启动计数器<br><strong>真正的计数器使能信号 CNT_EN 在 CEN 置 1 的一个时钟周期后被置 1</strong></p>
</blockquote>
<h4 id="关于预分频器"><a href="#关于预分频器" class="headerlink" title="关于预分频器"></a>关于预分频器</h4><blockquote>
<p>预分频器可对计数器时钟频率进行分频，分频系数介于 1 到 65536 之间（该预分频器基于 16 位/32 位TIMx_PSC寄存器所控制的 16 位计数器），由于该控制寄存器具有缓冲功能，因此<strong>预分频器可实现实时更改</strong>，新的预分频比将在下一更新事件发生时被采用</p>
</blockquote>
<p>所以不仅可以在定时器工作时动态更改计数器值，也可以动态更改分频值</p>
<p>示例时序图如下：</p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/image-20210516170857412.png" alt="image-20210516170857412"></p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/image-20210516170948206.png" alt="image-20210516170948206"></p>
<h3 id="定时器计数模式"><a href="#定时器计数模式" class="headerlink" title="定时器计数模式"></a>定时器计数模式</h3><p>下面的内容都是摘自官方文档</p>
<h4 id="递增模式"><a href="#递增模式" class="headerlink" title="递增模式"></a>递增模式</h4><blockquote>
<p><strong>计数器从0计数（自动+1）到自动重载值，然后重新从0开始计数并生成计数器上溢事件</strong><br><strong>每次发生计数器上溢时会生成更新事件</strong>，将 TIMx_EGR 寄存器中的 UG 位置 1（通过软件或使用从模式控制器）也可以生成更新事件<br>通过软件将 TIMx_CR1 寄存器中的 UDIS 位置 1 可禁止 UEV 事件。这可避免向预装载寄存器写入新值时更新影子寄存器。在 UDIS 位写入 0 之前不会产生任何更新事件，不过计数器和预分频器计数器都会重新从 0 开始计数（而预分频比保持不变）。此外如果 TIMx_CR1 寄存器中的 URS 位（更新请求选择）已置 1，则将 UG 位置 1 会生成更新事件 UEV，但不会将 UIF 标志置 1（因此，不会发送任何中断或 DMA 请求）。这样如果在发生捕获事件时将计数器清零，将不会同时产生更新中断和捕获中断。<br>发生更新事件时，将更新所有寄存器且将更新标志（TIMx_SR 寄存器中的 UIF 位）置 1（取 决于 URS 位）：</p>
<p>● 预分频器的缓冲区中将重新装载预装载值（TIMx_PSC 寄存器的内容）</p>
<p>● 自动重载影子寄存器将以预装载值进行更新</p>
</blockquote>
<h4 id="递减模式"><a href="#递减模式" class="headerlink" title="递减模式"></a>递减模式</h4><blockquote>
<p><strong>计数器从自动重载值开始递减计数到0， 然后重新从自动重载值开始计数并生成计数器下溢事件</strong><br><strong>每次发生计数器下溢时会生成更新事件</strong>，或将 TIMx_EGR 寄存器中的 UG 位置 1（通过软件或使用从模式控制器）也可以生成更新事件<br>通过软件将 TIMx_CR1 寄存器中的 UDIS 位置 1 可禁止 UEV 更新事件。这可避免向预装载寄存器写入新值时更新影子寄存器。在 UDIS 位写入 0 之前不会产生任何更新事件。不过，计数器会重新从当前自动重载值开始计数，而预分频器计数器则重新从 0 开始计数（但预分频比保持不变）。<br>此外如果 TIMx_CR1 寄存器中的 URS 位（更新请求选择）已置 1，则将 UG 位置 1 会生 成更新事件 UEV，但不会将 UIF 标志置 1（因此，不会发送任何中断或 DMA 请求）。这样如果在发生捕获事件时将计数器清零，将不会同时产生更新中断和捕获中断。<br>发生更新事件时，将更新所有寄存器且将更新标志（TIMx_SR 寄存器中的 UIF 位）置 1（取决于 URS 位）：</p>
<p>● 预分频器的缓冲区中将重新装载预装载值（TIMx_PSC 寄存器的内容）。</p>
<p>● 自动重载活动寄存器将以预装载值（TIMx_ARR 寄存器的内容）进行更新。</p>
<p><strong>自动重载寄存器会在计数器重载之前得到更新，因此下一个计数周期就是我们所希望的新的周期长度</strong></p>
</blockquote>
<h4 id="中心对齐"><a href="#中心对齐" class="headerlink" title="中心对齐"></a>中心对齐</h4><blockquote>
<p><strong>在中心对齐模式下，计数器从 0 开始计数到自动重载值-1， 生成计数器上溢事件；然后从自动重载值开始向下计数到 1 并生成计数器下溢事件。之后从 0 开始重新计数</strong>——一个计数周期生成两个上溢事件<br>当 TIMx_CR1 寄存器中的 CMS 位不为“00”时，中心对齐模式有效。将通道配置为输出模式时，其输出比较中断标志将在以下模式下置 1，即：计数器递减计数（中心对齐模式 1， CMS =“01”）、计数器递增计数（中心对齐模式 2，CMS =“10”）以及计数器递增/递 减计数（中心对齐模式 3，CMS =“11”）<br>此模式下无法写入方向位（TIMx_CR1 寄存器中的 DIR 位）；而是<strong>由硬件更新</strong>并指示当前计数器方向。<br>每次发生计数器上溢和下溢时都会生成更新事件，或将 TIMx_EGR 寄存器中的 UG 位置 1 （通过软件或使用从模式控制器）也可以生成更新事件。这种情况下，计数器以及预分频器计数器将重新从 0 开始计数<br>通过软件将 TIMx_CR1 寄存器中的 UDIS 位置 1 可禁止 UEV 更新事件。这可避免向预装载 寄存器写入新值时更新影子寄存器。在 UDIS 位写入 0 之前不会产生任何更新事件。计数器仍会根据当前自动重载值进行递增和递减计数</p>
<p>如果 TIMx_CR1 寄存器中的 URS 位（更新请求选择）已置 1，则将 UG 位置 1 会生 成更新事件 UEV，但不会将 UIF 标志置 1（因此，不会发送任何中断或 DMA 请求）。如果在发生捕获事件时将计数器清零，将不会同时产生更新中断和捕获中断。<br>发生更新事件时，将更新所有寄存器且将更新标志（TIMx_SR 寄存器中的 UIF 位）置 1（取 决于 URS 位）：</p>
<p>● 预分频器的缓冲区中将重新装载预装载值（TIMx_PSC 寄存器的内容）。</p>
<p>● 自动重载活动寄存器将以预装载值 （TIMx_ARR 寄存器的内容）进行更新。注意，如</p>
<p>果更新操作是由计数器上溢触发的，则自动重载寄存器在重载计数器之前更新，下一个计数周期就是我们所希望的新的周期长度（计数器被重载新的值）</p>
</blockquote>
<h3 id="时钟选择"><a href="#时钟选择" class="headerlink" title="时钟选择"></a>时钟选择</h3><p>计数器时钟可以由内部/外部时钟源提供</p>
<h4 id="内部时钟CK-INT"><a href="#内部时钟CK-INT" class="headerlink" title="内部时钟CK_INT"></a>内部时钟CK_INT</h4><p>如果禁止从模式控制器，则CEN、DIR、UG三个寄存器位就充当实际控制位，能且仅能通过软件更改，其中UG位还会自动清零；当CEN=1时，预分频器时钟由内部时钟CK_INT提供</p>
<h4 id="外部时钟模式1"><a href="#外部时钟模式1" class="headerlink" title="外部时钟模式1"></a>外部时钟模式1</h4><p>使用外部输入引脚TIx</p>
<p>当TIMx_SMCR寄存器中的SMS=111时，可选择此模式，计数器可在选定的输入信号出现上升沿或下降沿时计数</p>
<p>如下图所示</p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/image-20210518132306079.png" alt="image-20210518132306079"></p>
<p>使用方法：</p>
<ol>
<li>开启外部时钟输入通道TIx</li>
<li>可选择在TIMx_CCMR1寄存器的ICF[3:0]位写入滤波时间配置，或令ICF=0x0000来禁止滤波</li>
<li>边沿检测器和捕获预分频器不需要进行设置</li>
<li>选择上升沿/下降沿极性有效</li>
<li>配置定时器在外部时钟模式1下工作</li>
<li>选择已经开启的外部时钟输入通道TIx作为输入源</li>
<li>使能计数器</li>
</ol>
<p>配置完毕后，计数器就会在外部输入呈现对应上升沿/下降沿时计数一次并将TIF标志置1</p>
<h4 id="外部时钟模式2"><a href="#外部时钟模式2" class="headerlink" title="外部时钟模式2"></a>外部时钟模式2</h4><p><strong>仅对TIM2、3、4适用</strong></p>
<p>使用外部触发输入ETR</p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/image-20210518132925999.png" alt="image-20210518132925999"></p>
<p>与外部时钟模式1的最大区别就是可以自行配置预分频器来实现“每当ETR出现n个上升沿/下降沿时，计数器计数一次”的效果</p>
<p>同时可能会由于ETRP信号经过重新同步电路而引起ETR上升沿与实际计数器时钟之间的延迟</p>
<p>配置方法：</p>
<ol>
<li>设置滤波器滤波时间</li>
<li>设置ETR预分频器分频系数</li>
<li>选择上升沿/下降沿检测</li>
<li>使能外部时钟模式2</li>
<li>使能计数器</li>
</ol>
<h3 id="外部触发输入——外部触发同步"><a href="#外部触发输入——外部触发同步" class="headerlink" title="外部触发输入——外部触发同步"></a>外部触发输入——外部触发同步</h3><p>定时器可以以复位、门控和触发三种模式与外部触发实现同步</p>
<ol>
<li><p><strong>复位模式（从模式）</strong></p>
<p>当触发输入信号发生变化时，计数器及其预分频器可重新初始化</p>
<p>如果 TIMx_CR1 寄存器中的 URS 位处于低电平，则会生成更新事件 UEV，所有预装载寄存器 （TIMx_ARR 和 TIMx_CCRx）都将更新</p>
</li>
<li><p><strong>门控模式（从模式）</strong></p>
<p>输入信号的电平可用来使能计数器</p>
<p>门控模式作用于电平而非边沿，可设置为高/低电平触发使能定时器计数器</p>
</li>
<li><p><strong>触发模式（从模式）</strong></p>
<p>所选输入上发生某一事件时可以启动计数器，该事件使用软件程序决定，可以通过外设配置寄存器设置</p>
</li>
<li><p><strong>外部时钟模式2+触发模式（从模式）</strong></p>
<p>外部时钟模式 2 可与另一种从模式（外部时钟模式1和编码器模式除外）结合使用</p>
<p>ETR 信号用作外部时钟输入，在复位模式、门控模式或触发模式下工作时，可选择另一个输入作为触发输入，但不建议通过 TIMx_SMCR 寄存器中的 TS 位来选择 ETR 作为 TRGI</p>
</li>
</ol>
<h4 id="内部触发输入——定时器级联与同步"><a href="#内部触发输入——定时器级联与同步" class="headerlink" title="内部触发输入——定时器级联与同步"></a>内部触发输入——定时器级联与同步</h4><p>使用一个定时器作为另一个定时器的预分频器</p>
<p>定时器可以从内部连接在一起以实现定时器同步或级联。当某个定时器配置为主模式时， 可对另一个配置为从模式的定时器的计数器执行复位、启动、停止操作或为其提供时钟</p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/image-20210521225925100.png" alt="image-20210521225925100"></p>
<p>使用时需要注意：</p>
<ol>
<li>一定要设置好主模式定时器与从模式定时器</li>
<li>主模式定时器的输出连接到从模式定时器的输入，不能反接</li>
<li>将主模式和从模式定时器都配置为触发模式</li>
</ol>
<p>这个功能实现比较复杂，可以查阅参考手册中给出的示例程序</p>
<h3 id="捕获-比较通道"><a href="#捕获-比较通道" class="headerlink" title="捕获/比较通道"></a>捕获/比较通道</h3><p>一个定时器时基单元具有四个/三个/两个独立的捕获/比较通道，可以完成更高级的任务</p>
<p>每个捕获/比较通道均附带一个捕获/比较寄存器（包括一个影子寄存器）、一套输入阶段设备（数字滤波器、多路复用器和预分频器）和一套输出阶段设备（比较器和输出控制器）</p>
<p>下图为输入阶段设备结构框图</p>
<p>TIx作为输入进行采样，滤波器生成一个滤波后的信号 TIxF 输出到带有极性选择功能的边沿检测器。边沿检测器会根据配置生成一个上升沿/下降沿信号 (TIxFPx)，该信号可<strong>直接用作从模式控制器的触发输入</strong>（通过一套组合逻辑），也可先进行预分频 (ICxPS)，再进入捕获寄存器</p>
<p>信号可以来自TI1、2、3、4（只要有输入线、滤波器、边沿检测器就可以输入到多路复用器），进而输入到统一的预分频器</p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/image-20210518135027490.png" alt="image-20210518135027490"></p>
<p>下图是捕获/比较通道的主电路结构框图</p>
<p>捕获/比较模块由一个<strong>预装载寄存器</strong>和一个<strong>影子寄存器</strong>组成。始终可通过读写操作访问预装载寄存器。</p>
<p><em>在捕获模式下，<strong>捕获实际发生在影子寄存器中</strong>，然后<strong>将影子寄存器的内容复制到预装载寄存器中</strong></em></p>
<p><em>在比较模式下，<strong>预装载寄存器的内容将复制到影子寄存器中</strong>，然后将影子寄存器的内容<strong>与计数器</strong>进行<strong>比较</strong></em></p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/image-20210518135041953.png" alt="image-20210518135041953"></p>
<p>下图是捕获/比较通道的输出阶段设备</p>
<p>输出阶段的输出模式控制器会根据软件配置和来自主电路的信号生成一个中间基准波形：OCxRef（高电平有效）。这个信号可以经过一个三态门（输出使能电路）到输出捕获，也可以直接输送到主模式控制器</p>
<p>末端的输出使能电路决定最终输出信号的极性。</p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/image-20210518135052372.png" alt="image-20210518135052372"></p>
<h3 id="输入捕获与PWM输入"><a href="#输入捕获与PWM输入" class="headerlink" title="输入捕获与PWM输入"></a>输入捕获与PWM输入</h3><blockquote>
<p>输入捕获模式下，当相应的 ICx 信号被检测到跳变沿后，将使用<strong>捕获/比较寄存器</strong>(TIMx_CCRx)来锁存计数器的值，并触发捕获事件；发生捕获事件时，会将相应的CCXIF标志（TIMx_SR 寄存器）置1， 并可配置发送中断或 DMA 请求</p>
<p>如果发生捕获事件时 CCxIF 标志已处于高位，则会将重复捕获标志 CCxOF（TIMx_SR 寄存器）置1——可通过软件向 CCxIF 写入 0 来给 CCxIF 清零或读取存储在 TIMx_CCRx 寄存器中的已捕获数据——向 CCxOF 写入0后会将其清零</p>
</blockquote>
<p>输入捕获配置步骤如下：</p>
<ol>
<li><p>选择有效输入</p>
<p>TIMx_CCR1 必须连接到 TI1 输入，因此向 TIMx_CCMR1 寄存器中的CC1S 位写入 01——只要 CC1S 不等于 00，就会将通道配置为输入模式，并且 TIMx_CCR1 寄存器将处于只读状态</p>
</li>
<li><p>根据连接到定时器的信号，对所需的输入滤波时间进行编程</p>
<p>如果输入为 TIx 输入之一，则对 TIMx_CCMRx 寄存器中的 ICxF 位进行编程</p>
<p>注意：<strong>滤波时间必须大于输入信号发生抖动的内部时钟周期数</strong></p>
</li>
<li><p>选择输入通道的有效边沿</p>
</li>
<li><p>配置输入信号预分频器</p>
<p>预分频系数决定了累计多少个有效信号边沿后触发一次有效事件</p>
</li>
<li><p>将TIMx_CCER寄存器中的CC1E位置1，让计数器的捕获寄存器被使能</p>
</li>
<li><p>在需要的情况下可以使能中断、DMA请求</p>
<p>使能可以在任何时候通过软件操作外设控制寄存器进行</p>
</li>
</ol>
<p>使用输入捕获时，推荐<strong>在读出捕获溢出标志之前读取数据</strong>，这样可避免丢失在读取捕获溢出标志之后与读取数据之前可能出现的重复捕获信息</p>
<p>PWM输入模式是输入捕获模式的一个特例，用于对输入的PWM信号进行针对性捕获、分析</p>
<p>其实现步骤与输入捕获模式基本相同，仅存在以下不同之处：</p>
<ol>
<li>两个 ICx 信号被映射至同一个 TIx 输入</li>
<li>这两个 ICx 信号在边沿处有效，但极性相反</li>
<li>需要选择两个 TIxFP 信号之一作为触发输入，并将从模式控制器配置为复位模式</li>
</ol>
<h3 id="输出比较与PWM输出"><a href="#输出比较与PWM输出" class="headerlink" title="输出比较与PWM输出"></a>输出比较与PWM输出</h3><p>官方文档的输出比较模式总结如下：</p>
<blockquote>
<p>输出比较用于控制输出波形，或指示已经过某一时间段</p>
<p>当输出捕获/比较寄存器与计数器之间相匹配时，输出比较将进行以下操作：</p>
<ol>
<li>为相应的输出引脚分配一个有可编程输出比较模式和输出极性的输出值。匹配时，输出引脚既可保持其电平 (OCXM=000)，也可设置为有效电平 (OCXM=001)、无效电平(OCXM=010) 或进行翻转 (OCxM=011)</li>
<li>将中断状态寄存器中的标志置1</li>
<li>如果相应中断或DMA使能位置1，将生成中断或发送DMA请求</li>
</ol>
<p>此外，可以将TIMx_CCRx 寄存器配置为带或不带预装载寄存器；输出比较模式下，更新事件 UEV 对 OCxREF 和 OCx 输出毫无影响，同步的精度可以达到计数器的一个计数周期，输出比较模式也可用于输出单脉冲（在单脉冲模式下）</p>
<p>下面是基本使用步骤：</p>
<ol>
<li>选择计数器时钟（内部、外部、预分频器）</li>
<li>如果要生成中断和/或 DMA 请求，将 CCxIE 位和/或 CCxDE 位置 1</li>
<li>选择输出模式。例如，当 CNT 与 CCRx 匹配、未使用预装载 CCRx 并且 OCx 使能且为 高电平有效时，必须写入 OCxM=011、OCxPE=0、CCxP=0 和 CCxE=1 来翻转 OCx 输出引脚。</li>
<li>通过将 TIMx_CR1 寄存器中的 CEN 位置 1 来使能计数器。</li>
</ol>
<p>可随时通过软件更新 TIMx_CCRx 寄存器以控制输出波形，前提是未使能预装载寄存器 （OCxPE=0，否则仅当发生下一个更新事件 UEV 时，才会更新 TIMx_CCRx 影子寄存器）</p>
</blockquote>
<p>PWM模式实际上是基于输出比较模式实现的</p>
<p>利用输出比较模式可以生成PWM信号，<em>信号频率由 TIMx_ARR 寄存器值决定，其占空比则 由 TIMx_CCRx 寄存器值决定</em></p>
<blockquote>
<p>通用定时器具有独立的4个通道用于PWM模式输出，必须通过将 TIMx_CCMRx 寄存器中的 OCxPE 位置 1 使能相应预装载寄存器，再通过将 TIMx_CR1 寄存器中的 ARPE 位置 1 使能自动重载预装载寄存器。由于只有在发生更新事件时预装载寄存器才会传送到影子寄存器，因此启动计数器之前，必须通过将 TIMx_EGR 寄存器中的 UG 位置 1 来初始化所有寄存器。OCx 极性可使用 TIMx_CCER 寄存器的 CCxP 位来编程。既可以设为高电平有效，也可以设为低电平有效。OCx 输出通过将 TIMx_CCER 寄存器中的 CCxE 位置 1 来使能</p>
<p>在PWM模式下，MCU会将TIMx_CNT与TIMx_CCRx进行比较，之后根据计数器计数方向输出特定值。当比较结果发生改变或从“冻结”配置转换回任意PWM模式时，OCREF信号变为有效状态</p>
<p>定时器运行期间，可以通过软件强制 PWM 输出。根据 TIMx_CR1 寄存器中的 CMS 位状态，定时器也能够产生边沿对齐模式或中心对齐模式的 PWM 信号。</p>
</blockquote>
<p>PWM计数模式可配置为递增、递减、中心对齐三种，其中使用中心对齐模式时要注意以下几点：</p>
<ul>
<li>启动中心对齐模式时<strong>将使用当前的递增/递减计数配置</strong>，计数器将根据写入TIMx_CR1 寄存器中 DIR 位的值进行递增或递减计数</li>
<li><strong>不得同时</strong>通过软件<strong>修改</strong>DIR 和 CMS 位</li>
<li>不建议在运行中心对齐模式时对计数器执行<strong>写操作</strong>，否则将发生意想不到的结果</li>
<li>使用中心对齐模式最为保险的方法是：在启动计数器前通过软件生成更新（将 TIMx_EGR寄存器中的 UG 位置 1），并且不要在计数器运行过程中对其执行写操作</li>
</ul>
<h3 id="强制输出模式"><a href="#强制输出模式" class="headerlink" title="强制输出模式"></a>强制输出模式</h3><p>可以通过强制写入输出比较控制寄存器来强制定时器输出特定的电平</p>
<p>不太常用，官方文档介绍如下：</p>
<blockquote>
<p>在输出模式（TIMx_CCMRx 寄存器中的 CCxS 位 = 00）下，可直接由软件将每个输出比较信号（OCxREF 和 OCx）强制设置为有效电平或无效电平，而无需考虑输出比较寄存器和计数器之间的任何比较结果<br>要将输出比较信号 (OCXREF/OCx) 强制设置为有效电平，只需向相应 TIMx_CCMRx 寄存器 中的 OCxM 位写入 101。ocxref 进而强制设置为高电平（OCxREF 始终为高电平有效）， 同时 OCx 获取 CCxP 极性位的相反值<br>例如：CCxP=0（OCx 高电平有效）=&gt; OCx 强制设置为高电平<br>通过向 TIMx_CCMRx 寄存器中的 OCxM 位写入 100，可将 ocxref 信号强制设置为低电平<br>无论如何，TIMx_CCRx 影子寄存器与计数器之间的比较仍会执行，而且允许将标志置 1。 因此可发送相应的中断和 DMA 请求</p>
</blockquote>
<h3 id="单脉冲模式"><a href="#单脉冲模式" class="headerlink" title="单脉冲模式"></a>单脉冲模式</h3><p><strong>单脉冲模式</strong>OPM是基本定时器模式的一个特例</p>
<p>在这种模式下，计数器可以<strong>在一个激励信号的触发下启动</strong>，并可<strong>在一段可编程的延时后产生一个脉宽可编程的脉冲</strong></p>
<p><em>这个模式比较像单稳态触发器逻辑</em></p>
<p>可以通过从模式控制器启动计数器。可以在输出比较模式或 PWM 模式下生成波形。</p>
<p>开启方式：将 TIMx_CR1 寄存器中的 OPM 位置 1，即可选择单脉冲模式。发生下一更新事件 UEV 时，计数器将自动停止。只有当比较值与计数器初始值不同时，才能正确产生一个脉冲。</p>
<p>基本使用方法如下：</p>
<ol>
<li>将 TIxFPx 映射到 TIx，连接输入端口与单脉冲控制器</li>
<li>设置有效边沿极性</li>
<li>配置TIxFPx为从模式控制器的触发（TRGI）</li>
<li>配置触发模式，设置使用TIxFPx来启动计数器</li>
<li>正常配置时基单元</li>
<li>将脉冲发生之前的延迟时间T<del>delay</del>写入TIMx_CCR1寄存器</li>
<li>脉冲长度由自动重载值与比较值之差TIMx_ARR - TIMx_CCR1来定义</li>
</ol>
<p><strong>特例情况——OCx快速使能</strong></p>
<p>单脉冲模式下，TIx 输入的边沿检测会将 CEN 位置 1，表示使能计数器。然后在计数器值与比较值之间发生比较时，将切换输出。</p>
<p>但是完成这些操作需要多个时钟周期，这会限制可能的最小延迟（tDELAY 最小值）。</p>
<p>如果要输出延迟时间最短的波形，可以将 TIMx_CCMRx 寄存器中的 OCxFE 位置 1。这样会强制 OCxRef（和 OCx）对激励信号做出响应，而不再考虑比较的结果。其新电平与发生比较匹配时相同。仅当通道配置为 PWM1 或 PWM2 模式时，OCxFE 才会起作用。</p>
<h3 id="编码器接口模式"><a href="#编码器接口模式" class="headerlink" title="编码器接口模式"></a>编码器接口模式</h3><p>STM32提供了针对编码器控制的计数器优化</p>
<p>TI1 和 TI2 两个输入用于连接增量编码器，如下图所示</p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/image-20210521224858860.png" alt="image-20210521224858860"></p>
<p>使能计数器后，计数器的时钟由TI1FP1或YI2FP2上的<strong>每次有效信号转换</strong>提供。TI1FP1和TI2FP2是进行输入滤波器和极性选择后TI1和TI2的信号，如果不进行滤波和反相，则有TI1FP1=TI1，TI2FP2=TI2，根据两个输入的信号转换序列，定时器产生计数脉冲和方向信号，根据该信号转换序列，计数器相应递增或递减计数，同时硬件对TIMx_CR1寄存器的DIR位进行相应修改。任何输入（TI1 或 TI2）发生信号转换时，都会计算DIR位，无论计数器是仅在TI1或TI2边沿处计数还是同时在TI1和TI2处计数。可通过编程 TIMx_CCER 寄存器的 CC1P 和 CC2P 位选择 TI1 和 TI2 极性</p>
<p><strong>编码器接口模式就相当于带有方向选择的外部时钟</strong>，计数器仅根据方向设定在 0 到 TIMx_ARR 寄存器中的自动重载值之间进行连续计数，在启动前必须先配置 TIMx_ARR。此外捕获、比较、预分频器、触发输出功能继续正常工作。在此模式下，计数器会根据增量编码器的速度和方向自动进行修改，<strong>其内容始终表示编码器的位置</strong></p>
<p>使用该模式，外部增量编码器可直接与 MCU 相连，无需外部接口逻辑；通常使用比较器将编码器的差分输出转换为数字信号来提高抗噪声性能，用于指示机械零位的第三个编码器输出可与外部中断输入相连，用以触发计数器复位</p>
<p>定时器配置为<strong>编码器接口模式</strong>时，会提供传感器当前位置的相关信息。使用<em>另一个</em>配置为<strong>捕获模式</strong>的定时器<strong>测量两个编码器事件之间的周期</strong>，可获得动态信息（速度、加速度和减速度），指示机械零位的编码器输出即可用于此目的。根据两个事件之间的时间间隔，还可定期读取计数器——可以将计数器值锁存到第三个输入捕获寄存器来实现此目的（捕获信号必须为周期性信号，可以由另一个定时器产生）；还可以通过由RTC或其他定时器生成的DMA请求读取计数器值。</p>
<h3 id="特殊配置——发生外部事件时清除OCxREF信号"><a href="#特殊配置——发生外部事件时清除OCxREF信号" class="headerlink" title="特殊配置——发生外部事件时清除OCxREF信号"></a>特殊配置——发生外部事件时清除OCxREF信号</h3><p>对于给定通道，在 ETRF 输入施加高电平（相应 TIMx_CCMRx 寄存器中的 OCxCE 使能位置“1”），可使 OCxREF 信号变为低电平，此后OCxREF 信号将保持低电平直到发生下一更新事件 (UEV)<br>此功能仅能用于输出比较模式和 PWM 模式，不适用于强制输出模式</p>
<h3 id="特殊配置——定时器输入异或"><a href="#特殊配置——定时器输入异或" class="headerlink" title="特殊配置——定时器输入异或"></a>特殊配置——定时器输入异或</h3><p>借助TIMx_CR2寄存器中的TI1S位，可将通道1的输入滤波器连接到<strong>异或门</strong>的输出，从而将TIMx_CH1到TIMx_CH3这三个输入引脚组合在一起。<strong>异或输出可与触发或输入捕获等所有定时器输入功能配合使用</strong></p>
<h2 id="通用定时器组2"><a href="#通用定时器组2" class="headerlink" title="通用定时器组2"></a>通用定时器组2</h2><blockquote>
<p>备份！一定要备份！</p>
</blockquote>
<p>通用定时器由TIM9到TIM14组成，包含一个16位自动重载计数器，该计数器由可编程预分频器驱动</p>
<p>支持的功能和通用定时器组1完全一致，但是少了两个定时器附属多功能通道</p>
<p>结构框图如下所示：</p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/image-20210521231253113.png" alt="image-20210521231253113"></p>
<p>同时这些定时器也难以实现定时器组1能够实现的一些复杂功能，因为它们的控制寄存器、多路选择器被削减了一部分</p>
<p>TIM9和TIM12比较特殊，可以实现其他定时器无法完成的PWM输入、外部触发同步和定时器同步/级联，可以用作定时器组1的补充</p>
<h2 id="高级定时器"><a href="#高级定时器" class="headerlink" title="高级定时器"></a>高级定时器</h2><blockquote>
<p>大外设，体积大，多来几个装不下</p>
</blockquote>
<p>高级定时器由TIM1和TIM8组成，两个定时器共用一个16位自动重载计数器，该计数器由可编程预分频器驱动</p>
<p>支持以下功能</p>
<ul>
<li>通过输入捕获测量输入信号脉冲宽度</li>
<li>生成输出比较和PWM波</li>
<li>生成带死区插入的互补PWM</li>
</ul>
<p>高级定时器和通用定时器彼此完全独立，但两个高级定时器会共享资源</p>
<p>高级定时器和通用定时器可以实现同步功能</p>
<p>高级定时器拥有基本定时器、通用定时器的所有基础功能，并且内置了非常强大（但是在通用控制方面很少用到）的舵机、推进器、飞控、磁编码器等控制功能，可以说<em>一个更比六个强</em>！</p>
<p>下图是高级定时器的结构框图，足以看出其强大性能</p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/image-20210521231849841.png" alt="image-20210521231849841"></p>
<p>下面着重说明TIM1和TIM8与通用定时器不同的地方</p>
<h3 id="重复计数器"><a href="#重复计数器" class="headerlink" title="重复计数器"></a>重复计数器</h3><p>高级定时器配备了一个<strong>重复计数器</strong>，只有当重复计数器达到零时，才会生成更新事件</p>
<p>每当发生N+1个计数器上溢或下溢（其中N是TIMx_RCR重复计数器寄存器中的值），数据就将从预装载寄存器转移到影子寄存器（TIMx_ARR自动重载寄存器、 TIMx_PSC预分频器寄存器以及比较模式下的TIMx_CCRx捕获/比较寄存器）中</p>
<p>重复计数器是自动重载类型，其重复率为TIMx_RCR寄存器所定义的值，它允许的定时器计数器重载最大重复次数不超过128个，每个PWM周期内可实现更新占空比两次。当在中心对齐模式下，每个PWM周期仅刷新一次比较寄存器时，由于模式的对称性，最大分辨率为2xTck</p>
<p>重复计数器在下列情况下递减：</p>
<ol>
<li>递增计数模式下的每个计数器上溢</li>
<li>递减计数模式下的每个计数器下溢</li>
<li>中心对齐模式下每个计数器上溢和计数器下溢</li>
</ol>
<p>特别地，更新时间可以由软件或硬件人为生成，重复计数器会根据更新事件重新装载</p>
<p>中心对齐模式下如果RCR值为奇数，更新事件将在上溢或下溢时发生，这取决于何时写入RCR寄存器以及何时启动计数器：如果在启动计数器前写入RCR，则UEV在上溢时发生；如果在启动计数器后写入RCR，则UEV在下溢时发生</p>
<h3 id="特化的PWM输出模式"><a href="#特化的PWM输出模式" class="headerlink" title="特化的PWM输出模式"></a>特化的PWM输出模式</h3><p>根据TIMx_CR1寄存器中的CMS位状态，高级定时器能够产生<strong>边沿对齐模式</strong>或<strong>中心对齐模式</strong>的PWM信号</p>
<p>详情见参考手册，基本就是字面意思</p>
<h3 id="互补输出与死区插入"><a href="#互补输出与死区插入" class="headerlink" title="互补输出与死区插入"></a>互补输出与死区插入</h3><p>TIM1和TIM8可以输出两路互补信号，并管理输出的关断与接通瞬间（死区时间），用户可以根据与输出相连接的器件及其特性（电平转换器的固有延迟、开关器件产生的延迟等等）来调整死区时间做到精准控制。每路输出可以独立选择输出极性（主输出OCx或互补输出OCxN），通过对TIMx_CCER寄存器中的CCxP和CCxNP位执行写操作来完成极性选择。</p>
<p>互补信号 OCx 和 OCxN 通过</p>
<ol>
<li>TIMx_CCER 寄存器中的 CCxE 和 CCxNE 位</li>
<li>TIMx_BDTR 和 TIMx_CR2 寄存器中的 MOE、OISx、OISxN、OSSI 和 OSSR 位</li>
</ol>
<p>以上控制位的组合进行激活。需要注意：切换至IDLE（MOE下降到0）的时刻，死区仍然有效</p>
<p>CCxE 和 CCxNE 位同时置 1 并且 MOE 位置 1（如果存在断路）时，使能死区插入。TIMx_BDTR 寄存器中的 DTG[7:0] 位用于控制所有通道的死区生成。高级定时器将基于参考波形 OCxREF 生成 2 个输出 OCx 和 OCxN。</p>
<p>示例：OCx 和 OCxN 为高电平有效时，</p>
<ul>
<li>输出信号 OCx 与参考信号相同，只是其上升沿相对参考上升沿存在延迟。</li>
<li>输出信号 OCxN 与参考信号相反，并且其上升沿相对参考下降沿存在延迟。</li>
<li>如果延迟时间大于有效输出（OCx 或 OCxN）的宽度，则不会产生相应的脉冲</li>
</ul>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/image-20210522103114232.png" alt="image-20210522103114232"></p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/image-20210522103127846.png" alt="image-20210522103127846"><br>在输出模式（包括强制输出模式、输出比较模式和PWM模式）下，通过配置 TIMx_CCER 寄存 器中的 CCxE 和 CCxNE 位，可将 OCxREF 重定向到 OCx 输出或 OCxN 输出。通过此功能，可以在一个输出上发送特定波形（如PWM或静态有效电平)，而同时使互补输出保持无效电平；或者使两个输出同时保持无效电平；或者两个输出同时处于有效电平，两者互补并且带死区。</p>
<p>注意：如果仅使能 OCxN (CCxE=0, CCxNE=1)，两者不互补，一旦 OCxREF 为高电平，OCxN 即变为有效</p>
<p>示例：如果 CCxNP=0，则 OCxN=OCxRef。另一方面，如果同时使能 OCx 和 OCxN (CCxE=CCxNE=1)，OCx 在 OCxREF 为高电平时变为有效，而 OCxN 则与之互补， 在 OCxREF 为低电平时变为有效。</p>
<h3 id="断路功能"><a href="#断路功能" class="headerlink" title="断路功能"></a>断路功能</h3><blockquote>
<p>使用断路功能时，根据其它控制位（TIMx_BDTR 寄存器中的 MOE、OSSI 和 OSSR 位以及 TIMx_CR2 寄存器中的 OISx 和 OISxN 位）修改输出使能信号和无效电平。断路源可以是断路输入引脚，也可以是时钟故障事件，后者由复位时钟控制器中的时钟安全系统 (CSS) 生成</p>
<p>注意：任何情况下， OCx 和 OCxN 输出都不能同时置为有效电平<br>退出复位状态后，断路功能处于禁止状态，MOE 位处于低电平。将 TIMx_BDTR 寄存器 中的 BKE 位置 1，可使能断路功能。断路输入的极性可通过该寄存器中的 BKP 位来选择。BKE 和 BKP 位可同时修改。对 BKE 和 BKP 位执行写操作时，写操作会在 1 个 APB 时钟周期的延迟后生效。因此，执行写操作后，需要等待 1 个 APB 时钟周期，才能准确回读该位。</p>
<p>由于 MOE 下降沿可能是异步信号，因此在实际信号（作用于输出）与同步控制位（位于 TIMx_BDTR 寄存器中）之间插入了再同步电路，从而在异步信号与同步信号之间产生延迟。例如：如果在 MOE 处于低电平时向其写入 1，则必须首先插入延迟（空指令）， 才能准确进行读取——因为写入的是异步信号，而读取的却是同步信号。<br>发生断路（断路输入上出现所选电平）时需要执行以下操作：</p>
<ul>
<li><p>MOE 位异步清零，使输出处于无效状态、空闲状态或复位状态</p>
<p>即使 MCU 振荡器关闭，该功能仍然有效</p>
</li>
<li><p>MOE=0 时，将以 TIMx_CR2 寄存器 OISx 位中编程的电平驱动每个输出通道；如果OSSI=0，则定时器将释放使能输出，否则使能输出始终保持高电平</p>
</li>
</ul>
<p>除断路输入和输出管理外，断路电路内部还实施了写保护，用以保护应用的安全，用户可冻结多个参数配置</p>
<p>使用互补输出时电路会自动遵守以下原则：</p>
<ol>
<li>输出首先置于复位状态或无效状态</li>
<li>如果定时器时钟仍存在，则将重新激活死区发生器，在死区后以OISx和OISxN位中编程的电平驱动输出。即使在这种情况下，也不能同时将OCx和OCxN驱动至其有效电平。MOE会进行再同步，因此死区的持续时间会比通常情况长一些</li>
<li>如果 OSSI=0，则定时器会释放使能输出，否则只要 CCxE 位或 CCxNE 位处于高电平，使能输出就会保持或变为高电平、</li>
<li>可以通过配置寄存器使用定时器中断或DMA请求</li>
<li>如果TIMx_BDTR寄存器中的AOE位置1，则MOE位会在发生下一更新事件(UEV)时自动再次置1</li>
</ol>
<p>断路输入为电平有效。因此当断路输入有效电平时，不能将 MOE 位置 1（自动或通过软件都不行），也不能将状态标志 BIF 清零。断路可由 BRK 输入生成，该输入具有可编程极性，其使能位 BKE 位于 TIMx_BDTR 寄存器中</p>
<p>断路有两种生成方案：</p>
<ol>
<li>使用BRK输入生成，该输入具有可编程极性，其使能位 BKE 位于 TIMx_BDTR 寄存器中</li>
<li>由软件通过 TIMx_EGR 寄存器中的 BG 位生成</li>
</ol>
</blockquote>
<h3 id="生成六路互补PWM"><a href="#生成六路互补PWM" class="headerlink" title="生成六路互补PWM"></a>生成六路互补PWM</h3><p>可用于驱动三相交流异步电动机</p>
<p>当通道使用互补输出时，在OCxM、CCxE 和 CCxNE 位上提供预装载位。发生COM换向事件时，这些预装载位将传输到影子位。用户可以预先编程下一步骤的配置，并同时更改所有通道的配置。COM可由软件通过将 TIMx_EGR 寄存器中的 COM 位置 1 而生成，也可以由硬件在 TRGI 上升沿生成<br>发生 COM 事件时，TIMx_SR 寄存器中的 COMIF 位将会置 1。可以使用中断或DMA请求</p>
<h3 id="霍尔传感器驱动"><a href="#霍尔传感器驱动" class="headerlink" title="霍尔传感器驱动"></a>霍尔传感器驱动</h3><p>高级定时器最重要的功能之一就是直接驱动霍尔传感器</p>
<p>需要通过用于<strong>生成电机驱动 PWM 信号的高级控制定时器</strong>（TIM1、TIM8）以及中称为 “<strong>接口定时器</strong>”的<strong>另一个通用定时器</strong> TIMx（TIM2、TIM3、TIM4 或 TIM5），实现与霍尔传感器的连接。</p>
<p>连接要点如下所示：</p>
<ul>
<li><p>3个高级定时器的输入引脚TIMx_CH1、TIMx_CH2 和 TIMx_CH3通过<strong>异或门</strong>连接到TI1输入通道（通过将TIMx_CR2寄存器中的TI1S位置1来选择），由“接口定时器” 进行捕获</p>
</li>
<li><p>从模式控制器配置为复位模式，从输入设置为 TI1F_ED</p>
<p>每当3个输入中有一个输入发生切换时，计数器会从0开始重新计数。这样将产生由霍尔输入的任何变化而触发的时基</p>
</li>
<li><p>在“接口定时器”上，捕获/比较通道1配置为捕获模式，捕获信号为TRC。<strong>捕获值对应于输入上两次变化的间隔时间</strong>，可提供与电机转速相关的信息</p>
</li>
<li><p>“接口定时器”可用于在输出模式下产生脉冲，以通过触发 COM 事件更改高级控制定时器 （TIM1 或 TIM8）各个通道的配置</p>
</li>
<li><p>TIM1 定时器用于生成电机驱动 PWM 信号</p>
</li>
<li><p>必须对接口定时器通道进行编程，以便在编程的延迟过后产生正脉冲，该脉冲通过TRGO输出发送到高级控制定时器（TIM1 或 TIM8）</p>
</li>
</ul>
<p>在高级控制定时器TIM1中，必须选择正确的 ITR 输入作为触发输入，定时器编程为可产生 PWM 信号，捕获/比较控制信号进行预装载（TIMx_CR2 寄存器的 CCPC=1），并且 COM 事件由触发输入控制（TIMx_CR2 寄存器中 CCUS=1）。发生 COM 事件后，在 PWM 控制 位（CCxE、OCxM）中写入下一步的配置，此操作可在由 OC2REF 上升沿产生的中断子程序中完成。</p>
<p>示例程序的时序图如下：</p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/image-20210522104705636.png" alt="image-20210522104705636"></p>
<h2 id="基本定时器"><a href="#基本定时器" class="headerlink" title="基本定时器"></a>基本定时器</h2><blockquote>
<p>别鞭尸了，有种比比销量——8051</p>
</blockquote>
<p>基本定时器由TIM6和TIM7组成，包含一个16位自动重载计数器，该计数器由可编程预分频器驱动</p>
<p>可以用作通用定时器生成时基，也可以专用于驱动DAC——这两个定时器内部直连DAC并能够通过它触发输出驱动DAC，也就是说<strong>TIM6和TIM7可以用作“模拟输出”</strong></p>
<p>两个定时器彼此完全独立，不共享资源</p>
<p><img src="/2021/11/19/STM32%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E3%80%90%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%91/image-20210521231037664.png" alt="image-20210521231037664"></p>
<p>基本定时器的结构非常简单，形如其名——只有定时器的基本功能</p>
<p><strong>基本定时器适合于单纯需要定时的场合，因此常被用来当作备用的“SysTick”</strong></p>
<p>如果定时器资源不够用，不妨将简单的定时任务交给TIM6、7完成</p>
<h1 id="STM32的STP定时器库函数"><a href="#STM32的STP定时器库函数" class="headerlink" title="STM32的STP定时器库函数"></a>STM32的STP定时器库函数</h1><blockquote>
<p>从STP换到HAL，没想到愣是没有一丝改变</p>
</blockquote>
<p>STM32的定时器库函数<strong>非常多</strong></p>
<p>这里作以下基本梳理（大多是从.c文件开头的注释翻译整理）</p>
<h2 id="库函数的基本使用方法"><a href="#库函数的基本使用方法" class="headerlink" title="库函数的基本使用方法"></a>库函数的基本使用方法</h2><p>库函数被分成了9组功能，如下所示</p>
<h3 id="TIM时基管理"><a href="#TIM时基管理" class="headerlink" title="TIM时基管理"></a>TIM时基管理</h3><p>ST提供了一些库函数用来管理定时器的基础设置</p>
<p>时基管理的使用方法很简单，如下所示</p>
<blockquote>
<ol>
<li>使用RCC_APBxPeriphClockCmd(RCC_APBxPeriph_TIMx, ENABLE)函数开启定时器时钟</li>
<li>使用设定好的参数设置定时器初始化结构体</li>
<li>使用TIM_TimeBaseInit()函数来应用定时器时基设置</li>
<li>如果需要产生TIM更新中断，还需要使能NVIC并进行相关配置</li>
<li>使用TIM_ITConfig(TIMx, TIM_IT_Update)函数配置中断服务函数</li>
<li>使用TIM_Cmd(ENABLE)函数使能TIM计数器</li>
</ol>
</blockquote>
<ul>
<li>设置/获取分频系数Prescaler</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置分频系数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_PrescalerConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> Prescaler, <span class="keyword">uint16_t</span> TIM_PSCReloadMode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_ALL_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));</span><br><span class="line">  <span class="comment">/* Set the Prescaler value */</span></span><br><span class="line">  TIMx-&gt;PSC = Prescaler;</span><br><span class="line">  <span class="comment">/* Set or reset the UG Bit */</span></span><br><span class="line">  TIMx-&gt;EGR = TIM_PSCReloadMode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置/获取自动重装值Autoreload</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置定时器自动重装载值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SetAutoreload</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint32_t</span> Autoreload)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_ALL_PERIPH(TIMx));</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Set the Autoreload Register value */</span></span><br><span class="line">  TIMx-&gt;ARR = Autoreload;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取定时器自动重装载值</span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">TIM_GetPrescaler</span><span class="params">(TIM_TypeDef* TIMx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_ALL_PERIPH(TIMx));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get the Prescaler Register value */</span></span><br><span class="line">  <span class="keyword">return</span> TIMx-&gt;PSC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置定时器计数器寄存器值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SetCounter</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint32_t</span> Counter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">   assert_param(IS_TIM_ALL_PERIPH(TIMx));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the Counter Register value */</span></span><br><span class="line">  TIMx-&gt;CNT = Counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取定时器计数器寄存器值</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">TIM_GetCounter</span><span class="params">(TIM_TypeDef* TIMx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_ALL_PERIPH(TIMx));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get the Counter Register value */</span></span><br><span class="line">  <span class="keyword">return</span> TIMx-&gt;CNT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>计时模式配置</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置定时器计数器模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_CounterModeConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_CounterMode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmpcr1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST3_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));</span><br><span class="line"></span><br><span class="line">  tmpcr1 = TIMx-&gt;CR1;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset the CMS and DIR Bits */</span></span><br><span class="line">  tmpcr1 &amp;= (<span class="keyword">uint16_t</span>)~(TIM_CR1_DIR | TIM_CR1_CMS);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the Counter Mode */</span></span><br><span class="line">  tmpcr1 |= TIM_CounterMode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write to TIMx CR1 register */</span></span><br><span class="line">  TIMx-&gt;CR1 = tmpcr1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置时钟分频</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SetClockDivision</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_CKD)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST1_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_CKD_DIV(TIM_CKD));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset the CKD Bits */</span></span><br><span class="line">  TIMx-&gt;CR1 &amp;= (<span class="keyword">uint16_t</span>)(~TIM_CR1_CKD);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the CKD value */</span></span><br><span class="line">  TIMx-&gt;CR1 |= TIM_CKD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>选择单脉冲模式</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SelectOnePulseMode</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_OPMode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_ALL_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_OPM_MODE(TIM_OPMode));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset the OPM Bit */</span></span><br><span class="line">  TIMx-&gt;CR1 &amp;= (<span class="keyword">uint16_t</span>)~TIM_CR1_OPM;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Configure the OPM Mode */</span></span><br><span class="line">  TIMx-&gt;CR1 |= TIM_OPMode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>更新请求配置</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定时器更新中断请求配置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_UpdateRequestConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_UpdateSource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_ALL_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (TIM_UpdateSource != TIM_UpdateSource_Global)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Set the URS Bit */</span></span><br><span class="line">    TIMx-&gt;CR1 |= TIM_CR1_URS;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Reset the URS Bit */</span></span><br><span class="line">    TIMx-&gt;CR1 &amp;= (<span class="keyword">uint16_t</span>)~TIM_CR1_URS;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>更新失能配置</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定时器更新中断失能控制</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_UpdateDisableConfig</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_ALL_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_FUNCTIONAL_STATE(NewState));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (NewState != DISABLE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Set the Update Disable Bit */</span></span><br><span class="line">    TIMx-&gt;CR1 |= TIM_CR1_UDIS;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Reset the Update Disable Bit */</span></span><br><span class="line">    TIMx-&gt;CR1 &amp;= (<span class="keyword">uint16_t</span>)~TIM_CR1_UDIS;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>自动重装载配置</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ARR预装载寄存器配置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ARRPreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_ALL_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_FUNCTIONAL_STATE(NewState));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (NewState != DISABLE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Set the ARR Preload Bit */</span></span><br><span class="line">    TIMx-&gt;CR1 |= TIM_CR1_ARPE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Reset the ARR Preload Bit */</span></span><br><span class="line">    TIMx-&gt;CR1 &amp;= (<span class="keyword">uint16_t</span>)~TIM_CR1_ARPE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使能/关闭计数器</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_Cmd</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_ALL_PERIPH(TIMx)); </span><br><span class="line">  assert_param(IS_FUNCTIONAL_STATE(NewState));</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (NewState != DISABLE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Enable the TIM Counter */</span></span><br><span class="line">    TIMx-&gt;CR1 |= TIM_CR1_CEN;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Disable the TIM Counter */</span></span><br><span class="line">    TIMx-&gt;CR1 &amp;= (<span class="keyword">uint16_t</span>)~TIM_CR1_CEN;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关函数如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取消定时器初始化并关闭时钟</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_DeInit</span><span class="params">(TIM_TypeDef* TIMx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_ALL_PERIPH(TIMx)); </span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (TIMx == TIM1)</span><br><span class="line">  &#123;</span><br><span class="line">    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);</span><br><span class="line">    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (TIMx == TIM2) </span><br><span class="line">  &#123;     </span><br><span class="line">    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);</span><br><span class="line">    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (TIMx == TIM3)</span><br><span class="line">  &#123; </span><br><span class="line">    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);</span><br><span class="line">    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (TIMx == TIM4)</span><br><span class="line">  &#123; </span><br><span class="line">    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);</span><br><span class="line">    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (TIMx == TIM5)</span><br><span class="line">  &#123;      </span><br><span class="line">    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);</span><br><span class="line">    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (TIMx == TIM6)  </span><br><span class="line">  &#123;    </span><br><span class="line">    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);</span><br><span class="line">    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (TIMx == TIM7)</span><br><span class="line">  &#123;      </span><br><span class="line">    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);</span><br><span class="line">    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (TIMx == TIM8)</span><br><span class="line">  &#123;      </span><br><span class="line">    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);</span><br><span class="line">    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (TIMx == TIM9)</span><br><span class="line">  &#123;      </span><br><span class="line">    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);</span><br><span class="line">    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  </span><br><span class="line">   &#125;  </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (TIMx == TIM10)</span><br><span class="line">  &#123;      </span><br><span class="line">    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);</span><br><span class="line">    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (TIMx == TIM11) </span><br><span class="line">  &#123;     </span><br><span class="line">    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);</span><br><span class="line">    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (TIMx == TIM12)</span><br><span class="line">  &#123;      </span><br><span class="line">    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);</span><br><span class="line">    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (TIMx == TIM13) </span><br><span class="line">  &#123;       </span><br><span class="line">    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);</span><br><span class="line">    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123; </span><br><span class="line">    <span class="keyword">if</span> (TIMx == TIM14) </span><br><span class="line">    &#123;     </span><br><span class="line">      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);</span><br><span class="line">      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); </span><br><span class="line">    &#125;   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据已有设置配置定时器初始化结构体</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_TimeBaseStructInit</span><span class="params">(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Set the default configuration */</span></span><br><span class="line">  TIM_TimeBaseInitStruct-&gt;TIM_Period = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">  TIM_TimeBaseInitStruct-&gt;TIM_Prescaler = <span class="number">0x0000</span>;</span><br><span class="line">  TIM_TimeBaseInitStruct-&gt;TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">  TIM_TimeBaseInitStruct-&gt;TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">  TIM_TimeBaseInitStruct-&gt;TIM_RepetitionCounter = <span class="number">0x0000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据初始化结构体配置定时器设置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_TimeBaseInit</span><span class="params">(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmpcr1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_ALL_PERIPH(TIMx)); </span><br><span class="line">  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct-&gt;TIM_CounterMode));</span><br><span class="line">  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct-&gt;TIM_ClockDivision));</span><br><span class="line"></span><br><span class="line">  tmpcr1 = TIMx-&gt;CR1;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((TIMx == TIM1) || (TIMx == TIM8)||</span><br><span class="line">     (TIMx == TIM2) || (TIMx == TIM3)||</span><br><span class="line">     (TIMx == TIM4) || (TIMx == TIM5)) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Select the Counter Mode */</span></span><br><span class="line">    tmpcr1 &amp;= (<span class="keyword">uint16_t</span>)(~(TIM_CR1_DIR | TIM_CR1_CMS));</span><br><span class="line">    tmpcr1 |= (<span class="keyword">uint32_t</span>)TIM_TimeBaseInitStruct-&gt;TIM_CounterMode;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span>((TIMx != TIM6) &amp;&amp; (TIMx != TIM7))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Set the clock division */</span></span><br><span class="line">    tmpcr1 &amp;=  (<span class="keyword">uint16_t</span>)(~TIM_CR1_CKD);</span><br><span class="line">    tmpcr1 |= (<span class="keyword">uint32_t</span>)TIM_TimeBaseInitStruct-&gt;TIM_ClockDivision;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  TIMx-&gt;CR1 = tmpcr1;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the Autoreload value */</span></span><br><span class="line">  TIMx-&gt;ARR = TIM_TimeBaseInitStruct-&gt;TIM_Period ;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Set the Prescaler value */</span></span><br><span class="line">  TIMx-&gt;PSC = TIM_TimeBaseInitStruct-&gt;TIM_Prescaler;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> ((TIMx == TIM1) || (TIMx == TIM8))  </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Set the Repetition Counter value */</span></span><br><span class="line">    TIMx-&gt;RCR = TIM_TimeBaseInitStruct-&gt;TIM_RepetitionCounter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Generate an update event to reload the Prescaler </span></span><br><span class="line"><span class="comment">     and the repetition counter(only for TIM1 and TIM8) value immediatly */</span></span><br><span class="line">  TIMx-&gt;EGR = TIM_PSCReloadMode_Immediate;          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TIM输出比较管理"><a href="#TIM输出比较管理" class="headerlink" title="TIM输出比较管理"></a>TIM输出比较管理</h3><p>ST提供了有关输出捕获与输出比较的库函数</p>
<p>输出捕获实际上就是对定时器的输出信号进行监测，从而实现PWM等操作</p>
<p>使用方法如下：</p>
<blockquote>
<ol>
<li>使用RCC_APBxPeriphClockCmd(RCC_APBxPeriph_TIMx, ENABLE)函数开启定时器时钟</li>
<li>配置GPIO为复用模式并配置定时器到GPIO的复用选项</li>
<li>使用下面的参数配置定时器时基单元初始化结构体设置<ul>
<li>自动重装载值 = 0xFFFF</li>
<li>分频系数 = 0x0000</li>
<li>计数模式：向上计数</li>
<li>时钟分频：TIM_CKD_DIV1</li>
</ul>
</li>
<li>使用下面的参数配置定时器输出捕获初始化结构体设置<ul>
<li>输出比较模式：TIM_OCMode</li>
<li>输出状态：TIM_OutputState</li>
<li>定时器脉冲值：TIM_Pulse</li>
<li>定时器输出比较极性：根据输出比较所需电平有效性选择</li>
</ul>
</li>
<li>使用TIM_OCxInit(TIMx, &amp;TIM_OCInitStruct)函数使用合适的配置来设置所需的通道</li>
<li>使用TIM_Cmd(ENABLE)使能定时器计数器</li>
<li>如果要使用PWM输出，需要额外使能输出捕获预装载寄存器，使用函数TIM_OCxPreloadConfig(TIMx, TIM_OCPreload_ENABLE)</li>
<li>可以在输出捕获的基础上使用定时器中断或DMA，只要使用对应库函数TIM_ITConfig(TIMx, TIM_IT_CCx)或TIM_DMA_Cmd(TIMx, TIM_DMA_CCx)提前进行配置即可</li>
</ol>
</blockquote>
<p>输出捕获的最简单用法就是PWM，但是除了这个功能，他还能实现更多更复杂的功能，相关库函数如下：</p>
<ul>
<li>将每个通道独立配置为输出比较</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化通道1输入捕获</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OC1Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmpccmrx = <span class="number">0</span>, tmpccer = <span class="number">0</span>, tmpcr2 = <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST1_PERIPH(TIMx)); </span><br><span class="line">  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct-&gt;TIM_OCMode));</span><br><span class="line">  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct-&gt;TIM_OutputState));</span><br><span class="line">  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct-&gt;TIM_OCPolarity));   </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Disable the Channel 1: Reset the CC1E Bit */</span></span><br><span class="line">  TIMx-&gt;CCER &amp;= (<span class="keyword">uint16_t</span>)~TIM_CCER_CC1E;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Get the TIMx CCER register value */</span></span><br><span class="line">  tmpccer = TIMx-&gt;CCER;</span><br><span class="line">  <span class="comment">/* Get the TIMx CR2 register value */</span></span><br><span class="line">  tmpcr2 =  TIMx-&gt;CR2;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Get the TIMx CCMR1 register value */</span></span><br><span class="line">  tmpccmrx = TIMx-&gt;CCMR1;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* Reset the Output Compare Mode Bits */</span></span><br><span class="line">  tmpccmrx &amp;= (<span class="keyword">uint16_t</span>)~TIM_CCMR1_OC1M;</span><br><span class="line">  tmpccmrx &amp;= (<span class="keyword">uint16_t</span>)~TIM_CCMR1_CC1S;</span><br><span class="line">  <span class="comment">/* Select the Output Compare Mode */</span></span><br><span class="line">  tmpccmrx |= TIM_OCInitStruct-&gt;TIM_OCMode;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Reset the Output Polarity level */</span></span><br><span class="line">  tmpccer &amp;= (<span class="keyword">uint16_t</span>)~TIM_CCER_CC1P;</span><br><span class="line">  <span class="comment">/* Set the Output Compare Polarity */</span></span><br><span class="line">  tmpccer |= TIM_OCInitStruct-&gt;TIM_OCPolarity;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Set the Output State */</span></span><br><span class="line">  tmpccer |= TIM_OCInitStruct-&gt;TIM_OutputState;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span>((TIMx == TIM1) || (TIMx == TIM8))</span><br><span class="line">  &#123;</span><br><span class="line">    assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct-&gt;TIM_OutputNState));</span><br><span class="line">    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct-&gt;TIM_OCNPolarity));</span><br><span class="line">    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct-&gt;TIM_OCNIdleState));</span><br><span class="line">    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct-&gt;TIM_OCIdleState));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Reset the Output N Polarity level */</span></span><br><span class="line">    tmpccer &amp;= (<span class="keyword">uint16_t</span>)~TIM_CCER_CC1NP;</span><br><span class="line">    <span class="comment">/* Set the Output N Polarity */</span></span><br><span class="line">    tmpccer |= TIM_OCInitStruct-&gt;TIM_OCNPolarity;</span><br><span class="line">    <span class="comment">/* Reset the Output N State */</span></span><br><span class="line">    tmpccer &amp;= (<span class="keyword">uint16_t</span>)~TIM_CCER_CC1NE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Set the Output N State */</span></span><br><span class="line">    tmpccer |= TIM_OCInitStruct-&gt;TIM_OutputNState;</span><br><span class="line">    <span class="comment">/* Reset the Output Compare and Output Compare N IDLE State */</span></span><br><span class="line">    tmpcr2 &amp;= (<span class="keyword">uint16_t</span>)~TIM_CR2_OIS1;</span><br><span class="line">    tmpcr2 &amp;= (<span class="keyword">uint16_t</span>)~TIM_CR2_OIS1N;</span><br><span class="line">    <span class="comment">/* Set the Output Idle state */</span></span><br><span class="line">    tmpcr2 |= TIM_OCInitStruct-&gt;TIM_OCIdleState;</span><br><span class="line">    <span class="comment">/* Set the Output N Idle state */</span></span><br><span class="line">    tmpcr2 |= TIM_OCInitStruct-&gt;TIM_OCNIdleState;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Write to TIMx CR2 */</span></span><br><span class="line">  TIMx-&gt;CR2 = tmpcr2;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Write to TIMx CCMR1 */</span></span><br><span class="line">  TIMx-&gt;CCMR1 = tmpccmrx;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Set the Capture Compare Register value */</span></span><br><span class="line">  TIMx-&gt;CCR1 = TIM_OCInitStruct-&gt;TIM_Pulse;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Write to TIMx CCER */</span></span><br><span class="line">  TIMx-&gt;CCER = tmpccer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化通道2、通道3、通道4的库函数与初始化通道1库函数不能说一模一样，只能说别无二致，所以在此不列出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用默认设置初始化输入捕获初始化结构体</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OCStructInit</span><span class="params">(TIM_OCInitTypeDef* TIM_OCInitStruct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Set the default configuration */</span></span><br><span class="line">  TIM_OCInitStruct-&gt;TIM_OCMode = TIM_OCMode_Timing;</span><br><span class="line">  TIM_OCInitStruct-&gt;TIM_OutputState = TIM_OutputState_Disable;</span><br><span class="line">  TIM_OCInitStruct-&gt;TIM_OutputNState = TIM_OutputNState_Disable;</span><br><span class="line">  TIM_OCInitStruct-&gt;TIM_Pulse = <span class="number">0x00000000</span>;</span><br><span class="line">  TIM_OCInitStruct-&gt;TIM_OCPolarity = TIM_OCPolarity_High;</span><br><span class="line">  TIM_OCInitStruct-&gt;TIM_OCNPolarity = TIM_OCPolarity_High;</span><br><span class="line">  TIM_OCInitStruct-&gt;TIM_OCIdleState = TIM_OCIdleState_Reset;</span><br><span class="line">  TIM_OCInitStruct-&gt;TIM_OCNIdleState = TIM_OCNIdleState_Reset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>选择输出比较模式</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择输出比较的通道、使用定时器x、输出比较的模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SelectOCxM</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_Channel, <span class="keyword">uint16_t</span> TIM_OCMode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> tmp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmp1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST1_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_CHANNEL(TIM_Channel));</span><br><span class="line">  assert_param(IS_TIM_OCM(TIM_OCMode));</span><br><span class="line"></span><br><span class="line">  tmp = (<span class="keyword">uint32_t</span>) TIMx;</span><br><span class="line">  tmp += CCMR_OFFSET;</span><br><span class="line"></span><br><span class="line">  tmp1 = CCER_CCE_SET &lt;&lt; (<span class="keyword">uint16_t</span>)TIM_Channel;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Disable the Channel: Reset the CCxE Bit */</span></span><br><span class="line">  TIMx-&gt;CCER &amp;= (<span class="keyword">uint16_t</span>) ~tmp1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))</span><br><span class="line">  &#123;</span><br><span class="line">    tmp += (TIM_Channel&gt;&gt;<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reset the OCxM bits in the CCMRx register */</span></span><br><span class="line">    *(__IO <span class="keyword">uint32_t</span> *) tmp &amp;= CCMR_OC13M_MASK;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/* Configure the OCxM bits in the CCMRx register */</span></span><br><span class="line">    *(__IO <span class="keyword">uint32_t</span> *) tmp |= TIM_OCMode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    tmp += (<span class="keyword">uint16_t</span>)(TIM_Channel - (<span class="keyword">uint16_t</span>)<span class="number">4</span>)&gt;&gt; (<span class="keyword">uint16_t</span>)<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reset the OCxM bits in the CCMRx register */</span></span><br><span class="line">    *(__IO <span class="keyword">uint32_t</span> *) tmp &amp;= CCMR_OC24M_MASK;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Configure the OCxM bits in the CCMRx register */</span></span><br><span class="line">    *(__IO <span class="keyword">uint32_t</span> *) tmp |= (<span class="keyword">uint16_t</span>)(TIM_OCMode &lt;&lt; <span class="number">8</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">可以使用如下模式：</span></span><br><span class="line"><span class="comment">定时 TIM_OCMode_Timing</span></span><br><span class="line"><span class="comment">启动 TIM_OCMode_Active</span></span><br><span class="line"><span class="comment">翻转 TIM_OCMode_Toggle</span></span><br><span class="line"><span class="comment">PWM模式1 TIM_OCMode_PWM1</span></span><br><span class="line"><span class="comment">PWM模式2 TIM_OCMode_PWM2</span></span><br><span class="line"><span class="comment">强制启动 TIM_ForcedAction_Active</span></span><br><span class="line"><span class="comment">强制停止 TIM_ForcedAction_InActive</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>选择每个通道的极性</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置正极性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OC1PolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_OCPolarity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmpccer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST1_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));</span><br><span class="line"></span><br><span class="line">  tmpccer = TIMx-&gt;CCER;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set or Reset the CC1P Bit */</span></span><br><span class="line">  tmpccer &amp;= (<span class="keyword">uint16_t</span>)(~TIM_CCER_CC1P);</span><br><span class="line">  tmpccer |= TIM_OCPolarity;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write to TIMx CCER register */</span></span><br><span class="line">  TIMx-&gt;CCER = tmpccer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置负极性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OC1NPolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_OCNPolarity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmpccer = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST4_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));</span><br><span class="line">   </span><br><span class="line">  tmpccer = TIMx-&gt;CCER;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set or Reset the CC1NP Bit */</span></span><br><span class="line">  tmpccer &amp;= (<span class="keyword">uint16_t</span>)~TIM_CCER_CC1NP;</span><br><span class="line">  tmpccer |= TIM_OCNPolarity;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write to TIMx CCER register */</span></span><br><span class="line">  TIMx-&gt;CCER = tmpccer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个库函数都有4个不同通道的设置，在此仅列出通道1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>设置/获取输出捕获/比较寄存器的值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置输出比较寄存器1、2、3、4的值</span></span><br><span class="line"><span class="comment">//每个输出比较寄存器对应一个通道</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SetCompare1</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint32_t</span> Compare1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST1_PERIPH(TIMx));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the Capture Compare1 Register value */</span></span><br><span class="line">  TIMx-&gt;CCR1 = Compare1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SetCompare2</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint32_t</span> Compare2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST2_PERIPH(TIMx));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the Capture Compare2 Register value */</span></span><br><span class="line">  TIMx-&gt;CCR2 = Compare2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、4的库函数和1、2大同小异，在此不列出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置输出捕获寄存器1、2、3、4的值，2、3、4的设置库函数不列出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ForcedOC1Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_ForcedAction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmpccmr1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST1_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));</span><br><span class="line">  tmpccmr1 = TIMx-&gt;CCMR1;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset the OC1M Bits */</span></span><br><span class="line">  tmpccmr1 &amp;= (<span class="keyword">uint16_t</span>)~TIM_CCMR1_OC1M;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Configure The Forced output Mode */</span></span><br><span class="line">  tmpccmr1 |= TIM_ForcedAction;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write to TIMx CCMR1 register */</span></span><br><span class="line">  TIMx-&gt;CCMR1 = tmpccmr1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置定时器输出捕获预装载寄存器的值（同样是4个通道）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OC1PreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_OCPreload)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmpccmr1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST1_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));</span><br><span class="line"></span><br><span class="line">  tmpccmr1 = TIMx-&gt;CCMR1;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset the OC1PE Bit */</span></span><br><span class="line">  tmpccmr1 &amp;= (<span class="keyword">uint16_t</span>)(~TIM_CCMR1_OC1PE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Enable or Disable the Output Compare Preload feature */</span></span><br><span class="line">  tmpccmr1 |= TIM_OCPreload;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write to TIMx CCMR1 register */</span></span><br><span class="line">  TIMx-&gt;CCMR1 = tmpccmr1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>选择输出比较快速模式（Output Compare Fast mode）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出比较快速模式设置（4个通道）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OC1FastConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_OCFast)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmpccmr1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST1_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get the TIMx CCMR1 register value */</span></span><br><span class="line">  tmpccmr1 = TIMx-&gt;CCMR1;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset the OC1FE Bit */</span></span><br><span class="line">  tmpccmr1 &amp;= (<span class="keyword">uint16_t</span>)~TIM_CCMR1_OC1FE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Enable or Disable the Output Compare Fast Bit */</span></span><br><span class="line">  tmpccmr1 |= TIM_OCFast;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write to TIMx CCMR1 */</span></span><br><span class="line">  TIMx-&gt;CCMR1 = tmpccmr1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>选择输出比较强制模式（Output Compare Forced mode）</li>
<li>输出比较-预装载模式</li>
<li>清空输出比较参考值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//清空输出比较参考值（4通道）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ClearOC1Ref</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_OCClear)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmpccmr1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST1_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));</span><br><span class="line"></span><br><span class="line">  tmpccmr1 = TIMx-&gt;CCMR1;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset the OC1CE Bit */</span></span><br><span class="line">  tmpccmr1 &amp;= (<span class="keyword">uint16_t</span>)~TIM_CCMR1_OC1CE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Enable or Disable the Output Compare Clear Bit */</span></span><br><span class="line">  tmpccmr1 |= TIM_OCClear;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write to TIMx CCMR1 register */</span></span><br><span class="line">  TIMx-&gt;CCMR1 = tmpccmr1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>选择OCREF清空信号</li>
<li>使能/失能捕获/比较通道</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//控制捕获通道开启/关闭</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_CCxCmd</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_Channel, <span class="keyword">uint16_t</span> TIM_CCx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST1_PERIPH(TIMx)); </span><br><span class="line">  assert_param(IS_TIM_CHANNEL(TIM_Channel));</span><br><span class="line">  assert_param(IS_TIM_CCX(TIM_CCx));</span><br><span class="line"></span><br><span class="line">  tmp = CCER_CCE_SET &lt;&lt; TIM_Channel;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset the CCxE Bit */</span></span><br><span class="line">  TIMx-&gt;CCER &amp;= (<span class="keyword">uint16_t</span>)~ tmp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set or reset the CCxE Bit */</span> </span><br><span class="line">  TIMx-&gt;CCER |=  (<span class="keyword">uint16_t</span>)(TIM_CCx &lt;&lt; TIM_Channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制捕获比较通道开启/关闭</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_CCxNCmd</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_Channel, <span class="keyword">uint16_t</span> TIM_CCxN)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST4_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));</span><br><span class="line">  assert_param(IS_TIM_CCXN(TIM_CCxN));</span><br><span class="line"></span><br><span class="line">  tmp = CCER_CCNE_SET &lt;&lt; TIM_Channel;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset the CCxNE Bit */</span></span><br><span class="line">  TIMx-&gt;CCER &amp;= (<span class="keyword">uint16_t</span>) ~tmp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set or reset the CCxNE Bit */</span> </span><br><span class="line">  TIMx-&gt;CCER |=  (<span class="keyword">uint16_t</span>)(TIM_CCxN &lt;&lt; TIM_Channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TIM输入捕获管理"><a href="#TIM输入捕获管理" class="headerlink" title="TIM输入捕获管理"></a>TIM输入捕获管理</h3><p>ST也提供了定时器输入捕获的库函数</p>
<p>基本使用方法如下：</p>
<blockquote>
<ol>
<li>使用RCC_APBxPeriphClockCmd(RCC_APBxPeriph_TIMx, ENABLE) 函数开启定时器时钟</li>
<li>将GPIO配置为合适的输入引脚，设置位复用模式并连接到定时器输入捕获</li>
<li>如果需要可以自行配置定时器时基设定，但推荐默认状态为：<ul>
<li>自动重装载值：0xFFFF</li>
<li>分频值：0x0000</li>
<li>计数模式：向上计数</li>
<li>时钟分频：TIM_CKD_DIV1一分频</li>
</ul>
</li>
<li>使用以下参数配置定时器输入捕获初始化结构体<ul>
<li>定时器通道：选择合适的通道</li>
<li>定时器输入捕获选项：根据输入捕获选择</li>
<li>定时器输入捕获分频：随机应变</li>
<li>定时器输入捕获屏蔽器值：根据要过滤的捕获信号设置</li>
</ul>
</li>
<li>使用TIM_ICInit(TIMx, &amp;TIM_ICInitStruct)函数根据上面的设置配置所需通道，就可以让定时器输入捕获测量输入信号的频率、占空比，或使用TIM_PWMIConfig(TIMx, &amp;TIM_ICInitStruct)函数配置通道来测量输入PWM波的频率和占空比</li>
<li>可使用中断或DMA方式读取测量信号，TIM_ITConfig(TIMx, TIM_IT_CCx)和TIM_DMA_Cmd(TIMx, TIM_DMA_CCx)函数都可选</li>
<li>使用TIM_Cmd(ENABLE)来开启定时器计数器</li>
<li>使用TIM_GetCapturex(TIMx)来读取捕获到的值</li>
</ol>
</blockquote>
<ul>
<li>单独配置每个通道位输入捕获模式</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据输入捕获初始化结构体配置某个通道为输入捕获模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ICInit</span><span class="params">(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST1_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct-&gt;TIM_ICPolarity));</span><br><span class="line">  assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct-&gt;TIM_ICSelection));</span><br><span class="line">  assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct-&gt;TIM_ICPrescaler));</span><br><span class="line">  assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct-&gt;TIM_ICFilter));</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (TIM_ICInitStruct-&gt;TIM_Channel == TIM_Channel_1)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* TI1 Configuration */</span></span><br><span class="line">    TI1_Config(TIMx, TIM_ICInitStruct-&gt;TIM_ICPolarity,</span><br><span class="line">               TIM_ICInitStruct-&gt;TIM_ICSelection,</span><br><span class="line">               TIM_ICInitStruct-&gt;TIM_ICFilter);</span><br><span class="line">    <span class="comment">/* Set the Input Capture Prescaler value */</span></span><br><span class="line">    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (TIM_ICInitStruct-&gt;TIM_Channel == TIM_Channel_2)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* TI2 Configuration */</span></span><br><span class="line">    assert_param(IS_TIM_LIST2_PERIPH(TIMx));</span><br><span class="line">    TI2_Config(TIMx, TIM_ICInitStruct-&gt;TIM_ICPolarity,</span><br><span class="line">               TIM_ICInitStruct-&gt;TIM_ICSelection,</span><br><span class="line">               TIM_ICInitStruct-&gt;TIM_ICFilter);</span><br><span class="line">    <span class="comment">/* Set the Input Capture Prescaler value */</span></span><br><span class="line">    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (TIM_ICInitStruct-&gt;TIM_Channel == TIM_Channel_3)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* TI3 Configuration */</span></span><br><span class="line">    assert_param(IS_TIM_LIST3_PERIPH(TIMx));</span><br><span class="line">    TI3_Config(TIMx,  TIM_ICInitStruct-&gt;TIM_ICPolarity,</span><br><span class="line">               TIM_ICInitStruct-&gt;TIM_ICSelection,</span><br><span class="line">               TIM_ICInitStruct-&gt;TIM_ICFilter);</span><br><span class="line">    <span class="comment">/* Set the Input Capture Prescaler value */</span></span><br><span class="line">    TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* TI4 Configuration */</span></span><br><span class="line">    assert_param(IS_TIM_LIST3_PERIPH(TIMx));</span><br><span class="line">    TI4_Config(TIMx, TIM_ICInitStruct-&gt;TIM_ICPolarity,</span><br><span class="line">               TIM_ICInitStruct-&gt;TIM_ICSelection,</span><br><span class="line">               TIM_ICInitStruct-&gt;TIM_ICFilter);</span><br><span class="line">    <span class="comment">/* Set the Input Capture Prescaler value */</span></span><br><span class="line">    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用默认设置配置输入捕获初始化结构体</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ICStructInit</span><span class="params">(TIM_ICInitTypeDef* TIM_ICInitStruct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Set the default configuration */</span></span><br><span class="line">  TIM_ICInitStruct-&gt;TIM_Channel = TIM_Channel_1;</span><br><span class="line">  TIM_ICInitStruct-&gt;TIM_ICPolarity = TIM_ICPolarity_Rising;</span><br><span class="line">  TIM_ICInitStruct-&gt;TIM_ICSelection = TIM_ICSelection_DirectTI;</span><br><span class="line">  TIM_ICInitStruct-&gt;TIM_ICPrescaler = TIM_ICPSC_DIV1;</span><br><span class="line">  TIM_ICInitStruct-&gt;TIM_ICFilter = <span class="number">0x00</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可配置通道1/2处于PWM输入模式，用于获取外部脉冲/测量外部信号频率（如编码器输入、遥控信号输入等）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置通道为PWM输入模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_PWMIConfig</span><span class="params">(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> icoppositepolarity = TIM_ICPolarity_Rising;</span><br><span class="line">  <span class="keyword">uint16_t</span> icoppositeselection = TIM_ICSelection_DirectTI;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST2_PERIPH(TIMx));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Select the Opposite Input Polarity */</span></span><br><span class="line">  <span class="keyword">if</span> (TIM_ICInitStruct-&gt;TIM_ICPolarity == TIM_ICPolarity_Rising)</span><br><span class="line">  &#123;</span><br><span class="line">    icoppositepolarity = TIM_ICPolarity_Falling;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    icoppositepolarity = TIM_ICPolarity_Rising;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Select the Opposite Input */</span></span><br><span class="line">  <span class="keyword">if</span> (TIM_ICInitStruct-&gt;TIM_ICSelection == TIM_ICSelection_DirectTI)</span><br><span class="line">  &#123;</span><br><span class="line">    icoppositeselection = TIM_ICSelection_IndirectTI;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    icoppositeselection = TIM_ICSelection_DirectTI;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (TIM_ICInitStruct-&gt;TIM_Channel == TIM_Channel_1)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* TI1 Configuration */</span></span><br><span class="line">    TI1_Config(TIMx, TIM_ICInitStruct-&gt;TIM_ICPolarity, TIM_ICInitStruct-&gt;TIM_ICSelection,</span><br><span class="line">               TIM_ICInitStruct-&gt;TIM_ICFilter);</span><br><span class="line">    <span class="comment">/* Set the Input Capture Prescaler value */</span></span><br><span class="line">    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);</span><br><span class="line">    <span class="comment">/* TI2 Configuration */</span></span><br><span class="line">    TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct-&gt;TIM_ICFilter);</span><br><span class="line">    <span class="comment">/* Set the Input Capture Prescaler value */</span></span><br><span class="line">    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123; </span><br><span class="line">    <span class="comment">/* TI2 Configuration */</span></span><br><span class="line">    TI2_Config(TIMx, TIM_ICInitStruct-&gt;TIM_ICPolarity, TIM_ICInitStruct-&gt;TIM_ICSelection,</span><br><span class="line">               TIM_ICInitStruct-&gt;TIM_ICFilter);</span><br><span class="line">    <span class="comment">/* Set the Input Capture Prescaler value */</span></span><br><span class="line">    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);</span><br><span class="line">    <span class="comment">/* TI1 Configuration */</span></span><br><span class="line">    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct-&gt;TIM_ICFilter);</span><br><span class="line">    <span class="comment">/* Set the Input Capture Prescaler value */</span></span><br><span class="line">    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置输入捕获预分频器</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置输入捕获1、2、3、4通道预分频器的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SetIC1Prescaler</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_ICPSC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST1_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset the IC1PSC Bits */</span></span><br><span class="line">  TIMx-&gt;CCMR1 &amp;= (<span class="keyword">uint16_t</span>)~TIM_CCMR1_IC1PSC;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the IC1PSC value */</span></span><br><span class="line">  TIMx-&gt;CCMR1 |= TIM_ICPSC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取捕获/比较值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取输入捕获1、2、3、4的值</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">TIM_GetCapture1</span><span class="params">(TIM_TypeDef* TIMx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST1_PERIPH(TIMx));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get the Capture 1 Register value */</span></span><br><span class="line">  <span class="keyword">return</span> TIMx-&gt;CCR1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">TIM_GetCapture2</span><span class="params">(TIM_TypeDef* TIMx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST2_PERIPH(TIMx));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get the Capture 2 Register value */</span></span><br><span class="line">  <span class="keyword">return</span> TIMx-&gt;CCR2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">TIM_GetCapture3</span><span class="params">(TIM_TypeDef* TIMx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST3_PERIPH(TIMx)); </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get the Capture 3 Register value */</span></span><br><span class="line">  <span class="keyword">return</span> TIMx-&gt;CCR3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">TIM_GetCapture4</span><span class="params">(TIM_TypeDef* TIMx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST3_PERIPH(TIMx));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get the Capture 4 Register value */</span></span><br><span class="line">  <span class="keyword">return</span> TIMx-&gt;CCR4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高级定时器（TIM1、TIM8）的特殊控制库函数"><a href="#高级定时器（TIM1、TIM8）的特殊控制库函数" class="headerlink" title="高级定时器（TIM1、TIM8）的特殊控制库函数"></a>高级定时器（TIM1、TIM8）的特殊控制库函数</h3><p>STM32F4中具有两个高级定时器，ST也为它们提供了库函数</p>
<p>下面是基本使用方法</p>
<blockquote>
<ol>
<li>使用输出比较模式配置定时器通道</li>
<li>使用TIM_BDTRInitStruct结构体设置时钟断点极性、死区时间、锁定等级、OSSI/OSSR状态和AOE（自动输出使能）模式</li>
<li>使用TIM_BDTRConfig(TIMx, &amp;TIM_BDTRInitStruct)配置定时器的高级功能</li>
<li>使用TIM_CtrlPWMOutputs(TIM1, ENABLE)函数使能主输出</li>
<li>一旦断点发生，定时器的输出信号就会被置于重置或某个经过TIM_BDTRConfig()设定的状态</li>
</ol>
</blockquote>
<ul>
<li>配置断点输入（Break input）、死区时间、锁定等级、OSSI、OSSR状态、AOE（自动输入使能）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_BDTRConfig</span><span class="params">(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST4_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct-&gt;TIM_OSSRState));</span><br><span class="line">  assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct-&gt;TIM_OSSIState));</span><br><span class="line">  assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct-&gt;TIM_LOCKLevel));</span><br><span class="line">  assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct-&gt;TIM_Break));</span><br><span class="line">  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct-&gt;TIM_BreakPolarity));</span><br><span class="line">  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct-&gt;TIM_AutomaticOutput));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,</span></span><br><span class="line"><span class="comment">     the OSSI State, the dead time value and the Automatic Output Enable Bit */</span></span><br><span class="line">  TIMx-&gt;BDTR = (<span class="keyword">uint32_t</span>)TIM_BDTRInitStruct-&gt;TIM_OSSRState | TIM_BDTRInitStruct-&gt;TIM_OSSIState |</span><br><span class="line">             TIM_BDTRInitStruct-&gt;TIM_LOCKLevel | TIM_BDTRInitStruct-&gt;TIM_DeadTime |</span><br><span class="line">             TIM_BDTRInitStruct-&gt;TIM_Break | TIM_BDTRInitStruct-&gt;TIM_BreakPolarity |</span><br><span class="line">             TIM_BDTRInitStruct-&gt;TIM_AutomaticOutput;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用初始化结构体默认设置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_BDTRStructInit</span><span class="params">(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Set the default configuration */</span></span><br><span class="line">  TIM_BDTRInitStruct-&gt;TIM_OSSRState = TIM_OSSRState_Disable;</span><br><span class="line">  TIM_BDTRInitStruct-&gt;TIM_OSSIState = TIM_OSSIState_Disable;</span><br><span class="line">  TIM_BDTRInitStruct-&gt;TIM_LOCKLevel = TIM_LOCKLevel_OFF;</span><br><span class="line">  TIM_BDTRInitStruct-&gt;TIM_DeadTime = <span class="number">0x00</span>;</span><br><span class="line">  TIM_BDTRInitStruct-&gt;TIM_Break = TIM_Break_Disable;</span><br><span class="line">  TIM_BDTRInitStruct-&gt;TIM_BreakPolarity = TIM_BreakPolarity_Low;</span><br><span class="line">  TIM_BDTRInitStruct-&gt;TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使能/失能定时器外设主输出</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_CtrlPWMOutputs</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST4_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_FUNCTIONAL_STATE(NewState));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (NewState != DISABLE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Enable the TIM Main Output */</span></span><br><span class="line">    TIMx-&gt;BDTR |= TIM_BDTR_MOE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Disable the TIM Main Output */</span></span><br><span class="line">    TIMx-&gt;BDTR &amp;= (<span class="keyword">uint16_t</span>)~TIM_BDTR_MOE;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>选择通讯事件</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择通信事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SelectCOM</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST4_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_FUNCTIONAL_STATE(NewState));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (NewState != DISABLE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Set the COM Bit */</span></span><br><span class="line">    TIMx-&gt;CR2 |= TIM_CR2_CCUS;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Reset the COM Bit */</span></span><br><span class="line">    TIMx-&gt;CR2 &amp;= (<span class="keyword">uint16_t</span>)~TIM_CR2_CCUS;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置/重置捕获比较预装载控制位</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置捕获比较预装载控制位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_CCPreloadControl</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST4_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_FUNCTIONAL_STATE(NewState));</span><br><span class="line">  <span class="keyword">if</span> (NewState != DISABLE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Set the CCPC Bit */</span></span><br><span class="line">    TIMx-&gt;CR2 |= TIM_CR2_CCPC;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Reset the CCPC Bit */</span></span><br><span class="line">    TIMx-&gt;CR2 &amp;= (<span class="keyword">uint16_t</span>)~TIM_CR2_CCPC;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定时器中断、DMA与标志位管理"><a href="#定时器中断、DMA与标志位管理" class="headerlink" title="定时器中断、DMA与标志位管理"></a>定时器中断、DMA与标志位管理</h3><p>STM32中的一些定时器是可以触发定时器中断、DMA的，ST也提供了管理库函数</p>
<ul>
<li>使能/失能中断源</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使能或关闭定时器中断</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ITConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_IT, FunctionalState NewState)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_ALL_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_IT(TIM_IT));</span><br><span class="line">  assert_param(IS_FUNCTIONAL_STATE(NewState));</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (NewState != DISABLE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Enable the Interrupt sources */</span></span><br><span class="line">    TIMx-&gt;DIER |= TIM_IT;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Disable the Interrupt sources */</span></span><br><span class="line">    TIMx-&gt;DIER &amp;= (<span class="keyword">uint16_t</span>)~TIM_IT;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">TIM_IT参数可设置为以下值</span></span><br><span class="line"><span class="comment">TIM_IT_Update:定时器更新中断</span></span><br><span class="line"><span class="comment">TIM_IT_CC1:定时器比较中断4</span></span><br><span class="line"><span class="comment">TIM_IT_CC2:定时器比较中断4</span></span><br><span class="line"><span class="comment">TIM_IT_CC3:定时器比较中断4</span></span><br><span class="line"><span class="comment">TIM_IT_CC4:定时器比较中断4</span></span><br><span class="line"><span class="comment">TIM_IT_COM:定时器通讯中断</span></span><br><span class="line"><span class="comment">TIM_IT_Trigger:定时器触发中断</span></span><br><span class="line"><span class="comment">TIM_IT_Break:定时器暂停中断</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">TIM6和TIM7只能使用TIM_IT_Update，TIM9和TIM12只能使用TIM_IT_Update，TIM_IT_CC1, TIM_IT_CC2或TIM_IT_Trigger</span></span><br><span class="line"><span class="comment">TIM10、11、13、14只能使用TIM_IT_Update或TIM_IT_CC1</span></span><br><span class="line"><span class="comment">TIM1和TIM8两个高级定时器才被允许使用TIM_IT_COM和TIM_IT_Break</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置定时器软件事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_GenerateEvent</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_EventSource)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_ALL_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Set the event sources */</span></span><br><span class="line">  TIMx-&gt;EGR = TIM_EventSource;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">TIM_EventSource_Update:定时器更新事件（下面内容和上面中断的内冲差不多，懒得翻译了）</span></span><br><span class="line"><span class="comment">TIM_EventSource_CC1: Timer Capture Compare 1 Event source</span></span><br><span class="line"><span class="comment">TIM_EventSource_CC2: Timer Capture Compare 2 Event source</span></span><br><span class="line"><span class="comment">TIM_EventSource_CC3: Timer Capture Compare 3 Event source</span></span><br><span class="line"><span class="comment">TIM_EventSource_CC4: Timer Capture Compare 4 Event source</span></span><br><span class="line"><span class="comment">TIM_EventSource_COM: Timer COM event source  </span></span><br><span class="line"><span class="comment">TIM_EventSource_Trigger: Timer Trigger Event source</span></span><br><span class="line"><span class="comment">TIM_EventSource_Break: Timer Break event source</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">其中TIM6、7只能使用定时器更新事件；只有高级定时器TIM1、8才能使用后三个高级事件功能</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取标志状态</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取当前中断标志位状态</span></span><br><span class="line"><span class="function">FlagStatus <span class="title">TIM_GetFlagStatus</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_FLAG)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  ITStatus bitstatus = RESET;  </span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_ALL_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_GET_FLAG(TIM_FLAG));</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ((TIMx-&gt;SR &amp; TIM_FLAG) != (<span class="keyword">uint16_t</span>)RESET)</span><br><span class="line">  &#123;</span><br><span class="line">    bitstatus = SET;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    bitstatus = RESET;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bitstatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取中断状态</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取当前中断发生状态</span></span><br><span class="line"><span class="function">ITStatus <span class="title">TIM_GetITStatus</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_IT)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ITStatus bitstatus = RESET;  </span><br><span class="line">  <span class="keyword">uint16_t</span> itstatus = <span class="number">0x0</span>, itenable = <span class="number">0x0</span>;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_ALL_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_GET_IT(TIM_IT));</span><br><span class="line">   </span><br><span class="line">  itstatus = TIMx-&gt;SR &amp; TIM_IT;</span><br><span class="line">  </span><br><span class="line">  itenable = TIMx-&gt;DIER &amp; TIM_IT;</span><br><span class="line">  <span class="keyword">if</span> ((itstatus != (<span class="keyword">uint16_t</span>)RESET) &amp;&amp; (itenable != (<span class="keyword">uint16_t</span>)RESET))</span><br><span class="line">  &#123;</span><br><span class="line">    bitstatus = SET;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    bitstatus = RESET;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bitstatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>清空标志位/挂起标志位</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//清空中断标志位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ClearFlag</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_FLAG)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_ALL_PERIPH(TIMx));</span><br><span class="line">   </span><br><span class="line">  <span class="comment">/* Clear the flags */</span></span><br><span class="line">  TIMx-&gt;SR = (<span class="keyword">uint16_t</span>)~TIM_FLAG;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空中断挂起标志位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ClearITPendingBit</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_IT)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_ALL_PERIPH(TIMx));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Clear the IT pending Bit */</span></span><br><span class="line">  TIMx-&gt;SR = (<span class="keyword">uint16_t</span>)~TIM_IT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使能/失能DMA请求</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使能定时器DMA</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_DMACmd</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_DMASource, FunctionalState NewState)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST5_PERIPH(TIMx)); </span><br><span class="line">  assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));</span><br><span class="line">  assert_param(IS_FUNCTIONAL_STATE(NewState));</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (NewState != DISABLE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Enable the DMA sources */</span></span><br><span class="line">    TIMx-&gt;DIER |= TIM_DMASource; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Disable the DMA sources */</span></span><br><span class="line">    TIMx-&gt;DIER &amp;= (<span class="keyword">uint16_t</span>)~TIM_DMASource;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>配置DMA突发传输模式（burst mode）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置定时器DMA突发传输模式与相关设置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_DMAConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_DMABase, <span class="keyword">uint16_t</span> TIM_DMABurstLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST3_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_DMA_BASE(TIM_DMABase)); </span><br><span class="line">  assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the DMA Base and the DMA Burst Length */</span></span><br><span class="line">  TIMx-&gt;DCR = TIM_DMABase | TIM_DMABurstLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>选择捕获比较DMA请求</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择捕获比较DMA请求使能</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SelectCCDMA</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST3_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_FUNCTIONAL_STATE(NewState));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (NewState != DISABLE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Set the CCDS Bit */</span></span><br><span class="line">    TIMx-&gt;CR2 |= TIM_CR2_CCDS;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Reset the CCDS Bit */</span></span><br><span class="line">    TIMx-&gt;CR2 &amp;= (<span class="keyword">uint16_t</span>)~TIM_CR2_CCDS;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定时器时钟管理"><a href="#定时器时钟管理" class="headerlink" title="定时器时钟管理"></a>定时器时钟管理</h3><p>这里是关于定时器时钟源的管理库函数</p>
<ul>
<li>选择内部/外部时钟输入</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置定时器内部时钟</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_InternalClockConfig</span><span class="params">(TIM_TypeDef* TIMx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST2_PERIPH(TIMx));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Disable slave mode to clock the prescaler directly with the internal clock */</span></span><br><span class="line">  TIMx-&gt;SMCR &amp;=  (<span class="keyword">uint16_t</span>)~TIM_SMCR_SMS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置定时器内部触发作为外部时钟</span></span><br><span class="line"><span class="comment">//可选择TIM_TS_ITR0到3作为内部触发源</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ITRxExternalClockConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_InputTriggerSource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST2_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Select the Internal Trigger */</span></span><br><span class="line">  TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Select the External clock mode1 */</span></span><br><span class="line">  TIMx-&gt;SMCR |= TIM_SlaveMode_External1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置定时器触发器作为外部时钟源</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_TIxExternalClockConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_TIxExternalCLKSource,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">uint16_t</span> TIM_ICPolarity, <span class="keyword">uint16_t</span> ICFilter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST1_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));</span><br><span class="line">  assert_param(IS_TIM_IC_FILTER(ICFilter));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Configure the Timer Input Clock Source */</span></span><br><span class="line">  <span class="keyword">if</span> (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)</span><br><span class="line">  &#123;</span><br><span class="line">    TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Select the Trigger source */</span></span><br><span class="line">  TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);</span><br><span class="line">  <span class="comment">/* Select the External clock mode1 */</span></span><br><span class="line">  TIMx-&gt;SMCR |= TIM_SlaveMode_External1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>选择外部时钟模式为ETR（模式1/模式2）、TIx或ITRx</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置定时器ETR模式1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ETRClockMode1Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_ExtTRGPrescaler,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">uint16_t</span> TIM_ExtTRGPolarity, <span class="keyword">uint16_t</span> ExtTRGFilter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmpsmcr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST3_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));</span><br><span class="line">  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));</span><br><span class="line">  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));</span><br><span class="line">  <span class="comment">/* Configure the ETR Clock source */</span></span><br><span class="line">  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Get the TIMx SMCR register value */</span></span><br><span class="line">  tmpsmcr = TIMx-&gt;SMCR;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset the SMS Bits */</span></span><br><span class="line">  tmpsmcr &amp;= (<span class="keyword">uint16_t</span>)~TIM_SMCR_SMS;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Select the External clock mode1 */</span></span><br><span class="line">  tmpsmcr |= TIM_SlaveMode_External1;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Select the Trigger selection : ETRF */</span></span><br><span class="line">  tmpsmcr &amp;= (<span class="keyword">uint16_t</span>)~TIM_SMCR_TS;</span><br><span class="line">  tmpsmcr |= TIM_TS_ETRF;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write to TIMx SMCR */</span></span><br><span class="line">  TIMx-&gt;SMCR = tmpsmcr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置ETR模式2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ETRClockMode2Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_ExtTRGPrescaler, </span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">uint16_t</span> TIM_ExtTRGPolarity, <span class="keyword">uint16_t</span> ExtTRGFilter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST3_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));</span><br><span class="line">  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));</span><br><span class="line">  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Configure the ETR Clock source */</span></span><br><span class="line">  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Enable the External clock mode2 */</span></span><br><span class="line">  TIMx-&gt;SMCR |= TIM_SMCR_ECE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定时器同步管理"><a href="#定时器同步管理" class="headerlink" title="定时器同步管理"></a>定时器同步管理</h3><p>STM32中部分定时器可以实现同步功能，这里是相关的同步管理库函数</p>
<p>基本配置方法如下所示：</p>
<blockquote>
<p>两个/多个定时器可进行串连、同步、交错等多种配置，需要以下步骤：</p>
<ol>
<li>使用下面的两个函数配置主定时器：<ul>
<li>TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)选择输出触发源</li>
<li>TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)选择当前定时器模式为主从模式</li>
</ul>
</li>
<li>使用下面的函数配置从定时器：<ul>
<li>TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)选择触发源输入</li>
<li>TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)选择当前定时器模式为从模式</li>
</ul>
</li>
<li>这样从定时器就会被连接到主定时器的触发器，接收主定时器控制</li>
<li>使用TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)函数配置定时器的外部触发源，可实现由外部信号控制定时器</li>
<li>配合TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)与TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)函数，可以让定时器接收外部信号并作为从模式工作</li>
</ol>
</blockquote>
<ul>
<li>选择输入触发信号</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SelectInputTrigger</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_InputTriggerSource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmpsmcr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST1_PERIPH(TIMx)); </span><br><span class="line">  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get the TIMx SMCR register value */</span></span><br><span class="line">  tmpsmcr = TIMx-&gt;SMCR;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset the TS Bits */</span></span><br><span class="line">  tmpsmcr &amp;= (<span class="keyword">uint16_t</span>)~TIM_SMCR_TS;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the Input Trigger source */</span></span><br><span class="line">  tmpsmcr |= TIM_InputTriggerSource;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write to TIMx SMCR */</span></span><br><span class="line">  TIMx-&gt;SMCR = tmpsmcr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>选择输出触发信号</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SelectOutputTrigger</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_TRGOSource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST5_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset the MMS Bits */</span></span><br><span class="line">  TIMx-&gt;CR2 &amp;= (<span class="keyword">uint16_t</span>)~TIM_CR2_MMS;</span><br><span class="line">  <span class="comment">/* Select the TRGO source */</span></span><br><span class="line">  TIMx-&gt;CR2 |=  TIM_TRGOSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>选择主从模式</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置定时器为从模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SelectSlaveMode</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_SlaveMode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST2_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset the SMS Bits */</span></span><br><span class="line">  TIMx-&gt;SMCR &amp;= (<span class="keyword">uint16_t</span>)~TIM_SMCR_SMS;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Select the Slave Mode */</span></span><br><span class="line">  TIMx-&gt;SMCR |= TIM_SlaveMode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置定时器为主/从模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SelectMasterSlaveMode</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_MasterSlaveMode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST2_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset the MSM Bit */</span></span><br><span class="line">  TIMx-&gt;SMCR &amp;= (<span class="keyword">uint16_t</span>)~TIM_SMCR_MSM;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Set or Reset the MSM Bit */</span></span><br><span class="line">  TIMx-&gt;SMCR |= TIM_MasterSlaveMode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当作为外部触发使用时进行ETR配置</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置定时器外部触发模式（ETR）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ETRConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_ExtTRGPrescaler,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">uint16_t</span> TIM_ExtTRGPolarity, <span class="keyword">uint16_t</span> ExtTRGFilter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmpsmcr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST3_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));</span><br><span class="line">  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));</span><br><span class="line">  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));</span><br><span class="line"></span><br><span class="line">  tmpsmcr = TIMx-&gt;SMCR;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset the ETR Bits */</span></span><br><span class="line">  tmpsmcr &amp;= SMCR_ETR_MASK;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the Prescaler, the Filter value and the Polarity */</span></span><br><span class="line">  tmpsmcr |= (<span class="keyword">uint16_t</span>)(TIM_ExtTRGPrescaler | (<span class="keyword">uint16_t</span>)(TIM_ExtTRGPolarity | (<span class="keyword">uint16_t</span>)(ExtTRGFilter &lt;&lt; (<span class="keyword">uint16_t</span>)<span class="number">8</span>)));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write to TIMx SMCR */</span></span><br><span class="line">  TIMx-&gt;SMCR = tmpsmcr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定时器特殊结构管理"><a href="#定时器特殊结构管理" class="headerlink" title="定时器特殊结构管理"></a>定时器特殊结构管理</h3><p>定时器也可以作为特殊设备的接口使用，ST也提供了这样用法的库函数</p>
<ul>
<li>解码器接口配置</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_EncoderInterfaceConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_EncoderMode,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">uint16_t</span> TIM_IC1Polarity, <span class="keyword">uint16_t</span> TIM_IC2Polarity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmpsmcr = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmpccmr1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmpccer = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST2_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));</span><br><span class="line">  assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));</span><br><span class="line">  assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get the TIMx SMCR register value */</span></span><br><span class="line">  tmpsmcr = TIMx-&gt;SMCR;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get the TIMx CCMR1 register value */</span></span><br><span class="line">  tmpccmr1 = TIMx-&gt;CCMR1;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get the TIMx CCER register value */</span></span><br><span class="line">  tmpccer = TIMx-&gt;CCER;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the encoder Mode */</span></span><br><span class="line">  tmpsmcr &amp;= (<span class="keyword">uint16_t</span>)~TIM_SMCR_SMS;</span><br><span class="line">  tmpsmcr |= TIM_EncoderMode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Select the Capture Compare 1 and the Capture Compare 2 as input */</span></span><br><span class="line">  tmpccmr1 &amp;= ((<span class="keyword">uint16_t</span>)~TIM_CCMR1_CC1S) &amp; ((<span class="keyword">uint16_t</span>)~TIM_CCMR1_CC2S);</span><br><span class="line">  tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the TI1 and the TI2 Polarities */</span></span><br><span class="line">  tmpccer &amp;= ((<span class="keyword">uint16_t</span>)~TIM_CCER_CC1P) &amp; ((<span class="keyword">uint16_t</span>)~TIM_CCER_CC2P);</span><br><span class="line">  tmpccer |= (<span class="keyword">uint16_t</span>)(TIM_IC1Polarity | (<span class="keyword">uint16_t</span>)(TIM_IC2Polarity &lt;&lt; (<span class="keyword">uint16_t</span>)<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write to TIMx SMCR */</span></span><br><span class="line">  TIMx-&gt;SMCR = tmpsmcr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write to TIMx CCMR1 */</span></span><br><span class="line">  TIMx-&gt;CCMR1 = tmpccmr1;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write to TIMx CCER */</span></span><br><span class="line">  TIMx-&gt;CCER = tmpccer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>选择Hall Sensor</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SelectHallSensor</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST2_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_FUNCTIONAL_STATE(NewState));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (NewState != DISABLE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Set the TI1S Bit */</span></span><br><span class="line">    TIMx-&gt;CR2 |= TIM_CR2_TI1S;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Reset the TI1S Bit */</span></span><br><span class="line">    TIMx-&gt;CR2 &amp;= (<span class="keyword">uint16_t</span>)~TIM_CR2_TI1S;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定时器特殊重映射配置"><a href="#定时器特殊重映射配置" class="headerlink" title="定时器特殊重映射配置"></a>定时器特殊重映射配置</h3><p>一些定时器能够被重映射为特殊的配置端口，这里是该功能的管理库函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置定时器重映射端口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_RemapConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_Remap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_LIST6_PERIPH(TIMx));</span><br><span class="line">  assert_param(IS_TIM_REMAP(TIM_Remap));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the Timer remapping configuration */</span></span><br><span class="line">  TIMx-&gt;OR =  TIM_Remap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置TI1、2、3、4作为输入，这里仅列出TI1的库函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TI1_Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_ICPolarity, <span class="keyword">uint16_t</span> TIM_ICSelection,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">uint16_t</span> TIM_ICFilter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> tmpccmr1 = <span class="number">0</span>, tmpccer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Disable the Channel 1: Reset the CC1E Bit */</span></span><br><span class="line">  TIMx-&gt;CCER &amp;= (<span class="keyword">uint16_t</span>)~TIM_CCER_CC1E;</span><br><span class="line">  tmpccmr1 = TIMx-&gt;CCMR1;</span><br><span class="line">  tmpccer = TIMx-&gt;CCER;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Select the Input and set the filter */</span></span><br><span class="line">  tmpccmr1 &amp;= ((<span class="keyword">uint16_t</span>)~TIM_CCMR1_CC1S) &amp; ((<span class="keyword">uint16_t</span>)~TIM_CCMR1_IC1F);</span><br><span class="line">  tmpccmr1 |= (<span class="keyword">uint16_t</span>)(TIM_ICSelection | (<span class="keyword">uint16_t</span>)(TIM_ICFilter &lt;&lt; (<span class="keyword">uint16_t</span>)<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Select the Polarity and set the CC1E Bit */</span></span><br><span class="line">  tmpccer &amp;= (<span class="keyword">uint16_t</span>)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);</span><br><span class="line">  tmpccer |= (<span class="keyword">uint16_t</span>)(TIM_ICPolarity | (<span class="keyword">uint16_t</span>)TIM_CCER_CC1E);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write to TIMx CCMR1 and CCER registers */</span></span><br><span class="line">  TIMx-&gt;CCMR1 = tmpccmr1;</span><br><span class="line">  TIMx-&gt;CCER = tmpccer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title>电路设计从入门到弃坑【三极管理论分析】</title>
    <url>/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E4%B8%89%E6%9E%81%E7%AE%A1%E7%90%86%E8%AE%BA%E5%88%86%E6%9E%90%E3%80%91/</url>
    <content><![CDATA[<h1 id="电路设计从入门到弃坑2【三极管理论分析】"><a href="#电路设计从入门到弃坑2【三极管理论分析】" class="headerlink" title="电路设计从入门到弃坑2【三极管理论分析】"></a>电路设计从入门到弃坑2【三极管理论分析】</h1><p>按理说结束对基本半导体器件介绍后就应该进入放大电路的环节</p>
<p>但是在讨论放大电路之前，需要先了解三极管在放大区的工作特性——这一点在之前的介绍部分做的不是很详细，本篇作为补充（其实是重点）部分</p>
<p>建议读者将本部分内容和下一篇博文3结合阅读，加深关于三极管基础知识理解</p>
<h3 id="三极管放大区工作特性"><a href="#三极管放大区工作特性" class="headerlink" title="三极管放大区工作特性"></a>三极管放大区工作特性</h3><ol>
<li><p>输入特性</p>
<p> 三极管的U<del>BE</del>和I<del>B</del>之间的关系称为三极管的<strong>输入特性</strong>，描述了随BE结电压变化，b极电流的“输入”大小变化</p>
<p> 一般来说U<del>BE</del>&gt;0.7V，也就是高于三极管导通电压时，I<del>B</del>才会出现，随后I<del>B</del>会呈现指数变化。这是由于U<del>BE</del>决定了b极能吸引到的电子数，U<del>BE</del>增大，电流也就会增大</p>
 <span id="more"></span>

<p> 当考虑U<del>CE</del>时，会发现<strong>随着U<del>CE</del>增大，I<del>B</del>曲线右移</strong>，但是<strong>U<del>CE</del>增大到1V以上后，曲线右移就会变得不明显</strong>。这是因为U<del>CE</del>决定了从e极发射的电子总量，而U<del>BE</del>决定了能通过b区的电子量，电子总量增加，自然被吸引到b极的电子数量增加，b极电流相应增加，但是当e极所有电子都被发射出去以后——也就是发射的电子“饱和”了——不管怎么增加U<del>CE</del>，被b极吸引到的电子数目也不会有太大增加</p>
<p> <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E4%B8%89%E6%9E%81%E7%AE%A1%E7%90%86%E8%AE%BA%E5%88%86%E6%9E%90%E3%80%91/image-20211003140017638.png" alt="image-20211003140017638"></p>
</li>
<li><p>输出特性</p>
<p> 三极管的<strong>输出特性</strong>指的是U<del>CE</del>与I<del>C</del>之间的关系</p>
<p> 如下图所示，三极管的输出特性是一个很经典的模型</p>
<p> <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E4%B8%89%E6%9E%81%E7%AE%A1%E7%90%86%E8%AE%BA%E5%88%86%E6%9E%90%E3%80%91/image-20211003135948475.png" alt="image-20211003135948475"></p>
<blockquote>
<p>理解了这个模型，就可以说理解了三极管</p>
</blockquote>
<p> 先看I<del>B</del>恒定的情况下，选取其中I<del>B1</del>曲线，可以看到随U<del>CE</del>升高，I<del>C</del>迅速变大，这就体现了U<del>CE</del>控制电子发射总量。对应上一篇文章中提到过的电子管，就可以把U<del>CE</del>理解成“灯丝电压”，是I<del>C</del>主要的影响量（**根据KCL，I<del>E</del>=I<del>C</del>+I<del>B</del>，但是由于I<del>B</del>本来就很小，所以I<del>C</del>≈I<del>E</del>**），当U<del>CE</del>增大到某种程度后，I<del>C</del>就不再变化了，这是因为e极能释放的电子数已经达到了上限</p>
<p> 再看跟随I<del>B</del>变化的情况：I<del>B</del>=0区域以下被分成了“<strong>截止区</strong>”，这就对应了三极管截止工作状态；I<del>B</del>达到最大，也就是U<del>BE</del>≥U<del>CE</del>后，I<del>C</del>同样受到了限制，无法再进一步增大，这就是“<strong>饱和区</strong>”</p>
<p> 而模拟电路中最关注的就是放大，放大就要靠三极管工作在放大区。这个区域内，具有一个铁律：<br> $$<br> I_C=\beta I_B<br> $$<br> 其中$\beta=\frac{\Delta i_C}{\Delta i_B}$，这个参数仅由三极管结构和制造工艺决定（三极管固有性质）</p>
<p> 同样地，可以获得更精确的三极管电流公式：<br> $$<br> I_E=I_C+I_B=(\beta+1)I_B<br> $$<br> 通常三极管的β值都在几百，不过在实际电路中会通过外部条件限制β来让三极管工作在合适的状态</p>
</li>
<li><p>温度特性</p>
<p> 三极管是半导体器件，说到半导体就必须提温度特性了</p>
<p> <strong>温度升高，β值升高，导致I<del>B</del>不变时BE结电压U<del>BE</del>下降；或者U<del>BE</del>不变时I<del>B</del>升高</strong></p>
<p> 就因为这个性质，需要在后续的放大电路中引入<strong>补偿电阻（温度反馈电阻）</strong>，相关内容会在下一篇涉及</p>
<p> 同时，温度升高会导致三极管导通电压U<del>BE(ON)</del>降低，反向饱和电流I<del>CBO</del>增大。从图像上看，就是输入特性曲线左移，反向特性曲线下移。原理很简单，温度升高，PN结的温度漂移影响更加明显，导致更低的be结电压就能让三极管导通；同时截止电流会随温度漂移变大，这个过程和二极管的温度特性类似</p>
</li>
<li><p>性能参数</p>
<p> <strong>本部分内容的重点！</strong>看懂了三极管的性能参数，才能看懂datasheet，进而设计放大电路并对放大电路的参数进行规划。下面提到的参数都是基本放大电路中经常使用的，一些针对特定电路的参数会在之后的博文中介绍。</p>
<p> 三极管电流放大倍数<strong>β值</strong>：$\beta=\frac{\Delta i_c}{\Delta i_b}=\frac{I_c}{I_b}$，也可以用半导体物理的公式逆向计算</p>
<blockquote>
<p>注意：很多人认为β值是用半导体物理的公式推导出来的，但实际上上面这个式子就是它的定义式，半导体物理反用了这个参数来进行计算</p>
</blockquote>
<p> β值、α值关系：$\alpha=\frac{\Delta i_C}{\Delta i_E}=\frac{\beta}{1+\beta}$</p>
<p> **饱和管压降$U_{CES}$**：临界饱和电压，放大区与饱和区的边界电压，当三极管越过这个压降时就从放大区进入了饱和区。对于小功率管来说，大概是0.7V左右，对于大功率管来说，可以达到2~3V。</p>
<blockquote>
<p>实际工程中并不会严格按照这个压降来确定放大区和饱和区，不过只要根据这个参数算出静态工作点该在的位置，就可以从理论上保证不会出现饱和失真了</p>
</blockquote>
<p> **be结电阻$r_{be}$**：上一篇提到过的b极e极之间的寄生电阻，可以用$r_{bb’}$进行计算</p>
<p> **输出漏电流$I_{CEO}$**：c极和e极之间的漏电流，也称为穿透电流，指基极断开时C、E间加电压测得的电流</p>
<blockquote>
<p>这个电流是因为发射区的自由电子在不加基极电压时候会自发的穿越基区到达集电区形成</p>
</blockquote>
<p> 最大工作频率$f_T$：使β=1的信号频率，当信号大于该频率时，三极管将不能正常工作（大概率直接烧毁，因为高频的信号会让三极管工作在开关状态，发热巨大）</p>
<p> 最大集电极电流$I_{CM}$：三极管放大工作状态下集电极输出（流入）的最大电流</p>
<p> CE结击穿电压$U_{(BR)CEO}$：三极管能允许的CE脚之间最大电压</p>
<p> 最大集电极耗散功率$P_{CM}$：集电极会存在用于发热的耗散功率，当三极管c极功率达到最大时，耗散会达到最大</p>
</li>
</ol>
<h2 id="三极管电路模型"><a href="#三极管电路模型" class="headerlink" title="三极管电路模型"></a>三极管电路模型</h2><p>上面的部分介绍了三极管放大区的工作特性。简单梳理一下逻辑：<strong>我们想要使用三极管对信号进行控制，那么就只能让三极管保持在放大区工作，如果出现三极管截止或者饱和的情况，都会导致电路无法实现应有的功能，这就产生了两个基本的失真：截止失真和饱和失真；随后，因为三极管是半导体器件，自然要考虑温、声、光、压、电几方面的内部不稳定因素——声音、光线、压力这三个不稳定因素都被三极管外部的塑料封装消除了，我们需要考虑的就剩下温度和电磁这两个干扰因素——先解决温度，让三极管拥有不受温度变化干扰的能力，解决方法是在放大电路中引入补偿电阻，或者从根本上改变电路结构来保证稳定性；最后是电磁干扰，这个因素是最麻烦的，因为很多电源本身就“脏”，带着各种各样的高频低频脉冲，甚至三极管自己的放大过程如果出现问题，也会在输出端生成尖峰——注意，这个尖峰是被放大了几百倍的，因此后续电路对于这样的干扰就更为难了，不过我们可以通过组合多个三极管、二极管，搭建复合的电路来抑制这种干扰。</strong>学习模电中放大电路的思路就应该按照上述逻辑进行。实际电路中很可能还会考虑更多因素，通过引入更复杂的反馈、耦合控制机制可以消除这些东西，不过这都是更需要经验的工作了，笔者也只是个想分享一下知识的菜b，不再班门弄斧。</p>
<p>回到正题，分析放大电路之前，需要先了解三极管的理想电路模型（下一篇还会介绍更加准确、能用于高频的三极管EM小信号模型）</p>
<p>三极管电路模型分为大信号模型和小信号模型，这里的大和小是相对的概念——放大电路中电源信号一般常用3.3V、5V、9V、18V、24V乃至60V，而需要放大的信号往往只有1V、0.3V、0.02V、0.001V乃至更低，有些微弱信号甚至只有μA级别的电流，因此<strong>放大电路中的直流信号被称为大信号，交流信号称为小信号</strong></p>
<h3 id="大信号模型"><a href="#大信号模型" class="headerlink" title="大信号模型"></a>大信号模型</h3><p>放大电路中，三极管存在一个直流回路和一个交流回路，其中直流回路拓扑如下所示</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E4%B8%89%E6%9E%81%E7%AE%A1%E7%90%86%E8%AE%BA%E5%88%86%E6%9E%90%E3%80%91/image-20211012001528232.png" alt="image-20211012001528232"></p>
<p>这里先不介绍该电路的结构和分析方法，只由此引出该怎么对三极管进行抽象建模。</p>
<p>首先我们能看到四个电阻——他们被称为<strong>偏置电阻</strong>，为提供三极管合适的静态工作点。萌新读者暂时不用理会专有名词，这些会在下一篇详细介绍。可以看到三极管作为一个节点接入电路，恒有<br>$$<br>I_E=I_B+I_C \<br>I_C=\beta I_B<br>$$<br>第一个方程是电路的拓扑约束，第二个方程则是元件约束。为了抽取三极管的重点特性，我们一定要将β拿出来，因为没有这个东西，三极管的放大功能就无法描述。该怎么建模？答案是流控电流源——它正好符合元件约束的方程。此外，需要注意拓扑约束不能逾越，C极和B极要共地隔离。</p>
<p>常用的三极管直流大信号等效模型如下所示：b、e之间是一个等效压降，即Ube——be结压降（硅0.7；锗0.3）；c、e之间是一个流控电流源，它的大小I<del>C</del>=βI<del>B</del></p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E4%B8%89%E6%9E%81%E7%AE%A1%E7%90%86%E8%AE%BA%E5%88%86%E6%9E%90%E3%80%91/image-20211012002258539.png" alt="image-20211012002258539"></p>
<p>这里和上面的分析不一样，因为它引入了结压降U<del>be</del>，不过也很好理解——半导体结压降特性在二极管等效模型中也有用到，如果你的电路供电电压很高的话其实也可以直接忽略。</p>
<p>以后遇到放大电路的直流信号分析，直接把这个模型套上去就可以把模电变成电路原理了！</p>
<h3 id="小信号模型"><a href="#小信号模型" class="headerlink" title="小信号模型"></a>小信号模型</h3><p>三极管小信号模型的分析相对更简单一点——上面说了因为三极管的元件约束决定了它需要保留β；因此对于交流信号，β在所难免，不过这里把结压降扔了，因为结压降是针对直流而言的固定，对于一个交流信号，更常用“阻抗”进行描述——把所有电阻、电容、电感全部抽象成“输入阻抗”、“输出阻抗”、“寄生阻抗”就行了！如下图所示，R<del>b</del>就是一个be结寄生阻抗的等效。在半导体物理中还有一个公式专门计算它：<br>$$<br>R_{b} \approx R_{bb’} + (1+\beta) \frac{U_T}{I_{EQ}}，其中U_T \approx 23mV<br>$$<br><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E4%B8%89%E6%9E%81%E7%AE%A1%E7%90%86%E8%AE%BA%E5%88%86%E6%9E%90%E3%80%91/image-20211012003443867.png" alt="image-20211012003443867"></p>
<p>遇到交流信号分析时，直接将这个模型带入就可以了</p>
<h3 id="三极管高频等效模型简介"><a href="#三极管高频等效模型简介" class="headerlink" title="三极管高频等效模型简介"></a>三极管高频等效模型简介</h3><blockquote>
<p>想看高频？</p>
<p>别想了！下一篇再说!</p>
</blockquote>
<h2 id="三极管偏置"><a href="#三极管偏置" class="headerlink" title="三极管偏置"></a>三极管偏置</h2><p><strong>在阅读以下内容之前，强烈建议刚接触模电的新手先去阅读传统教材的放大电路部分，再对本教程的下一篇进行粗略阅读，至少掌握放大电路的基本拓扑结构</strong>，否则可能会根本读不懂</p>
<p>这部分内容其实应该放在放大电路部分讲，本教程将三极管偏置条件放在这里的原因是它更接近让三极管保持在放大区的一个性质，并且使用理论分析就可以得到很好的效果，而不需要放大电路设计经验或者什么玄学因素。</p>
<p>三极管的偏置设计讲究两个基本要求：</p>
<ol>
<li>三极管能干活——保证三极管工作在放大区</li>
<li>三极管偏置电阻尽量少且能耗低</li>
</ol>
<h3 id="理论计算"><a href="#理论计算" class="headerlink" title="理论计算"></a>理论计算</h3><p>为了满足上述两个要求，就需要根据规定的最大不失真输出电压$U_{OM}$设计电路，避免出现截止失真和饱和失真，根据下面的公式可以比较好地实现目的<br>$$<br>I_{CQ} \ge I_{CM}+ I_{CEO}\newline<br>U_{CEQ} \ge U_{OM}+U_{CES}<br>$$<br>其中$I_{CEO}$表示CE结漏电流，$I_{CM}$表示最大集电极电流，</p>
<p>上面的电路分别说明：</p>
<ul>
<li>C极静态工作电压不小于CE结漏电流+最大集电极电流。这样就能保证三极管不出现截止失真</li>
<li>CE极静态工作电压要不小于最大不失真输出电压+CE结饱和管压降（由U<del>OM</del>计算式反推而来）。这样可以保证三极管不出现饱和失真</li>
</ul>
<p>下面的公式给出了三极管放大电路最大不失真输出电压的计算方法<br>$$<br>U_{OM}=min{\frac{V_{CC}-U_{CEQ}}{\sqrt2},\frac{U_{CEQ}-U_{CES}}{\sqrt2}}<br>$$<br>此外还需要考虑偏置电阻的耗能情况，一般至少选用几千欧的电阻为三极管提供电压，或在集成电路中为了保证优良的功耗采用电流源电路为三极管提供偏置。在设计偏置电阻的过程中还需要考虑电阻对放大倍数的影响</p>
<p>比如在常见的共射放大电路中，有以下公式描述电路基本性质<br>$$<br>\dot{A_u}-\beta\frac{R_C}{R_b+r_{be}} \newline<br>R_i=R_b+r_{be} \newline<br>R_o=R_C<br>$$<br>对应电路如下所示（建议参考第3部分内容）</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E4%B8%89%E6%9E%81%E7%AE%A1%E7%90%86%E8%AE%BA%E5%88%86%E6%9E%90%E3%80%91/image-20211206220029190.png" alt="image-20211206220029190"></p>
<h3 id="偏置电路设计方法"><a href="#偏置电路设计方法" class="headerlink" title="偏置电路设计方法"></a>偏置电路设计方法</h3><p>一般的三极管偏置电路需要三部分</p>
<ul>
<li>电源</li>
<li>偏置电阻</li>
<li>反馈</li>
</ul>
<p>下面的拓扑是最经典的一个偏置电路</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E4%B8%89%E6%9E%81%E7%AE%A1%E7%90%86%E8%AE%BA%E5%88%86%E6%9E%90%E3%80%91/image-20211206114357733.png" alt="image-20211206114357733"></p>
<blockquote>
<p>在集成电路使用时往往会去除C1、C2两个耦合电容，将Vcc改成镜像电流源，并从输出端引入反馈用以稳定晶体管工作在放大区</p>
<p>其中Rb1、Rb2、Rc充当偏置电阻</p>
<p>Re充当反馈电阻进行温度补偿</p>
</blockquote>
<p>首先需要保证输入信号叠加在b极，并不能超过$U_{OM}$；其次要求偏置稳定；最后要求Re能够良好地补偿温度变化</p>
]]></content>
      <tags>
        <tag>电路设计</tag>
      </tags>
  </entry>
  <entry>
    <title>电路设计从入门到弃坑【场效应管】</title>
    <url>/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E3%80%91/</url>
    <content><![CDATA[<h1 id="电路设计从入门到弃坑2-5【场效应管】"><a href="#电路设计从入门到弃坑2-5【场效应管】" class="headerlink" title="电路设计从入门到弃坑2.5【场效应管】"></a>电路设计从入门到弃坑2.5【场效应管】</h1><p>在详细谈MOSFET之前，我们先通过一份datasheet回顾一下MOSFET的伏安特性</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E3%80%91/image-20211023112946344.png"></p>
<p>这是通用功率MOSFET IRF220的datasheet，我们可以了解到它能承受4A@150V，有些型号能够承受5A@200V，比一般的功率三极管高到不知哪里去了，同时它的导通电阻（DS电阻）仅为0.8~1.2Ω，并且具有很高的输入阻抗（High Input Impedance）</p>
<span id="more"></span>

<p>右下角是他的电路符号</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E3%80%91/image-20211023113255328.png" alt="image-20211023113255328"></p>
<p>这则是IRF22x系列的最大电气值，V<del>DS</del>=200，I<del>D</del>=5A，P<del>D</del>=40W，耐温达到300℃</p>
<p>手册下面就是详细的电气特性：</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E3%80%91/image-20211023113513332.png" alt="image-20211023113513332"></p>
<p>阈值电压2V~4V，I<del>D</del>=250μA</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E3%80%91/image-20211023113603145.png" alt="image-20211023113603145"></p>
<p>漏电流100nA</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E3%80%91/image-20211023113623369.png" alt="image-20211023113623369"></p>
<p>开启时延20~40ns，关断时延50~100ns</p>
<p>寄生电容有点大，但不完全大</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E3%80%91/image-20211023113753748.png" alt="image-20211023113753748"></p>
<p>同样存在略大的寄生电感</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E3%80%91/image-20211023113811937.png" alt="image-20211023113811937"></p>
<p>这个管子就是典型的增强型功率NMOSFET</p>
<h2 id="MOSFET伏安特性分析"><a href="#MOSFET伏安特性分析" class="headerlink" title="MOSFET伏安特性分析"></a>MOSFET伏安特性分析</h2><p>场效应管可以如下进行分类</p>
<ul>
<li><p>结型场效应管JFET</p>
<ul>
<li><p>增强型</p>
</li>
<li><p>耗尽型</p>
</li>
<li><p>N-JFET</p>
<p>  <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E3%80%91/image-20211108213013223.png" alt="image-20211108213013223"></p>
<p>  <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E3%80%91/image-20211108212951498.png" alt="image-20211108212951498"></p>
</li>
<li><p>P-JFET</p>
<p>  <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E3%80%91/image-20211108213029447.png" alt="image-20211108213029447"></p>
<p>  <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E3%80%91/image-20211108212958798.png" alt="image-20211108212958798"></p>
</li>
</ul>
</li>
<li><p>金属氧化物半导体场效应管MOSFET</p>
<ul>
<li><p>增强型</p>
<p>  <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E3%80%91/image-20211108213525698.png" alt="image-20211108213525698"></p>
<p>  <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E3%80%91/image-20211108213530366.png" alt="image-20211108213530366"></p>
</li>
<li><p>耗尽型</p>
<p>  <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E3%80%91/image-20211108213442424.png" alt="image-20211108213442424"></p>
<p>  <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E3%80%91/image-20211108213448797.png" alt="image-20211108213448797"></p>
</li>
<li><p>NMOS</p>
</li>
<li><p>PMOS</p>
</li>
</ul>
</li>
</ul>
<p>这里需要强调一下才JFET和MOSFET的区别：JFET是在同一块N形半导体上制作两个高掺杂的P区，将它们连接在一起引出栅极g，N型半导体两端分别引出两个电极，分别称为漏极d，源极s。与MOSFET相比JFET更像三极管，原理也更加“原始”：通过电压改变沟道的导电性来实现对输出电流的控制；对应MOSFET则使用电压先控制反型层，进而控制导电沟道。</p>
<p>结型场效应管JFET是典型的单极型管，具有噪声小、抗辐射能力强、工作电压低的特点，同时器件工艺使得其适合制造（由于成本等限制，几乎所有JFET都是）耗尽型场效应管，常用于高速器件。但是由于它需要外加电压夹断导电沟道，也就使得电压低时漏电流相对较大，不够节能，因此在数字集成电路中不常用。本部分<strong>主要以增强型MOSFET为例介绍场效应管的性质</strong></p>
<blockquote>
<p>MOSFET的基本知识已经在【基础晶体管】部分提到，这里默认读者已经<em>相对了解了MOSFET的电路符号并且能够判断其类型</em>，能够<em>大致说出电场效应是什么</em>，能够<em>理解增强型MOSFET的三种工作模式</em></p>
</blockquote>
<h3 id="输出特性"><a href="#输出特性" class="headerlink" title="输出特性"></a>输出特性</h3><p>当$V_{GS}$恒定时，测量S-D两端电压$V_{DS}$和漏极电流$I_D$之间的关系</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E3%80%91/image-20210901235011715.png" alt="image-20210901235011715"></p>
<p>公式表述就是<br>$$<br>i_D=f(u_{DS})|<em>{U</em>{GS}=Const}<br>$$<br>当$U_{GS}$很小时，反型层未形成，导电沟道不会开启，MOSFET工作在截止区，此使存在微小的GS漏电流。</p>
<p>理论上MOSFET工作在该区域时，G-S之间的电阻式无穷大的。</p>
<p>当$U_{GS}$在增大到<strong>阈值电压</strong>（开启电压）时，</p>
<p>当MOSFET处于饱和区时，当DS电压增加时，D极电流几乎恒定，称为<strong>饱和状态</strong></p>
<p>综上可以推导出一个MOSFET静态工作模型如下：</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E3%80%91/image-20211108214600502.png" alt="image-20211108214600502"></p>
<p>实际上该电阻值在TΩ量级</p>
<p>特别地，如果$u_{GS}$过大，会导致MOSFET击穿——这与$u_{DS}$无关，当$u_{DS}$超过击穿电压后，沟道内发生雪崩击穿，漏极电流急速上升，如果瞬间电流过大，会之间烧毁导电沟道部分。这个特性导致了MOSFET的GS之间很害怕静电：GS之间存在非常小的寄生电容，当外界条件变化引起感应起电或让GS带电后，即使微小的电荷也会导致大电压，进而出现下面两种<strong>静电击穿</strong>：</p>
<ul>
<li><strong>电压静电击穿</strong>：栅极的薄氧化层发生击穿，形成针孔，使GS间或GD间短路</li>
<li><strong>功率静电击穿</strong>：静电放电形成的是短时大电流，放电脉冲的时间常数远小于器件散热的时间常数，当静电放电电流通过面积很小的半导体结时，将产生很大的瞬间功率密度，形成局部过热，于是金属化薄膜铝条被熔断，造成栅极开路或者是源极开路</li>
</ul>
<p>应用中，增强型和耗尽型场效应管都具有类似上面这样的输出特性</p>
<p>从最上面的曲线图可以看出MOSFET可以工作在三种模式下，分别是恒流（<strong>饱和</strong>）<strong>模式</strong>、<strong>截止模式</strong>、线性（<strong>欧姆</strong>）<strong>模式</strong>，具体的模式描述已经在上一篇博文中谈过，如果无法理解，请立刻中止阅读并复习上一篇博文内容</p>
<blockquote>
<p>这里需要补充一下：MOSFET的性质在模电教材中并未显著提及，可能是作为电路基础教材不应谈及过深入的内容；本博文对于MOSFET的讲述也会不甚深入，因为其中很多原理需要先了解半导体物理、量子力学基础知识后才能有效应用，这里仅作为补充引入一些概念（对于上篇博文中概念的定量公式补充）</p>
<ul>
<li><p>由于电子能量的玻尔兹曼分布，导致总有一些高能量电子能够穿透沟道并运动到漏极，因此在截止模式下，MOSFET中总是不可避免出现弱反转电流，遵循以下公式：<br>  $$<br>  I_D \approx I_{DO}e^{\frac{V_{GS}-V_{th}}{nV_T}} \<br>  $$</p>
<p>  $$<br>  n=1+\frac{C_D}{C_{ox}}<br>  $$</p>
</li>
<li><p>跨导-电流比的定义式：$\frac{g_m}{I_D}=\frac{1}{nV_T}$</p>
</li>
<li><p>经过整理的d-s电流公式<br>  $$<br>  I_D=K_n[2(V_{GS}-V_{th})V_{DS}-V_{DS}^2] \<br>  $$<br>  $$<br>  K_n=\frac{K_m}{2}=\frac{W\mu_n C_{ox}}{2L} \<br>  $$</p>
<p>  $$<br>  K_p=\mu_n C_{ox}=\mu_n \frac{\epsilon_{ox}}{t_{ox}}<br>  $$</p>
<p>  其中$K_n$是MOS常数，当且仅当W=2L时，$K_p=K_n$</p>
</li>
<li><p>MOSFET的导电是通过一个较宽的二维或三维电流分布实现的，这个区域关断的开始称为夹断。</p>
<p>  MOSFET和三极管类似，也存在由于结而形成的厄利尔电压$V_M$，由于厄利尔电压的存在，夹断情况附近漏极电流并不主要依赖漏极电压，而是按以下公式：<br>  $$<br>  I_D=\frac{\mu_n C_{ox}W}{2L}(V_{GS}-V_{th})^2(1+\lambda V_{DS})<br>  $$<br>  于是可以根据该公式推导出MOSFET跨导的半导体物理描述<br>  $$<br>  g_m=\frac{2I_D}{V_{OV}}=\frac{2I_D}{V_{GS}-V_{th}}=g_m=\frac{\partial i_D}{\partial v_{GS}}<br>  $$<br>  同时可以得到MOSFET得到输出阻抗<br>  $$<br>  r_O=\frac{1}{\lambda I_D}=\frac{\partial V_{DS}}{\partial I_{DS}}<br>  $$<br>  若$I_D$趋于0时，器件无限大的输出阻抗会让电路的预期行为变得不可靠，出现速度饱和、准弹道传输、势垒降低效应</p>
</li>
</ul>
</blockquote>
<h3 id="输入特性（转移特性）"><a href="#输入特性（转移特性）" class="headerlink" title="输入特性（转移特性）"></a>输入特性（转移特性）</h3><p>输入特性又叫转移特性</p>
<p>当S-D两端电压$V_{DS}$恒定时，测量$V_{GS}$和漏极电流$I_D$之间的关系，即转移特性：$I_D=f(V_{GS})|<em>{V</em>{DS}=Const}$</p>
<p>这里主要解释一下MOSFET电压“输入”的思想</p>
<p>MOSFET相比三极管很特殊，它的G-S极被看作开路，所以它并不能把电流视为“输入”——而是将GS电压作为输入的信号，于是问哦们可以用一个经典的$i_D$-$u_{GS}$图像描述MOSFET在信号输入回路的电气特性</p>
<p>增强型：</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E3%80%91/image-20211202120733970.png" alt="image-20211202120733970"></p>
<p>存在一个由管型决定的门限电压（<strong>开启电压</strong>），输入信号小于开启电压不会有输出电流，这个开启电压对应着输出特性中截止区与电阻区的分界曲线</p>
<p>耗尽型：</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E3%80%91/image-20211202120751210.png" alt="image-20211202120751210"></p>
<p>耗尽型MOSFET则存在一个关断电压（<strong>夹断电压</strong>），当$u_{GS}=0$时并不意味着输出为0，实际上此时MOSFET还工作在电阻区，只有达到这个负的（不一定是负的，取决于管型）夹断电压，耗尽型MOSFET才会真正关断</p>
<h3 id="温度特性"><a href="#温度特性" class="headerlink" title="温度特性"></a>温度特性</h3><p>耗尽型NMOS当温度升高时，d极电流下降</p>
<p><strong>温度升高</strong>会导致MOSFET的内部分子热运动加剧，进而使内电流增大，g极外电场<strong>对导电沟道的控制能力下降</strong>，对应的结果需要按照MOSFET的型号决定</p>
<h3 id="场效应管重新梳理"><a href="#场效应管重新梳理" class="headerlink" title="场效应管重新梳理"></a>场效应管重新梳理</h3><p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E3%80%91/image-20211108215026665.png" alt="image-20211108215026665"></p>
<p>需要注意：耗尽型FET在$u_{GS}=0$时才可以工作在恒流区；增强型MOSFET中N沟道就像是N型BJT一样，需要正的$u_{GS}$才能工作在恒流区；相反，P沟道增强型MOSFET需要负的$u_{GS}$才能工作在恒流区</p>
<p>下面来介绍MOSFET的电路分析模型（低频模型）</p>
<ol>
<li><p>直流等效模型</p>
<p> <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E3%80%91/image-20211205182641359.png" alt="image-20211205182641359"></p>
<p> 下图是从模集教材中截取的内容，板级电路设计中通常需要考虑$C_{GS}$、$C_{DS}=(C_{DB}+C_{SB})//(C_{GB})$、$C_{GD}$，还需要额外注意D-B之间和B-S之间存在因为半导体结出现的寄生二极管</p>
<p> <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E3%80%91/image-20211205214630263.png" alt="image-20211205214630263"></p>
<p> 在中低频中低压电路分析中常用的模型如上图所示，可以将gs端看作一个压控电流源，并有一个并联在ds端的电阻$r_{ds}$，可近似看成一个无穷大的电阻或一个无穷小的电导。这个电阻就是MOSFET的输出电阻，常常用以下公式描述<br> $$<br> r_o=\frac{\frac1\lambda +V_{DS}}{I_D}\approx \frac{V_E L}{I_D} \<br> $$<br> $$<br> 沟道调制长度\lambda =\frac{1}{V_E L}<br> $$</p>
<p> λ仅与工艺有关，在65nm节点，λ大约在4V/μm，对于板级使用，只要认为它是个与管型有关的系数就可以了，可以从datasheet直接查阅MOSFET的输出电阻参数</p>
<p> 根据之前所说的MOSFET转移特性可推导出跨导$g_m=\frac{\partial i_D}{\partial v_{GS}}|<em>{v</em>{DS}=Const}$，这个方程描述了MOSFET在线性区的工作状态</p>
<p> 电路设计中并不会使用该模型，因为它缺少细节，这个模型往往会在模电考试和<strong>定性分析电路</strong>中出现</p>
</li>
<li><p>交流等效模型</p>
<p> 非常简单，MOSFET因为输入电阻可以看作无穷大，三极管中很多冗余参数都可以舍弃，</p>
<p> 只要了解<br> $$<br> g_m=\frac{\partial i_D}{\partial v_{GS}}|<em>{v</em>{DS}=Const}<br> $$<br> 即可</p>
<p> 但是在小信号情况下，还可以用$I_{DQ}$近似$i_D$得到<br> $$<br> g_m=\frac{2\sqrt{I_{DO}I_{DQ}}}{U_{GS(th)}}<br> $$</p>
</li>
</ol>
<h1 id="基于场效应管的基本放大电路"><a href="#基于场效应管的基本放大电路" class="headerlink" title="基于场效应管的基本放大电路"></a>基于场效应管的基本放大电路</h1><p>基本放大电路也可以基于场效应管实现，实际上由于MOSFET技术比较成熟，很多功率放大器件都会基于MOSFET工艺实现。但是场效应管是电压控制电流器件，其GS极在低压中低频近似为开路，导致MOSFET基本放大电路的一些特性与三极管基本放大电路不同，集中体现在以下几点：</p>
<ul>
<li>输入电阻普遍偏大</li>
<li>存在一个相对较大的g极寄生电容和s-d极寄生电容</li>
<li>同拓扑电路整体性质与三极管放大电路存在差别</li>
</ul>
<h2 id="MOSFET基本放大电路拓扑"><a href="#MOSFET基本放大电路拓扑" class="headerlink" title="MOSFET基本放大电路拓扑"></a>MOSFET基本放大电路拓扑</h2><p>MOSFET放大电路就是三极管放大电路的翻版，因此了解该部分之前应该先阅读下一部分【基本放大电路】</p>
<blockquote>
<p>在阅读以下内容前，请确认已经阅读完了【基础放大电路部分】，并务必<em>熟悉三极管放大电路的分析方法</em></p>
</blockquote>
<h3 id="共源放大电路"><a href="#共源放大电路" class="headerlink" title="共源放大电路"></a>共源放大电路</h3><p>对应共射放大电路，拓扑如下所示</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E3%80%91/image-20211108215530571.png" alt="image-20211108215530571"></p>
<ol>
<li><p>静态分析</p>
<p> 在设计实际放大电路之前需要先设置好管子的静态工作点。该电路可以使用三种方式获得稳定的静态工作点</p>
<ol>
<li><p>基本偏置</p>
<p> 和上面的基本拓扑一样，可以完成基本的放大任务，但是存在很多问题</p>
<p> <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E3%80%91/image-20211205222943460.png" alt="image-20211205222943460"></p>
</li>
<li><p>自给偏压电路</p>
<p> 这个电路可以由正电源获得负偏压，这样就能放大正负周期信号了，但是只有结型场效应管、耗尽型MOS管才适合使用这种方式。自给偏压电路<strong>不适合增强型MOS管使用</strong>，因为在共源放大电路中，需要较大的驱动电压才能让增强型MOSFET工作，但是输入耦合电容C1会对交流信号大量分压，使得带载能力弱的信号无法驱动MOSFET</p>
<p> <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E3%80%91/image-20211108220139048.png" alt="image-20211108220139048"></p>
</li>
<li><p>分压偏置电路</p>
<p> 一般来说MOSFET都会使用这个拓扑来获得完善的静态工作点</p>
<p> <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E3%80%91/image-20211108220158343.png" alt="image-20211108220158343"></p>
</li>
</ol>
</li>
<li><p>动态分析</p>
<p> <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E3%80%91/image-20211205223306771.png" alt="image-20211205223306771"></p>
<p> 对应的交流等效电路如下（可以看到忽略了很多东西）</p>
<p> <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E3%80%91/image-20211108215956098.png" alt="image-20211108215956098"></p>
<p> 不难看出，共源放大电路的特点就是输入电阻即答，输出电阻由“上拉电阻Rd”决定<br> $$<br> R_i=\infty \<br> R_o=R_d\<br> A_u=-g_m R_d<br> $$</p>
</li>
</ol>
<h3 id="共漏放大电路"><a href="#共漏放大电路" class="headerlink" title="共漏放大电路"></a>共漏放大电路</h3><p>对应共集放大电路，拓扑如下所示</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E3%80%91/image-20211108220521743.png" alt="image-20211108220521743"></p>
<p>对应的电路分析等效如下</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E3%80%91/image-20211205223557520.png" alt="image-20211205223557520"></p>
<p>可以看到<br>$$<br>R_i=\infty \<br>$$</p>
<p>$$<br>R_o=R_s//r_{GS} \<br>$$</p>
<p>$$<br>A_u=\frac{g_m R_s}{1+g_m R_s}<br>$$</p>
<blockquote>
<p>最后请读者重新阅读最开头的datasheet，看看能不能读明白</p>
</blockquote>
]]></content>
      <tags>
        <tag>电路设计</tag>
      </tags>
  </entry>
  <entry>
    <title>电路设计从入门到弃坑【多级放大电路】</title>
    <url>/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%A4%9A%E7%BA%A7%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E3%80%91/</url>
    <content><![CDATA[<h1 id="电路设计从入门到弃坑4【多级放大电路】"><a href="#电路设计从入门到弃坑4【多级放大电路】" class="headerlink" title="电路设计从入门到弃坑4【多级放大电路】"></a>电路设计从入门到弃坑4【多级放大电路】</h1><p>基本放大电路可以应付常用的情景，但是在需要微小信号放大（要求A<del>u</del>&gt;=5000）、大输入阻抗、小输出阻抗、极宽通频带的时候，就难以应付了，因此引入了多级放大电路，通过组合多个单极放大电路的方式改进放大电路的参数特性。</p>
<h2 id="多级放大电路的耦合方式"><a href="#多级放大电路的耦合方式" class="headerlink" title="多级放大电路的耦合方式"></a>多级放大电路的耦合方式</h2><p><strong>耦合</strong>：两个功能相关但拓扑不同电路之间连接的方式</p>
<p>多级放大电路常采用以下的耦合方式</p>
<span id="more"></span>

<h3 id="直接耦合"><a href="#直接耦合" class="headerlink" title="直接耦合"></a>直接耦合</h3><p>两级放大电路的输入输出直接通过导线级联</p>
<p>优点：能够放大低频/高频信号，便于集成化</p>
<p>缺点：会产生<strong>零点漂移</strong>，且信号失真部分会逐级放大</p>
<p>零点漂移指的是由于前后级电路相互影响，尤其是共射放大电路接在c极上电阻R<del>c</del>作用下，后级电路Q点电势被抬高，以至于输入为0时，输出产生变化的现象</p>
<p>输入信号越微小，零点漂移越严重，前级由于温度变化引起的电流、电势变化会逐级放大以至于输出失真</p>
<p>面对这种情况，可以考虑<strong>在e极和地之间接入稳压管，并在Vcc和e极之间跨接上拉电阻</strong>，这样就能通过稳压二极管的负反馈<strong>抑制零点漂移</strong></p>
<p>采用基本放大电路的温度改进版拓扑也是一种抑制零点漂移的方法</p>
<p>此外，直接耦合非常不适合两个NPN管级联使用——后级电路c极电势会被前级电路的c极抬升，级联越多，抬升越明显，最后甚至会接近电源电压，这样三极管就无法实现放大作用了。而PNP、NPN管混合级联就可以相对应避免这种情况</p>
<blockquote>
<p>在之后还会介绍使用PNP、NPN管共同构建的准互补OCL电路，该电路具有较好的放大性能，使用的就是类似直接耦合的思想</p>
</blockquote>
<h4 id="零点漂移现象的详细解释"><a href="#零点漂移现象的详细解释" class="headerlink" title="零点漂移现象的详细解释"></a>零点漂移现象的详细解释</h4><p>【待补全】</p>
<h3 id="阻容耦合"><a href="#阻容耦合" class="headerlink" title="阻容耦合"></a>阻容耦合</h3><p>在前后级之间接入大电容，就可以将前后级隔离开</p>
<p>这种思路简单粗暴，称为阻容耦合</p>
<p>并且由于前后级隔离、直流通路和交流通路隔离，整个电路的零点漂移被完美抑制！Q点相互独立，也很方便调参</p>
<p>但是由于级联中使用的耦合电容往往容量在1uF以上，甚至某些低频信号需要使用法拉电容进行耦合，因此不适合集成化。往往能在高端功放中看到阻容耦合的放大器，它们一般会使用很大的电容来获取好的低频特性，因此造价不菲。</p>
<p>优点：Q点相互独立，能有效抑制零点漂移</p>
<p>缺点：不能放大变化缓慢的信号，低频特性差，不能集成化</p>
<h3 id="变压器耦合"><a href="#变压器耦合" class="headerlink" title="变压器耦合"></a>变压器耦合</h3><p>变压器体积巨大，听名字就知道这个耦合方法不适合集成电路</p>
<p>但是这种耦合方法常见于各种开关电源——使用变压器耦合-反馈并存的特性在输出的同时获得反馈对开关信号进行调制。高频情况下变压器的功率特性比较接近理想变压器，这种耦合方式的功率特性也不错</p>
<p>然而并不能用于集成电路——甚至一般的低频分立元件放大器也很少使用</p>
<h3 id="光电耦合"><a href="#光电耦合" class="headerlink" title="光电耦合"></a>光电耦合</h3><p>使用光耦进行电信号耦合</p>
<p>特点就是频率特性差但是能够做到前后级绝对隔离</p>
<p>常用于两个不同电压域之间的信号传输</p>
<h2 id="多级放大电路理论分析方法"><a href="#多级放大电路理论分析方法" class="headerlink" title="多级放大电路理论分析方法"></a>多级放大电路理论分析方法</h2><p>多级放大电路实际上就是基本放大电路的简单组合，只要掌握了基本放大电路的分析流程，多级放大电路最多就是乘乘除除</p>
<h3 id="直流通路分析"><a href="#直流通路分析" class="headerlink" title="直流通路分析"></a>直流通路分析</h3><ol>
<li><p>静态工作点</p>
<p> 对于直接耦合的电路，需要从输入开始依次计算三极管的静态工作点，并在前级c极电压的基础上计算后一级的静态工作点，因为每个三极管的静态工作点都会由于直接耦合而累加起来；对于阻容耦合的电路，分别计算所有直流通路的静态工作点即可</p>
</li>
<li><p>带载能力</p>
<p> 多级放大电路的带载能力由供电电源功率决定，需要结合交流通路中的负载和电源能提供的最大功率计算</p>
</li>
</ol>
<h3 id="交流通路分析"><a href="#交流通路分析" class="headerlink" title="交流通路分析"></a>交流通路分析</h3><ol>
<li><p><strong>电压放大倍数</strong><br> $$<br> A_u=\frac{u_o}{u_i}=\prod_{j=1}^{n}A_{u_j}<br> $$<br> <strong>就是各级放大电路电压增益之积</strong></p>
</li>
<li><p><strong>输入阻抗</strong></p>
<p> <strong>等于第一级放大电路的输入阻抗</strong></p>
</li>
<li><p><strong>输出阻抗</strong></p>
<p> <strong>等于最后一级放大电路的输出阻抗</strong></p>
</li>
</ol>
<p>显然，输入阻抗大、输出阻抗小、放大倍数大、最大不失真输出电压大、通频带大</p>
<p>满足以上要求的放大器就是优秀的放大器了</p>
<h3 id="小结论"><a href="#小结论" class="headerlink" title="小结论"></a>小结论</h3><ul>
<li>在前级均未出现失真的情况下，多级放大电路的最大不失真电压等于输出级的最大不失真电压</li>
<li>放大电路的总体特性需要根据采用的放大电路具体分析</li>
</ul>
<h2 id="多级放大电路实际分析方法"><a href="#多级放大电路实际分析方法" class="headerlink" title="多级放大电路实际分析方法"></a>多级放大电路实际分析方法</h2><p>现在的放大电路常常以集成运放的形式出现，集成运放相关内容会在之后的博文涉及，因此这里不赘述。厂商往往会为自家的集成运放配备计算工具、datasheet、辅助脚本乃至仿真器等工具，只要将相关参数输入计算工具，就可以轻松得到要选用的电路元件参数和放大电路特性。</p>
<p>而在设计集成运放时，会使用PSpice等仿真软件，直接根据晶体管特性仿真得到电路的相关参数，它们往往依赖VHDL、hspice等模拟集成电路设计工具。</p>
<p>设计电路和分析电路时需要结合理论分析和工具仿真来得到可信结果</p>
]]></content>
      <tags>
        <tag>电路设计</tag>
      </tags>
  </entry>
  <entry>
    <title>电路设计从入门到弃坑【差分放大电路】</title>
    <url>/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%B7%AE%E5%88%86%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E3%80%91/</url>
    <content><![CDATA[<h1 id="电路设计从入门到弃坑5【差分放大电路】"><a href="#电路设计从入门到弃坑5【差分放大电路】" class="headerlink" title="电路设计从入门到弃坑5【差分放大电路】"></a>电路设计从入门到弃坑5【差分放大电路】</h1><p>之前的博文里介绍了基本放大电路的拓扑和分析方法，并且利用这些电路构造出多级放大电路；多级放大器可以解决大多数信号处理中产生的问题——但是很多晶体管本身的问题并不能通过组合放大器来解决，而且一般的放大器组合以后很可能还会导致一些新问题出现（比如交越失真），需要进一步改进。在放大器出现早期，由于当时技术缺陷，晶体管受温度影响非常大，面对这种情况，很多电路都会使用外电路补偿，而随着控制理论的发展，差分放大电路应运而生，很大程度上解决了晶体管受温度影响大的问题</p>
<span id="more"></span>

<h2 id="零点漂移"><a href="#零点漂移" class="headerlink" title="零点漂移"></a>零点漂移</h2><p><strong>零点漂移</strong>：放大电路中输入电压为0，但是输出电压不为0的现象</p>
<p>产生<strong>原因</strong>：</p>
<ul>
<li>温度变化</li>
<li>直流电源波动（偏置电流不稳定）</li>
<li>元器件老化</li>
</ul>
<p>主要原因是<strong>晶体管对温度敏感</strong>，因此零点漂移（零漂）也称为温度漂移（温漂）</p>
<p>克服温漂的方法：<strong>引入直流负反馈</strong>，<strong>温度补偿</strong>。</p>
<p>为了解决零点漂移的问题，人们构造了差分放大电路</p>
<h2 id="差分放大电路"><a href="#差分放大电路" class="headerlink" title="差分放大电路"></a>差分放大电路</h2><p>基本放大电路是这样的：</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%B7%AE%E5%88%86%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E3%80%91/image-20211126193536767.png" alt="image-20211126193536767"></p>
<p>信号从Rb输入三极管，而当发生零点漂移时，Rb相当于短路，而uo处相当于存在一个直流激励</p>
<p>自然可以想到在uo处加入一个电流源（或用电压源替代）来消除零点漂移，如下所示</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%B7%AE%E5%88%86%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E3%80%91/image-20211126193735965.png" alt="image-20211126193735965"></p>
<p>考虑到这个电压源要跟随三极管的性质变化而变化，显然无法实现，于是考虑从三极管本身的性质入手</p>
<p>假设存在一个和T完美对称的三极管，把它组成基本放大电路后接到uo的负极，于是就可以等效替代这个电压源了，如下图</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%B7%AE%E5%88%86%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E3%80%91/image-20211126193919573.png" alt="image-20211126193919573"></p>
<p>显而易见，Re1和Re2还可以用一个电阻Re=Re1//Re2来等效，于是我们就得到了教科书里面常见的<strong>差分放大电路拓扑</strong>，如下所示：</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%B7%AE%E5%88%86%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E3%80%91/image-20211126194055051.png" alt="image-20211126194055051"></p>
<p>其中两个三极管放大电路的参数抑制，因此外电路支路量也一致，并且<strong>等于其中一个三极管放大电路支路量的2倍</strong><br>$$<br>I_{BQ1}=I_{BQ2}=I_{BQ}\<br>$$<br>$$<br>I_{CQ1}=I_{CQ2}=\frac12 I_{C}\<br>$$</p>
<p>$$<br>I_{CQ1}=I_{CQ2}=\frac12 I_{C}\<br>$$</p>
<p>$$<br>I_{EQ1}=I_{EQ2}=\frac12 I_{E}\<br>$$</p>
<p>$$<br>U_{CQ1}=U_{CQ2}=U_{CQ}\<br>$$</p>
<p>$$<br>u_{OC}=U_{CQ1}-U_{CQ2}=0\<br>$$</p>
<p>其中Uoc指<em>共模信号</em>（见下文解释）</p>
<p>为了对这个电路放大的信号进行区分，定义两类信号</p>
<ul>
<li>共模信号Uc（Common）：大小相等、极性相同的信号</li>
<li>差模信号Ud（Difference）：大小相等、极性相反的信号</li>
</ul>
<p>需要注意，这里说的极性指的不只是信号的正负极，还可以理解成“信号导数的符号”</p>
<blockquote>
<p>当Ua、Ub具有相同增减性时（Ub增大，Ua也增大），二者就是一对共模信号；相反，当Ua、Ub增减性相反时，二者就被视为一对差模信号</p>
</blockquote>
<p>特别指出：共模信号如果大小不等，计算时一般使用两个信号的平均值$\frac{A+B}{2}$；差模信号则使用两个信号之差的平均$\frac{|A-B|}{2}$</p>
<p>直观上看，零点漂移就是与晶体管<strong>本身</strong>有关的共模信号。差分放大电路可以有效抑制这种共模信号，并将外加到Ui1、Ui2上的差模信号正常放大。</p>
<blockquote>
<p>这里的表述不严谨，相关等效推理请看下面的“反馈”介绍</p>
</blockquote>
<p>电路左侧Ui1称为同相输入端，右侧Ui2则是反相输入端——对于上面的基本差分放大电路，这个定义是可以左右互换的</p>
<p>另外有一个不引人注意的问题：差分放大电路需要引入<em>负电源</em>——为了放大完整的交流信号，这是必要的，并且负电源应该和正电源对称。当然这就使得差分放大电路的应用存在一定难度。不过在之后我们会介绍修复这个问题的方法</p>
<p><strong>这个电路只能工作在理想状态下</strong></p>
<blockquote>
<p>现实中没有两个一模一样的三极管，如果有，那就是测量精度不够高</p>
<p>在人类能造水滴之前，大概是没办法生产出这样的晶体管的（笑）</p>
</blockquote>
<p>但是根据这个电路，我们可以有效地克服零点漂移、抑制共模信号、放大差模信号</p>
<p>它可以作为实际差分放大电路的理想模型使用；而实际使用的差分放大电路就是根据它设计出来的。在介绍实际使用的差分放大电路之前，我们还应该仔细讨论一下<strong>长尾式差分放大电路</strong>的性质，并引入一些新概念</p>
<h2 id="长尾式差分放大电路"><a href="#长尾式差分放大电路" class="headerlink" title="长尾式差分放大电路"></a>长尾式差分放大电路</h2><blockquote>
<p>因为Re就像是一个长尾巴所以上面的基本差分放大电路被称为长尾式差分放大电路</p>
</blockquote>
<p>不管什么放大电路，归根结底都可以用之前说的放大电路分析流程去套用。首先来看静态分析</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%B7%AE%E5%88%86%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E3%80%91/image-20211126201942159.png" alt="image-20211126201942159"></p>
<p>差分放大电路的静态分析体现了它的<em>共模抑制效应</em></p>
<p>在这里假设Uic是一个输入的共模信号（包括且不限于零漂、线阻导致的信号偏移、雷击导致的感应电流），因为共模信号对整个电路起作用，而且我们要分析的是共模信号对输出的影响，所以在这里等效为两输入端接到一个电压源的同极</p>
<p>显而易见，</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%B7%AE%E5%88%86%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E3%80%91/image-20211126202347153.png" alt="image-20211126202347153"></p>
<p>并且</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%B7%AE%E5%88%86%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E3%80%91/image-20211126202403502.png" alt="image-20211126202403502"></p>
<p>也就是说当**两个三极管完美对称时，共模放大倍数$A_C=\frac{\Delta u_{Oc}}{\Delta u_{Ic}}=0$**，共模信号得到了抑制</p>
<p>特别指出这里的共模信号：<br>$$<br>u_{I1}=u_{I2}=u_{Ic}<br>$$<br>上面的推导看似很完美，但是只要你想起这篇文章的开篇就能知道一个问题：温漂是三极管内部的问题，怎么把它等效成一个外部问题？</p>
<p>这就是Re发挥的<em>负反馈</em>作用</p>
<p>首先引入一个名词：<strong>反馈</strong>（Feedback）。反馈指的是将系统的输出引回输入的过程，Re就将温度变化引起的各种信号变化等效为共模信号。当温度升高，会导致三极管CE结压降减少，相对应Ic会增大，进而导致Ue电位升高（因为Re分压把Ue的电位抬高了，这就是Re发挥的作用），导致基极电流Ib减少，于是Ic=βIb，Ic就又小了。经过这套流程，Re相当于把Ic反馈到了两管的b极（正规说法就是电流负反馈，具体解释会在后面集成运放的部分讲述）</p>
<p>接下来再进行动态分析，如下图所示：</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%B7%AE%E5%88%86%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E3%80%91/image-20211126202008754.png" alt="image-20211126202008754"></p>
<p>动态分析主要关注信号输入对信号输出造成的影响，信号输入是典型的一对差模信号，具有以下关系：<br>$$<br>u_{I1}=-u_{I2}=u_{Id}/2<br>$$<br>直接用一堆带Δ的量表示差模信号，如下图所示：</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%B7%AE%E5%88%86%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E3%80%91/image-20211126215002871.png" alt="image-20211126215002871"></p>
<p>可以推知：$\Delta i_{E1}=-\Delta i_{E2}$，即Re对差模信号无反馈作用</p>
<p>差模放大倍数<br>$$<br>A_d=\frac{\Delta u_{Od}}{\Delta u_{Id}}=-\frac{\beta (R_C // \frac{R_L}{2})}{R_b+r_{be}}<br>$$<br>其中$R_i=2(R_b+r_{be})$，$R_O=2R_C$</p>
<h2 id="差分放大电路的接法"><a href="#差分放大电路的接法" class="headerlink" title="差分放大电路的接法"></a>差分放大电路的接法</h2><p>经过上述分析，已经能够基本得到差分放大电路的总体拓扑和原理，下面先介绍一下它的几个参数</p>
<ul>
<li><p>共模抑制比$K_{CMR}=\frac{A_d}{A_c}$：表述差分放大电路放大差模信号和抑制共模信号的能力</p>
<p>  当差分放大电路参数理想对称时，$K_{CMR}=\infty$</p>
<p>  <strong>该参数越大，差分放大器性能越好</strong></p>
</li>
<li><p>差模放大倍数$A_d$</p>
</li>
<li><p>共模放大倍数$A_c$</p>
</li>
<li><p>输入电阻$R_i$</p>
</li>
<li><p>输出电阻$R_o$</p>
</li>
</ul>
<p>上面这些参数也会在之后介绍的运算放大器中出现，其中共模抑制比、差模、共模放大倍数是差分放大电路独有的参数</p>
<h3 id="差分放大电路具有四种基本接法"><a href="#差分放大电路具有四种基本接法" class="headerlink" title="差分放大电路具有四种基本接法"></a>差分放大电路具有四种基本接法</h3><ol>
<li><p>双入单出</p>
<p> <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%B7%AE%E5%88%86%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E3%80%91/image-20211126215943041.png" alt="image-20211126215943041"></p>
<p> 基本参数变化情况如下：</p>
<p> 输入回路没有变化，Ieq、Ibq、Icq和双端输出时候一样，但是输出端发生了变化：<br> $$<br> U_{CQ2}=V_{CC}-I_{CQ}R_C\<br> $$<br> $$<br> U_{CQ1}=\frac{R_L}{R_C+R_L} V_{CC}-I_{CQ}(R_C//R_L) \cdot \cdot \cdot \cdot这里出现了变化<br> $$</p>
<p> 同时，差模信号下<br> $$<br> A_d=-\frac12 \frac{\beta(R_C //R_L)}{R_b+r_{be}}\<br> $$<br> $$<br> A_c=-\frac{\beta(R_C //R_L)}{R_b+r_{be}+2(1+\beta)R_e}<br> $$</p>
<p> 需要特别注意：</p>
<p> 双端输出时的Ad<strong>不是</strong>单端输出时的两倍</p>
<p> 单端：$A_d=-\frac{\beta (R_C // \frac{R_L}{2})}{R_b+r_{be}}$</p>
<p> 双端：$A_d=-\frac12 \frac{\beta(R_C //R_L)}{R_b+r_{be}}$</p>
</li>
<li><p>双入双出</p>
<p> 就是上面作为例子介绍的最基本接法</p>
<p> 不再赘述</p>
</li>
<li><p>单入双出</p>
<p> 对于单端输入的差分放大电路，<strong>输入差模信号的同时总是伴随着共模信号输入</strong><br> $$<br> u_{Id}=u_I\<br> u_{Ic}=u_I/2<br> $$<br> <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%B7%AE%E5%88%86%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E3%80%91/image-20211126221455004.png" alt="image-20211126221455004"></p>
<p> 于是<br> $$<br> u_O=A_d u_I+A_C \frac{u_I}{2} +U_{OQ}<br> $$<br> 输出=差模输出+共模输出+静态偏置</p>
</li>
<li><p>单入单出</p>
<p> 单端输入单端输出则融合了上面所说的输入输出特点：</p>
<ul>
<li><p>双端输入时<strong>无共模信号输入</strong>；单端输入时<strong>有共模信号输入</strong></p>
</li>
<li><p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%B7%AE%E5%88%86%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E3%80%91/image-20211126221717344.png" alt="image-20211126221717344"></p>
</li>
<li><p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%B7%AE%E5%88%86%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E3%80%91/image-20211126221725724.png" alt="image-20211126221725724"></p>
<p>  （上面都是来自模电老师ppt的截图，太全了）</p>
</li>
</ul>
</li>
</ol>
<p>这就是差分放大电路在接入时的特点</p>
<p>需要注意：双端输出具有比单端输出更优秀的差分特性，所以尽可能使用双端输出；单端输入则让一部分共模信号输入放大电路，在某些场合是必要的，不能够一味否定</p>
<h2 id="改进的差分放大电路"><a href="#改进的差分放大电路" class="headerlink" title="改进的差分放大电路"></a>改进的差分放大电路</h2><p>根据上述计算，Re越大，每边漂移越小，共模负反馈越强，那么单端输出时的Ac越小，Kcmr越大，差分放大器性能越好；但是Re越大，所需Vee越大；同时三极管很难做到完美对称，中间损失的部分必须使用更强的Re反馈来弥补。综上所述，为了让差分放大电路能在现实中得到应用，我们需要趋于无穷大的Re和合适的Ieq</p>
<p>于是<strong>可以用电流源取代Re</strong></p>
<p>一个恒流源的等效电阻为无穷大，而且能为三极管提供合适的偏置电流</p>
<p>在实际应用中往往使用<strong>镜像电流源</strong>电路来实现，相关内容会在后面的运算放大器结构部分介绍，这里简单看一下它的理想电路模型</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%B7%AE%E5%88%86%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E3%80%91/image-20211126222826560.png" alt="image-20211126222826560"></p>
<p>为了弥补两个三极管不对称带来的误差电流，还可以在电流源和三极管e极之间接入一个<strong>调零电位器</strong>Rw</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%B7%AE%E5%88%86%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E3%80%91/image-20211126222921976.png" alt="image-20211126222921976"></p>
<p>其取指应当稍大，这样可以减少损耗电流</p>
<p>引入这个电位器后，可以通过调节它的中点位置来平衡两边三极管e极流过的电流，使得差分电路完美对称，给电路带来以下参数变化：<br>$$<br>A_d=-\frac{\beta R_C}{R_b+r_{be}+(1+\beta)\frac{R_W}{2}}\<br>$$<br>$$<br>R_i=2(R_b+r_{be})+(1+\beta)R_W<br>$$</p>
<p>对于集成电路实现的差分放大电路，因为制作MOSFET比较方便，可以使用MOSFET制造差分放大电路，如下图所示</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%B7%AE%E5%88%86%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E3%80%91/image-20211126223230929.png" alt="image-20211126223230929"></p>
<p>也有着不错的效果</p>
]]></content>
      <tags>
        <tag>电路设计</tag>
      </tags>
  </entry>
  <entry>
    <title>电路设计从入门到弃坑【集成运算放大器的构成】</title>
    <url>/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E6%9E%84%E6%88%90%E3%80%91/</url>
    <content><![CDATA[<h1 id="电路设计从入门到弃坑7【集成运算放大器的构成】"><a href="#电路设计从入门到弃坑7【集成运算放大器的构成】" class="headerlink" title="电路设计从入门到弃坑7【集成运算放大器的构成】"></a>电路设计从入门到弃坑7【集成运算放大器的构成】</h1><p>在之前的运放简介部分，已经介绍过运算放大器的基本构成，这部分要结合电路原理推导来详细说明一下集成运放的构成</p>
<p>在开始之前我们先来看一个经典运放LM358的datasheet</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E6%9E%84%E6%88%90%E3%80%91/image-20211218204757164.png" alt="image-20211218204757164"></p>
<p>如右上角图片所示，LMx58家族有三种主要封装：比较大体积的PDIP-8、小体积的SOIC-8和不常见的Micro8，一般来说个人DIY最常用的就是DIP-8封装，而如果制作PCB的话还是应该选择体积较小相对性能更好的SOIC-8</p>
<p>左侧介绍也已经说了：LM358是LM324这个四路运放芯片的一半，也就是双运放IC，它们都属于<strong>通用运放</strong>，运放是分为各种特化类型的，相关内容会在之后介绍。</p>
<span id="more"></span>

<p>它们的供电电压很宽：3V最低32V最高，同时还能使用负电源</p>
<p>右下角部分就是它的封装图了，内部包含两个输入输出独立的运放模块，而它们共用一套供电</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E6%9E%84%E6%88%90%E3%80%91/image-20211218205243270.png" alt="image-20211218205243270"></p>
<p>下面这部分简要介绍了IC的性能，基本上现代的运放都得标配这些</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E6%9E%84%E6%88%90%E3%80%91/image-20211218205404100.png" alt="image-20211218205404100"></p>
<p>可以看到它支持两套供电方式：单电源或双电源，注意之前说的宽供电电压在双电源使用的情况下就会变成标定的1/2</p>
<p>下面是我们的重点：内部电路图</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E6%9E%84%E6%88%90%E3%80%91/image-20211218205520690.png" alt="image-20211218205520690"></p>
<p>看起来很复杂，但是不要慌，我们接下来就要把这个电路图分成四个基本部分，用上一部分说过的结构去分析它</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E6%9E%84%E6%88%90%E3%80%91/image-20211218205617637.png" alt="image-20211218205617637"></p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E6%9E%84%E6%88%90%E3%80%91/image-20211218205628299.png" alt="image-20211218205628299"></p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E6%9E%84%E6%88%90%E3%80%91/image-20211218205643204.png" alt="image-20211218205643204"></p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E6%9E%84%E6%88%90%E3%80%91/image-20211218205657393.png" alt="image-20211218205657393"></p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E6%9E%84%E6%88%90%E3%80%91/image-20211218205725260.png" alt="image-20211218205725260"></p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E6%9E%84%E6%88%90%E3%80%91/image-20211218205740855.png" alt="image-20211218205740855"></p>
<p>这一部分都是对运放性能的阐述，这部分内容会放到下一篇博文的应用部分去仔细说明</p>
<p>后面的datasheet还附上了典型应用（typical application），同样会放到下一篇博文说明</p>
<h2 id="集成运放概念复习"><a href="#集成运放概念复习" class="headerlink" title="集成运放概念复习"></a>集成运放概念复习</h2><p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E6%9E%84%E6%88%90%E3%80%91/image-20211218211302448.png" alt="image-20211218211302448"></p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E6%9E%84%E6%88%90%E3%80%91/image-20211218211607209.png" alt="image-20211218211607209"></p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E6%9E%84%E6%88%90%E3%80%91/image-20211218211617653.png" alt="image-20211218211617653"></p>
<p>理想运放是一套双输入单输出的差分放大器，共模和差模输入电阻都为无穷大，输出电阻为0，差模电压放大倍数为正无穷大，共模电压放大倍数为0，通频带也为无穷大；实际运放已经能够近似成理想运放，所以之后的推导都会以理想运放模型为基础，只有在需要修正的时候才加以补充</p>
<h2 id="输入级、放大级和偏置电路"><a href="#输入级、放大级和偏置电路" class="headerlink" title="输入级、放大级和偏置电路"></a>输入级、放大级和偏置电路</h2><p>输入级就是应用长尾式差分放大电路，放大级就是应用一套级连或者使用达林顿管的共射放大电路，而偏置电路使用的镜像电流源在上一篇中已经讲过，这里不再赘述</p>
<p>这里主要结合之前的知识对上面的LM358内部电路进行一下分级</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E6%9E%84%E6%88%90%E3%80%91/image-20211218205520690.png" alt="image-20211218205520690"></p>
<p>先看最右边，这个电路是两套运放的共同偏置电路，负责提供一个总偏置电位，电流通过Q23的e极节点输出到Q1，进而调节左侧Q15的输出电流。</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E6%9E%84%E6%88%90%E3%80%91/image-20211218212841640.png" alt="image-20211218212841640"></p>
<p>Q15、Q16和Q19是主要的偏置电流提供管，同时Q15还具有为输出极提供推挽电流的作用</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E6%9E%84%E6%88%90%E3%80%91/image-20211218213150441.png" alt="image-20211218213150441"></p>
<p>再来看输入级这边的一坨管子</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E6%9E%84%E6%88%90%E3%80%91/image-20211218213244102.png" alt="image-20211218213244102"></p>
<p>可以很明显地发现Q17、Q18、Q21、Q20共同构成一套改良的差分放大器作为输入级，同时长尾端所需电流源由Q3、Q4实现，它们所需的电流供能和偏置都来自Q19，Q2、Q5则起到反馈作用，这两个管子先按下不表。再来看右下角的一堆</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E6%9E%84%E6%88%90%E3%80%91/image-20211218213537671.png" alt="image-20211218213537671"></p>
<p>它们都纠缠在一起，看起来不好拆解，于是按节点找到周围的管子</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E6%9E%84%E6%88%90%E3%80%91/image-20211218213646290.png" alt="image-20211218213646290"></p>
<p>发现右边的Q8、Q10是一个镜像源，Q10的c极又被直接拉到输出端，Q8的镜像输入则来自Q7b极；Q6、Q26的偏置都来自电流源Q16，它们似乎组成了一对推挽输出极，输出在Q9放大后推给了Q11，看似放大级的构造但是分析不出什么，那我们再来看看上一级差分放大电路的输出具体到了哪里</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E6%9E%84%E6%88%90%E3%80%91/image-20211218214052598.png" alt="image-20211218214052598"></p>
<p>它通过一个5pF电容耦合到了Q12的c极和Q9的c极，这就很明显了：右下角一坨电路并不是放大级：其中的Q6、Q7、Q26、Q8都是为Q9提供信号的，它们把来自Q5的信号变换为反相后，由Q9输出一个拉电流，这样就能实现对信号负半周的放大了。这里电路的主要作用是通过反馈消除信号的失真并增宽通频带</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E6%9E%84%E6%88%90%E3%80%91/image-20211218215328338.png" alt="image-20211218215328338"></p>
<p>真正的放大级由Q14、Q9共同组成，Q14是一个射随器，输出电流被送到Q13上通过40k电阻转化成电压信号驱动Q13；而Q9的拉电流负责驱动Q11；Q11、Q12是典型的推挽输出级，也就是驱动级（后面会详细讲），它可以提供很大的输出电流；这个输出电流又被25欧电阻采样为电压信号反馈给Q14和Q9，从而稳定输出，消除交越失真</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E6%9E%84%E6%88%90%E3%80%91/image-20211218215822371.png" alt="image-20211218215822371"></p>
<p>最后说会Q2、Q5两个电阻，这两个电阻主要构成了运放的保护回路——当电流过大时，两管会直接导通以卸掉电流源电路的额外功率，Q5还会通过Q6、Q7等反馈机制把后续的输出稳定下来</p>
<blockquote>
<p>以上内容全部为个人理解，很多内容有错漏见谅，恳请各位批评指正</p>
<p>网上对于这种通用运放的分析太少了……只能自己胡诌（</p>
</blockquote>
<p>分析电路的基本方法如下：</p>
<ul>
<li><strong>了解用途</strong>：了解要分析的电路的应用场合、用途和技术指标</li>
<li><strong>拆解电路</strong>：将整个电路图分为各自具有一定功能的基本电路，按信号流通顺序或反馈回路顺序或功能模块顺序依次分析各个子电路</li>
<li><strong>分析功能</strong>：定性分析每个子电路的基本功能和性能，如果分析不通应该从输出端的反馈回路看回来</li>
<li><strong>统观整体</strong>：从模块分布确定电路相互连接关系以及连接后电路实现的功能和性能，分析整个电路的性能特点</li>
<li><strong>定量计算</strong>：对于含有电容、电阻等元件的电路，一定仔细看好参数，通过计算或估算或计算机仿真确定其作用和电路参数</li>
</ul>
<h2 id="驱动级"><a href="#驱动级" class="headerlink" title="驱动级"></a>驱动级</h2><p>驱动级通常使用一套功率放大器拓扑，因为集成运放的主要使用目的是放大模拟信号而不是进行功率输出，所以一般都会简单使用消除了交越失真的OCL电路，详细内容可以参考后面的功率放大电路部分，这里仅做简要介绍</p>
<p>一般使用下面的这个结构组成推挽输出级</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E6%9E%84%E6%88%90%E3%80%91/image-20211219160149001.png" alt="image-20211219160149001"></p>
<p>这个拓扑称为消除交越失真的准互补<strong>OCL电路</strong>，左侧两个二极管利用它们的管压降，配合上面的R6来消除后面三极管的<strong>交越失真</strong></p>
<blockquote>
<p>交越失真是在输入信号发生正半周-负半周交替的时候，由于电压没有达到晶体管门限电压，负责放大的晶体管并不导通，在对应部分出现输出电压为0的特殊情况</p>
<p>通过让晶体管处于放大区和截止区之间的临界状态或让晶体管提前/延后导通可以消除交越失真</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E6%9E%84%E6%88%90%E3%80%91/image-20211219160417012.png" alt="image-20211219160417012"></p>
<p>上面的波形描述的就是交越失真了</p>
<p>这里用的方法就是让两个二极管-0.7V的电势差和三极管be结+0.7V的电势差相互抵消，于是就能让三极管上管提前导通，下管延后导通，从而消除交越失真</p>
</blockquote>
<p>两个NPN-PNP管e极接到一起，NPN管c极接正电源，PNP管c极接负电源，两者b极接到同一个信号输入，这就构成了图腾柱放置，也就是所谓的<strong>推挽输出</strong>。其中NPN管称为<strong>上管</strong>；PNP管称为<strong>下管</strong>，正半轴时NPN管导通，负半周时PNP管导通，这样就能放大整个波形了</p>
<p>不过这种交替导通并消除交越失真的电路会导致晶体管一直工作在放大状态，发热严重效率相对低。这种电路称为<em>甲乙类功放</em>电路</p>
<p>后面的内容中会仔细讲解功率放大电路，这里就先理解这部分电路是为了运放能够获得<strong>低输出电阻</strong>、<strong>大电流输出能力</strong>和<strong>宽通频带</strong>就可以了</p>
<h2 id="集成运放分类"><a href="#集成运放分类" class="headerlink" title="集成运放分类"></a>集成运放分类</h2><p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%9A%84%E6%9E%84%E6%88%90%E3%80%91/image-20211218222235883.png" alt="image-20211218222235883"></p>
<blockquote>
<p>偷懒放了老师ppt截图，基本分类就是这样——上面这些东西都比较理论，实际上知道每个概念都在讲什么就好</p>
</blockquote>
<p>如果按照性能指标分，就有以下几种主要类型</p>
<ul>
<li><strong>高阻型</strong>：输入电阻很大，可高于10^12Ω，一般用于<strong>仪表放大器</strong>的输入级</li>
<li><strong>高速型</strong>：高频截止频率高，通频带宽会相对窄一些，但是SR很高，可达1000V/μs，用于各种高速设备（ADC/DAC等）</li>
<li><strong>高精度型</strong>：优化失调、温漂抑制、噪声特性，可以达到100dB以上的开环差模放大倍数</li>
<li><strong>低功耗型</strong>：优化静态功耗和动态功耗，一般用于低功耗设备</li>
<li><strong>大功率型</strong>：一般会被做成功放IC的形式，但本质上也是个运放，但是会牺牲开环放大倍数</li>
<li><strong>仪表放大器</strong>：由多个运放构成的复合电路，放大倍数极大、失真度极低</li>
<li><strong>隔离运放</strong>：输入输出-供电端不共地，实现隔离</li>
<li><strong>缓冲放大器</strong>：又称为缓冲门，常用于数字电路或高频模拟电路，一般用高速的三极管或MOS管实现，用于两级电路之间耦合，高输入电阻、低输出电阻、高通频带和几乎为1的放大倍数</li>
</ul>
]]></content>
      <tags>
        <tag>电路设计</tag>
      </tags>
  </entry>
  <entry>
    <title>电路设计从入门到弃坑【集成运算放大器简介】</title>
    <url>/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%AE%80%E4%BB%8B%E3%80%91/</url>
    <content><![CDATA[<h1 id="电路设计从入门到弃坑6【集成运算放大器简介】"><a href="#电路设计从入门到弃坑6【集成运算放大器简介】" class="headerlink" title="电路设计从入门到弃坑6【集成运算放大器简介】"></a>电路设计从入门到弃坑6【集成运算放大器简介】</h1><p>集成电路是以半导体单晶硅为芯片，采用专门的制造工艺，把晶体管、场效应管、二极管、电阻和电容等元件及其之间连线组成的完整电路制作在一起，使之具有特定功能的电路技术</p>
<span id="more"></span>

<p>集成运放是一种典型的模拟集成电路，集成运放具有以下基本特征：</p>
<ul>
<li>级间直接耦合</li>
<li>能够方便制造对管（一致性良好的对偶晶体管），因此广泛采用差分放大电路和电流源电路</li>
<li>能够方便地实现复杂电路，使得性能良好</li>
<li>使用有源元件来替代难以集成的无源器件，甚至会使用大量晶体管替代电阻、电容</li>
<li>多采用复合管工艺</li>
</ul>
<p><strong>实际集成运放的性能非常高</strong>，以至于常常可以近似为理想运放，分析外特征和电气特性时也常常使用理想运放模型进行等效</p>
<p>理想运放即理想运算放大器，就是将集成运放的各项技术指标理想化得到的电路模型，具有以下指标：</p>
<ul>
<li>开环差模电压增益$A_{od}=\infty$</li>
<li>差模输入电阻$r_{id}=\infty$</li>
<li>共模抑制比$A_{od}=\infty$</li>
<li>输出电阻$r_O=0$</li>
<li>输入失调电压、电流、零漂均为0</li>
</ul>
<p>一言以蔽之，<em>输入电阻无穷、输出电阻为0、开环电压放大倍数正无穷、共模抑制比正无穷的差分放大器</em></p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%AE%80%E4%BB%8B%E3%80%91/image-20211125141004634.png" alt="image-20211125141004634"></p>
<p>可以推导出它的重要特征：</p>
<ul>
<li>伏安特性是阶跃函数，i&lt;0时输出$-U_{OM}$，i&gt;0时输出$+U_{OM}$，在i=0时发生跃变</li>
<li>虚短：两输入端电势相等</li>
<li>虚断：两输入端节点流向运放输入端的电流为0</li>
</ul>
<p>上面三个结论会在后面的运放应用部分详细梳理，这里请先当作背景知识记一下</p>
<p>实际的集成运放还是和理想运放有些区别。</p>
<p>一个是它的工作区域分为线性区和非线性区，实际运放的放大倍数无法达到正无穷，因此它的非线性区<em>相对</em>较宽</p>
<blockquote>
<p>实际通用运放的$A_{od}$能够达到几十万倍，因此是“相对较宽”</p>
<p>这也导致集成运放工作在线性区时的最大输入电压$u_P-u_N$值仅为<strong>uV</strong>级别，需要使用反馈机制才能让它工作在线性区</p>
</blockquote>
<p>本篇的重点在于集成运放的内部结构，一个典型运放的结构框图如下所示：</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%AE%80%E4%BB%8B%E3%80%91/image-20211125141212297.png" alt="image-20211125141212297"></p>
<p>其中，</p>
<ul>
<li>偏置电路：为各级放大电路设置合适的静态工作点。采用<strong>电流源电路</strong>（电流镜）构造，为晶体管<strong>提供偏置电流</strong></li>
<li>输入级：又称前置级，多采用差分放大电路。要求<strong>输入电阻</strong>Ri<strong>大</strong>，<strong>差模放大倍数</strong>Ad<strong>大</strong>， <strong>共模放大倍数</strong>Ac<strong>小</strong>，<strong>输入端耐压高</strong>。</li>
<li>中间级：又称主放大级，多采用共射放大电路。要求<strong>有足够的放大能力</strong>。</li>
<li>输出级：又称功率级，多采用准互补输出放大电路。要求<strong>输出电阻</strong>Ro<strong>小</strong>，<strong>最大不失真输出电压</strong>Uom尽可能大。</li>
</ul>
<p>下面来单独讨论各级结构</p>
<h2 id="输入级"><a href="#输入级" class="headerlink" title="输入级"></a>输入级</h2><p><strong>输入级常常</strong>（一定会）<strong>使用差分放大电路拓扑</strong>，目的有三个：</p>
<ul>
<li>抑制共模信号，<strong>防止零漂</strong></li>
<li>提高差模放大倍数，<strong>增大输入电阻</strong></li>
<li>使用高压对管，增大耐压</li>
</ul>
<p>对运放输入级来说，最重要的性能指标就是很大的输入电阻和高共模抑制比</p>
<p>因此运放中常常使用差分放大电路，并构造一个“长尾”电流源来抑制零漂。具体内容会在下一篇中谈到</p>
<h2 id="电流源电路"><a href="#电流源电路" class="headerlink" title="电流源电路"></a>电流源电路</h2><p>电流源电路组成了运放总体的供能系统，可以说运放的所有电路都离不开电流源电路</p>
<p>一般使用三极管或MOS管组成<strong>镜像电流源电路</strong>（也称为电流镜），如下图所示</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%AE%80%E4%BB%8B%E3%80%91/image-20211206222059135.png" alt="image-20211206222059135"></p>
<p>其中有$I_R=(V_{CC}-U_{BE})/R$，因为两个三极管对称，在三极管参数一定时左右分得电流相等，可以推出$I_R=I_C+\frac{2I_C}{\beta}$</p>
<p>经过变换可以推导出<br>$$<br>I_C=\frac{\beta}{\beta+2}I_R<br>$$<br>也就是说当$\beta&gt;&gt;2$时，总有$I_C\approx I_R$，并且不受其他因素干扰</p>
<p><strong>通过设置Vcc和IR的值就可以确定对管的c极电流，从而让处于c极这一支路上所有串联元件电流相等</strong></p>
<blockquote>
<p>考虑厄利尔电压时，c极电流要加入修正项；同时考虑c-e电压产生的c极电流变化，可确定如下公式<br>$$<br>I_C=I_S(e^{\frac{V_{BE}}{V_T}}-1)(1+\frac{V_{CE}}{V_A})\newline<br>\frac{I_{C1}}{I_{C0}}=\frac{1+\frac{V_{CE1}}{V_A}}{1+\frac{V_{CE0}}{V_A}}<br>$$<br>可以发现这个电路得交流小信号模型中诺顿等效电压<br>$$<br>V_{Th}=I_OR_o=I_{C1}\frac{V_A}{I_{C0}}=V_A<br>$$<br>则如果电流源输出为开路，会有$-V_A$这么强的电压出现在晶体管T0两端，很危险；但事实上不会发生这种情况，因为电流源两端电压达到0时晶体管会进入饱和态，上面的公式失效</p>
<p>需要额外注意，在集成电路中，使用超过MΩ级的电阻是很消耗硅片面积的，如果可能，尽量不要使用大电阻来获得某个值的电流，而应该换用电路拓扑，比如使用、<strong>改进型的基本电流源</strong>、<strong>Widlar电流源（微电流源）</strong>、<strong>威尔逊电流源</strong>、或者使用特殊制造工艺的<strong>多重电流源</strong></p>
</blockquote>
<p>当要求提供很小的静态电流，但无法使用大电阻时，可以采用<strong>微电流源</strong>拓扑作为替代方案</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%AE%80%E4%BB%8B%E3%80%91/image-20211208100523942.png" alt="image-20211208100523942"></p>
<p>它仅在T1的e极加入了一个反馈电阻，可以获得以下方程<br>$$<br>U_{BE0}-U_{BE1}=U_T ln(\frac{I_{E0}}{I_{E1}})=I_{E1}R_e<br>$$<br>于是可得$I_{E0}\approx I_{C0}\approx I_R=\frac{V_{CC}-U_{BE0}}{R}$</p>
<p>设计过程中首先要确定$I_{E0}$和$I_{C0}$，然后选定R和$R_e$</p>
<blockquote>
<p>电路中的电阻甚至也可以用一对电流源替换，这样能大大减少使用的电阻，晶体管工作在并联模式，电路的输出电阻<br>$$<br>r_{replace}=(1+\beta)r_{o2}<br>$$</p>
</blockquote>
<p>电流源电路可以通过并联来扩展，如下图所示的<strong>多路电流源</strong>就是用一个三极管作为镜像源，同时提供三路输出</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%AE%80%E4%BB%8B%E3%80%91/image-20211208093347348.png" alt="image-20211208093347348"></p>
<p>这个电路需要根据每一路需要的静态电流来选取$R_{e_n}$的值，恒有以下方程<br>$$<br>U_{BEn}+I_{Rn}R_{en}=U_{BE0}+I_{Rm}R_{e0}<br>$$<br>任意两路的be结电压和电阻分压之和都相等$U_{BEn} \approx U_{BE0}$，在晶体管管型一样的情况下，可以得到<br>$$<br>I_{Rn}R_{en}=I_{R0}R_{e0}<br>$$<br>选取合适的Re即可在镜像源能提供电流的范围内得到任意恒定电流</p>
<p>在集成电路中，可以很方便地在三极管上制造多个集电极，于是就可以制造出这样的电路：</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%AE%80%E4%BB%8B%E3%80%91/image-20211208093918020.png" alt="image-20211208093918020"></p>
<p>它和这个电路等效：<img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%AE%80%E4%BB%8B%E3%80%91/image-20211208093952095.png" alt="image-20211208093952095"></p>
<p>三个集电区面积为$S_0、S_1、S_2$，则有<br>$$<br>\frac{I_{C1}}{I_{C0}}=\frac{S_1}{S_0} \newline<br>\frac{I_{C2}}{I_{C0}}=\frac{S_2}{S_0}<br>$$<br>所以常常通过这个结构利用c结面积变化来实现不同的恒定电流</p>
<blockquote>
<p>简单介绍一下一些改进型的电流源</p>
<p><strong>改进型基本电流源</strong>是在电流源镜像b极和镜像源三极管c极之间加入一个额外的三极管，可以把它较做加射极输出器的电流源</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%AE%80%E4%BB%8B%E3%80%91/image-20211208101302199.png" alt="image-20211208101302199"></p>
<p>参考电流$I_R=\frac{V_{CC}-V_{BE1}-V_{BE3}}{R_1}$，输出电流$I_O=I_{C2}=\frac{I_R}{1+2(\beta^2+\beta_F)}$</p>
<p>这个电流源的最大特点就是通过引入反馈晶体管减少输出电流对晶体管参数的依赖性，两个晶体管参数不完全一致也可以得到相对高精度的电流源输出</p>
<p><strong>威尔逊电流源</strong>常常用于提供高输出电阻的高精度电流输出，广泛应用在各种集成运放内部</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%AE%80%E4%BB%8B%E3%80%91/image-20211208102013338.png" alt="image-20211208102013338"></p>
<p>这个电路可以看作在有源负载电路基础上改进而来，<strong>有源负载电路</strong>就是把基本镜像电流源中的NPN管换成PNP管，这样就实现了灌电流输出，对外可以看成一个吸收电流的网络，可以提供一个恒定的吸收电流。威尔逊电流源在有源负载输出端加入一个调整管，可以让$I_{C2}$高度稳定，只要三个PNP管的特性近似，就可以达到较高的输出精度<br>$$<br>I_{C2}=(1-\frac{2}{\beta^2+2\beta+2})I_R\approx I_R<br>$$<br>当β很大或很小时，都可以认为$I_{C2}\approx I_R$</p>
</blockquote>
<p>MOSFET同样可以构成电流源，显而易见可以通过类似的构造，<strong>通过修改MOSFET沟道尺寸来实现各种不同的输出电流</strong></p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%AE%80%E4%BB%8B%E3%80%91/image-20211218221605156.png" alt="image-20211218221605156"></p>
<p>沟道长宽比S=W/L，则$\frac{I_{Dn}}{I_{D0}}=\frac{S_n}{S_0}$</p>
<h2 id="放大级"><a href="#放大级" class="headerlink" title="放大级"></a>放大级</h2><p>运放中常使用的放大级电路一般是共射放大电路，可以提供很高的放大倍数</p>
<p>针对高频、高精度、低温漂等特性设计的专用运放也会使用共基放大电路</p>
<p>这一部分电路实际上已经在之前的三极管放大电路部分介绍过，不再赘述</p>
<h2 id="直接耦合互补输出"><a href="#直接耦合互补输出" class="headerlink" title="直接耦合互补输出"></a>直接耦合互补输出</h2><p>互补输出级是直接耦合的功率放大电路，基本要求有：</p>
<ul>
<li>带载能力强：必须有足够的驱动能力，为外界负载提供大电流，自身压降也要低</li>
<li>直流功耗小：静态工作电流小，自身损耗低</li>
<li>负载电阻上无直流功耗：不存在零漂</li>
<li>最大不失真输出电压大：双电源供电时$U_{OM}$接近电源电压；单电源供电时也要接近1/2的电源电压</li>
</ul>
<p>最常用的电路拓扑就是<strong>推挽输出</strong>的OCL电路</p>
<p>详细内容将在之后介绍</p>
<h2 id="集成运放的基本应用"><a href="#集成运放的基本应用" class="headerlink" title="集成运放的基本应用"></a>集成运放的基本应用</h2><p>从集成运放开始，模拟电路就进入了“宏观”应用，在此之前的内容都是模拟电路的底层基础（也包括之后要提的集成运放内部结构）；而此后的内容将会和信号与系统紧密结合——通过集成运放对模拟信号进行控制和变换</p>
<h3 id="电压传输特性"><a href="#电压传输特性" class="headerlink" title="电压传输特性"></a>电压传输特性</h3><p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%AE%80%E4%BB%8B%E3%80%91/image-20211208104828069.png" alt="image-20211208104828069"></p>
<p>上图就是经典的集成运放电压传输特性：两个非线性区，一个很窄的线性区</p>
<p>理想运放的电压传输特性可以近似为一个阶跃函数</p>
<p>对于运放的宏观应用，突出三个重点</p>
<ul>
<li>反馈：需要使用反馈来让运放保持在线性区</li>
<li>虚短、虚断：两输入端电位相等、流入电流为0</li>
<li>非线性：利用运放的非线性工作状态搭建数字电路</li>
</ul>
<h3 id="运算电路"><a href="#运算电路" class="headerlink" title="运算电路"></a>运算电路</h3><p>运算电路的<strong>输出电压</strong>是<strong>输入电压</strong>某种运算的结果，也就是运算电路能实现关系式$u_o=f(u_i)$</p>
<p>分析和设计过程中都需要依靠<strong>虚断</strong>和<strong>虚短</strong>特性作为出发点，配合基本的电路定律进行定量分析或通过信号与系统的角度进行定性分析</p>
<ol>
<li><p>比例运算电路（放大器）</p>
<ul>
<li><p>基本正相：$u_o=(1+\frac{R_f}{R})u_i$</p>
<p>  <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%AE%80%E4%BB%8B%E3%80%91/image-20211217222054256.png" alt="image-20211217222054256"></p>
</li>
<li><p>电压跟随器：$u_o=u_i$</p>
<p>  <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%AE%80%E4%BB%8B%E3%80%91/image-20211217222102538.png" alt="image-20211217222102538"></p>
</li>
<li><p>基本反相：$u_o=-\frac{R_f}{R}u_i$</p>
<p>  <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%AE%80%E4%BB%8B%E3%80%91/image-20211217222040850.png" alt="image-20211217222040850"></p>
</li>
<li><p>T型反馈网络：$u_o=-\frac{R_2+R_4}{R_1}(1+\frac{R_2//R_4}{R_3})u_i$</p>
<p>  <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%AE%80%E4%BB%8B%E3%80%91/image-20211217222048650.png" alt="image-20211217222048650"></p>
</li>
</ul>
</li>
<li><p>模拟加法电路</p>
<ul>
<li><p>反相求和：$u_o=-R_f(\sum_{k}^{n} \frac{R_{ik}}{R_k})$</p>
<p>  <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%AE%80%E4%BB%8B%E3%80%91/image-20211217222111715.png" alt="image-20211217222111715"></p>
</li>
<li><p>同相求和：$u_o=R_f(\sum_{k}^{n} \frac{R_{ik}}{R_k})$</p>
<p>  <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%AE%80%E4%BB%8B%E3%80%91/image-20211217222122066.png" alt="image-20211217222122066"></p>
</li>
</ul>
</li>
<li><p>模拟减法电路</p>
<p> <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%AE%80%E4%BB%8B%E3%80%91/image-20211217222154460.png" alt="image-20211217222154460"></p>
<p> $u_o=\frac{R_f}{R}(u_{i2}-u_{i1})$</p>
</li>
<li><p>模拟乘法电路</p>
<p> <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%AE%80%E4%BB%8B%E3%80%91/image-20211217222210182.png" alt="image-20211217222210182"></p>
<p> $u_o=\frac{R_c}{2U_TR_e}u_Xu_Y$</p>
<p> 用下列符号表示模拟乘法器</p>
<p> <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%AE%80%E4%BB%8B%E3%80%91/image-20211217222243344.png" alt="image-20211217222243344"></p>
<p> 延伸出乘方电路</p>
<p> <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%AE%80%E4%BB%8B%E3%80%91/image-20211217222301017.png" alt="image-20211217222301017"></p>
</li>
<li><p>模拟除法电路</p>
<p> <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%AE%80%E4%BB%8B%E3%80%91/image-20211217222314122.png" alt="image-20211217222314122"></p>
<p> $u_o=-\frac{R_2}{R_1}\frac{u_{i1}}{ku_{i2}}$</p>
<p> 可延伸出开方电路</p>
<p> <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%AE%80%E4%BB%8B%E3%80%91/image-20211217222405899.png" alt="image-20211217222405899"></p>
<p> $u_o=\sqrt{-\frac{R_2}{kR_1}u_i}$</p>
</li>
<li><p>积分电路</p>
<p> <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%AE%80%E4%BB%8B%E3%80%91/image-20211217222140513.png" alt="image-20211217222140513"></p>
<p> $u_o=-\frac{1}{RC}\int_{t_1}^{t_2}u_i dt +u_o(t_1)$</p>
<p> 若u1再t1~t2为常量，则$u_o=-\frac{1}{RC}u_i(t_2-t_1) +u_o(t_1)$</p>
</li>
<li><p>微分电路</p>
<p> <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%AE%80%E4%BB%8B%E3%80%91/image-20211217222146286.png" alt="image-20211217222146286"></p>
<p> $u_o=-RC\frac{du_i}{dt}$</p>
</li>
<li><p>对数电路</p>
<p> <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%AE%80%E4%BB%8B%E3%80%91/image-20211217221947716.png" alt="image-20211217221947716"></p>
<p> $u_o=-U_T ln\frac{u_i}{I_S R}$</p>
</li>
<li><p>指数电路</p>
<p> <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%AE%80%E4%BB%8B%E3%80%91/image-20211217221958778.png" alt="image-20211217221958778"></p>
<p> $u_o=-I_SRe^{\frac{u_i}{U_T}}$</p>
</li>
</ol>
<h3 id="信号处理电路"><a href="#信号处理电路" class="headerlink" title="信号处理电路"></a>信号处理电路</h3><ol>
<li><p>信号生成器电路</p>
<p> 用于生成特定频率特定波形模拟信号的电路</p>
</li>
<li><p>有源滤波电路</p>
<p> 无源滤波电路的滤波参数随负载变化，而有源滤波电路中常常使用电压隔离器将滤波电路和负载隔离，这样就能让滤波参数不变，得到更大带宽；但是相应的有源滤波电路不是功率电路，输出电压电流大小受器件的参数和供电电源功率限制</p>
<ul>
<li>低通滤波器<strong>LPF</strong>：阻高频、通低频</li>
<li>高通滤波器<strong>HPF</strong>：阻低频、通高频</li>
<li>带通滤波器<strong>BPF</strong>：只允许特定频率信号通过</li>
<li>全通滤波器<strong>APF</strong>：实现频率-相位转换或相移的特殊滤波器</li>
<li>带阻滤波器<strong>BEF</strong>：只阻止特定频率信号</li>
</ul>
</li>
<li><p>有源负载电路</p>
<p> 用于模拟各性质负载的电路</p>
<p> <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E9%9B%86%E6%88%90%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%AE%80%E4%BB%8B%E3%80%91/image-20211218221625965.png" alt="image-20211218221625965"></p>
<p> 本质上就是一个提供拉电流的镜像电流源只不过一般都会通过限制输出电阻来控制它的功率</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>电路设计</tag>
      </tags>
  </entry>
  <entry>
    <title>电路设计从入门到弃坑【基本放大电路】</title>
    <url>/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E6%9C%AC%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E3%80%91/</url>
    <content><![CDATA[<h1 id="电路设计从入门到弃坑3【基本放大电路】"><a href="#电路设计从入门到弃坑3【基本放大电路】" class="headerlink" title="电路设计从入门到弃坑3【基本放大电路】"></a>电路设计从入门到弃坑3【基本放大电路】</h1><p>三极管在模电中的基本应用就是基本放大器，正像真空管曾经的功能一样，工作在放大区。而在数电中，三极管经常工作在截止区或饱和区，并且要求能够快速地通过放大器，这里暂不讨论。</p>
<p>电子电路中放大的对象是变化量，也就是说，放大电路需要处理变化的信号，有时候是低频交流，有时候是高频脉动直流。任何放大电路都可以从信号的角度上抽象成一个二端口网络，可以使用H参数矩阵对其进行基本描述。</p>
<span id="more"></span>

<p>上一篇在三极管的基础上详细说明了它工作在放大区的相关特性，并整理出了构造放大电路、学习模电的逻辑顺序。本篇内容就是要结合模电内容讲述基本放大电路的构造</p>
<blockquote>
<p>真正的模电由此开始</p>
</blockquote>
<p>能够控制能量的电路元件就是有源器件，使用有源器件能够实现能量的控制和转换，也就是所谓的“放大”。对于放大电路，要求信号损失小、带载能力强、通频带宽、耐压高、负载电流大、信号不失真；但实际电路往往难以面面俱到，所以就需要从基本的电路开始改进</p>
<p>基本性能指标：</p>
<ul>
<li><strong>电压放大倍数</strong>：$A_u=\frac{U_o}{U_i}$ 输出电压/输入电压，就是H参数矩阵中的电压参数</li>
<li><strong>电流放大倍数</strong>：$A_i=\frac{I_o}{I_i}$ 输出电流/输入电流，H参数矩阵中的电流参数</li>
<li>转移参数：这个参数就是H参数矩阵中的跨导和跨阻，但是在实际应用中作用不大，所以一般不讨论，只在特定电路中进行计算</li>
<li><strong>通频带</strong>：衡量放大电路对不同频率信号适应能力的参数，分为上限频率和下限频率，以0.707也就是$1/\sqrt{2}$为界限，取放大倍数位于0.707|A<del>M</del>|中间的频率值作为通频带，也称为中频段</li>
<li><strong>输入电阻</strong>：$R_i=\frac{U_i}{I_i}$，从输入端看去的网络等效电阻（<em>输入电压电流有效值之比</em>），一般越大越好（能够保持输入信号的完整性）</li>
<li><strong>输出电阻</strong>：$R_o=\frac{U_o}{I_o}$，从输出端看去的网络等效电阻，一般越小越好（可以将输入信号完好地传递给后续电路或以比较高的功率输出给后续用电器）。另一种计算方法（带载）：$R_o=\frac{U_o^<code>-U_o&#125;&#123;\frac&#123;U_o&#125;&#123;R_L&#125;&#125;=(\frac&#123;U_o^</code>}{U_o}-1)R_L$，U<del>o</del>表示带R<del>L</del>时的电压输出有效值；U<del>o</del>‘表示空载时输出电压有效值</li>
<li>**最大不失真输出电压U<del>OM</del>**：输出电压的交流有效值</li>
<li><strong>最大输出功率</strong>：用来衡量功率放大电路的带载性能</li>
<li>效率η：输出电压和输入电压之比$\eta=\frac{U_o}{U_i}$</li>
</ul>
<h2 id="共射放大电路"><a href="#共射放大电路" class="headerlink" title="共射放大电路"></a>共射放大电路</h2><p>最基本拓扑如下图所示</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E6%9C%AC%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E3%80%91/image-20211003163725682.png" alt="image-20211003163725682"></p>
<p>其中Vin和Rb需要保证U<del>BE</del>大于三极管开启电压，并让I<del>B</del>处于合适的区间；Vcc通过R<del>C</del>控制U<del>CE</del>来让三极管工作在放大区,R<del>C</del>用于将集电极电流变化转换为电压变化</p>
<h3 id="静态工作点"><a href="#静态工作点" class="headerlink" title="静态工作点"></a>静态工作点</h3><blockquote>
<p>因为三极管的放大工作状态需要很多支路量来描述，所以引入了<strong>静态工作点</strong>概念：输入电压为0时，晶体管<strong>各极电流、BE端电压、管压降</strong>这些参数统称三极管的静态工作点，如下所示：</p>
<ul>
<li>**B极电流$I_{BQ}$**：b极对应的输入电流，一般通过外置电阻分压/电阻值求得</li>
<li>**C极电流$I_{CQ}$*<em>：c极对应的输出（输入）电流，一般通过β</em>I<del>BQ</del>求得</li>
<li><strong>E极电流$I_{EQ}$（工程上常常将其近似等于$I_{CQ}$）</strong>：e极对应的输出电流，一般通过（1+β）*I<del>BQ</del>求得</li>
<li>**BE间电压$U_{BEQ}$**：b、e极之间的电压，直接算出外置电阻分压即可获得</li>
<li>**管压降$U_{CEQ}$**：c、e之间的电压，一般使用$电源电压V_{CC}-I_{CQ}*c极偏置电阻R_C$求得</li>
</ul>
</blockquote>
<p><strong>引入静态工作点就是为了描述一个放大电路在什么条件下能够实现“良好的放大性能”</strong></p>
<p>信号放大的基本要求就是：</p>
<ol>
<li><p>信号完整性：被放大的信号不能出现失真</p>
<p> 失真就是指输出信号和输入信号在函数<em>形式</em>上出现不一致（但是它们的相位是允许出现偏差的，峰值也一定会发生变化）</p>
</li>
<li><p>信号强度：被放大的信号应该变强，至少不能被削弱</p>
<p> 1V峰值的信号可以被放大到2V，但是不应该被削弱到0.1V，不过在某些特殊电路里可以牺牲信号强度换取信号质量（比如把1V的信号转换成0.8V，在某些工况下是可行的）</p>
</li>
</ol>
<p>对于这个放大电路来说，如果静态工作点发生<strong>偏移</strong>，就很可能出现信号的<strong>饱和失真</strong>和<strong>截止失真</strong></p>
<blockquote>
<p>对于该电路，交流信号会直接叠加在直流电源信号上，从图像上看，输出信号是输入信号先经过反相，再向上平移直流电源电压的距离。如果静态工作点发生偏移，就会导致三极管无法保持工作在放大区的状态</p>
<p><em>截止失真：由晶体管截止造成的失真</em></p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E6%9C%AC%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E3%80%91/image-20211003165509573.png" alt="image-20211003165509573"></p>
<p><em>饱和失真：由晶体管饱和造成的失真</em></p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E6%9C%AC%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E3%80%91/image-20211003165551205.png" alt="image-20211003165551205"></p>
<p>上面两句话说了个寂寞。给大伙翻译翻译什么叫截止失真：三极管本来工作在放大区，但是如果Q点（静态工作点）“下偏”——也就是U<del>CE</del>偏大时，同样的信号电压（信号电流源于电压）就无法让三极管保持放大状态，而三极管直接截止，<strong>信号的波谷就会被削去</strong>；经过三极管反相放大后，<strong>输出信号就会出现削波峰</strong>的情况，这就是截止失真</p>
<p>同理，如果U<del>CE</del>偏小时，由于信号电流过大，三极管直接从放大区冲进了饱和区，于是信号的波峰就无法被放大了；经过三极管反相后，<strong>输出信号的波谷就会被削去</strong></p>
<p>需要注意的就是<em>“只有”静态工作点偏移会导致这两种失真，如果是输入信号本身电压过大或过小，都将视为静态工作点设置问题</em>；而且和习惯上的“截止、饱和”不一样，三极管基本放大电路具有反相放大的特性，导致输出电压的削波峰、削波谷是相反的</p>
</blockquote>
<p>因此，为了保证模拟电路正常工作，就要保证晶体管的静态工作点稳定且正确，一般还要让输入输出信号共地，且负载上无直流分量</p>
<p>为了解决这个问题，工程师提出了下面的<strong>阻容耦合放大电路</strong>，这个电路是便宜小家电（尤其是小夜灯）里最常见的模拟电路之一</p>
<h3 id="直接耦合与阻容耦合"><a href="#直接耦合与阻容耦合" class="headerlink" title="直接耦合与阻容耦合"></a>直接耦合与阻容耦合</h3><p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E6%9C%AC%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E3%80%91/image-20211003160425432.png" alt="image-20211003160425432"></p>
<p>使用两个耦合电容C1、C2将放大电路分为直流通路和交流通路</p>
<p>相较于直接通过电阻耦合信号、输出部分，<strong>阻容耦合电路能够显著改善交流损失和输出部分叠加直流分量的问题</strong></p>
<p>它将整个电路分割成了直流通路和交流通路，直流部分起到电源的作用，交流部分则实现了前后级可解耦可耦合的信号传输。</p>
<blockquote>
<p>电路中，“耦合”指的是电路网络中，若其中某一回路支路量发生变化，能影响到其他电路也发生类似的变化。耦合的作用就是把某一电路区域的能量输送（或转换）到其他的电路区域中去</p>
<p>解耦指的就是两部分电路不相干或者相干性很小，能够近乎独立地工作</p>
<p>良好的放大电路要求电路内部信号可解耦，电路传输过程中信号高耦合</p>
</blockquote>
<p>对于阻容耦合，最关键的就是耦合电容容量要好好选取，并且极性电容的极性不能弄反。<strong>耦合电容一般都选择大电容，而且以低ESR的钽电容或高频低阻电容为优</strong>，很多HiFi电路中都是用上百uF的黑金刚电容来保证直流-交流回路隔离，<strong>小信号电路中也一般使用1~100uF的较大电容</strong>，这是为了减小容抗（$X_C=\frac{-j}{\omega C}$）</p>
<h3 id="针对温度漂移的改进电路"><a href="#针对温度漂移的改进电路" class="headerlink" title="针对温度漂移的改进电路"></a>针对温度漂移的改进电路</h3><p>由于半导体器件对于温度较敏感，而三极管工作在放大区，需要承载较大电流的情况下常常会产生很大的热量，因此需要保证静态工作点稳定，克服温度漂移。一般来说通过调节I<del>BQ</del>实现Q点稳定</p>
<p>如果考虑到温度漂移，可以设计<strong>基本共射放大电路</strong>，如下所示：</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E6%9C%AC%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E3%80%91/image-20211003160400652.png" alt="image-20211003160400652"></p>
<p>该电路在基本放大电路基础上引入了反馈电阻R2、Re和旁路电容C3</p>
<p><strong>在I<del>R2</del>&gt;&gt;I<del>B</del>条件下</strong>，$U_{BQ}=\frac{R_2}{R_1 + R_2} V_{CC}$，进而存在$I_{EQ}=\frac{U_{BQ}-U_{BEQ}}{R_e}$，令$U_{BQ}=U_{BE}+\Delta U_{BE}$模拟温度漂移的情况，存在$U_{BQ}-U_{BE}&gt;&gt;\Delta U_{BE}$，因此$I_{EQ}$会保持稳定状态</p>
<p>这就是Re为直流通路引入了<strong>反馈</strong></p>
<blockquote>
<p>反馈是模拟电路中的经典工作调节方式，通过将输出端的信号引回到控制电路，可以以此调整控制电路内部的电压电流，这一控制方式也广泛应用于数字信号处理中</p>
<p><strong>负反馈</strong>：使输出量变化减小的反馈</p>
<p><strong>正反馈</strong>：使输出量变化增大的反馈</p>
<p>这里Re就起到了直流负反馈的作用，其值越大，反馈越强（I<del>EQ</del>收到抑制越强），Q点越稳定</p>
</blockquote>
<p>以上直流通路称为<strong>分压式电流负反馈工作点稳定电路</strong>，这个电路的特点就是通过引入直流负反馈补偿温度漂移，其实使用更直接的方法也可以——比如将R1、R2替换成热敏电阻，并放置在三极管旁边，这样就能根据三极管的温度来实时稳定电路输出，但是显然成本更高；还可以直接在b、e之间接入稳压二极管，这种方法也相当于引入了负反馈</p>
<p>还应该注意<em>旁路电容C3</em>：<strong>这个电容主要用于提高引入负反馈后的交流信号放大倍数</strong>，如果不加这个电容，就相当于增大输入电阻为$R_i=R_1//R_2//[r_{be}+(1+\beta)R_e]$，进而可以算出放大倍数$A_u\approx -\frac{R_L}{R_e}$，可以发现没有旁路电容时，相当于输入回路和输出回路都并接了一个Re电阻——<strong>去掉旁路电容后，输入电阻会变大，输出电阻则不变</strong></p>
<p>针对电路交流部分使用交流等效模型，得到电路参数：<br>$$<br>V_{BB}=\frac{R_1}{R_1R_2} V_{CC} \newline<br>R_b=R_1//R_2<br>$$</p>
<h3 id="放大电路动态参数"><a href="#放大电路动态参数" class="headerlink" title="放大电路动态参数"></a>放大电路动态参数</h3><p>最后说一下如何确定基本共射放大电路的参数，但是在此之前==需要读者先了解三极管的电路分析模型，可以复习上篇博文，并且参考本篇最后部分的等效电路法求解电路参数==</p>
<blockquote>
<p>开篇提过放大电路的主要性能参数，这些参数都是针对要放大的交流信号而言的，其中比较常用，且题中也比较常出现的参数有：</p>
<p>输入阻抗$R_i$：从三极管输入端——交流信号激励（不包含激励源内阻$R_s$）看向be结的等效阻抗。一般直接忽略串联的容抗，将连在三极管直流电源支路上的阻抗视为接地</p>
<p>输出阻抗$R_o$：从三极管输出端（不包含负载$R_L$）看向ce结的等效阻抗</p>
<p>电压放大倍数$A_u$：$A_u=\frac{u_o}{u_i}$，对于共射放大电路，有$u_O=-\beta I_b *(R_C // R_L)$，$u_i=I_b * r_{be}$，于是消去$I_b$，得$A_u=\frac{-\beta (R_C // R_L)}{r_{be}}$</p>
<p>电流放大倍数$A_i$：$A_i=\frac{i_o}{i_i}$</p>
<p>最大不失真输出电压$U_{OM}$：能保证输出波形不出现饱和失真的最大输出电压，在条件充足的情况下是用公式$U_{OM}=U_{CEQ}-U_{CES}$计算，其中$U_{CEQ}$表示<em>静态工作点管压降</em>，$U_{CES}$表示<em>饱和管压降</em>，这个公式的含义就是使用三极管工作时的输出电压减去三级管进入饱和区的临界电压来计算能让三极管在放大区工作，不至于进入饱和区的临界电压</p>
</blockquote>
<h2 id="共集放大电路"><a href="#共集放大电路" class="headerlink" title="共集放大电路"></a>共集放大电路</h2><p>共集放大电路是另一种常用的基本放大电路拓扑，它具有放大电流但几乎不放大电压的特性，因此又被称为射极跟随器（简称射随器）。</p>
<p>它的电路如下所示：</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E6%9C%AC%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E3%80%91/image-20211015232117483.png" alt="image-20211015232117483"></p>
<blockquote>
<p>这个电路以这样的形式展现可能不太好看，常见的形式如下所示：</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E6%9C%AC%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E3%80%91/image-20211015232422930.png" alt="image-20211015232422930"></p>
<p>整个电路就像被垂直翻转的共射放大电路</p>
</blockquote>
<p>这个电路的特点就是当$(1+\beta)R_e &gt;&gt; R_b + r_{be}$时，有$A_u \approx 1$，即$U_o \approx U_i$，对于电压来说放大作用不明显</p>
<p>此外，它还具有<strong>阻抗变换</strong>的作用：带负载后，$R_i=R_b+r_{be}+(1+\beta)(R_e //R_L)$，从基集的输入端看入，就好像$R_e//R_L$被增大了$(1+\beta)$倍一样；对于输入电阻，有$R_o=R_e//\frac{r_b+r_{be}}{1+\beta}$，相当于输入电阻被减小到原来的$\frac{1}{1+\beta}$</p>
<p>于是可以总结出它的特点：<strong>输入电阻大(1+β)，输出电阻小(1/(1+β))，只放大电流(1+β)，不放大电压(≈1)，在合适的工作情况下具有电压跟随作用</strong>。</p>
<p>因为这个原因，共集放大电路常被用于集成放大器的输入级和输出级，用来减小输入阻抗和输出阻抗；它还常用于多级放大器级间耦合，用于放大电流，提高信号保真度</p>
<h2 id="共基放大电路"><a href="#共基放大电路" class="headerlink" title="共基放大电路"></a>共基放大电路</h2><p>共基放大电路是一种在电源中常用的放大电路，因为它“只放大电压，不放大电流”</p>
<p>基本拓扑结构如下：</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E6%9C%AC%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E3%80%91/image-20211015234532264.png" alt="image-20211015234532264"></p>
<p>更常见的画法如下：</p>
<p><img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E6%9C%AC%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E3%80%91/image-20211015235249128.png" alt="image-20211015235249128"></p>
<p>以上电路通过Rb2和Re作为反馈可以有效抑制温度漂移</p>
<p>这里对上面的简化电路进行分析：</p>
<p>$R_i=R_e+\frac{r_{be}}{1+\beta},R_o=R_c$</p>
<p>可以看到其<strong>输入电阻较小，输出电阻和共射放大电路类似</strong></p>
<p>对于电压增益，有</p>
<p>$A_u=\frac{\beta R_c}{r_{be}+(1+\beta)R_e}$</p>
<p>可见它<strong>只放大电压，不放大电流</strong></p>
<h3 id="三种基本放大电路"><a href="#三种基本放大电路" class="headerlink" title="三种基本放大电路"></a>三种基本放大电路</h3><table>
<thead>
<tr>
<th>接法</th>
<th>共射</th>
<th>共集</th>
<th>共基</th>
</tr>
</thead>
<tbody><tr>
<td>$A_u$</td>
<td>大</td>
<td>小于1</td>
<td>大</td>
</tr>
<tr>
<td>$A_i$</td>
<td>β</td>
<td>1+β</td>
<td>α</td>
</tr>
<tr>
<td>$R_i$</td>
<td>中</td>
<td>大</td>
<td>小</td>
</tr>
<tr>
<td>$R_o$</td>
<td>大</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>频带</td>
<td>窄</td>
<td>中</td>
<td>宽</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>三种放大电路通过“共地的引脚”加以区分</strong></p>
<p>忽略直流通路的区别，交流通路中，以b极输入，c极输出的就是共射放大电路，它的地直接连在e极；以b极输入，e极通过一个下拉电阻转化电流信号输出的则是共集放大电路，它的地直连c极，e极无法直接通过电流驱动负载，所以需要加入$R_b$将电流转化成电压（也就是引入一个内电导）；以e极输入，c极输出的则是共基放大电路，它的地连在b极，这个电路的工作频率可以达到很高</p>
</blockquote>
<h2 id="分析三极管放大电路的通用方法"><a href="#分析三极管放大电路的通用方法" class="headerlink" title="分析三极管放大电路的通用方法"></a>分析三极管放大电路的通用方法</h2><p>对于模拟电路尤其是放大电路的分析，前人已经总结出了一套通用的分析方法学。不同于模拟集成电路，一般的分立元件模拟电路都有着明显的直流和交流通路，也不需要考虑器件大小和导线寄生参数造成的种种干扰，一般来说遵循以下步骤对放大电路进行分析就可以得到电路的大致特性</p>
<h3 id="直流通路和交流通路分解"><a href="#直流通路和交流通路分解" class="headerlink" title="直流通路和交流通路分解"></a>直流通路和交流通路分解</h3><p>为了便于实现、减少干扰，现代的放大电路都会将直流驱动信号和交流小信号分成<em>正交</em>（指的是互不影响）的两个部分，称为<strong>直流通路</strong>和<strong>交流通路</strong></p>
<p>二者一般通过耦合电容、旁路电容、滤波电容进行隔离。对于直流通路，应保留R<del>S</del>，置U<del>S</del>=0，电容视为开路，电感视为短路或仅保留寄生电阻；对于交流通路，将大容量电容视为短路，直流电源视为短路或仅保留内阻，如果是较高频信号，可视情况保留容抗</p>
<p>直流通路一般用于设置Q点，交流通路负责传输信号。因此直流通路关心的是Q点稳定性与整体功耗；交流通路则关心信号放大倍数、输入阻抗、输出阻抗、通频带、带载能力等</p>
<h3 id="图解法静态分析"><a href="#图解法静态分析" class="headerlink" title="图解法静态分析"></a>图解法静态分析</h3><p>根据测量/仿真结果进行信号动态分析（扫频、扫相、输入输出采样）后，获取一个放大电路的输入特性和输出特性。之后根据V<del>BB</del>、R<del>b</del>在输入特性曲线上画出输入回路负载线；根据V<del>CC</del>、R<del>c</del>在输出特性曲线上画出负载线，即可得到两图中的交点，也就是静态工作点Q。两个负载线的函数如下：<br>$$<br>u_{BE}=V_{BB}-i_B R_b \newline<br>u_{CE}=V_{CC}-i_C R_c<br>$$<br>根据图像调整Q点位置就可以改善静态工作点</p>
<p>同时，根据<strong>输出图像上的负载线斜率</strong>可以得到<strong>电压放大倍数</strong>。有A<del>i</del>/A<del>u</del>是图像变化时的斜率</p>
<h3 id="电路失真分析与波形分析"><a href="#电路失真分析与波形分析" class="headerlink" title="电路失真分析与波形分析"></a>电路失真分析与波形分析</h3><p>使用示波器分别测量输入和输出信号的波形就可以得知电路失真情况和电路稳定性</p>
<p>对应可以采用改变静态工作点的方法消除失真</p>
<p>这个方法常用于配合图解法静态分析：依次进行失真分析和图解法分析，微调电路参数，可以快速让电路<em>收敛</em>到适合放大的区域</p>
<p>截止失真消除方法：增大V<del>BB</del>（也就是<strong>向上平移输出回路负载线</strong>），对于采用了反馈机制的基本共射放大电路，还可以减小R1、增大R2</p>
<p>饱和失真消除方法：增大R<del>b</del>，减小R<del>c</del>，减小β，减小V<del>BB</del>、增大V<del>CC</del>（<strong>向下平移输出回路负载线</strong>）</p>
<p>一般将电路调参的过程称为<strong>电路参数收敛</strong>，这也是仿真软件通用的描述</p>
<p>特别地，<strong>交流负载线也过Q点，并且斜率等于$R_C //R_L$</strong></p>
<h3 id="等效电路法求解电路参数"><a href="#等效电路法求解电路参数" class="headerlink" title="等效电路法求解电路参数"></a>等效电路法求解电路参数</h3><p>三极管是一个典型的非线性器件，但是可以忽略某些特殊参数，使用线性元件建立<strong>三极管电路分析等效模型</strong>，这样就能够建立放大电路等效模型，使用传统的电路分析方法对电路参数进行求解</p>
<p>上篇已经介绍了三极管的等效模型，这里介绍几个更加准确的模型</p>
<ol>
<li><p><strong>直流模型</strong></p>
<p> 该模型适用于Q点分析，可以用于估算静态工作点，等效电路如下所示：</p>
<p> <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E6%9C%AC%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E3%80%91/image-20211003181631915.png" alt="image-20211003181631915"></p>
<p> 这就是三极管最经典的<strong>流控电流源模型</strong>，但是有时候为了突出三极管的PN结特性，还会再I<del>B</del>、I<del>C</del>的位置上串接两个二极管（方向从P到N）</p>
<p> 使用这个模型分析基本放大电路：<br> $$<br> I_{BE}=\frac{V_{BB}-U_{BEQ}}{R_b},U_{BEQ}随管类型变化,一般为0.7V\newline<br> I_{CQ}=\beta I_{BQ}\newline<br> U_{CEQ}=V_{CC}-I_{CQ}R_e<br> $$<br> 事实上就是刚开始使用的推导方式，输入回路等效于恒压源（0.7V），输出回路等效于流控电流源，二者共地</p>
<p> 这个模型在精度要求不高的情况下适用性很广</p>
</li>
<li><p><strong>交直流EM模型与厄利尔效应</strong></p>
<p> 在理想的器件中，集电极电流大小应等于基极电流乘常数增益β。但实际上，每个PN结中有两个耗尽层，对于be结，它的耗尽层处于基极和集电极之间，基极的掺杂浓度明显高于集电极，但基极很薄，因此很薄耗尽层会占用很薄的基极宽度中的一部分，当集电极电压增加时，耗尽层变宽，基极宽度继续变窄，这就导致<strong>在U<del>BE</del>增加时，三极管增益β会增大</strong>，这个现象称为<strong>厄利尔效应</strong>。</p>
<p> 为了精确地对三极管进行建模，在理论层面上产生了一个称为<strong>EM模型</strong>的东西，三极管有直流EM模型和交流EM模型</p>
<p> 对于更加精确的直流EM模型，有时候就会使用两个流控电流源配合两个二极管来对厄利尔效应进行近似。<em>分别是CB结处的α<del>E</del>I<del>ED</del>和BE结处的α<del>R</del>I<del>CD</del>电流源，配合CB结寄生二极管和BE结寄生二极管，注意它们的方向是相反的，且I<del>ED</del>表示BE结电流I<del>E</del>，I<del>CD</del>表示CB节电流I<del>C</del></em></p>
<p> 如果将二者合并，可以形成一个稍微不那么精确的Π形式EM模型，此时只有一个跨接在CE之间的流控电流源，其大小为I<del>CT</del>=I<del>CC</del>-I<del>CE</del></p>
<p> 这个等效模型还可以再精确地考虑晶体管中的寄生电容，它们分别跨接在PN结和集电极-衬底之间，一般在高频等效时才会考虑这个性质，这里不再赘述</p>
<p> 对于交流EM模型，他常常用于三极管的高精度小信号分析。b区寄生电阻r<del>bb‘</del>、BC结间跨导r<del>μ</del>、寄生电容、c区输出电阻r<del>C</del>、e区寄生电阻r<del>E</del>都被考虑在内，详细电路比较复杂，详见本博文的参考书《模拟电子系统设计指南》中P93的图5.31，这个模型就是模拟集成电路中常用的三极管等效模型，相当精确</p>
<p> 对于一般的电路分析，只要使用直流模型和低频小信号模型就足够了</p>
</li>
<li><p><strong>低频小信号模型</strong></p>
<p> <strong>该模型只适用于低频小信号</strong></p>
<p> 直接将三极管视为一个二端口网络，使用H参数矩阵进行描述<br> $$<br> u_{BE}=f(i_B,u_{CE}) \newline<br> i_C=f(i_B,u_{CE})<br> $$<br> 由上述方程可以得到交流等效模型</p>
<p> <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E6%9C%AC%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E3%80%91/image-20211003182400056.png" alt="image-20211003182400056"></p>
<p> 输入回路是一个U<del>CE</del>控制的压控电压源和输入电阻h<del>11</del>的串联；输出则还是和直流模型一样，只不过输出部分并联了一个跨导</p>
<p> 可以写出这个二端口网络的H参数矩阵</p>
<p> <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E6%9C%AC%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E3%80%91/image-20211223062537147.png" alt="image-20211223062537147"></p>
<p> 小信号等效模型应用在交流通路上，可以得到以下<strong>交流等效模型</strong></p>
<p> <img src="/2021/12/21/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E5%9F%BA%E6%9C%AC%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E3%80%91/image-20211003182908707.png" alt="image-20211003182908707"></p>
<p> 这个模型的基本公式就是<br> $$<br> r_{be} \approx r_{bb’} + (1+\beta) \frac{U_T}{I_{EQ}}<br> $$<br> 小结论：<strong>在输入特性曲线上，Q点越高，r<del>be</del>越小</strong></p>
</li>
</ol>
<h3 id="静态分析和动态分析"><a href="#静态分析和动态分析" class="headerlink" title="静态分析和动态分析"></a>静态分析和动态分析</h3><p>最后一个分析方法就是静态-动态分析的混合使用</p>
<p><strong>静态分析</strong>就是指对直流通路直流信号进行分析，一般使用<strong>直流等效模型</strong>，这是为了找到合适的Q点（即找到合适的I<del>CQ</del>、I<del>BQ</del>、U<del>CEQ</del>）</p>
<p><strong>动态分析</strong>就是指对交流通路交流信号进行分析，一般使用<strong>交流等效模型</strong>（三极管交流小信号模型）</p>
<p>二者用于估算放大电路的元件参数和三极管选型，是分析过程中的最后一步</p>
<p>于是整体的设计思路就是：</p>
<ol>
<li>确定要放大的信号幅值、频率、所需放大倍数</li>
<li>根据波形分析选择合适的三极管</li>
<li>完成静态分析和动态分析，搭建测试电路</li>
<li>多轮测试完成电路收敛</li>
<li>收敛过程中综合使用图解法、等效模型仔细推敲元件选型，最后将静态工作点稳定到合适的位置</li>
</ol>
<p>分析电路时则要反向思路，先使用示波器和扫频法测出电路的目标信号和基本参数，再通过等效模型确定外围元件参数</p>
<ol>
<li><p>先分析直流通路，计算出静态工作点Q（U<del>BEQ</del>、I<del>CQ</del>、I<del>BQ</del>、U<del>CEQ</del>）</p>
<p> 分析时可以将电容开路、电感短路，先三极管的基本工作状态，要保证它的工作区间是放大区</p>
</li>
<li><p>分析交流通路，得到交流输出小信号的幅值U<del>OM</del>和波形</p>
<p> 分析时注意将电路中的直流电压源当作地处理，当交流信号频率较低时，直接将电容短路、电感开路</p>
</li>
<li><p>对于高频交流信号，必须考虑三极管寄生电容的影响</p>
</li>
<li><p>基本的交流信号分析步骤如下：</p>
<ol>
<li><p>画出晶体管电路的直流等效电路</p>
</li>
<li><p>计算静态工作点</p>
</li>
<li><p>绘制交流等效电路</p>
</li>
<li><p>确定交流小信号模型所需的参数β、r<del>be</del>、R<del>c</del></p>
</li>
<li><p>进行小信号分析，得到输入阻抗R<del>i</del>、电压增益A<del>u</del>、输出阻抗R<del>o</del></p>
<p> 其中A<del>u</del>除了直接根据输入输出电压得到，还可以直接通过计算输入输出阻抗之比乘以-β得到，即有公式<br> $$<br> A_u=-\frac{\beta R_o}{R_i}<br> $$</p>
</li>
</ol>
</li>
</ol>
<h3 id="密勒定理"><a href="#密勒定理" class="headerlink" title="密勒定理"></a>密勒定理</h3><p>密勒定理：在线性电路中，如果存在一条连接两个节点（电势分别为V<del>1</del>和V<del>2</del>）的支路，该支路的阻抗为Z，则这个支路可以用其他两个支路代替，分别对应于V<del>1</del>、V<del>2</del>到地的连接，这两条支路的阻抗分别表示为$\frac{Z}{1-k}$和$\frac{kZ}{k-1}$，其中k是两节点之间的电压增益$k=\frac{V_2}{V_1}$</p>
<p>使用密勒定理可以化简某些三极管等效电路</p>
<blockquote>
<p>依次使用双端口网络参数矩阵、诺顿-戴维南等效电路、源吸收理论，可以将两个通过受控源关联的双端口进行密勒等效，最重要的一步是源吸收理论：如果电路中有一个流控电压源，那么它可以用一个等于控制源因子的简单阻抗代替；如果电路中有一个压控电流源，那么它可以用一个等于控制源因子的简单导纳代替，其大小就是输出量/控制量。</p>
<p>使用这个等效方式可以让三极管的流控电流源和r<del>be</del>两个支路直接简化成两个并联的电阻r<del>be</del>和1/β</p>
</blockquote>
<p>在集成电路制造中还常常使用基于密勒定理形成的<strong>密勒效应</strong>电路，这是分析包含容性反馈反相放大器的关键。一般集成电路中都会将CB结寄生电容考虑在内，而当要在集成电路中实现一个相对较低截止频率的低通滤波器时，<em>很难占用大空间来制造足够大的电容</em>，这时候就可以使用小电容，再经由三极管的跨导和寄生电容来放大它。假设在寄生电容上施加电压，会有$I=C_C \frac{\Delta V}{\Delta t}$，但是由于负载电阻的增益会使流经寄生电容的电流更大，因此从输出侧看去就好像接入了一个大电容</p>
]]></content>
      <tags>
        <tag>电路设计</tag>
      </tags>
  </entry>
</search>
