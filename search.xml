<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>我的新博客</title>
    <url>/2021/11/13/%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%91%E3%80%90%E7%94%B5%E8%B7%AF%E6%A6%82%E8%AE%BA%E3%80%91/</url>
    <content><![CDATA[<h1 id="电路设计从入门到弃坑0【电路概论】"><a href="#电路设计从入门到弃坑0【电路概论】" class="headerlink" title="电路设计从入门到弃坑0【电路概论】"></a>电路设计从入门到弃坑0【电路概论】</h1><p>在本系列博客中，将遵循以下缩写/简写</p>
<ul>
<li>电路原理：电子线路、电子线路分析基础等基础电路课</li>
<li>模电：模拟电子电路、模拟电路、模拟电子技术、模拟电子线路等模拟电路课</li>
<li>数电：数字电子电路、数字电路、数字电子技术、数字电子线路等数字电路课</li>
<li>通信原理：通信原理、通信电子线路、通信电子电路、高频电子电路、高频电子线路等高频电路及通信理论课</li>
<li>强电：功率电子电路、功率电子线路、电力电子电路、电力电路等电力电子系统及理论课</li>
</ul>
<p>电路原理阐述了电路运行的基本规律：使用抽象电路模型、电磁学、图论、高等数学、线性代数、拉普拉斯变换等基础学科知识描述电路，提供一般的电路分析方法</p>
<p>模电则是从半导体器件的性质介绍如何使用这些器件构建能够对电信号或功率电压电流进行处理的电路</p>
<p>数电针对逻辑电路进行分析，结合布尔代数引入了晶体管在导通、截至两状态下的应用，并提炼出使用硬件描述语言对数字电路进行设计、分析、仿真的基本方法</p>
<p>通信原理则从分布参数电路与谐振、傅里叶分析角度解释模拟电路工作在高频情况下的状态与应用，并根据电磁场与电磁波理论介绍如何对通信信号进行调制-解调，以实现远距离电通信</p>
<p>强电则结合电机学、电工学相关知识，阐明功率半导体器件的工作原理和应用，主要关注功率、效率、质量三个要素</p>
<h3 id="专有名词解释"><a href="#专有名词解释" class="headerlink" title="专有名词解释"></a>专有名词解释</h3><p>本教程中使用的专有名词是更贴近直观的解释，和专业参考书籍存在一定差异，请以专业参考书为准</p>
<ul>
<li>电路拓扑：就是电路图的“形式”——把具体元件抽离出电路图，把实际电路图变换成理想电路模型，抽象出节点、支路后剩下的一个图就称为电路拓扑。可以形象理解成电路的套路或者说格式</li>
<li>系统：电路实现其功能过程的抽象。可以形象理解成电路功能框图</li>
<li>信息：就是信息论里面的信息</li>
<li>信号：从系统角度看，每个支路量都承载了信息，因此支路量可以称为信号</li>
<li>激励-响应：从系统的角度看电路时，系统中某个功能框的输入称为激励，系统某个功能框的输出称为响应</li>
<li>反馈：把某个响应引入到激励部分或功能框内部的过程称为反馈，对应的信号称为反馈信号</li>
</ul>
<h2 id="模电"><a href="#模电" class="headerlink" title="模电"></a>模电</h2><p>模电的知识结构是自下而上的</p>
<h3 id="半导体物理与半导体器件"><a href="#半导体物理与半导体器件" class="headerlink" title="半导体物理与半导体器件"></a>半导体物理与半导体器件</h3><p>讲述掺杂与导电性、PN结、双结型晶体管、场效应管等的基本物理原理和制造工艺对器件性能的影响</p>
<p>这一部分内容更偏重理论，和电路原理一样属于帮助理解模电、数电等工程应用的理论基础</p>
<h3 id="常见的半导体器件"><a href="#常见的半导体器件" class="headerlink" title="常见的半导体器件"></a>常见的半导体器件</h3><p>二极管、三极管、场效应管等基本的半导体器件，连同它们的变种器件，共同组成了模拟电子电路，经由开关频率特殊优化的开关管器件则构成了数字电路的基础——逻辑门和触发器</p>
<h4 id="二极管"><a href="#二极管" class="headerlink" title="二极管"></a>二极管</h4><p>由一个PN结封装成器件，就得到了具有单向导电性的二极管</p>
<p>生产中用到的不仅有二极管的单向导电性，还有击穿电压、漏电流等等一系列特性</p>
<h4 id="三极管和场效应管"><a href="#三极管和场效应管" class="headerlink" title="三极管和场效应管"></a>三极管和场效应管</h4><p>两个PN结封装成一个器件，就得到了三极管；而利用金属-氧化物绝缘层-半导体形式封装产生的电场效应，可以生产出场效应管。</p>
<p>三极管一般是电流控制电流型器件；而场效应管一般是电压控制电压型器件，二者可以互补——于是出现了结合二者，能够实现高功率输出的晶闸管（可控硅）和IGBT（绝缘栅双极型晶体管），以及复合单一器件的达林顿管</p>
<p>早期设备中使用真空管（电子管），正是因为半导体技术的发展才让三极管取代了真空管，但是二者的功能是一致的：<strong>对电信号加以控制</strong></p>
<h3 id="晶体管信号放大电路"><a href="#晶体管信号放大电路" class="headerlink" title="晶体管信号放大电路"></a>晶体管信号放大电路</h3><p>这里的晶体管是BJT（双结型晶体管，也就是三极管）和FET（场效应管）的统称</p>
<p>晶体管通过某些组合，可以最大限度发挥其控制信号的作用，而这种电路一般用于放大某些小信号，所以被称为晶体管信号放大电路。</p>
<p>放大电路并不是指输入1V，凭空就能输出3V，而是指<em>输入信号1V，通过外加2V的供电，能输出为2V的信号</em></p>
<p>信号放大电路往往看重信号的保真程度和信号的放大倍数，然而晶体管往往很容易受到门限电压、温度升高、电源变化等影响造成信号失真，为了避免这些问题，人们就对普通放大电路进行改进；同时为了获取更高的放大倍数，常常采用前级-输入级-驱动级-输出级这样的多级放大模式，从而提高信号放大倍数</p>
<p>主要参考的性能参数就是电压增益和电流增益：$A_v=\frac{v_o}{v_i}$ $A_i=\frac{i_o}{i_i}$</p>
<h3 id="晶体管功率放大电路"><a href="#晶体管功率放大电路" class="headerlink" title="晶体管功率放大电路"></a>晶体管功率放大电路</h3><p>对于一些特殊的应用（比如音响），信号放大电路无法驱动后级输出设备（扬声器）</p>
<p>于是出现了晶体管功率放大电路</p>
<p>这类电路一般使用特殊设计的能经受大电流、高电压的晶体管作为放大器件，于是可以在电源部分加大功率</p>
<p>通常需要注意功率放大电路的效率：$\eta=\frac{P_L}{P_S}$</p>
<h3 id="晶体管振荡电路"><a href="#晶体管振荡电路" class="headerlink" title="晶体管振荡电路"></a>晶体管振荡电路</h3><p>为了控制或产生周期性的激励，人们还设计出了能够产生振荡信号的晶体管电路</p>
<p>这种电路建立在放大电路和闭环控制理论的基础上，利用反馈进行工作</p>
<p>一般分立式元件难以产生高精度的信号输出，现在一般使用单片机（微控制器）或专用的集成电路生成振荡信号</p>
<h3 id="集成运算放大器"><a href="#集成运算放大器" class="headerlink" title="集成运算放大器"></a>集成运算放大器</h3><p>随着集成电路技术的发展，可以将多个二极管和晶体管集成在单个芯片中，内部大多为模拟电路的芯片被称为模拟集成电路，内部结构中多数字电路的芯片则是数字集成电路。其中通过将晶体管信号放大电路集成在一个芯片上，可以实现良好的放大性能，这种模拟集成电路就是集成运算放大器</p>
<p>集成运算放大器具有虚短、虚短、高输入阻抗、低输出阻抗等特征，利用这些特征可以组合出模拟运算电路和其他特殊的放大电路</p>
<p>集成运放工作在晶体管的基础上</p>
<h3 id="集成功率放大器"><a href="#集成功率放大器" class="headerlink" title="集成功率放大器"></a>集成功率放大器</h3><p>集成功率放大器即集成功放，是分立式晶体管功率放大器在功率半导体器件发展的基础上形成的一套新型集成电路</p>
<p>现代模拟电路具有集成化、小型化的趋势，集成功率电路正是舍弃了一部分高功率特性换来了更高的转换效率和更小的体积</p>
<h3 id="电源管理芯片和功率电源电路"><a href="#电源管理芯片和功率电源电路" class="headerlink" title="电源管理芯片和功率电源电路"></a>电源管理芯片和功率电源电路</h3><p>模拟电路的另一作用就是基于变压器、二极管、晶体管、基本电抗元件等构建稳压或恒流电源</p>
<p>在此基础上伴随半导体技术的发展，氮化镓、氮化砷等新型功率半导体器件为实现小型化、大功率、高效率的电源电路提供了可能</p>
<h2 id="数电"><a href="#数电" class="headerlink" title="数电"></a>数电</h2><p>数电的知识结构是从抽象到具体的</p>
<h3 id="布尔代数"><a href="#布尔代数" class="headerlink" title="布尔代数"></a>布尔代数</h3><p>布尔代数就是逻辑代数，使用布尔代数可以化简很多代数运算，并让电路得以实现</p>
<p>数电的基础是数学，数电的所有器件都是为了解决数学计算问题而设计</p>
<p>所以布尔代数是数字电路的基础</p>
<h3 id="开关管与逻辑门"><a href="#开关管与逻辑门" class="headerlink" title="开关管与逻辑门"></a>开关管与逻辑门</h3><p>电路可以使用高电平或低电平表示布尔代数中的0和1，进而实现数学计算</p>
<p>为了对数字信号进行处理，前人设计出了三种基本的逻辑门——与门、或门、非门</p>
<p>使用MOSFET（金属氧化物半导体场效应管）可以实现这三种逻辑门，进而实现更多复杂功能</p>
<p>在现代集成电路技术中，多采用CMOS工艺，将两个MOSFET制造在一起，并通过两个成对的MOSFET实现基础的逻辑门</p>
<p>只使用逻辑门构成的数字电路称为<strong>组合逻辑电路</strong></p>
<p>组合逻辑电路只能“瞬时”（由于寄生电容的存在，实际的组合逻辑电路存在延迟）地反映当前输入对应的输出，换句话说，它可以描述函数关系，但不能描述状态关系</p>
<h3 id="触发器与锁存器"><a href="#触发器与锁存器" class="headerlink" title="触发器与锁存器"></a>触发器与锁存器</h3><p>使用CMOS器件还可以制造具有“记忆”功能的器件——锁存器</p>
<p>锁存器可以暂时地保存输入的电平，通过再次加入一对MOSFET便可以让锁存器“滴答”（Tik-Tok）起来，这就是所谓的触发器</p>
<p>触发器是一种在外部信号输入后输出之前保存过电平的器件</p>
<p>使用触发器就可以实现随状态变化的数字电路，我们一般将其称为<strong>状态机</strong></p>
<h2 id="数电模电混合电路"><a href="#数电模电混合电路" class="headerlink" title="数电模电混合电路"></a>数电模电混合电路</h2><p>在生活中的任何一个角落，都有数模混合电路的存在——模拟电路负责供能、处理信号；数字电路负责对电信号进行计算、控制。</p>
<p>本系列博客将结合个人所学，以模电-数电-数模混合电路的逻辑讲述电路设计中的一些基础知识与技巧，同步进行开关电源、MCU板级外设电路等成体系电路的设计方法说明</p>
<p><strong>长期维护更新</strong></p>
<p>作者水平有限，如有错误疏漏，敬请谅解。</p>
]]></content>
      <tags>
        <tag>电路设计</tag>
      </tags>
  </entry>
  <entry>
    <title>我的新博客</title>
    <url>/2021/11/13/%E6%88%91%E7%9A%84%E6%96%B0%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>我的新博客</title>
    <url>/2021/11/13/msp430%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="MSP430"><a href="#MSP430" class="headerlink" title="MSP430"></a>MSP430</h1><p>该MCU是由德州仪器TI生产的16位低功耗单片机</p>
<p>主要分以下型号：</p>
<ul>
<li>专注低功耗的<strong>1xx</strong>通用型，配备1KB-60KB FLASH、512B-10KB RAM，工作时耗电仅达200uA/MIPS，RAM保持模式耗电0.1uA，RTC模式耗电0.7uA；可在6us之内快速唤醒。搭载10/12位斜率SAR ADC，集成模拟比较器、DMA、硬件乘法器、BOR、SVS、12位DAC</li>
<li>能耗比高的<strong>F2xx</strong>通用型，性能<a href="mailto:&#x31;&#54;&#77;&#73;&#x50;&#83;&#64;&#51;&#46;&#x33;&#86;">&#x31;&#54;&#77;&#73;&#x50;&#83;&#64;&#51;&#46;&#x33;&#86;</a>，配备1-120KB FLASH，8-128KB RAM，工作耗电220uA，配备10/12位斜率SAR ADC，集成16位Σ-ΔADC，基本上等于1xx的升级版</li>
<li><strong>性价比</strong>高的<strong>G2xx</strong>经济型，性能<a href="mailto:&#x31;&#x36;&#x4d;&#x49;&#80;&#83;&#64;&#x33;&#x2e;&#x33;&#x56;">&#x31;&#x36;&#x4d;&#x49;&#80;&#83;&#64;&#x33;&#x2e;&#x33;&#x56;</a>，对标友商stm32l，主打模拟外设和低功耗</li>
<li>面向计量和智能电网的AFE2xx专用型：性能略低于以上两个2xx系列，但是集成了1-3个独立的24位Σ-ΔADC，一个16位定时器、一个16位硬件乘法器、USART控制器、看门狗和GPIO</li>
<li>停产的老型号3xx</li>
<li>面向低功耗<strong>多媒体</strong>的<strong>4xx</strong>控制型，8-16MIPS处理性能，<strong>配备LCD控制器</strong>、<strong>FLL、SVS</strong>，针对低功耗测量和医疗应用，功耗和1xx相近，4-120KB FLASH、8-256KB RAM，引脚丰富最多可达80Pin，配备10/12位斜率SAR、16位Σ-ΔADC，同样集成了12位ADC、DMA、硬件乘法器、运放、USCI模块等</li>
<li><strong>超高能耗比的5xx超低功耗型</strong>，能达到<a href="mailto:&#50;&#53;&#x4d;&#x49;&#80;&#83;&#x40;&#51;&#x2e;&#x33;&#x56;">&#50;&#53;&#x4d;&#x49;&#80;&#83;&#x40;&#51;&#x2e;&#x33;&#x56;</a>，工作模式功耗165uA/MIPS，RTC模式2.5uA，RAM保持模式可达1uA，待机唤醒时间极短，小于5ms，配备256KB FLASH、18KB RAM，额外集成了USB、模拟比较器</li>
<li>高性能、低功耗的6xx系列旗舰型，达到<a href="mailto:&#50;&#53;&#77;&#73;&#80;&#83;&#x40;&#51;&#46;&#51;&#x56;">&#50;&#53;&#77;&#73;&#80;&#83;&#x40;&#51;&#46;&#51;&#x56;</a>，配备功耗优化的创新电源管理模块和USB控制器，配备LCD控制器，有256KB FLASH、18KB RAM，74Pin引脚，功耗与5xx系列相同，还额外集成了电压管理模块</li>
<li>基于<strong>FRAM</strong>技术的<strong>FRxx</strong>系列，和主要的F系列差别在于使用了FRAM存储技术，能够达到更快的FLASH访问速度并在所有功率模式下实现零功率状态保持，即使发生功率损耗的情况也可以保证写入操作，写入寿命能达到100M个周期，不再需要EEPROM</li>
<li>低电压C、L系列，两个谢列都可以在0.9-1.65V电压范围内工作并提供4MIPS的性能</li>
<li>集成射频基带的CC无线系列，具有低于1GHz的片上射频收发器，工作电压为1.8-3.3V，处理性能20MIPS</li>
<li>特殊系列：面对车规应用、电容触摸、超声波测量、DSP等等特殊用途的系列设备</li>
</ul>
<p>综合来看MSP430具有以下特点：</p>
<ol>
<li><p>超低功耗</p>
<p>使用1.8-3.6V低电压供电，RAM数据保持方式下耗电仅为0.1μA/MIPS，活动模式下耗电也仅仅为250μA/MIPS，IO输入端口漏电流仅为50mA，相比之下只有stm8和stm32l0系列能够达到同等级的低功耗水准。普通的8051则远远落后</p>
</li>
<li><p>能效比高，针对算法加速</p>
<p>MSP430基于RISC架构，采用了一般DSP才有的16位多功能硬件乘法器、硬件乘-加功能、DMA等架构，可以高效实现如FFT、DFT、FIR滤波等数字信号处理算法</p>
</li>
<li><p>模拟外设技术高</p>
<p>MSP430片内集成多种模拟外设，包括液晶驱动器和ADC、DAC等，具体外设由型号决定</p>
</li>
<li><p>外设寄存器直接按位寻址</p>
<p>外设寄存器可以直接进行赋值、按位操作</p>
</li>
</ol>
<p>msp430系列使用了冯诺依曼架构，并构建了MAB（存储器地址总线）、MDB（存储器数据总线）两个总线协议，其中RAM、FLASH共用同一个地址空间，程序被下载到FLASH，设备复位后自动读取并执行程序指令，局部变量存储在RAM，BSS段变量存储在FLASH，FLASH掉电不丢失</p>
<p>设备内部时钟至少具有3套时钟源：</p>
<ol>
<li>LFXT1CLK：低频时钟，32.768kHz</li>
<li>XT2CLK：高频时钟，8MHz</li>
<li>DCOCLK：片内数字控制RC振荡器，经常用作系统和外设时钟信号，其稳定性由FLL与硬件控制</li>
</ol>
<p>三套时钟源可以被设备单独选用，时钟通过片内总线提供给设备；有些型号还具有更多类型的时钟源</p>
<p>DMA可以直接接管总线以提高传输效率（不同于AMBA总线的仲裁，MAB、MDB总线只采用主控设备-从设备的方式）</p>
<p>CPU则采用了双总线位宽的灵活处理方式，分为<strong>16位寻址的CPU</strong>和<strong>20位寻址的CPUX</strong>。CPU采用RISC架构，配备27条指令和7种统一的寻址模式，寻址空间64KB；CPUX寻址空间为1MB，采用面向控制的结构和指令系统，集成了计算分支、表处理等特性，可以在不分页的情况下处理1MB的地址范围，属于RISC正交指令集（正交：指令集的绝大多数指令格式相同、长度相同，所有寄存器的寻址可以替换；而指令的操作码、寻址方式、操作数寄存器字段的取值相互独立），可以实现MTM（内存到内存）传输，不需要经过中间寄存器，一并对16位CPU实现了兼容</p>
<p>在电赛中最常用的就是==<strong>MSP430F5529</strong>==，下面均以F5529为例说明</p>
<h2 id="外围电路设计"><a href="#外围电路设计" class="headerlink" title="外围电路设计"></a>外围电路设计</h2><h3 id="供电"><a href="#供电" class="headerlink" title="供电"></a>供电</h3><p>MCU部分模拟外设和FLASH、RAM对于电源要求较高，但是MCU数字部分对于电源要求较低，因此采用双电源——模拟/数字的方式为MCU供电。模拟-数字电源之间采用磁珠跨接3.3V和地除杂波，同时需要使用10uF、100nF电容并联进行滤波，10uF用于滤除低频杂波，100nF则用于旁路</p>
<h3 id="复位"><a href="#复位" class="headerlink" title="复位"></a>复位</h3><p>RST引脚低电平有效，因此和一般单片机的复位电路一样即可</p>
<h3 id="晶振"><a href="#晶振" class="headerlink" title="晶振"></a>晶振</h3><p>需要使用两个晶振接入来保证电源稳定，<strong>XT1接低频32.768kHz</strong>，<strong>XT2接高频晶振，一般为4MHz</strong>，因为内部电容不足以起振，所以同时需要单独配备20-30pF的匹配电容，一般使用22pF电容</p>
<h3 id="USB"><a href="#USB" class="headerlink" title="USB"></a>USB</h3><p>f5529具有USB控制器，能够使用4芯电缆：5V、D+、D-、GND，并可以兼容USB OTG的ID线。</p>
<h2 id="编译烧录"><a href="#编译烧录" class="headerlink" title="编译烧录"></a>编译烧录</h2><p>MSP430支持JTAG和SBW（Spy-Bi-Wire，TI指定的两线调试接口，信号叫为SBWTCK和SBWTDIO）</p>
<p>同时也支持BSL（BootStrap Loader），或者说BootLoader加载程序烧录可以通过USB、UART等对单片机进行ISP烧录，在PUR引脚和USB D+之间跨接1.4k电阻，下连1M电阻到地，并通过一个加了限流电阻（一般为100Ω）的微动开关连接到VCC即可实现USB的BSL烧录</p>
<p>MSP430的开发环境是TI基于eclipse开发的Code Composer Studio，简称<strong>CCS</strong>，在其中使用专用的MSP430 Compile与Linker即可实现C程序编译链接</p>
<h3 id="关键字和内联函数"><a href="#关键字和内联函数" class="headerlink" title="关键字和内联函数"></a>关键字和内联函数</h3><p>同时CCS支持了一些扩展关键字，列举如下：</p>
<ul>
<li><p><code>__asm</code>用于C语言内嵌汇编，这个和keil一样</p>
</li>
<li><p><code>__interrupt</code>放在函数前指示中断函数，一般和#pragma指令共用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=UART0RX_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">UART_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>上例指示了一个串口0接收中断，#pragma指令让中断向量表中的地址位重定向了</p>
</li>
<li><p><code>__monitor</code>放在函数前，在执行到函数时自动关闭全局中断，类似__atom指令</p>
</li>
<li><p><code>__no_init</code>放在全局变量钱让程序启动时不被变量赋初值</p>
</li>
<li><p><code>__raw</code>关闭中断服务函数的恢复现场能力，这会导致中断服务函数无法返回</p>
</li>
<li><p><code>__regvar</code>声明变量为寄存器变量，注意不能使用指针指向寄存器变量，并且必须搭配使用__no_init禁止初始化</p>
</li>
<li><p><code>sfrb</code>用于声明单字节IO数据类型对象，和51一样用于定义寄存器地址</p>
</li>
</ul>
<p>除了关键字外，CCS还包含了许多内联函数，常见的几个摘录如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__no_operation();<span class="comment">//空指令，相当于NOP</span></span><br><span class="line">__enable_interrupt();<span class="comment">//打开全局中断</span></span><br><span class="line">__disable_interrupt();<span class="comment">//关闭全局中断</span></span><br><span class="line">__delay_cycles(<span class="keyword">unsigned</span> <span class="keyword">long</span> __cycles);<span class="comment">//延时__cycles个主时钟（MCLK）周期</span></span><br><span class="line">__set_SP_register(<span class="keyword">unsigned</span> <span class="keyword">short</span>);<span class="comment">//为堆栈指针寄存器SP赋值</span></span><br></pre></td></tr></table></figure>

<h3 id="预定义寄存器"><a href="#预定义寄存器" class="headerlink" title="预定义寄存器"></a>预定义寄存器</h3><p>CCS中还预置了一些单片机常用的寄存器和配置，如下所示</p>
<ol>
<li><p>端口定义，其中x表示端口号</p>
<p>PxIN：端口输入寄存器</p>
<p>PxOUT：端口输出寄存器</p>
<p>PxDIR：端口方向控制寄存器</p>
<p>PxSEL：端口复用寄存器</p>
<p>注意：<strong>MSP430不支持位操作，一般通过屏蔽位的方法实现位操作，这是它和51开发方面最大的不同</strong>，如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT0 00000001b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT1 00000010b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT2 00000100b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT3 00001000b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT4 00010000b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT5 00100000b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT6 01000000b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT7 10000000b</span></span><br><span class="line"></span><br><span class="line">P1OUT |= BIT0;</span><br><span class="line"><span class="comment">//这样可以实现P1.0输出</span></span><br><span class="line"></span><br><span class="line">P1OUT |= BIT4;</span><br><span class="line"><span class="comment">//这样可以实现P1.0和P1.3同时输出</span></span><br><span class="line"></span><br><span class="line">P1OUT &amp;= ~BIT1;</span><br><span class="line"><span class="comment">//这样可以取消P1.0的输出</span></span><br></pre></td></tr></table></figure></li>
<li><p>低功耗模式的进入和退出</p>
<p>CCS预定义了一些宏指令用来实现低功耗模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LPM3;<span class="comment">//进入低功耗模式</span></span><br><span class="line">LPM3_EXIT;<span class="comment">//退出低功耗模式</span></span><br></pre></td></tr></table></figure>

<p>其中数字可以写0-4，分别对应四种低功耗模式</p>
</li>
<li><p>外设寄存器</p>
<p>各种片上外设的寄存器都被定义为了宏，可以通过<code>|=</code>与<code>&amp;=~</code>的方式进行按位控制</p>
</li>
<li><p>部分常用代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_dint(); <span class="comment">//等效于__disable_interrupt</span></span><br><span class="line">_EINT(); <span class="comment">//等效于__enable_interrupt</span></span><br><span class="line">_NOP(); <span class="comment">//空指令</span></span><br><span class="line">_OPC(x); <span class="comment">//在指令流中插入一个常熟，对与参数对应的任何指令进行编码</span></span><br><span class="line">_SWAP_BYTES(x); <span class="comment">//将无符号16位整数的高8位和低8位交换</span></span><br><span class="line">monitor <span class="comment">//关键字__monitor的宏定义</span></span><br><span class="line">no_init <span class="comment">//关键字__no_init的宏定义</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>综上所述，MSP430的开发和8051的开发非常类似，并没有stm32的库封装，而是直接操作寄存器。这不仅仅是由于MSP430的性能较低，也是由于这样的编程方式写出的代码更加简洁、指令量更少，能突出体现MSP430低功耗的优势</p>
<h2 id="片上外设开发"><a href="#片上外设开发" class="headerlink" title="片上外设开发"></a>片上外设开发</h2><p>MSP430的片上外设寄存器具体配置和51单片机的很像，但是有一些功能更加复杂，和stm32的寄存器接近，同时也提供了简化操作的库函数</p>
<h3 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h3><p>f5529一共有80个引脚，和stm32的<strong>gpio</strong>结构类似，并且也具有<strong>复用功能</strong>。除此之外某些引脚具备基本的<strong>电源功能</strong>，分别能够为MCU的片上数字电路和模拟电路供电，一般情况下可以共用一个电源，但在某些高精度测量场合需要双电源隔离供电。msp430还具有一个USB电源，可以直接输出5V供电，经过片上LDO后能在端口VBUS处输出稳定的3.3V电压供单片机和外设使用，最大驱动电流60mA</p>
<p>其中P1、P2端口IO都具有外部中断能力，分别对应P1IV中断向量和P2IV中断向量。端口可单独配置强驱动和弱驱动模式，<strong>强驱动模式下全片最大输出电流100mA，单端口最大电流15mA；弱驱动模式下全片最大输出电流48mA，单端口最大电流6mA</strong></p>
<p>寄存器操作可以通过上面介绍过的屏蔽位法，也可以通过分别操作寄存器高8位和低8位的方法实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用三种方法将P1.1和P2.2配置为输出功能</span></span><br><span class="line">P1DIR |= <span class="number">0x02</span>; <span class="comment">//0x02 == 00000010b</span></span><br><span class="line">P2DIR |= <span class="number">0x04</span>; <span class="comment">//0x04 == 00000100b</span></span><br><span class="line"></span><br><span class="line">PADIR_L |= <span class="number">0x02</span>; <span class="comment">//DIR寄存器低8位，代表P1</span></span><br><span class="line">PADIR_H |= <span class="number">0x04</span>; <span class="comment">//DIR寄存器高8位，代表P2</span></span><br><span class="line"></span><br><span class="line">PADIR |= <span class="number">0x0402</span>; <span class="comment">//直接操作DIR寄存器，将其视作uint16_t</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>端口配置</p>
<p>如下配置端口为输入状态并配置内部上拉</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P1DIR &amp;= ~BIT1; <span class="comment">//BIT1 == 0x00000010b，设置P1.1为输入模式</span></span><br><span class="line">P1REN |= BIT1; <span class="comment">//使能上下拉电阻</span></span><br><span class="line">P1OUT |= BIT1; <span class="comment">//P1.1配置上拉电阻</span></span><br></pre></td></tr></table></figure>

<p>通过配置PxDIR.n |= 1可以将相应的IO口配置为输出状态，在输出状态下，PxREN、PxIN无效。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P1OUT |= BIT1; <span class="comment">//P1.1输出高电平</span></span><br><span class="line">P1OUT &amp;= ~BIT1; <span class="comment">//P1.1输出低电平</span></span><br><span class="line"></span><br><span class="line">P1DS<span class="number">.1</span> &amp;= ~BIT1; <span class="comment">//配置P1.1为弱驱动输出</span></span><br><span class="line">P1DS<span class="number">.1</span> |= BIT1; <span class="comment">//配置P1.1为强驱动输出</span></span><br></pre></td></tr></table></figure></li>
<li><p>端口复用配置</p>
<p>基本每个IO都有端口复用功能，通过配置PxSEL.n把对应的IO口配置为复用功能</p>
<p>使用以下代码配置P1.0为定时器A0时钟输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P1DIR &amp;= ~BIT0; <span class="comment">//设置P1.0为输入状态</span></span><br><span class="line">P1SEL |= BIT0; <span class="comment">//将P1.0复用为定时器A0时钟输入</span></span><br></pre></td></tr></table></figure>

<p>相关配置需要按照datasheet中的端口复用表选择</p>
</li>
</ol>
<h3 id="时钟系统与低功耗"><a href="#时钟系统与低功耗" class="headerlink" title="时钟系统与低功耗"></a>时钟系统与低功耗</h3><p>msp430f5529具有<strong>5种时钟源</strong>（XT1CLK、XT2CLK、VLOCLK、REFOCLK、DCOCLK）和<strong>3种时钟信号</strong>（MCLK、SMCLK、ACLK）</p>
<p>时钟系统可以软件配置成不需要外部晶振、需要一个外部晶振、需要两个外部晶振、外部时钟输入等方式，最极端的情况下单片机内部具有自身振荡器可以为CPU及片上外设提供系统时钟</p>
<p>时钟系统的安全性比较重要，msp430配备了紧急保护系统，在外部时钟故障时会自动选择内部时钟源REFOCLK或VLOCLK作为时钟信号，并产生响应故障信号（可选中断）</p>
<p>系统时钟大致分为两级，<em>信号生成级</em>和<em>信号分配级</em>，中间通过MUX连接。信号生成级别分为三个模块基本的OSC模块可以通过晶振旁路、内部REFO或VLO直接输出XT1CLK、VLOCLK、REFOCLK三种信号；可选的XT2模块直接输出XT2晶振的4MHz时钟作为XT2CLK；可以通过晶振旁路和FLL（Frequency Locked Loop锁频环）进行晶振时钟倍频和分频，信号源（即FLLREFCLK反馈时钟）通过MUX直接引用XT1CLK、REFOCLK、XT2CLK之一，经过多个倍频分频器后输出为DCOCLK和DCOCLKDIV。所有信号分别输出到信号分配级，通过MUX分配给ACLK、MCLK、SMCLK</p>
<p><strong>XT1CLK</strong>：<strong>外部低频或高频时钟源</strong>，默认关闭，需要接入外部晶振并通过软件使晶振起振后再使用，一般使用32.768kHz的低频晶振，但是也可以使用4-32MHz的外部高频时钟源，<strong>端口P5.4、P5.5</strong></p>
<p>使用下面的代码对时钟源进行配置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P5SEL |= BIT4 | BIT5; <span class="comment">//配置P5.4、P5.5为XT1复用功能</span></span><br><span class="line">UCSCTL6 |= XCAP_3; <span class="comment">//配置匹配电容为12pF</span></span><br><span class="line">UCSCTL6 &amp;= ~XT1OFF; <span class="comment">//使能XT1，使外部晶振起振</span></span><br><span class="line"><span class="keyword">while</span>(SFRIFG1 &amp; OFIFG)</span><br><span class="line">&#123;</span><br><span class="line">    UCSCTL7 &amp;= ~(XT2OFFG + XT1LFOFFG + DCOFFG); <span class="comment">//清除三类时钟故障标志位，等待起振</span></span><br><span class="line">    SFRIFG1 &amp;= ~OFIFG; <span class="comment">//清除震荡器故障标志位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>XT2CLK</strong>：和XT1CLK类似，但只能接4-32MHz的<strong>高频晶振</strong>，一般接入4MHz晶振，需要额外加匹配电容方便起振。<strong>端口P5.2、P5.3</strong></p>
<p>需要注意的是在配置SMCLK和MCLK为XT2CLK时钟源之前需要先修改ACLK和REFCLK的时钟源，因为它们的时钟源默认为XT1CLK，但这里并没有启动，所以会导致没有必要的XT1CLK始终故障，会影响判断XT2是否起振，实现代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P5SEL |= BIT2 | BIT3; <span class="comment">//配置P5.2、P5.3为XT2复用功能</span></span><br><span class="line">UCSCTL6 &amp;= ~XT2OFF; <span class="comment">//使能XT2</span></span><br><span class="line">UCSCTL4 = UCSCTL4 &amp; (~(SELA_7)) | SELA_1; <span class="comment">//将ACLK配置为VLOCLK</span></span><br><span class="line">UCSCTL3 |= SELREF_2; <span class="comment">//将REFCLK配置为REFOCLK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(SFRIFG1 &amp; OFIFG)</span><br><span class="line">&#123;</span><br><span class="line">    UCSCTL7 &amp;= ~(XT2OFFG + XT1LFOFFG + DCOFFG); <span class="comment">//清除三类时钟故障标志位，等待起振</span></span><br><span class="line">    SFRIFG1 &amp;= ~OFIFG; <span class="comment">//清除震荡器故障标志位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>VLOCLK</strong>：<strong>内部低功耗、低频时钟源</strong>，<strong>频率10kHz</strong>，精度较低，会随电源电压和温度产生较大漂移，用于不需要精准时钟基准的系统控制，被使用时自动开启、不使用时自动关闭，低功耗唤醒模式下回优先使用该时钟源作为系统和看门狗时钟</p>
<p>配置UCSCTL4选择</p>
<p><strong>REFOCLK</strong>：<strong>内部修整低频参考时钟源，精度较高，32.768kHz</strong>，和VLOCLK一样不需要配置寄存器进行起振，若未使用外部晶振，系统会自动选择该时钟源作为ACLK和DCOCLK锁频环参考时钟源</p>
<p>通过UCSCTL4选择</p>
<p><strong>DCOCLK</strong>：内部数字控制时钟源，具有宽工作频率，<strong>最高可产生25MHz时钟频率</strong>，可以和FLL配合控制参考时钟，也可以引入其他时钟源反馈进行时钟分频/倍频，但是需要额外配置</p>
<p>这是f5xx中<strong>最常用的时钟源</strong>，类似于stm32的PLL时钟（它的内部也是类似的PLL）</p>
<p>其频率计算公式如下<br>$$<br>DCOCLK = D \times (N+1) \times \frac{REFCLK}{n} \<br>DCOCLKDIV = (N+1) \times \frac{REFCLK}{n}<br>$$<br>REFCLK来源见上文</p>
<p>n为输入时钟分频，通过UCSCTL3中的FLLCLKDIV设定，查找该寄存器介绍可知其取值0-7，对应n取值2^p^，默认为0，不分频</p>
<p>D通过UCSCTL2中的FLLD设对，可取值0-7，对应D取值2^p^，默认为1，即D=2，二分频</p>
<p>N可以通过UCSCTL2中的FLLN设定，取值0-1023，当FLLN=0时，N=1，除此之外N=FLLN，默认为31，即N=31</p>
<p>如果系统复位后不进行任何设置，DCOCLK=2097152Hz，DCOCLKDIV=1048576Hz</p>
<p><strong>MCLK和SMCLK都默认选择DCOCLKDIV作为时钟源</strong>。</p>
<p>通过配置DCORSEL、DCOx、MOD来选择DCO的频率设置范围（最小值和最大值）</p>
<p>详细内容参考datasheet</p>
<p><strong>MODOSC</strong>：内部模块振荡器，是<strong>UCS时钟模块下属的振荡器</strong>，能产生<strong>4.8MHz的MODCLK时钟</strong>，用于FLASH、ADC等片上外设</p>
<p><strong>MCLK</strong>：为CPU和片上外设提供<strong>主时钟</strong>，默认使用DCOCLKDIV</p>
<p>通过配置DIVM选择MCLK分频系数为1、2、4、8、16、32</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UCSCTL4 = UCSCTL4 &amp; (~SELM_7) | SELM_0; <span class="comment">//XT1CLK时钟源</span></span><br><span class="line">UCSCTL4 = UCSCTL4 &amp; (~SELM_7) | SELM_1; <span class="comment">//VLOCLK时钟源</span></span><br><span class="line">UCSCTL4 = UCSCTL4 &amp; (~SELM_7) | SELM_2; <span class="comment">//REFOCLK时钟源</span></span><br><span class="line">UCSCTL4 = UCSCTL4 &amp; (~SELM_7) | SELM_3; <span class="comment">//DCOCLK时钟源</span></span><br><span class="line">UCSCTL4 = UCSCTL4 &amp; (~SELM_7) | SELM_4; <span class="comment">//DCOCLKDIV时钟源</span></span><br><span class="line">UCSCTL4 = UCSCTL4 &amp; (~SELM_7) | SELM_5; <span class="comment">//XT2CLK时钟源</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UCSCTL5 = UCSCTL5 &amp; (~DIVM_7) | DIVM_0; <span class="comment">//MCLK不分频</span></span><br><span class="line">UCSCTL5 = UCSCTL5 &amp; (~DIVM_7) | DIVM_1; <span class="comment">//MCLK 2分频</span></span><br><span class="line">UCSCTL5 = UCSCTL5 &amp; (~DIVM_7) | DIVM_2; <span class="comment">//MCLK 4分频</span></span><br><span class="line">UCSCTL5 = UCSCTL5 &amp; (~DIVM_7) | DIVM_3; <span class="comment">//MCLK 8分频</span></span><br><span class="line">UCSCTL5 = UCSCTL5 &amp; (~DIVM_7) | DIVM_4; <span class="comment">//MCLK 16分频</span></span><br><span class="line">UCSCTL5 = UCSCTL5 &amp; (~DIVM_7) | DIVM_5; <span class="comment">//MCLK 32分频</span></span><br></pre></td></tr></table></figure>

<p><strong>ACLK</strong>：<strong>辅助时钟</strong>，专用来为外围模块提供信号。默认使用XT1CLK时钟源，如果未起振，则使用REFOCLK。配置方法和MCLK完全一致</p>
<p><strong>SMCLK</strong>：<strong>子系统主时钟</strong>，和MCLK基本一致，只是不为CPU提供时钟</p>
<p>上电复位后，UCS默认配置如下：</p>
<ul>
<li>ACLK选择XT1为时钟源，如果未起振则使用REFOCLK并生成时钟故障标志</li>
<li>MCLK选择DCOCLKDIV</li>
<li>SMCLK选择DCOCLKDIV</li>
</ul>
<p>需要注意：msp430f5529的XTIN和XTOUT引脚默认为GPIO功能，并在上电情况下不会启动，需要额外进行软件设置</p>
<p>同时P7.7、P2.2、P1.0分别能够对外输出MCLK、SMCLK、ACLK时钟</p>
<p>这里用最为复杂的DCO配置说明整个时钟系统的配置流程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430f5529.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetVcoreUp</span><span class="params">(<span class="keyword">uint_32_t</span> level)</span></span>; <span class="comment">//提升核心电压以提升工作频率</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">XT1_ON</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//启动XT1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DCO__16MHz</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//使用DCO将XT1倍频到16MHz</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW + WDTHOLD;</span><br><span class="line">    P1SEL |= BIT0; <span class="comment">//P1.0 ACLK输出</span></span><br><span class="line">    P1DIR |= BIT0;</span><br><span class="line">    P2SEL |= BIT2; <span class="comment">//SMCLK输出</span></span><br><span class="line">    P2DIR |= BIT2;</span><br><span class="line">    P7SEL |= BIT7; <span class="comment">//MCLK输出</span></span><br><span class="line">    P7DIR |= BIT7;</span><br><span class="line">    P7DIR |= BIT0; <span class="comment">//P7.0 LED驱动输出</span></span><br><span class="line">    P1OUT |= BIT0;</span><br><span class="line">    </span><br><span class="line">    XT1_ON();</span><br><span class="line">    DCO__16MHz();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        __delay_cycles(<span class="number">8000000</span>); <span class="comment">//每0.5s</span></span><br><span class="line">        P7OUT ^= BIT0 ;<span class="comment">//LED状态翻转一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetVcoreUp</span><span class="params">(<span class="keyword">uint_32_t</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PMMCTL0_H = PMMPW_H; <span class="comment">//解锁PMM寄存器，允许写入</span></span><br><span class="line">    SVSMHCTL = SVSHE + SVSHRVL0 * level + SVMHE + SVSMHRRL0 * level; <span class="comment">//设置SVS/SVM高侧到新的等级</span></span><br><span class="line">    SVSMLCTL = SVSLE + SVMLE + SVSMLRRL0 * level; <span class="comment">//设置SVS低侧到新的等级</span></span><br><span class="line">    <span class="keyword">while</span>((PMMIFG &amp; SVSMLDLYIFG) == <span class="number">0</span>); <span class="comment">//等待SVM稳定</span></span><br><span class="line">    PMMIFG &amp;= ~(SVMLVLRIFG + SVMLIFG); <span class="comment">//清除已经置位的标志</span></span><br><span class="line">    PMMCTL0_L = PMMCOREV0 * level; <span class="comment">//设置VCORE到新的等级</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span>((PMMIFG &amp; SVMLIFG)) <span class="comment">//等待达到新的电压等级</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>((PMMIFG &amp; SVMLVLRIFG) == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置SVS/SVM低侧到新的水平</span></span><br><span class="line">    SVSMLCTL = SVSLE + SVSLRVL0 * level + SVMLE + SVSMLRRL0 * level;</span><br><span class="line">    PMMCTL0_H = <span class="number">0x00</span>; <span class="comment">//锁住PMM的写入路径</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">XT1_ON</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    P5SEL |= BIT4 |BIT5; <span class="comment">//配置XT1引脚</span></span><br><span class="line">    UCSCTL6 |= XCAP_3; <span class="comment">//配置电容为12pF</span></span><br><span class="line">    UCSCTL6 &amp;= ~XT1OFF; <span class="comment">//使能XT1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(SFRIFG1 &amp; OFIFG)</span><br><span class="line">    &#123;</span><br><span class="line">        UCSCTL7 &amp;= ~(XT2OFFG + XT1LFOFFG + DCOFFG); <span class="comment">//清除三类时钟错误标志位</span></span><br><span class="line">        SFRIFG1 &amp;= ~OFIFG; <span class="comment">//清除时钟错误标志位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DCO__16MHz</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SetVcoreUp(<span class="number">1</span>); <span class="comment">//一级一级提升核心电压，不能跨级</span></span><br><span class="line">    SetVcoreUp(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置寄存器使DCOCLK=4.9MHz,DCOCLKDIV=2.45MHz */</span></span><br><span class="line">    __bis_SR_register(SCG0); <span class="comment">//关闭FLL库函数</span></span><br><span class="line">    UCSCTL0 = <span class="number">0x0000</span>; <span class="comment">//清零寄存器值，FLL运行时系统会自动配置该寄存器</span></span><br><span class="line">    UCSCTL1 = DCORSEL_5; <span class="comment">//选择DCOCLK频率范围 6-23.7MHz</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//FLLD=0，则D=1；FLLN=487，则N=487；N在UCSCTL3寄存器，默认值为1，则DCOCLK=1*(487+1)*32768=15.990784MHz</span></span><br><span class="line">    <span class="comment">//DCODIVCLK=(487+1)*32768=15.990784MHz</span></span><br><span class="line">    UCSCTL2 = FLLD_0 + <span class="number">487</span>; </span><br><span class="line">    </span><br><span class="line">    __bic_SR_register(SCG0); <span class="comment">//开启FLL控制回路</span></span><br><span class="line">    __delay_cycles(<span class="number">76563</span>); <span class="comment">//延时等待时钟稳定</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(SFRIFG1 &amp; OFIFG) <span class="comment">//检测时钟错误并等待时钟稳定</span></span><br><span class="line">    &#123;</span><br><span class="line">        UCSCTL7 &amp;= ~(XT2OFFG + XT1LFOFFG + DCOFFG);</span><br><span class="line">        SFRIFG1 &amp;= ~OFIFG;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>低功耗配置</strong></em></p>
<p>msp430一共有8种工作模式</p>
<ul>
<li>活跃模式（AM）</li>
<li>低功耗模式（LPM）0</li>
<li>低功耗模式1</li>
<li>低功耗模式2</li>
<li>低功耗模式3</li>
<li>低功耗模式3.5</li>
<li>低功耗模式4</li>
<li>低功耗模式4.5</li>
</ul>
<p>但是并不是所有系列都支持这些工作模式，对于f5529来说，不支持LPM3.5</p>
<p>使用以下指令来进入和退出低功耗模式0-4</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 开总中断并进入低功耗模式 */</span></span><br><span class="line">__bis_SR_register(LPMn_bits + GIE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 退出低功耗模式 */</span></span><br><span class="line">LPMn_EXIT; <span class="comment">//其中n可以换成数字0-4</span></span><br></pre></td></tr></table></figure>

<p>需要注意：<strong>低功耗模式唤醒都需要使用外部中断</strong>，所以需要在进入低功耗模式同时开启总中断</p>
<p>在最高级别LPM4.5低功耗模式下，RAM中内容会直接丢失，所以在从LPM4.5唤醒后需要重新配置寄存器和相关设置</p>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>低功耗模式唤醒使用的指令实际上是通过直接修改SR寄存器的值，清除休眠标志，它内联到以下函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_bic_SR_register_on_exit(LPM3_bits);<span class="comment">//退出LPM3</span></span><br></pre></td></tr></table></figure>

<p>MSP430和arm一样都具有<em>系统中断</em>、<em>不可屏蔽中断</em>和<em>可屏蔽中断</em>三种，其中系统中断和不可屏蔽中断优先级最高；可屏蔽中断可以通过<strong>状态寄存器SR</strong>中的GIE位来屏蔽和开启</p>
<p>大致的中断作用与arm类似，而使用方式与51类似</p>
<p>下面主要介绍外部中断</p>
<ol>
<li><p>初始化端口时要清空中断标志位</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P1IFG &amp;= ~(BIT0); <span class="comment">//清空中断标志位</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>PIES</code>寄存器选择触发边沿（0为上升沿，1为下降沿）并使用<code>PxIE</code>寄存器使能中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P1IES &amp;= ~BIT0; <span class="comment">//P1.0上升沿触发</span></span><br><span class="line">P1IES |= BIT1; <span class="comment">//P1.1下降沿触发</span></span><br><span class="line">P1IES |= BIT2; <span class="comment">//P1.2下降沿触发</span></span><br><span class="line">    </span><br><span class="line">P1IE |= BIT0; <span class="comment">//使能P1.0中断</span></span><br><span class="line">P1IE |= BIT1; <span class="comment">//使能P1.1中断</span></span><br><span class="line">P1IE |= BIT2; <span class="comment">//使能P1.2中断</span></span><br></pre></td></tr></table></figure></li>
<li><p>开总中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__bis_SR_register(GIE);</span><br></pre></td></tr></table></figure></li>
<li><p>编写中断服务函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector = 中断向量地址</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">ISR_function</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//中断服务函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在中断函数内部清零中断标志位</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__even_in_range(P1IV, <span class="number">16</span>); <span class="comment">//用于查询P1的所有中断标志位并自动清零，使用该函数可以实现将所有P1的外部中断放在同一个函数内解决的功能,如下所示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(__even_in_range(P1IV, <span class="number">16</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//无中断</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//P1IFG.0</span></span><br><span class="line">        <span class="comment">/* 中断处理函数 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">//P1IFG.1</span></span><br><span class="line">        <span class="comment">/* 中断处理函数 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: <span class="comment">//P1IFG.2</span></span><br><span class="line">        <span class="comment">/* 中断处理函数 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>: <span class="comment">//P1IFG.3</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>: <span class="comment">//P1IFG.4</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>: <span class="comment">//P1IFG.5</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">14</span>: <span class="comment">//P1IFG.6</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">16</span>: <span class="comment">//P1IFG.7</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">//出错情况</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>此外，msp430还支持<em>手动的</em>嵌套中断</p>
<p>示例程序如下所示（TI的七段数码管驱动示例程序）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> SEVENSEG_OUTPUT[<span class="number">10</span>] = &#123;<span class="number">0x3f</span>, <span class="number">0x06</span>, <span class="number">0x5b</span>, <span class="number">0x4f</span>, <span class="number">0x66</span>, <span class="number">0x6d</span>, <span class="number">0x7d</span>, <span class="number">0x07</span>, <span class="number">0x7f</span>, <span class="number">0x6f</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> loopCounter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> timeCounter1; </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> timeCounter2;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> timeCounter3;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW | WDTHOLD; <span class="comment">//关闭看门狗</span></span><br><span class="line"></span><br><span class="line">    PADIR = <span class="number">0x03ff</span>; <span class="comment">// P1, P2.0 and P2.1 output, P2.6 and P2.7 input</span></span><br><span class="line">    PAOUT = <span class="number">0xc03f</span>;</span><br><span class="line"></span><br><span class="line">    P2REN = <span class="number">0xc0</span>; <span class="comment">// P2.6 P2.7 上拉电阻使能</span></span><br><span class="line">    P2IES = <span class="number">0x3f</span>; <span class="comment">// P2.6 P2.7 配置中断为上升沿</span></span><br><span class="line">    P2IE = <span class="number">0xc0</span>; <span class="comment">// P2.6 P2.7 interrupt enabled</span></span><br><span class="line"></span><br><span class="line">    PM5CTL0 &amp;= ~LOCKLPM5; <span class="comment">// 关闭GPIO高阻抗模式</span></span><br><span class="line"></span><br><span class="line">    RTCMOD = <span class="number">50</span>; <span class="comment">// 设置RTC重装计数值为50</span></span><br><span class="line">                 <span class="comment">// 64/32768 * 51 = ~0.1 sec.</span></span><br><span class="line">    SYSCFG2 |= RTCCKSEL; <span class="comment">// Source = ACLK = REFO，64分频，选择ACLK作为RTC时钟</span></span><br><span class="line">    RTCCTL = RTCSS_1 | RTCSR | RTCPS__64;</span><br><span class="line"></span><br><span class="line">    P2IFG = <span class="number">0</span>; <span class="comment">// 清除P1.3中断标志位</span></span><br><span class="line">    __bis_SR_register(GIE); <span class="comment">//开全局中断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PAOUT |= (BIT9 | SEVENSEG_OUTPUT[timeCounter3]);  <span class="comment">// 按顺序显示七段数码管数字</span></span><br><span class="line">        __delay_cycles(<span class="number">100</span>);</span><br><span class="line">        PAOUT = <span class="number">0xc000</span>; <span class="comment">// 清除引脚</span></span><br><span class="line"></span><br><span class="line">        PAOUT |= (BIT8 | SEVENSEG_OUTPUT[timeCounter2]);</span><br><span class="line">        __delay_cycles(<span class="number">100</span>);</span><br><span class="line">        PAOUT = <span class="number">0xc000</span>;</span><br><span class="line"></span><br><span class="line">        P1OUT |= (BIT7 | SEVENSEG_OUTPUT[timeCounter1]);</span><br><span class="line">        __delay_cycles(<span class="number">100</span>);</span><br><span class="line">        P1OUT = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RTC中断服务函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=RTC_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">RTC_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __bis_SR_register(GIE); <span class="comment">// 允许嵌套中断</span></span><br><span class="line">    RTCIV = <span class="number">0</span>;</span><br><span class="line">    timeCounter1++; <span class="comment">// timeCounter1代表0.1s, timeCounter2代表1s,timeCounter3代表10s，经典延时操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(timeCounter1 &gt; <span class="number">9</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        timeCounter1 = <span class="number">0</span>;</span><br><span class="line">        timeCounter2++;</span><br><span class="line">        <span class="keyword">if</span>(timeCounter2 &gt; <span class="number">9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            timeCounter3++;</span><br><span class="line">            timeCounter2 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(timeCounter3 &gt; <span class="number">9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            timeCounter3 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P2中断服务函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=PORT2_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">Port_2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __bis_SR_register(GIE); <span class="comment">// 允许嵌套中断</span></span><br><span class="line">    <span class="keyword">if</span>(P2IFG &amp; BIT6)</span><br><span class="line">    &#123;</span><br><span class="line">        P2IFG &amp;= ~BIT6; <span class="comment">// 清除P2.6中断标志位</span></span><br><span class="line">        <span class="comment">// 第一次按下按钮时开启定时器；第二次按下时停止定时器</span></span><br><span class="line">        <span class="keyword">if</span>(loopCounter == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          	loopCounter++; <span class="comment">//开启一轮循环</span></span><br><span class="line">            RTCCTL |= RTCIE; <span class="comment">//开启定时器</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            RTCCTL &amp;= ~RTCIE; <span class="comment">//关闭定时器</span></span><br><span class="line">            loopCounter = <span class="number">0</span>; <span class="comment">//循环清零</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(P2IFG &amp; BIT7)</span><br><span class="line">    &#123;</span><br><span class="line">        P2IFG &amp;= ~BIT7; <span class="comment">// 清除P2.7中断标志位并复位秒表</span></span><br><span class="line">        RTCCTL &amp;= ~RTCIE; <span class="comment">//关闭定时器</span></span><br><span class="line">        </span><br><span class="line">        loopCounter = <span class="number">0</span>; <span class="comment">//复位所有变量</span></span><br><span class="line">        timeCounter3 = <span class="number">0</span>;</span><br><span class="line">        timeCounter2 = <span class="number">0</span>;</span><br><span class="line">        timeCounter1 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现中断嵌套需要注意以下几点：</p>
<p>msp430默认关闭中断嵌套，一定要中断嵌套的话，就必须在中断服务程序中打开总中断</p>
<p>msp430的指令中，_DINT()和_EINT()分别指关和开总中断</p>
<p>当进入中断服务程序时，只要不在中断服务程序中再次开中断，则总中断是关闭的，此时来中断不管是比当前中断的优先级高还是低都不执行</p>
<p><strong>若在中断服务程序A中开了总中断，则可以响应后来的中断B（不管B的优先级比A高还是低），B执行完再继续执行A</strong></p>
<p>注意：进入中断服务程序B后总中断同样也会关闭，如果B中断程序执行时需响应中断C，则此时也要开总中断，若不需响应中断，则不用开中断，B执行完后跳出中断程序进入A程序时，总中断会自动打开</p>
<p><strong>若在中断服务程序中开了总中断，后来的中断同时有多个，则会按优先级来执行，即中断优先级只有在多个中断同时到来时才起作用，中断服务不执行抢先原则</strong></p>
<p>对于单源中断，只要响应中断，系统硬件会自动清除中断标志位。对于TA/TB定时器的比较/捕获中断，只要访问TAIV/TBIV，标志位就会被自动清除；对于多源中断要手动清标志位，比如P1/P2口中断，要手工清除相应的标志。如果在这种中断里用<code>_EINT();</code>开中断,而在打开中断前没有清标志，就会有相同的中断不断嵌入，导致堆栈溢出引起复位，所以在<strong>这类中断中必须先清标志再打开中断开关</strong></p>
<p><strong>常用中断向量表</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASICTIMER_VECTOR   (0 * 2u) <span class="comment">/* 0xFFE0 Basic Timer */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT2_VECTOR        (1 * 2u)  <span class="comment">/* 0xFFE2 Port 2 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USART1TX_VECTOR     (2 * 2u) <span class="comment">/* 0xFFE4 USART 1 Transmit */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USART1RX_VECTOR     (3 * 2u) <span class="comment">/* 0xFFE6 USART 1 Receive */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT1_VECTOR        (4 * 2u)  <span class="comment">/* 0xFFE8 Port 1 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMERA1_VECTOR      (5 * 2u) <span class="comment">/* 0xFFEA Timer A CC1-2, TA */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMERA0_VECTOR      (6 * 2u) <span class="comment">/* 0xFFEC Timer A CC0 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADC12_VECTOR          (7 * 2u)  <span class="comment">/* 0xFFEE ADC */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USART0TX_VECTOR     (8 * 2u) <span class="comment">/* 0xFFF0 USART 0 Transmit */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USART0RX_VECTOR     (9 * 2u) <span class="comment">/* 0xFFF2 USART 0 Receive */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WDT_VECTOR          (10 * 2u) <span class="comment">/* 0xFFF4 Watchdog Timer */</span></span></span><br><span class="line"></span><br><span class="line">#defineCOMPARATORA_VECTOR  (<span class="number">11</span> * <span class="number">2u</span>) <span class="comment">/* 0xFFF6Comparator A */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMERB1_VECTOR      (12 * 2u) <span class="comment">/* 0xFFF8 Timer B CC1-6, TB */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMERB0_VECTOR      (13 * 2u) <span class="comment">/* 0xFFFA Timer B CC0 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NMI_VECTOR          (14 * 2u) <span class="comment">/* 0xFFFC Non-maskable */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RESET_VECTOR        (15 * 2u) <span class="comment">/* 0xFFFE Reset [HighestPriority] */</span></span></span><br></pre></td></tr></table></figure>

<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>msp430有四个基本定时器，外加一个RTC定时器，部分定时器具有PWM输出功能</p>
<p>计数器核心是一个计数寄存器，对输入的时钟信号进行计数，可以配置其捕获跳变沿种类和分频系数，使用寄存器TAxR获取当前计数值。定时器主要分成两部分：主计数器和捕获比较器模块。捕获比较器模块与主计数器模块通过TAxR连通，主计数器会根据输入的信号跳变沿递增/递减寄存器TAxR/TBxR的值，捕获比较器会根据收到的比较值对寄存器的值进行检查，根据当前模式不同做出不同反应，因为计数寄存器被共用，所以可以将其分成多个通道。一般当捕获比较器满足设置的条件时就会产生中断，存储计数值或输出相应的信号。<em>只需要主计数器即可完成定时工作，捕获比较器的作用则在于配合主计数器完成更多扩展功能</em></p>
<ul>
<li><p><strong>Timer_A</strong>：<strong>16位定时器</strong>（最大值65535），具有7个捕获比较器，支持<em>多路捕获比较</em>、<em>PWM输出</em>、<em>间隔定时</em>功能</p>
<p>F5529中包含两个Timer_A模块，记作Timer_A0、Timer_A1、Timer_A2，三个模块的主计数器在结构上完全相同，单捕获比较器的数量不相同：Timer_A0有7个，Timer_A1和Timer_A2各有3个。</p>
</li>
<li><p><strong>Timer_B</strong>：<strong>16位定时器</strong>（最大值65535），具备Timer_A的所有功能，但它还具备<em>双缓冲比较锁存</em>与<em>同步加载</em>功能</p>
</li>
</ul>
<p>定时器的基本模式如下：</p>
<ul>
<li><p>捕获器模式</p>
<p>触发信号到来时捕获器将计数寄存器的值复制到捕获比较器的计数值寄存器TAxCCRn/TBxCCRn，并产生中断请求</p>
</li>
<li><p>比较器模式</p>
<p>需要程序向计数值寄存器TAxCCRn/TBxCCRn中写入初值，当主计数器的计数寄存器TAxR/TBxR计数值达到寄存器中存储的初值后定时器模块就会向CPU请求中断 </p>
</li>
</ul>
<p>通过配置TASSEL可以选择时钟来自ACLK、SMCLK、TAxCLK（外部输入）或INCLK（定时器级联）</p>
<h4 id="定时器A"><a href="#定时器A" class="headerlink" title="定时器A"></a>定时器A</h4><p>msp430的定时器A的主计数器具有以下几个工作模式</p>
<ul>
<li><p>增模式</p>
<p>设备会重复<strong>从0自增到TAxCCRn的值</strong>，溢出时触发中断</p>
<p>最基础的功能</p>
</li>
<li><p>连续模式</p>
<p>设备会重复<strong>从0自增到0FFFFh</strong>，然后从0重新开始计数</p>
<p>一般用于生成独立的时间间隔和输出频率，时间间隔完成时会生成中断</p>
<p>起始设置TAxCCRn的初值，并在中断服务函数中重新设置TAxCCRn的值，使其与初值的计数个数相同即可产生固定的时间间隔，这种操作还可以应用多个通道，因为多通道之间相互独立</p>
<p>最基础的功能</p>
</li>
<li><p>增减模式</p>
<p>定时器从0自增到TAxCCR0，再自减到0，也就是说其定时周期为两倍的TAxCCR0</p>
</li>
</ul>
<p>捕获比较器工作模式如下：</p>
<p>通过设置捕获比较器中的CAP位可以选择捕获比较器的工作模式为比较模式（0）或捕获模式（1），</p>
<ul>
<li><p>捕获模式</p>
<p>当CAP=1时选择捕获模式，用于记录时间时间。</p>
<p>触发信号输入CCIxA/CCIxB连接外部的引脚或内部的信号，通过CCIS位来选择；通过CM位选择触发捕获事件的输入信号触发沿</p>
<p>每当触发信号到来时，捕获比较器会1. 将TAxR的值复制到TAxCCRn寄存器中；2. 将捕获器中断标志CCIFG置位触发中断</p>
</li>
<li><p>比较模式</p>
<p>如果计数器TAxR的值和某个TAxCCRn的值相等时，相应的中断标志位会被置位，产生一个比较中断。一般该模式用于产生PWM信号</p>
</li>
<li><p>输出模式</p>
<p>传统的定时器通过标志位判断来触发事件，但msp430配备了专用的输出模块，使用输出模块寄存器OUTMODEx可以快速输出PWM信号或其他控制信号</p>
</li>
</ul>
<h4 id="定时器中断"><a href="#定时器中断" class="headerlink" title="定时器中断"></a>定时器中断</h4><p>定时器A具有两个中断源，捕获比较器0中断独立，其他所有中断（定时器溢出中断、捕获比较器1中断、捕获比较器2中断等等）共用中断源，通过TAxIV来确定具体触发中断的中断源</p>
<p>使用步骤如下：</p>
<ol>
<li><p>设置主计数器时钟</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TA0CTL = TASSEL_1;</span><br></pre></td></tr></table></figure></li>
<li><p>设置分频</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TA0EX0 = TAIDEX_7 <span class="comment">//8分频</span></span><br></pre></td></tr></table></figure></li>
<li><p>初始化CCR寄存器（设置初值）并使能中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TA0CCR0 = <span class="number">9000</span>; <span class="comment">//设置初值</span></span><br><span class="line">TA0CCTL0 = CCIE; <span class="comment">//使能TA0CCR0中断</span></span><br></pre></td></tr></table></figure></li>
<li><p>设置捕获比较器模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TA0CTL |= MC_2 + TACLR; <span class="comment">//清除TA0R，启动定时器，选择连续计数模式</span></span><br></pre></td></tr></table></figure>

<p>也可以使用下面的代码启用其他模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MC_1 增模式</span><br><span class="line">MC_3 减增模式</span><br></pre></td></tr></table></figure></li>
<li><p>开总中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__bis_SR_register(GIE);</span><br></pre></td></tr></table></figure></li>
<li><p>配置中断服务函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector = TIMER0_A0_VECTOR <span class="comment">//TA0CCR0中断</span></span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">TA0CCR0_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TA0CCR0 += <span class="number">16384</span>; <span class="comment">//添加偏置</span></span><br><span class="line">    <span class="comment">/* 中断处理函数 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="定时器B"><a href="#定时器B" class="headerlink" title="定时器B"></a>定时器B</h4><p>在捕获比较器和比较器之间加入的比较锁存器可以分组控制比较值载入的时刻，实现同步更新数据</p>
<p>在Timer_B中可以通过配置寄存器TBxCCTLn来选择TBxCCRn载入TBxCLn的时刻，在Timer_B中起到比较作用的是比较锁存器TBxCLn而不是CCR寄存器，当TBxR的值达到TBxCLn时，相应的中断标志位置位，产生比较器中断请求，TBxCCRn的值会在寄存器设置的时间点载入TBxCLn，从而实现比较延时更新</p>
<h4 id="输入捕获"><a href="#输入捕获" class="headerlink" title="输入捕获"></a>输入捕获</h4><p>使用定时器的外部计数功能来测量脉冲个数，可用于测速、编码器驱动等场合</p>
<p>基本使用方式和上面的定时器中断类似，但是需要以下额外语句</p>
<ol>
<li><p>配置外部时钟源，使能溢出中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TA0CTL = TASSEL_0 + TAIE;</span><br></pre></td></tr></table></figure></li>
<li><p>清除TAxR、启动定时器并工作于连续模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TA0CTL |= TACLR + MC_2;</span><br></pre></td></tr></table></figure></li>
<li><p>在定时器中断服务函数内递增全局计数变量用于获取输入捕获的脉冲数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> counter;</span><br><span class="line"><span class="keyword">uint8_t</span> loop;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector = TIMER0_A1_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">TA0_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    counter++;</span><br><span class="line">    <span class="keyword">if</span>(counter&gt;<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        loop++;</span><br><span class="line">        counter=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="PWM输出"><a href="#PWM输出" class="headerlink" title="PWM输出"></a>PWM输出</h4><p>msp430可以实现在不占用CPU资源的情况下输出PWM信号，程序如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430f5529.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW | WDTHOLD; <span class="comment">//关闭看门狗</span></span><br><span class="line">    P1DIR |= BIT2 | BIT3;</span><br><span class="line">    P1SEL |= BIT2 | BIT3; <span class="comment">//设置为定时器复用</span></span><br><span class="line">    TA0CCR0 = <span class="number">512</span><span class="number">-1</span>; <span class="comment">//PWM周期，频率=32768/512=64</span></span><br><span class="line">    TA0CCTL1 = OUTMODE_7; <span class="comment">//CCR1输出模式7</span></span><br><span class="line">    TA0CCR1 = <span class="number">384</span>; <span class="comment">//CCR1 PWM占空比设置为384/512=75%</span></span><br><span class="line">    TA0CCTL2 = OUTMODE_7; <span class="comment">//CCR2输出模式7</span></span><br><span class="line">    TA0CCR2 = <span class="number">128</span>; <span class="comment">//CCR2 PWM占空比设置为128/512=25%</span></span><br><span class="line">    <span class="comment">//开启定时器</span></span><br><span class="line">    TA0CTL = TASSEL_1 + MC_1 + TACLR; <span class="comment">//定时器时钟设置为32768Hz的ACLK，配置为增模式，清空TA0R</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 可实现在P1.2上输出75%占空比，在P1.3上输出25%占空比，频率都是64Hz的PWM信号 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总线协议"><a href="#总线协议" class="headerlink" title="总线协议"></a>总线协议</h3><p>msp430f5529中配备了<strong>通用串行通信接口模块USCI</strong>，它支持了多种通信模式，UART、SPI、IIC都可以使用该外设进行处理</p>
<p>使用方法很类似，仅给出示例代码</p>
<h4 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h4><p>串口接收并复读数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430f5529.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW + WDTHOLD;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 初始化UART */</span></span><br><span class="line">    P4SEL |= BIT4 + BIT5; <span class="comment">//配置P4.4、P4.5为USCI_A1 Tx、Rx</span></span><br><span class="line">    UCA1CTL1 |= UCSWRST; <span class="comment">//复位USCI_A1</span></span><br><span class="line">    UCA1CTL1 |= UCSSEL_2; <span class="comment">//SMCLK 无校验位 8字符长度 1个停止位</span></span><br><span class="line">    UCA1BR0 = <span class="number">9</span>; <span class="comment">//低8位=9</span></span><br><span class="line">    UCA1BR1 = <span class="number">0</span>; <span class="comment">//高8位=0，调制后波特率约为115200bps</span></span><br><span class="line">    UCA1MCTL |= UCBRS_1 + UCBRF_0; <span class="comment">//调制器UCBRSx=1,UCBRFx=0</span></span><br><span class="line">    UCA1CTL1 &amp;= ~UCSWRST; <span class="comment">//启动USCI_A1</span></span><br><span class="line">    UCA1IE |= UCRXIE; <span class="comment">//使能USCI_A1接收中断</span></span><br><span class="line">    __bis_SR_register(LPM0_bits + GIE); <span class="comment">//使能全局中断</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=USCI_A1_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">USCI_A1_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(__even_in_range(UCA1IV, <span class="number">4</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//无中断</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//接收中断RXIFG</span></span><br><span class="line">            UCA1TXBUF = UCA1RXBUF; <span class="comment">//复读</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">//发送中断TXIFG</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UCA1TXBUF：串口发送寄存器</p>
<p>UCA1RXBUF：串口接收寄存器</p>
<p>UCA1IE：串口中断控制寄存器，可以选择接收中断、发送中断</p>
<h4 id="IIC"><a href="#IIC" class="headerlink" title="IIC"></a>IIC</h4><p>需要注意，msp430的IIC无法内部上拉，所以必须在外部接入4.7k的上拉电阻到VCC（3.3V）</p>
<p>下面的代码仅说明如何将USCI配置成IIC驱动模式</p>
<ol>
<li><p>包含头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>初始化引脚复用功能</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P4SEL |= BIT1 + BIT2;</span><br></pre></td></tr></table></figure></li>
<li><p>初始化USCI，并配置传输速率</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UCB1CTL1 |= UCSWRST; <span class="comment">//复位USCI_B1</span></span><br><span class="line">UCB1CTL0 |= UCMST + UCMODE_3 + UCSYNC; <span class="comment">//配置为IIC主机，同步模式</span></span><br><span class="line">UCB1CTL1 = UCSSEL_2 + UCSWRST; <span class="comment">//SMCLK，保持UCSWRST置位</span></span><br><span class="line"></span><br><span class="line">UCB1BR0 = <span class="number">12</span>; <span class="comment">//fscl=SMCLK/12=100kHz</span></span><br><span class="line">UCB1BR1 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>设置从机地址</p>
<p>这里假设从机地址是0x48</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UCB1I2CSA = <span class="number">0x48</span>; <span class="comment">//从机地址0x48</span></span><br></pre></td></tr></table></figure></li>
<li><p>启动外设</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UCB1CTL1 &amp;= ~UCSWRST; <span class="comment">//清除复位标志，外设开始运行</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写中断控制函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> IIC_RXByte;</span><br><span class="line"><span class="keyword">uint8_t</span> IIC_TXByte;</span><br><span class="line"><span class="keyword">uint8_t</span> *PRxData; <span class="comment">//接收缓存</span></span><br><span class="line"><span class="keyword">uint8_t</span> *PTxData; <span class="comment">//发送缓存</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=USCI_B1_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">USCI_B1_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(__even_in_range(UCB1IV, <span class="number">12</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//无中断</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//ALIFG</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">//无响应中断NACKIFG</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: <span class="comment">//STTIFG</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>: <span class="comment">//停止位中断STPIFG</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>: <span class="comment">//接收中断RXIFG</span></span><br><span class="line">            IIC_RXByte--; <span class="comment">//递减字节计数变量</span></span><br><span class="line">            <span class="keyword">if</span>(IIC_RXByte) <span class="comment">//如果没有接收完毕</span></span><br><span class="line">            &#123;</span><br><span class="line">                *PRxData++ = UCB1RXBUF; <span class="comment">//接收剩下的数据到缓存区</span></span><br><span class="line">                <span class="keyword">if</span>(IIC_RXByte == <span class="number">1</span>) <span class="comment">//检查是否只剩一个字节未接收</span></span><br><span class="line">                &#123;</span><br><span class="line">                    UCB1CTL1 |= UCTXSTP; <span class="comment">//发送停止条件</span></span><br><span class="line">				&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//已经接收完毕</span></span><br><span class="line">            &#123;</span><br><span class="line">                *PRxData = UCB1RXBUF; <span class="comment">//将最后一字节数据存储到缓存区</span></span><br><span class="line">                UCB1IE &amp;= ~UCRXIE; <span class="comment">//禁用接收中断</span></span><br><span class="line">                __bic_SR_registe_on_exit(LPM0_bits); <span class="comment">//退出LPM0，进入活跃模式</span></span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">12</span>: <span class="comment">//发送中断TXIFG</span></span><br><span class="line">            <span class="keyword">if</span>(IIC_TXByte) <span class="comment">//如果没有发送完毕</span></span><br><span class="line">            &#123;</span><br><span class="line">                UCB1TXBUF = *PTxData; <span class="comment">//IIC发送数据</span></span><br><span class="line">                IIC_TXByte--; <span class="comment">//递减字节计数变量</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//已经接收完毕</span></span><br><span class="line">            &#123;</span><br><span class="line">                UCB1CTL1 |= UCTXSTP; <span class="comment">//置位发送停止条件位</span></span><br><span class="line">                UCB1IFG &amp;= ~UCTTXIFG; <span class="comment">//清除发送中断标志位TXIFG</span></span><br><span class="line">                UCB1IE &amp;= ~UCTXIE; <span class="comment">//禁用发送中断</span></span><br><span class="line">                __bic_SR_registe_on_exit(LPM0_bits); <span class="comment">//退出LPM0，进入活跃模式</span></span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写相关驱动</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TxData[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//发送缓存区</span></span><br><span class="line">RxData[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//接收缓存区</span></span><br><span class="line"><span class="keyword">uint8_t</span> IIC_RXByte;</span><br><span class="line"><span class="keyword">uint8_t</span> IIC_TXByte;</span><br><span class="line"><span class="keyword">uint8_t</span> *PRxData; <span class="comment">//接收缓存</span></span><br><span class="line"><span class="keyword">uint8_t</span> *PTxData; <span class="comment">//发送缓存</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 这里省略初始化部分 */</span></span><br><span class="line">    disable_WDG();</span><br><span class="line">    init_iic();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 发送设置 */</span></span><br><span class="line">        PTxData = TxData;</span><br><span class="line">        IIC_TXByte = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">while</span>(UCB1CTL1 &amp; UCTXSTP); <span class="comment">//确保停止条件已发送，总线空闲</span></span><br><span class="line">        </span><br><span class="line">        UCBCTL1 |= UCTR; <span class="comment">//设置主机工作在发送机模式</span></span><br><span class="line">        UCBCTL1 |= UCTXSTT; <span class="comment">//发送开始条件并发送有“写标志位”的地址</span></span><br><span class="line">        UCB1IE |= UCTXIE; <span class="comment">//使能发送中断</span></span><br><span class="line">        __bis_SR_register(LPM0_bits + GIE); <span class="comment">//进入LPM0，使能全局中断</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 接收设置 */</span></span><br><span class="line">        PRxData = RxData;</span><br><span class="line">        IIC_RXByte = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">while</span>(UCB1CTL1 &amp; UCTXSTP); <span class="comment">//确保停止条件已发送，总线空闲</span></span><br><span class="line">        UCBCTL1 &amp;= ~UCTR;<span class="comment">//设置主机工作在接收机模式</span></span><br><span class="line">        UCBCTL1 |= UCTXSTT; <span class="comment">//发送开始条件并发送有“读标志位”的地址</span></span><br><span class="line">        UCB1IE |= UCRXIE; <span class="comment">//使能接收中断</span></span><br><span class="line">        __bis_SR_register(LPM0_bits + GIE); <span class="comment">//进入LPM0，使能全局中断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h4><p>使用以下代码设置SPI</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这里省略端口复用设置 */</span></span><br><span class="line">UCB0CTL1 |= UCSWrST;</span><br><span class="line">UCB0CTL0 |= UCMST + UCSYNC; <span class="comment">//设置为三线SPI主机模式，8位数据位</span></span><br><span class="line">UCB1CTL1 = UCSSEL_2; <span class="comment">//时钟设置为SMCLK</span></span><br><span class="line">UCB1BR0 = <span class="number">0xFF</span>; <span class="comment">//UCB0CLK = SMCLK / 0xFFF</span></span><br><span class="line">UCB1BR1 = <span class="number">0x0F</span>; <span class="comment">//一般来说可以选择100kHz以上的频率，通常使用4MHz频率</span></span><br><span class="line"></span><br><span class="line">UCB1CTL1 &amp;= ~UCSWRST; <span class="comment">//清除复位标志，外设开始运行</span></span><br></pre></td></tr></table></figure>

<p>中断和驱动编写部分和IIC基本一致，不再赘述</p>
<h3 id="片上模拟外设"><a href="#片上模拟外设" class="headerlink" title="片上模拟外设"></a>片上模拟外设</h3><p>msp430集成了12位ADC/DAC和模拟比较器外设</p>
<h4 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h4><p>f5529配备了SAR架构的ADC12_A模块，支持12位ADC，具有16个模拟输入通道、16个独立的转换和存储单元，可在脱离CPU情况下完成ADC转换，最高200ksp（千次采样/每秒）</p>
<p>基本配置流程如下：</p>
<ol>
<li><p>配置核心控制寄存器，选择时钟、转换模式、启动参考电压生成器</p>
<p>ADC12_A内部具有独立的REF模块，可以提供1.5V、2V、2.5V参考电压。通过REF模块的REFMSTR位选择参考电压：置1时（默认状态）使用REF模块控制参考电压；置0时使用ADC12_A的参考电压模块控制参考电压</p>
<p>使用ADC12REF2_5V控制参考电压大小，ADC12REFON控制是否开启电压生成器，ADC12REFOUT控制是否输出参考电压</p>
<p>ADC使用ADC12CLK时钟用来控制采样和转换的时间和周期，时钟源可选择SMCLK、MCLK、ACLK和ADC12OSC（UCS模块的MODCLK的5MHz内部振荡器），时钟源使用ADC12DIV控制的预分频器和ADC12SSELx控制的分频器进行分频，可选择1-32分频</p>
<p>基本配置程序如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADC12CTL0 = ADC12ON+ADC12SHT0_8+ADC12MSC; <span class="comment">//开启ADC12,设置采样时间,设置采样模式（这里使用了多采样转换）</span></span><br></pre></td></tr></table></figure>

<p>ADC具有4种模式，通过CONSEQx位选择</p>
<ul>
<li><strong>单通道模式</strong>：单通道只采样和转换一次，当ADC12SC置位时触发一次采样转换操作，持续一段时间后自动复位</li>
<li>序列通道（<strong>自动扫描</strong>）<strong>模式</strong>：使用CSTARTADDx位选择开始转换的第一个ADC1MCTLx，指定后序列启动指针会自动递增，被它指向的通道会自动开始转换，转换完成后自动复位，操作一直继续直到处理到ADC12EOS=1的ADC12MCTLx才会停止，ADC12EOS作为序列结束的标志，只在序列转换模式下使用</li>
<li><strong>重复单通道模式</strong>：一个单独的通道会被不断采样转换，可以设置完成中断来读取转换结果</li>
<li><strong>重复序列通道</strong>（自动重复）<strong>模式</strong>：一序列通道会被重复采样和转换，使用CSTARTADDx定义第一个ADC12McTLx，序列再检测到ADC12EOS（序列结束标志）置位后会自动结束，下一个触发信号将重新开始序列</li>
</ul>
</li>
<li><p>保持其处于禁用状态，ADC12ENC=0</p>
</li>
<li><p>配置引脚复用</p>
<p>将GPIO复用为ADC输入引脚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PxSEL |= <span class="number">0x0</span>n; <span class="comment">//选择Px.n引脚复用为ADC输入</span></span><br></pre></td></tr></table></figure>

<p>注意：<strong>只有能接入ADC的对应IO口才能复用</strong></p>
</li>
<li><p>配置采样定时器</p>
<p>一次转换由一个采样信号SHI的上升沿引起，可通过SHSx位来选择，可以选为直接由ADC12SC位控制或使用定时器来控制</p>
<ul>
<li>ADC12SHP=0，使用<strong>扩展采样模式</strong>，SHI信号直接控制SAMPCON并定义采样周期长度；SAMPCON=1时采样活跃，SAMPCON的下降沿会在同步ADC12CLK信号后启动转换</li>
<li>ADC12SHP=1，使用<strong>脉冲采样模式</strong>，SHI信号用于触发采样定时器，采样定时器在同步AD12CLK后将SAMPCON保持在高电平并持续一个可编程的间隔$t_{sample}$，整个采样时间就是$t_{sample}+t_{sync}$</li>
</ul>
</li>
<li><p>可单独配置每个通道的参考电压和输入源</p>
<p>使用ADC12MCTLx（x为0-15）控制转换存储单元，通过ADC12SREF和ADC12INCH分别选择参考电压和模拟信号的输入通道</p>
<p>在单通道单转换模式中，复位ADC12ENC<strong>立刻</strong>停止一个转换且会导致转换结果不可预知，一般来说需要使用以下语句停止单通道转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(ADC12BUSY != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    delay();</span><br><span class="line">&#125;</span><br><span class="line">ADC12ENC = <span class="number">0</span>; <span class="comment">//等待ADC12BUSY = 0后才能停止单通道转换</span></span><br></pre></td></tr></table></figure>

<p>重复单通道模式下，复位ADC12ENC会在<strong>当前转换结束</strong>时停止转换器</p>
<p>序列通道或重复序列通道中，复位ADC12ENC会在<strong>序列结束</strong>时停止转换器</p>
<p><em>任何模式中都可以通过清零ADC12CONSEQ并复位ADC12ENC位来立刻停止，但这样会导致转换结果不可预知</em></p>
</li>
<li><p>可以使能集成温度传感器或配置转换完成中断</p>
<p>ADC可以直接连接内部的温度传感器（这是参考电压生成器的一部分）来获取内部温度，计算公式如下<br>$$<br>T=(ADC_{raw} - CAL_ADC_T30) \times (\frac{85-30}{CAL_ADC_T85 - CAL_ADC_T30}) + 30<br>$$<br>其中T是精确温度值，$ADC_{raw}$是数模转换结果，两个$CAL_ADC_T$为温度矫正参数，需要通过地址进行访问调用，每个设备的矫正参数都不同，该参数会被使用TLV（Tag-Length-Value）的方式写入单片机，地址调用形式如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*((<span class="keyword">unsigned</span> <span class="keyword">int</span>*)<span class="number">0x1A1A</span>) <span class="comment">//具体地址需要根据电压和设备的不同来确定，详细内容参考datasheet即可</span></span><br></pre></td></tr></table></figure>

<p><strong>ADC12_A具有18个中断，共用一个中断源</strong></p>
<p>可单独配置某通道完成中断、ADC12MEMx溢出中断、ADC12_A计时溢出中断，所有中断通过唯一的中断向量寄存器来配置，也就是说只使用一个中断服务函数</p>
<p>注意：任何对于ADC12IV的读写操作都会自动复位ADC12OV或ADC12TOV，如果中断服务函数在访问ADC12IV寄存器时有ADC12OV和ADC12IFGx中断生成，那么ADC12OV中断条件会自动复位，在中断服务函数返回后紧接着处理其他中断，因此应避免中断执行时间过长导致ADC中断占用前台应用</p>
<p>使用下面的程序来开启ADC中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADC12IE = <span class="number">0x01</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>将ADC12ENC=1来使能设备</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADC12CTL0 |= ADC12ENC;</span><br><span class="line">ADC12CTL0 |= ADC12SC;</span><br></pre></td></tr></table></figure></li>
<li><p>通过读取ADC12MCTLx对应的ADC12MEMx来获取转换结果</p>
</li>
</ol>
<p>单通道单次转换示例如下（测量引脚电压高于参考电压则指示灯亮）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	WDTCTL = WDTPW + WDTHOLD;  <span class="comment">//停止WDG</span></span><br><span class="line">  	ADC12CTL0 = ADC12SHT02 + ADC12ON; <span class="comment">//设置采样时间并开启ADC12_A</span></span><br><span class="line"> 	ADC12CTL1 = ADC12SHP; <span class="comment">//使用采样定时器</span></span><br><span class="line">  	ADC12IE = <span class="number">0x01</span>; <span class="comment">//使能中断</span></span><br><span class="line">  	ADC12CTL0 |= ADC12ENC; <span class="comment">//使能转换通道</span></span><br><span class="line">  	P6SEL |= <span class="number">0x01</span>; <span class="comment">//配置P6.1复用为ADC输入</span></span><br><span class="line">  	P1DIR |= <span class="number">0x01</span>; <span class="comment">//配置P1.0信号指示输出</span></span><br><span class="line"></span><br><span class="line">  	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  	&#123;</span><br><span class="line">    	ADC12CTL0 |= ADC12SC; <span class="comment">//开始依次采样</span></span><br><span class="line"></span><br><span class="line">    	__bis_SR_register(LPM0_bits + GIE); <span class="comment">//进入LPM0,开启全局中断</span></span><br><span class="line">    	__no_operation(); <span class="comment">//用于调试器打断点的空指令</span></span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADC中断服务函数 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector = ADC12_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">ADC12_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="keyword">switch</span>(__even_in_range(ADC12IV,<span class="number">34</span>))</span><br><span class="line">  	&#123;</span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">0</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  0:  No interrupt</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">2</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  2:  ADC溢出中断</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">4</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  4:  ADC超时中断</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">6</span>:                                  <span class="comment">// Vector  6:  ADC12IFG0</span></span><br><span class="line">		<span class="comment">/* 测量P1引脚 */</span></span><br><span class="line">    	<span class="keyword">if</span> (ADC12MEM0 &gt;= <span class="number">0x7ff</span>)               <span class="comment">// ADC12MEM = A0 &gt; 0.5AVcc?</span></span><br><span class="line">      		P1OUT |= BIT0;                    <span class="comment">// P1.0 = 1</span></span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">      		P1OUT &amp;= ~BIT0;                   <span class="comment">// P1.0 = 0</span></span><br><span class="line"></span><br><span class="line">    	__bic_SR_register_on_exit(LPM0_bits); <span class="comment">//退出LPM0模式</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">8</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  8:  ADC12IFG1</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">10</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 10:  ADC12IFG2</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">12</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 12:  ADC12IFG3</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">14</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 14:  ADC12IFG4</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">16</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 16:  ADC12IFG5</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">18</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 18:  ADC12IFG6</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">20</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 20:  ADC12IFG7</span></span><br><span class="line"> 	<span class="keyword">case</span> <span class="number">22</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 22:  ADC12IFG8</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">24</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 24:  ADC12IFG9</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">26</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 26:  ADC12IFG10</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">28</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 28:  ADC12IFG11</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">30</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 30:  ADC12IFG12</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">32</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 32:  ADC12IFG13</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">34</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 34:  ADC12IFG14</span></span><br><span class="line">  	<span class="keyword">default</span>: <span class="keyword">break</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>多通道重复转换示例如下（连续读取P6.0、P6.1、P6.2、P6.3的ADC值）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Num_of_Results 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> A0results[Num_of_Results];</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> A1results[Num_of_Results];</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> A2results[Num_of_Results];</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> A3results[Num_of_Results];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	WDTCTL = WDTPW+WDTHOLD;                   <span class="comment">//关闭WDG</span></span><br><span class="line">    </span><br><span class="line">  	P6SEL = <span class="number">0x0F</span>;                             <span class="comment">//使能ADC复用引脚（P6的低四位0、1、2、3进行复用）</span></span><br><span class="line">  	ADC12CTL0 = ADC12ON+ADC12MSC+ADC12SHT0_8; <span class="comment">//开启ADC、扩展采样时间避免结果溢出</span></span><br><span class="line">  	ADC12CTL1 = ADC12SHP+ADC12CONSEQ_3;       <span class="comment">//使用采样定时器，设置为多通道重复采样模式</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置0、1、2、3通道的参数 */</span></span><br><span class="line">  	ADC12MCTL0 = ADC12INCH_0;                 <span class="comment">// ref+=AVcc, channel = A0</span></span><br><span class="line">  	ADC12MCTL1 = ADC12INCH_1;                 <span class="comment">// ref+=AVcc, channel = A1</span></span><br><span class="line">  	ADC12MCTL2 = ADC12INCH_2;                 <span class="comment">// ref+=AVcc, channel = A2</span></span><br><span class="line">  	ADC12MCTL3 = ADC12INCH_3+ADC12EOS;        <span class="comment">// ref+=AVcc, channel = A3 ，设置ADC结束标志</span></span><br><span class="line">    </span><br><span class="line">  	ADC12IE = <span class="number">0x08</span>;                           <span class="comment">//使能ADC12IFG.3中断</span></span><br><span class="line">  	ADC12CTL0 |= ADC12ENC;                    <span class="comment">//使能转换通道</span></span><br><span class="line">  	ADC12CTL0 |= ADC12SC;                     <span class="comment">//开始转换-软件触发</span></span><br><span class="line">  </span><br><span class="line">  	__bis_SR_register(LPM0_bits + GIE);       <span class="comment">//进入LPM0并开启全局中断</span></span><br><span class="line">  	__no_operation();                         <span class="comment">//用于调试器打断点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=ADC12_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">ADC12ISR</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">switch</span>(__even_in_range(ADC12IV,<span class="number">34</span>))</span><br><span class="line">  	&#123;</span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">0</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  0:  No interrupt</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">2</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  2:  ADC overflow</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">4</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  4:  ADC timing overflow</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">6</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  6:  ADC12IFG0</span></span><br><span class="line">  	<span class="keyword">case</span>  <span class="number">8</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector  8:  ADC12IFG1</span></span><br><span class="line"> 	<span class="keyword">case</span> <span class="number">10</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 10:  ADC12IFG2</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">12</span>:                                  <span class="comment">// Vector 12:  ADC12IFG3</span></span><br><span class="line">    	A0results[index] = ADC12MEM0;         <span class="comment">// Move A0 results, IFG is cleared</span></span><br><span class="line">    	A1results[index] = ADC12MEM1;         <span class="comment">// Move A1 results, IFG is cleared</span></span><br><span class="line">    	A2results[index] = ADC12MEM2;         <span class="comment">// Move A2 results, IFG is cleared</span></span><br><span class="line">    	A3results[index] = ADC12MEM3;         <span class="comment">// Move A3 results, IFG is cleared</span></span><br><span class="line">    	index++;                              <span class="comment">// 保存到结果缓存区</span></span><br><span class="line">    </span><br><span class="line">    	<span class="keyword">if</span> (index == <span class="number">8</span>)</span><br><span class="line">    	&#123;</span><br><span class="line">      		(index = <span class="number">0</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">  	<span class="keyword">case</span> <span class="number">14</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 14:  ADC12IFG4</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">16</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 16:  ADC12IFG5</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">18</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 18:  ADC12IFG6</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">20</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 20:  ADC12IFG7</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">22</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 22:  ADC12IFG8</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">24</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 24:  ADC12IFG9</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">26</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 26:  ADC12IFG10</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">28</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 28:  ADC12IFG11</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">30</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 30:  ADC12IFG12</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">32</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 32:  ADC12IFG13</span></span><br><span class="line">  	<span class="keyword">case</span> <span class="number">34</span>: <span class="keyword">break</span>;                           <span class="comment">// Vector 34:  ADC12IFG14</span></span><br><span class="line">  	<span class="keyword">default</span>: <span class="keyword">break</span>; </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DAC"><a href="#DAC" class="headerlink" title="DAC"></a>DAC</h4><p>msp430f5529配备了DAC12_A模块，模块组成结构如下：</p>
<ul>
<li><p>核心</p>
<p>可以通过修改DAC12RES的值将DAC12_A配置为8位或12位模式；配置DAC12IR和DAC12OG位可以将满标度输出配置为所选参考电压的1倍、2倍或3倍；配置DAC12DF位选择输入的数据格式是原码还是补码。</p>
</li>
<li><p>端口</p>
<p>大多数DAC复用的端口都有其他复用功能，但是当DAC12AMPx&gt;0时，DAC12_A会忽略PxSEL.y和PxSEL.x的值，自动配置端口为DAC12_A输出复用功能</p>
<p>每个DAC通道都能输出到两个不同的端口，通过DAC122OPS选择，详细参数需要查阅datasheet</p>
</li>
<li><p>参考电压</p>
<p>使用DAC12SREFx选择DAC12_A参考电压，该值从AVCC、外部电压输入、内部1.16V参考电压、内部REF模块提供1.5V、2V、2.5V参考电压之一选择</p>
</li>
<li><p>参考输入和电压输出缓冲区</p>
<p>参考输入和电压输出缓冲区通过寄存器配置来平衡建立时间和功耗，通过配置DAC12AMPx来选择组合，其值越小、建立时间越长、缓冲区上的电流消耗越小</p>
</li>
<li><p>数据格式</p>
<p>使用原码或补码形式都可以设置DAC，使用DAC12_xDAT（取值范围0800h（输出0V）-07ffh（输出标度），另外取值0000h时输出标度的一半）控制</p>
</li>
</ul>
<p>相关示例程序如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 输出固定电压 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW+WDTHOLD; <span class="comment">//关闭WDG</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置无增益，参考电压AVCC，启动DAC校准</span></span><br><span class="line">    DAC12_0CTL0 = DAC12IR + DAC12SREF_1 + DAC12AMP_5 + DAC12CALON;</span><br><span class="line">	DAC12_0CTL0 |= DAC12ENC; <span class="comment">//使能DAC12_A</span></span><br><span class="line">    <span class="comment">//需要注意这里的输出值是12位</span></span><br><span class="line">    DAC12_0DAT = <span class="number">0x000</span>; <span class="comment">//DAC输出0V</span></span><br><span class="line">    <span class="comment">//和上面一样的流程</span></span><br><span class="line">    DAC12_1CTL0 = DAC12IR + DAC12SREF_1 + DAC12AMP_5 + DAC12CALON;</span><br><span class="line">    DAC12_0CTL0 |= DAC12ENC; <span class="comment">//使能DAC12_A</span></span><br><span class="line">    DAC12_0DAT = <span class="number">0x700</span>; <span class="comment">//输出1.4V</span></span><br><span class="line">    __bis_SR_register(LPM4_bits); <span class="comment">//进入LPM4，DAC会自动输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出波形 */</span></span><br><span class="line"><span class="comment">//以FLASH换内存</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> Sin_tab[<span class="number">100</span>] = &#123; </span><br><span class="line"><span class="number">1638</span>,<span class="number">1740</span>,<span class="number">1843</span>,<span class="number">1944</span>,<span class="number">2045</span>,<span class="number">2143</span>,<span class="number">2240</span>,<span class="number">2335</span>,<span class="number">2426</span>,<span class="number">2515</span>,</span><br><span class="line"><span class="number">2600</span>,<span class="number">2681</span>,<span class="number">2758</span>,<span class="number">2831</span>, <span class="number">2899</span>,<span class="number">2962</span>,<span class="number">3020</span>,<span class="number">3072</span>,<span class="number">3119</span>,<span class="number">3160</span>,</span><br><span class="line"><span class="number">3195</span>,<span class="number">3224</span>,<span class="number">3246</span>,<span class="number">3262</span>,<span class="number">3272</span>,<span class="number">3272</span>,<span class="number">3263</span>,<span class="number">3247</span>,<span class="number">3224</span>,<span class="number">3196</span>,</span><br><span class="line"><span class="number">3161</span>,<span class="number">3120</span>,<span class="number">3074</span>,<span class="number">3021</span>,<span class="number">2964</span>,<span class="number">2901</span>,<span class="number">2833</span>,<span class="number">2760</span>,<span class="number">2683</span>,<span class="number">2602</span>,</span><br><span class="line"><span class="number">2517</span>,<span class="number">2429</span>,<span class="number">2337</span>,<span class="number">2243</span>,<span class="number">2146</span>,<span class="number">2047</span>,<span class="number">1947</span>,<span class="number">1845</span>,<span class="number">1743</span>,<span class="number">1640</span>,</span><br><span class="line"><span class="number">1537</span>,<span class="number">1435</span>,<span class="number">1333</span>,<span class="number">1233</span>,<span class="number">1134</span>,<span class="number">1037</span>,<span class="number">943</span>,<span class="number">851</span>,<span class="number">762</span>,<span class="number">677</span>,<span class="number">596</span>,</span><br><span class="line"><span class="number">519</span>,<span class="number">446</span>,<span class="number">378</span>,<span class="number">314</span>,<span class="number">256</span>,<span class="number">204</span>,<span class="number">157</span>,<span class="number">116</span>,<span class="number">81</span>,<span class="number">52</span>,<span class="number">29</span>,<span class="number">13</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>,</span><br><span class="line"><span class="number">12</span>,<span class="number">28</span>,<span class="number">50</span>,<span class="number">78</span>,<span class="number">113</span>,<span class="number">154</span>,<span class="number">200</span>,<span class="number">252</span>,<span class="number">310</span>,<span class="number">373</span>,<span class="number">440</span>,<span class="number">513</span>,<span class="number">590</span>,</span><br><span class="line"><span class="number">671</span>,<span class="number">756</span>,<span class="number">756</span>,<span class="number">844</span>,<span class="number">936</span>,<span class="number">1030</span>,<span class="number">1127</span>,<span class="number">1225</span>,<span class="number">1326</span>,<span class="number">1427</span>,<span class="number">1529</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW + WDTHOLD; <span class="comment">//停看门狗</span></span><br><span class="line"> 	INIT_XT2(); <span class="comment">//开启时钟   </span></span><br><span class="line"></span><br><span class="line"> 	P5SEL = <span class="number">0XFF</span>;</span><br><span class="line"> 	ADC12CTL0 = REFON; <span class="comment">//参考电压为内部2.5v  </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置DMA，直接将Sin_tab数据传输到DAC */</span></span><br><span class="line"> 	DMA0SA = (<span class="keyword">int</span>) Sin_tab; <span class="comment">//源地址寄存器</span></span><br><span class="line"> 	DMA0DA = DAC12_0DAT_; <span class="comment">//目的地址寄存器</span></span><br><span class="line">	DMA0SZ = <span class="number">100</span>; <span class="comment">//传输基本单元的个数</span></span><br><span class="line"> 	DMACTL0 = DMA0TSEL_5; <span class="comment">// DAC12_0CTL的DAC12IFG标志</span></span><br><span class="line"> 	DMA0CTL = DMADT_4 + DMASRCINCR_3 + DMAEN; <span class="comment">//DMADT_4：重复的块传输方式</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使用内部1.5V参考电压，无增益，使能DAC12_A校准并使能DAC12_A */</span></span><br><span class="line">	DAC12_0CTL = DAC12LSEL_2 + DAC12IR + DAC12AMP_5 + DAC12IFG + DAC12ENC; <span class="comment">//配置DAC</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 强制输出第一个中断 */</span></span><br><span class="line"> 	CCTL1 = OUTMOD_3; <span class="comment">//设置并复位</span></span><br><span class="line">	CCR1 = <span class="number">1</span>; <span class="comment">// PWM Duty Cycle   </span></span><br><span class="line">	CCR0 = <span class="number">8</span><span class="number">-1</span>; <span class="comment">//1kHz频率</span></span><br><span class="line">	TACTL = TASSEL_2 + MC_1; <span class="comment">//使用SMCLK时钟源,向上计数模式  </span></span><br><span class="line">	__bis_SR_register(LPM0_bits); <span class="comment">//进入LPM0，DMA和DAC都在工作，会自动输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可编程比较器"><a href="#可编程比较器" class="headerlink" title="可编程比较器"></a>可编程比较器</h4><p>f5529配备了Comp_B模块，支持精密线性数模转换、电源电压监控、外部模拟信号电压监测功能</p>
<p>其中核心是一个精密电压比较器，同相端比反相端电压高，则输出高电平，否则输出低电平，使用CBON位打开/关闭比较器</p>
<p>使用CBCTL0寄存器控制外部输入端口，CBIPEN和CBIMEN分别控制同相端和反相端；使用CBIMSEL和CBIPSEL控制端子连接的GPIO，应选择P6的端口，以这两个寄存器控制端口号</p>
<p>可以使用CBSHORT短路正反相输入，可用来建立简单的采样-保持机制，一般来说设置采样时间为3-10τ，3τ可以将采样电容充电到95%的输入信号电压值，5τ可以将采样电容充电到99%，10τ可以满足12位的精度</p>
<p>使用CBF控制位控制输出信号的输出滤波器</p>
<p>使用参考电压生成器来生成VREF，可以应用于比较器输入端，使用CBREF0x和CBREF1xl来控制</p>
<p>使用CBPWRMD来选择比较器功耗模式，默认为00——最大功耗、最快速度；可以调节到11来使用最低功耗、最低速度</p>
<p>使用CBCTL3来控制比较器的端口是否禁用；使用CBIPSEL或CBIMSEL来控制对应端口的输入缓冲区</p>
<p><strong>比较器也可以开启中断</strong></p>
<p>对于可编程电压比较器而言，一般使用滞后比较来让参考电压根据输出值变化，可以让比较器输出更加稳定，降低噪声</p>
<p>代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW + WDTHOLD; <span class="comment">//停看门狗</span></span><br><span class="line">    P1DIR |= BIT6; <span class="comment">//P1.6作输出</span></span><br><span class="line">    P1SEL |= BIT6; <span class="comment">//复用为比较器输出CBOUT</span></span><br><span class="line">    </span><br><span class="line">    P7DIR |= <span class="number">0xFF</span>; <span class="comment">//P7设置为输出，用来驱动LED显示当前比较器结果</span></span><br><span class="line">    </span><br><span class="line">    CBCTL0 |= CBIPEN + CBIPSEL_0; <span class="comment">//比较器施恩那个，设置输入通道CB0为P6.0</span></span><br><span class="line">    CBCTL1 |= CBPWRMD_0; <span class="comment">//设置为高速模数</span></span><br><span class="line">    CBCTL2 |= CBRSEL; <span class="comment">//使用VREF作为反相端的参考电压</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置高低两个阈值电压 */</span></span><br><span class="line">    CBCTL2 |= CBRS_1 + CBREF13; <span class="comment">//以VCC为参考电压，CBREF1=8，VREF=VCC/4</span></span><br><span class="line">    CBCTL2 |= CBREF04 + CBREF03; <span class="comment">//VREF0=VCC * 3/4</span></span><br><span class="line">    </span><br><span class="line">    CBCTL3 |= BIT0; <span class="comment">//打开Comp_B</span></span><br><span class="line">    CBCTL1 |= CBON; <span class="comment">//使能比较器</span></span><br><span class="line">    __delay_cycles(<span class="number">75</span>); <span class="comment">//等待比较器内部参考电压达到稳定</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(CBCTL1 &amp; CBOUT) <span class="comment">//如果CBOUT为高电平</span></span><br><span class="line">        &#123;</span><br><span class="line">            P7OUT = <span class="number">0x00</span>; <span class="comment">//LED点亮</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            P7OUT = <span class="number">0xFF</span>; <span class="comment">//LED熄灭</span></span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码在输入电压大于VREF0=3/4 VCC时CBOUT输出高电平，LED点亮；输入电压小于VREF0=1/4 VCC时CBOUT输出低电平，LED熄灭；当电压在二者之间时，CBOUT状态不变，起到了稳定输出的作用</p>
<p>同样的比较器也可以产生中断信号，在检测到设定的跳变沿（上升沿或下降沿）后触发中断，进入对应的中断服务函数，可以在其中判断比较器输出的电平，避免了轮询</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CBCTL1 |= CBPWRMD_1 + CBF + CBFDLY_3; <span class="comment">//普通模式，选择中断边压，使用输出滤波</span></span><br><span class="line"><span class="comment">/* 在中间设置其他比较器参数 */</span></span><br><span class="line"><span class="comment">/* 等待一定时间来让参考电压稳定 */</span></span><br><span class="line">CBINT &amp;= ~(CBIFG + CCBIIFG); <span class="comment">//清除错误中断标志</span></span><br><span class="line">CBINT |= CBIE + CBIIE; <span class="comment">//使能比较器输出中断和输出反相中断</span></span><br><span class="line">__bis_SR_register(LPM0_bits + GIE); <span class="comment">//开启全局中断</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=COMP_B_VECTOR</span></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">Comp_B_ISR</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(__even_in_range(CBIV, <span class="number">4</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//无中断</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//中断CBIFG</span></span><br><span class="line">            <span class="keyword">if</span>(CBCTL1 &amp; CBOUT) <span class="comment">//判断是否输出高电平</span></span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">//反相中断CBIIFG</span></span><br><span class="line">            <span class="keyword">if</span>(!(CBCTL1 &amp; CBOUT)) <span class="comment">//反相端需要相反的判断</span></span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里仅列出中断服务函数和其开启方式</p>
<h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><p>msp430的DMA最多有8个通道，但是msp430f5529只有3个通道</p>
<p>基本使用方法和stm32的DMA完全一样，四种模式、单传输、块传输、连续传输都和stm32的传输方法类似，但设置更为简单</p>
<p>一个使用DMA进行UART传输的例子如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;msp430.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> String1[] = &#123;<span class="string">&quot;Hello World\r\n&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WDTCTL = WDTPW + WDTHOLD; <span class="comment">//停看门狗</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 端口配置 */</span></span><br><span class="line">    P4SEL = BIT4 + BIT5; <span class="comment">//配置P4.4、P4.5为Tx、Rx端口</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* 配置USCI_A1为UART模式 */</span></span><br><span class="line">    UCA1CTL1 = UCSSEL_1; <span class="comment">//使用ACLK为时钟源</span></span><br><span class="line">    <span class="comment">//控制分频器设置波特率为9600</span></span><br><span class="line">	UCA1BR0 = <span class="number">0x03</span>; <span class="comment">//分频器高八位</span></span><br><span class="line">    UCA1BR1 = <span class="number">0x0</span>; <span class="comment">//分频器低八位</span></span><br><span class="line">    UCA1MCTL = UCBRS_3 + UCBRF_0; <span class="comment">//调制器UCBRSx = 3</span></span><br><span class="line">    UCA1CTL1 &amp;= ~UCSWRST; <span class="comment">//启动设备</span></span><br><span class="line">    <span class="comment">/* 配置DMA */</span></span><br><span class="line">    DMACTL0 = DMA0TSEL_1; <span class="comment">//以定时器TA0CCR0 CCIFG为触发源</span></span><br><span class="line">    </span><br><span class="line">    __data16_write_addr((<span class="keyword">uint16_t</span>)&amp;DMA0SA, (<span class="keyword">uint32_t</span>)String1); <span class="comment">//源地址：String1字符串</span></span><br><span class="line">    __data16_write_addr((<span class="keyword">uint16_t</span>)&amp;DMA0DA), (<span class="keyword">uint32_t</span>)&amp;UCA1TXBUF); <span class="comment">//目标地址：UART发送缓存区域</span></span><br><span class="line">	</span><br><span class="line">	DMA0CTL = DMADT_4 + DMASRCINCR_3 + DMASBDB +DMAEN; <span class="comment">//重复单传输，递增模式，字节到字节，并使能DMA</span></span><br><span class="line">    <span class="comment">/* 配置定时器 */</span></span><br><span class="line">    TA0CCR0 = <span class="number">8192</span>; <span class="comment">//字符传输频率=32768/8192=4 字节/s</span></span><br><span class="line">	TA0CTL = TASSEL_1 + MC_1; <span class="comment">//使用ACLK作为时钟源，采用增模式</span></span><br><span class="line">    __bis_SR_register(LPM0_bits); <span class="comment">//进入LPM3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序会连续向外以9600波特率发送串口数据</p>
<h3 id="电源管理"><a href="#电源管理" class="headerlink" title="电源管理"></a>电源管理</h3><p>msp430f5529的电源管理模块PMM由监督器SVS和监视器SVM组成</p>
<p>SVS是强制要求的，用于保障设备稳定运行</p>
<p>SVM是宽松可编程的，用于进行一些低功耗控制和安全保障</p>
<p>可以通过对SVM编程提高VCORE来支持更高的MCLK，也就是所谓的<strong>超频</strong></p>
]]></content>
      <tags>
        <tag>电赛笔记</tag>
      </tags>
  </entry>
</search>
